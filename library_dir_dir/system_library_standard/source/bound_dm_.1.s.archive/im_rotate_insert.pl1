/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *                                                         *
   *********************************************************** */

/* DESCRIPTION

          This module attempts to make room in the node control interval in
     which the new key is to be inserted by moving keys, one-at-a-time, from
     the lower numbered slots of the new key's node into the previous node.
     Keys are rotated until:
          1) enough room is made in the new key's node to
	   insert the new key;
	2) there is no more room in the previous node to
	   rotate keys into it; or,
	3) all of the lower-slot keys have been rotated.
     
          The first case is a successful rotation, and this module is done.

          The second case indicates that the  "rotate_previous" can not
     (ultimately) succeed in finding room to insert the new key, and this
     module has "failed", also indicating the module is done.

          The third case requires further investigation.  Either the new key
     will fit in the "previous" node or it won't.  In the former situation, it
     is inserted in the previous node and this module has succeeded.  In the
     latter case this module has failed.  In either event, it is done.

     NOTE:
          The target node (control interval) of the rotation, the previous
     node, may be empty (i.e., contain no keys).  This requires some special
     care in using/setting the key_range of the target node's header.  This
     situation arises when a node is being split.  First a new node is set up
     by im_general_insert/replace, using im_split, then keys are rotated out
     of the "old" node into the "new" one, using this module.

*/

/* HISTORY:
Written by Lindsey Spratt, 04/07/82.
Modified:
06/07/82 by Lindsey Spratt:  Changed to set the "new" (target) node (from a
	  split) to point to the "old" (source) node's old parent key as its
	  parent key, rather than having the "new" and "old" nodes point to
	  the same key as their parent key.
06/16/82 by Matthew Pierret: Removed the beginning_offset argument from
            calls to collection_manager_$put_element.
07/20/82 by Lindsey Spratt:  Fixed branch node rotation.  The control interval
	  pointed at by the low_branch_id was being "lost" when one or more
	  keys was rotated and the target of the rotation was not empty
	  (i.e., the rotation was not being done as part of a "split").
	  Added rotation to the "next" node.  Changed name of procedure from
	  im_rotate_previous_insert to im_rotate_insert.
08/02/82 by Lindsey Spratt:  Fixed rotate "next" to correctly increment the
	  key_range.last value in the target_ci.  Fixed setting of the
	  key_string_ptr to set the correct string_ptr.
08/05/82 by Lindsey Spratt:  Fixed the calls to general_insert to have the
	  local_branch_ci_header filled in correctly in the case where the
	  parent key is to be replaced.
08/09/82 by Matthew Pierret:  Removed offset and length arguments in calls to
            collection_manager_$get_element.  Changed new_ci to be aligned.
09/02/82 by Lindsey Spratt:  Changed to use version 2 of the index_cursor
	  structure.  Fixed "bad version" sub_err_ call (in check_version).
09/11/82 by Lindsey Spratt:  Changed to set the branch_ci_header_ptr or 
            leaf_ci_header_ptr equal to common_ci_header_ptr, according to the
            value of common_ci_header.is_leaf.
09/16/82 by Lindsey Spratt:  Completely re-structured the module from a single
	  main execution path with many conditionals to 8 major cases based
	  on: rotate previous or next, nodes are branches or leaves, target
	  node is initially empty or non-empty.
09/21/82 by Lindsey Spratt:  Added the internal_debug switch.  When on, the
	  "rotate" internal procedure prints a description of what kind of
	  rotation was done and how much was rotated.  The debug_on and
	  debug_off entries set this switch.  Also, changed the rotation
	  loop (labeled "ROTATE_KEY_LOOP") to terminate based on the
	  amount_of_storage_to_be_moved, rather than the
	  additional_storage_required.  The amount_of_storage_to_be_moved is
	  set to the maximum of the additional_storage_required and half of
	  the key_tail_space_used_since_last_prefix_compaction.
09/22/82 by Lindsey Spratt:  All four of the branch rotation cases  now
	  attempt to put/alloc the new key string in the low_branch_id, if
	  possible.  It is only possible if the desired slot has been
	  rotated down (or up, if it is a next rotation) to the "low_branch"
	  location.  Added the "put_headers" and "convert_low_branch_to_key"
	  internal procedures.  Changed the "empty branch" rotations to be
	  prepared for a target with a non-zero low_branch_id.
09/24/82 by Lindsey Spratt:  Removed the superfluous
	  "there_is_more_room_in_target_ci" case from the branch rotations.
	  Changed the next_branch rotations to compare the desired slot
	  against the last source slot, instead of the last target slot,
	  when deciding to insert or put at the low_branch_id.  Changed the
	  nex_branch_rotations to update the source branches when the result
	  of the rotation is to insert into the midst of the source node.
11/02/82 by Lindsey Spratt:  Changed to use index_opening_info to get  the
	  file_opening_id and the collection_id instead of the index_cursor.
	  Changed to get the field_table_ptr out of the index_opening_info
	  rather than passing it as a separate parameter.  Changed all
	  internal procedure names to uppercase.  Changed the calling
	  sequence to have p_index_opening_info_ptr instead of
	  p_index_header_ptr, p_cursor_ptr, and p_field_table_ptr.  Changed
	  to record the new root_id by calling im_update_opening_info$root_id
	  rather than setting it directly.  Changed to use new calling
	  sequences to im_update_branches and im_general_insert.
01/17/83 by Matthew Pierret:  Changed to fully qualify references to
            (common branch leaf)_ci_header. source_ci_header_ptr is used in 
            those places that were previously unqualified.
            Changed to use the buffered access method during rotation.
            Added the internal subroutines ALLOCATE_ELEMENT and FREE_ELEMENT,
            which, along with GET_ELEMENT and PUT_ELEMENT, access CIs in 
            either buffered or unbuffered mode according to the value of the 
            global flag use_soure_and_target_ci_buffers.
01/19/83 by Matthew Pierret: Changed to correctly intitialize range.last in
            the target ci when allocating the first key in the ci (in
            ALLOCATE_KEY_IN_TARGET_CI).
01/25/83 by Lindsey Spratt:  Changed SETUP_PARENT_KEY_FROM_LEAF to get
	  the "high" key from key_range.first and the "low" key from
	  key_range.last, using the source or target CI based on whether a
	  rotate previous or next (respectively) is being done.  Changed
	  ROTATE to set the (high low)_key_string_ptr's appropriately.
	  Changed all of the rotation cases to return immediately upon
	  discovering that nothing can be moved from the source CI into the
	  target CI, and that the p_key_string cannot be put/allocated
	  anywhere, rather than continuing through the "cleanup" code at the
	  end of each case (which is pointless and potentially harmful).
01/26/83 by Lindsey Spratt:  Changed the get,put, free and allocate primitives
	  to check not only that use_source_and_target_ci_buffers is on
	  before using the buffered constraint_idx cm_ entry, but also that
	  the requested CI is either the source or the target CI.
01/27/83 by Lindsey Spratt:  Fixed FREE_ELEMENT to not always call
	  cm_$free_element, which it was doing regardless of whether it 
	  call cm_$free_element_buffered or not.
04/12/83 by Lindsey L. Spratt:  Changed ALLOCATE_KEY_IN_TARGET_CI to set the
            one_or_more_keys_were_rotated flag on so that its callers will
            know to fix the parent key.
04/13/83 by Lindsey L. Spratt:  Fixed CONVERT_LOW_BRANCH_TO_KEY to set the
            branch_key.branch_id before putting the new branch_key, rather
            than after (when it no longer matters).  The branch_key was being
            stored with a garbage branch_id.
10/24/83 by Lindsey L. Spratt:  Fixed to invoke update_branches on the source
            in the PREVIOUS_NONEMPTY_BRANCH rotation case after putting the
            buffered ci's.
10/28/83 by Lindsey L. Spratt:  Fixed to update the source branches in a
            particular subcase of the PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH
            case which was not being caught previously.
10/31/83 by Lindsey L. Spratt:  Fixed next rotations to not move the target
            slot out of the source ci when doing a replacement
            (^p_insert_new_key) operation.
11/08/83 by Lindsey L. Spratt:  Changed to use new im_update_branches calling
            sequence, which requires a node_buffer_ptr.
03/13/84 by Lindsey L. Spratt:  Fixed the PREVIOUS_ROTATION_INTO_EMPTY_BRANCH
            procedure to set low_index to key_range.first + 1 instead of + 2.
            This only caused a problem when the key_id.index = 3.
03/14/84 by Lindsey L. Spratt:  Fixed the previous branch rotations to
            decrement the addr(p_key_id_string) -> element_id.index when doing
            a COMPRESS_LOW_BRANCH, since the p_key insertion point will move
            down by one as a result of the compression.
           Fixed previous_rotation_into_empty_branch to do a
            im_update_branches$single when just the low_branch_id of the
            source_ci was changed.
05/10/84 by Matthew Pierret:  Changed to align buffers on even-word
            boundaries.
06/06/84 by Matthew Pierret:  Re-named cm_$free_element to cm_$delete,
            cm_$free_element_buffered to cm_$delete_from_ci_buffer,
            cm_$*buffered_ci to cm_$=ci_buffer, cm_$simple_get_element_buffered
            to cm_$simple_get_from_ci_buffer, cm_$get_element to cm_$get,
            cm_$put_element to cm_$modify, cm_$put_element_buffered to
            cm_$modify_in_ci_buffer, PUT_ELEMENT to MODIFY_ELEMENT,
            cm_$allocate_element to cm_$put, cm_$allocate_element_buffered to
            cm_$put_in_ci_buffer, ALLOCATE_ELEMENT to PUT_ELEMENT.
10/28/84 by Lindsey L. Spratt:  Changed to use version 2 index_opening_info.
11/15/84 by Lindsey L. Spratt:  Changed the modularization of the program.
02/08/84 by R. Michael Tague:  Changed so that ROTATE_(PREVIOUS NEXT)_BRANCH
            will always correctly set the low branch id.
03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
03/22/85 by Lindsey L. Spratt:  Fixed to always call im_update_branches on the
            target_ci in ROTATE_PREVIOUS_BRANCH.
*/

/* format: style2,ind3 */

im_rotate_insert:
   proc (p_index_opening_info_ptr, p_common_ci_header_ptr, p_rotate_previous, p_insert_new_key, p_insert_parent_key,
        p_key_string, p_key_id_string, p_additional_storage_required, p_code);

/* START OF DECLARATIONS */
/* Parameter */

      dcl	    p_index_opening_info_ptr
			       ptr parameter;
      dcl	    p_insert_new_key       bit (1) aligned parameter;
      dcl	    p_common_ci_header_ptr ptr parameter;
      dcl	    p_rotate_previous      bit (1) aligned parameter;
      dcl	    p_insert_parent_key    bit (1) aligned parameter;
      dcl	    p_key_string	       bit (*) parameter;
      dcl	    p_key_id_string	       bit (36) aligned parameter;
      dcl	    p_additional_storage_required
			       fixed bin (35) parameter;
      dcl	    p_code	       fixed bin (35) parameter;

/* Automatic */

      dcl	    1 local_branch_ci_header
			       like branch_ci_header;
      dcl	    new_ci	       fixed bin (24) unsigned;


      dcl	    temp_key_string_length fixed bin (35);

      dcl	    (source_ci, target_ci) fixed bin (24) unsigned unaligned;
      dcl	    target_element_id_string
			       bit (36) aligned;
      dcl	    source_key_index       fixed bin (12) unsigned unaligned;
      dcl	    (source_ci_header_ptr, target_ci_header_ptr, source_ci_ptr, target_ci_ptr)
			       ptr;
      dcl	    temp_key_string_ptr    ptr;
      dcl	    old_temp_key_string_ptr
			       ptr;
      dcl	    one_or_more_keys_were_rotated
			       bit (1) aligned;
      dcl	    target_ci_was_empty    bit (1) aligned;
      dcl	    high_key_string_ptr    ptr;
      dcl	    low_key_string_ptr     ptr;
      dcl	    current_key_buffer_ptr ptr;
      dcl	    old_key_buffer_ptr     ptr;

      dcl	    (source_ci_header_has_changed, source_ci_has_changed, target_ci_header_has_changed, target_ci_has_changed,
	    update_target_branches, update_source_branches, there_is_more_room_in_target_ci,
	    use_source_and_target_ci_buffers)
			       bit (1) aligned init ("0"b);
      dcl	    original_target_index  fixed bin (12) unsigned unaligned;
      dcl	    (low_index, high_index)
			       fixed bin (35);
      dcl	    rotate_idx	       fixed bin (35);

      dcl	    (target_header_buffer, local_fsk_header_buffer)
			       bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)) aligned;
      dcl	    (local_key_buffer_1, local_key_buffer_2, local_key_buffer_3, local_parent_key_buffer,
	    local_source_ci_buffer, local_target_ci_buffer)
			       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);

      dcl	    total_amount_of_storage_moved
			       fixed bin (24);
      dcl	    additional_storage_required
			       fixed bin (24);
      dcl	    total_storage_available
			       fixed bin (35);
      dcl	    amount_of_storage_to_be_moved
			       fixed bin (24);

/* Based */

      dcl	    based_header_buffer    bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS))
			       based aligned;
      dcl	    (
	    key_buffer	       based,
	    key_buffer_1	       based (addr (local_key_buffer_1)),
	    key_buffer_2	       based (addr (local_key_buffer_2)),
	    key_buffer_3	       based (addr (local_key_buffer_3)),
	    parent_key_buffer      based (addr (local_parent_key_buffer)),
	    source_ci_buffer       based (addr (local_source_ci_buffer)),
	    target_ci_buffer       based (addr (local_target_ci_buffer))
	    )		       bit (BITS_PER_PAGE) aligned;
      dcl	    1 target_element_id    like element_id based (addr (target_element_id_string));
      dcl	    1 p_key_id	       aligned like element_id based (addr (p_key_id_string));
      dcl	    1 source_parent_id     aligned like element_id
			       based (addr (source_ci_header_ptr -> common_ci_header.parent_id_string));
      dcl	    source_parent_id_string
			       aligned bit (36)
			       based (addr (source_ci_header_ptr -> common_ci_header.parent_id_string));
      dcl	    1 target_parent_id     aligned like element_id
			       based (addr (target_ci_header_ptr -> common_ci_header.parent_id_string));
      dcl	    target_parent_id_string
			       aligned bit (36)
			       based (addr (target_ci_header_ptr -> common_ci_header.parent_id_string));

/* Builtin */

      dcl	    (addr, divide, length, max, null, unspec)
			       builtin;

/* Controlled */
/* Constant */

      dcl	    ALL_FIELDS_PRESENT     init (-1) fixed bin (17) unal internal static options (constant);

      dcl	    (
	    LEAF_NODE	       init ("1"b),
	    BRANCH_NODE	       init ("0"b),
	    REPLACE_KEY	       init ("0"b),
	    INSERT_KEY	       init ("1"b),
	    PREVIOUS_ROTATION      init ("1"b),
	    NEXT_ROTATION	       init ("0"b),
	    DONT_UPDATE_STORAGE_MOVED
			       init ("0"b),
	    UPDATE_STORAGE_MOVED   init ("1"b)
	    )		       bit (1) aligned internal static options (constant);

      dcl	    (
	    BITS_PER_PAGE	       init (36 * 1024),
	    DOUBLE_WORDS_PER_PAGE  init (512)
	    )		       fixed bin internal static options (constant);

      dcl	    myname	       init ("im_rotate_insert") char (16) internal static options (constant);

/* Entry */

      dcl	    ioa_		       entry () options (variable);
      dcl	    sub_err_	       entry () options (variable);
      dcl	    im_general_insert      entry (ptr, ptr, bit (1) aligned, bit (*), bit (36) aligned, fixed bin (35));
      dcl	    im_init_branch_ci_header
			       entry (ptr);
      dcl	    im_make_parent_key     entry (ptr, ptr, fixed bin unal, ptr, fixed bin unal, ptr, fixed bin (35), ptr, ptr,
			       fixed bin (35), bit (1) aligned, fixed bin (35));
      dcl	    im_update_branches     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, uns fixed bin (24) unal,
			       uns fixed bin (12) unal, fixed bin (35));
      dcl	    im_update_branches$single
			       entry (ptr, bit (36) aligned, bit (36) aligned, ptr, uns fixed bin (24) unal,
			       uns fixed bin (12) unal, fixed bin (35));
      dcl	    im_update_opening_info$root_id
			       entry (ptr, uns fixed bin (24), fixed bin (35));


/* External */

      dcl	    error_table_$unimplemented_version
			       fixed bin (35) ext;
      dcl	    dm_error_$long_element fixed bin (35) ext;

/* Static */

      dcl	    internal_debug	       bit (1) aligned internal static init ("0"b);

/* END OF DECLARATIONS */

      p_code = 0;

      call INITIALIZE (p_rotate_previous);

      if source_ci_header_ptr -> common_ci_header.is_leaf
      then if p_rotate_previous
	 then if target_ci_was_empty
	      then call PREVIOUS_ROTATION_INTO_EMPTY_LEAF;
	      else call PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF;
	 else if target_ci_was_empty
	 then call NEXT_ROTATION_INTO_EMPTY_LEAF;
	 else call NEXT_ROTATION_INTO_NONEMPTY_LEAF;
      else if p_rotate_previous
      then if target_ci_was_empty
	 then call PREVIOUS_ROTATION_INTO_EMPTY_BRANCH;
	 else call PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH;
      else if target_ci_was_empty
      then call NEXT_ROTATION_INTO_EMPTY_BRANCH;
      else call NEXT_ROTATION_INTO_NONEMPTY_BRANCH;

      if p_additional_storage_required > 0
      then call ERROR_RETURN (dm_error_$long_element);

MAIN_RETURN:
      return;


ERROR_RETURN:
   proc (er_p_code);
      dcl	    er_p_code	       fixed bin (35);
      p_code = er_p_code;
      goto MAIN_RETURN;
   end ERROR_RETURN;


debug_on:
   entry ();
      internal_debug = "1"b;
      return;

debug_off:
   entry ();
      internal_debug = "0"b;
      return;

%page;
/* This procedure is used to increment the target_element_id. */

ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT:
   proc ();
      if target_element_id.index = 0
      then target_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
      else target_element_id.index = target_element_id.index + 1;
   end ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT;


/* This procedure is used to decrement the target_element_id. */

ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT:
   proc ();
      if target_element_id.index = 0
      then target_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
   end ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT;


%page;
/* This procedure is used to attempt to place the new key in the target ci.
If the key is being modified (^p_insert_key), then the old version of the key
exists in the source ci, and must be deleted.

The two parameters are both output parameters.  akitc_p_key_string_ptr only
being set if the attempted insertion is successful, and akitc_p_key_doesnt_fit
being set to "1"b if the insertion is unsuccessful.
*/

ALLOCATE_KEY_IN_TARGET_CI:
   proc (akitc_p_key_string_ptr, akitc_p_key_doesnt_fit);
      dcl	    akitc_p_key_string_ptr ptr parameter;
      dcl	    akitc_p_key_doesnt_fit bit (1) aligned parameter;

      dcl	    akitc_element_allocated
			       bit (1) aligned;

      call PUT_ELEMENT_TEST (target_element_id_string, length (p_key_string), addr (p_key_string),
	 total_storage_available, akitc_element_allocated);
      if akitc_element_allocated
      then
         do;					/* Success !! */
	  additional_storage_required = 0;
	  one_or_more_keys_were_rotated = "1"b;
	  if target_ci_header_ptr -> common_ci_header.key_range.first = 0
	  then target_ci_header_ptr -> common_ci_header.key_range.first,
		  target_ci_header_ptr -> common_ci_header.key_range.last = DEFAULT_INITIAL_KEY_SLOT;
	  else target_ci_header_ptr -> common_ci_header.key_range.last =
		  target_ci_header_ptr -> common_ci_header.key_range.last + 1;
	  target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction =
	       target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction
	       + length (p_key_string);

	  target_ci_header_has_changed = "1"b;
	  call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (p_key_string),
	       akitc_p_key_string_ptr);

/* The old version of the key being replaced must be freed from the source_ci,
as the new version is now in the target_ci. */

	  if ^p_insert_new_key
	  then call DELETE_KEY (p_key_id.control_interval_id, p_key_id.index, source_ci_header_ptr,
		  length (p_key_string), source_ci_header_has_changed, update_source_branches);
						/* length(p_key_string) is an approximation of the length of the old version of the key. */

	  p_key_id_string = target_element_id_string;

         end;
      akitc_p_key_doesnt_fit = ^akitc_element_allocated;
   end ALLOCATE_KEY_IN_TARGET_CI;
%page;
/* This procedure is used to enforce a constraint on the structure of indexes,
that only adjacent nodes **with the same parent node** may be used when
rotating keys.
*/

CHECK_NODES_HAVE_SAME_PARENT:
   proc;
      if target_parent_id.control_interval_id ^= source_parent_id.control_interval_id
      then call ERROR_RETURN (dm_error_$long_element);

   end CHECK_NODES_HAVE_SAME_PARENT;
%page;
/* This procedure is invoked when the insertion of p_key_string has failed
(presumably for lack of space in both the source and target CIs).  The
csr_p_additional_storage_required parameter is an input/output parameter which
is decremented  by the csr_p_total_amount_of_storage_moved.  If no storage was
moved at all, then the error exit of im_rotate_insert is invoked.
*/

CHECK_STORAGE_REQUIREMENTS:
   proc (csr_p_total_amount_of_storage_moved, csr_p_additional_storage_required);
      dcl	    csr_p_total_amount_of_storage_moved
			       fixed bin (24) parameter;
      dcl	    csr_p_additional_storage_required
			       fixed bin (24) parameter;

      if csr_p_total_amount_of_storage_moved = 0
      then call ERROR_RETURN (dm_error_$long_element);

      csr_p_additional_storage_required = csr_p_additional_storage_required - csr_p_total_amount_of_storage_moved;

   end CHECK_STORAGE_REQUIREMENTS;
%page;
CHECK_VERSION:
   proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      dcl	    cv_p_received_version  char (8) aligned parameter;
      dcl	    cv_p_expected_version  char (8) aligned parameter;
      dcl	    cv_p_structure_name    char (*);

      if cv_p_expected_version ^= cv_p_received_version
      then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^d of the ^a structure. Received version ^d instead.", cv_p_expected_version,
	      cv_p_structure_name, cv_p_received_version);

   end CHECK_VERSION;
%page;
/* This procedure takes a node which has no key in its low_branch_id slot and
moves the first branch key branch id into the low_branch_id slot, deleting
(freeing) the branch_key itself.
*/

COMPRESS_LOW_BRANCH_ID:
   proc (clbi_p_update_storage_moved, clbi_p_control_interval_id, clbi_p_ci_header_ptr, clbi_p_ci_header_has_changed,
        clbi_p_update_branches);
      dcl	    clbi_p_update_storage_moved
			       bit (1) aligned parameter;
      dcl	    clbi_p_control_interval_id
			       fixed bin (24) unsigned unaligned parameter;
      dcl	    clbi_p_ci_header_ptr   ptr parameter;
      dcl	    clbi_p_ci_header_has_changed
			       bit (1) aligned parameter;
      dcl	    clbi_p_update_branches bit (1) aligned parameter;

      dcl	    1 clbi_element_id      aligned like element_id;
      dcl	    clbi_temp_key_string_length
			       fixed bin (35);

      clbi_element_id.control_interval_id = clbi_p_control_interval_id;
      clbi_element_id.index = clbi_p_ci_header_ptr -> common_ci_header.key_range.first;

      call GET_ELEMENT (clbi_element_id.control_interval_id, clbi_element_id.index, key_buffer_3,
	 clbi_temp_key_string_length);

      bk_string_length = 0;

      clbi_p_ci_header_ptr -> branch_ci_header.low_branch_id = addr (key_buffer_3) -> branch_key.branch_id;

      call DELETE_KEY (clbi_element_id.control_interval_id, clbi_element_id.index, clbi_p_ci_header_ptr,
	 clbi_temp_key_string_length, clbi_p_ci_header_has_changed, clbi_p_update_branches);

      if clbi_p_update_storage_moved = UPDATE_STORAGE_MOVED
      then total_amount_of_storage_moved = total_amount_of_storage_moved + clbi_temp_key_string_length;

   end COMPRESS_LOW_BRANCH_ID;
%page;
/* This procedure takes the low_branch_id of a node and creates an
appropriately valued branch_key with that branch id.  The newly created key is
always inserted into the target_ci, although it can be created from either the
source or target ci's low_branch_id.
*/

CONVERT_LOW_BRANCH_TO_TARGET_KEY:
   proc (clbttk_p_target_element_id_adjustment_proc, clbttk_p_ci_header_ptr, clbttk_p_ci_header_has_changed);
      dcl	    clbttk_p_target_element_id_adjustment_proc
			       entry () variable parameter;
      dcl	    clbttk_p_ci_header_ptr ptr parameter;
      dcl	    clbttk_p_ci_header_has_changed
			       bit (1) aligned parameter;

      dcl	    clbttk_code	       fixed bin (35);


      call FIND_SPLIT_KEYS (clbttk_p_ci_header_ptr -> branch_ci_header.low_branch_id, key_buffer_1, key_buffer_2);

      call im_make_parent_key (index_opening_info.field_table_ptr, addr (key_buffer_1), ALL_FIELDS_PRESENT,
	 addr (key_buffer_2), ALL_FIELDS_PRESENT, addr (parent_key_buffer), length (parent_key_buffer), null,
	 branch_key_ptr, bk_string_length, "0"b, clbttk_code);
      if clbttk_code ^= 0
      then call ERROR_RETURN (clbttk_code);

      branch_key.branch_id = clbttk_p_ci_header_ptr -> branch_ci_header.low_branch_id;

      call clbttk_p_target_element_id_adjustment_proc ();

      call PUT_KEY (target_element_id.control_interval_id, target_element_id.index, length (unspec (branch_key)),
	 branch_key_ptr, target_ci_header_ptr, target_ci_header_has_changed, update_target_branches,
	 total_storage_available);


      clbttk_p_ci_header_has_changed = "1"b;
      clbttk_p_ci_header_ptr -> branch_ci_header.low_branch_id = 0;

   end CONVERT_LOW_BRANCH_TO_TARGET_KEY;
%page;
/* This procedure deletes a key from the source ci. */

DELETE_KEY:
   proc (dk_p_control_interval_id, dk_p_index, dk_p_ci_header_ptr, dk_p_key_length, dk_p_ci_header_has_changed,
        dk_p_update_branches);
      dcl	    dk_p_control_interval_id
			       fixed bin (24) unsigned unaligned parameter;
      dcl	    dk_p_index	       fixed bin (12) unsigned unaligned parameter;
      dcl	    dk_p_ci_header_ptr     ptr parameter;
      dcl	    dk_p_key_length	       fixed bin (35) parameter;
      dcl	    dk_p_ci_header_has_changed
			       bit (1) aligned parameter;
      dcl	    dk_p_update_branches   bit (1) aligned parameter;

      call DELETE_ELEMENT (dk_p_control_interval_id, dk_p_index);

      dk_p_ci_header_ptr -> common_ci_header.key_range.last = dk_p_ci_header_ptr -> common_ci_header.key_range.last - 1;
      dk_p_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction =
	 max (0,
	 dk_p_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction - dk_p_key_length);

      dk_p_ci_header_has_changed = "1"b;

/* Set the dk_p_update_branches indicator only if it hasn't already been
turned on.  Once on, leave it on.
*/

      if ^dk_p_update_branches
      then if (dk_p_index < dk_p_ci_header_ptr -> common_ci_header.key_range.last)
	 then dk_p_update_branches = "1"b;

   end DELETE_KEY;
%page;
/* This procedure finds the two leaf keys "split" by a branch key.  It does so
by finding the least leaf key in the subtree identified by the branch_id of the
branch key (fsk_p_origin_ci), and the key immediately preceding this least
leaf key.
*/

FIND_SPLIT_KEYS:
   proc (fsk_p_origin_ci, fsk_p_low_key_buffer, fsk_p_high_key_buffer);
      dcl	    fsk_p_origin_ci	       fixed bin (24) unsigned unaligned parameter;
      dcl	    fsk_p_low_key_buffer   bit (*) aligned parameter;
      dcl	    fsk_p_high_key_buffer  bit (*) aligned parameter;
      dcl	    fsk_current_ci	       fixed bin (24) unsigned unaligned;

      fsk_current_ci = fsk_p_origin_ci;
      call GET_ELEMENT (fsk_current_ci, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
	 addr (local_fsk_header_buffer) -> based_header_buffer, 0);

      do while (^addr (local_fsk_header_buffer) -> common_ci_header.is_leaf);
         fsk_current_ci = addr (local_fsk_header_buffer) -> branch_ci_header.low_branch_id;
         call GET_ELEMENT (fsk_current_ci, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
	    addr (local_fsk_header_buffer) -> based_header_buffer, 0);
      end;

      call GET_ELEMENT (fsk_current_ci, (addr (local_fsk_header_buffer) -> leaf_ci_header.key_range.first),
	 fsk_p_high_key_buffer, 0);
      fsk_current_ci = addr (local_fsk_header_buffer) -> leaf_ci_header.previous_id;
      call GET_ELEMENT (fsk_current_ci, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
	 addr (local_fsk_header_buffer) -> based_header_buffer, 0);
      call GET_ELEMENT (fsk_current_ci, (addr (local_fsk_header_buffer) -> leaf_ci_header.key_range.last),
	 fsk_p_low_key_buffer, 0);
   end FIND_SPLIT_KEYS;
%page;
/* This procedure deletes an element from a node. */

DELETE_ELEMENT:
   proc (fe_p_ci, fe_p_index);

      dcl	    fe_p_ci	       fixed bin (24) unsigned unaligned parameter;
      dcl	    fe_p_index	       fixed bin (12) unsigned unaligned parameter;
      dcl	    fe_code	       fixed bin (35);
      dcl	    fe_ci_ptr	       ptr;

      dcl	    1 fe_element_id	       aligned like element_id based (addr (fe_element_id_string));
      dcl	    fe_element_id_string   bit (36) aligned;

      fe_element_id.control_interval_id = fe_p_ci;
      fe_element_id.index = fe_p_index;

      if use_source_and_target_ci_buffers & (fe_p_ci = source_ci | fe_p_ci = target_ci)
      then
         do;
	  if fe_element_id.control_interval_id = source_ci
	  then fe_ci_ptr = source_ci_ptr;
	  else fe_ci_ptr = target_ci_ptr;

	  call collection_manager_$delete_from_ci_buffer (fe_ci_ptr, index_opening_info.file_opening_id,
	       index_opening_info.collection_id, fe_element_id_string, "0"b, fe_code);
         end;
      else call collection_manager_$delete (index_opening_info.file_opening_id, index_opening_info.collection_id,
	      fe_element_id_string, "0"b, fe_code);
      if fe_code ^= 0
      then call ERROR_RETURN (fe_code);

   end DELETE_ELEMENT;
%page;
/* This procedure copies an element from a node into the provided buffer. */

GET_ELEMENT:
   proc (ge_p_ci, ge_p_index, ge_p_buffer, ge_p_length);

      dcl	    ge_p_ci	       fixed bin (24) unsigned unaligned;
      dcl	    ge_p_index	       fixed bin (12) unsigned unaligned;
      dcl	    ge_p_buffer	       bit (*) aligned parameter;
      dcl	    ge_p_length	       fixed bin (35);
      dcl	    ge_code	       fixed bin (35);
      dcl	    ge_ci_ptr	       ptr;

      dcl	    1 ge_element_id	       aligned like element_id based (addr (ge_element_id_string));
      dcl	    ge_element_id_string   bit (36) aligned;

      ge_element_id.control_interval_id = ge_p_ci;
      ge_element_id.index = ge_p_index;

      if use_source_and_target_ci_buffers & (ge_p_ci = source_ci | ge_p_ci = target_ci)
      then
         do;
	  if ge_element_id.control_interval_id = source_ci
	  then ge_ci_ptr = source_ci_ptr;
	  else ge_ci_ptr = target_ci_ptr;

	  call collection_manager_$simple_get_from_ci_buffer (ge_ci_ptr, index_opening_info.collection_id,
	       ge_element_id_string, addr (ge_p_buffer), length (ge_p_buffer), ge_p_length, ge_code);
         end;
      else call collection_manager_$get (index_opening_info.file_opening_id, index_opening_info.collection_id,
	      ge_element_id_string, 0, addr (ge_p_buffer), length (ge_p_buffer), null, "0"b, null, ge_p_length, ge_code)
	      ;
      if ge_code ^= 0
      then call ERROR_RETURN (ge_code);

   end GET_ELEMENT;
%page;
/* This procedure initializes the global variables for im_rotate_insert. */

INITIALIZE:
   proc (i_p_rotate_previous);
      dcl	    i_p_rotate_previous    bit (1) aligned;
      dcl	    i_code	       fixed bin (35) init (0);

      index_opening_info_ptr = p_index_opening_info_ptr;
      call CHECK_VERSION (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");

      source_ci_header_ptr = p_common_ci_header_ptr;

      common_ci_header_ptr, leaf_ci_header_ptr, branch_ci_header_ptr = null;

      source_ci = p_key_id.control_interval_id;
      source_ci_ptr = addr (source_ci_buffer);

      call collection_manager_$setup_ci_buffer (index_opening_info.file_opening_id, index_opening_info.collection_id,
	 (source_ci), source_ci_ptr, length (source_ci_buffer), i_code);
      if i_code ^= 0
      then call ERROR_RETURN (i_code);

      i_code = 0;
      use_source_and_target_ci_buffers = "1"b;

      if i_p_rotate_previous
      then target_element_id.control_interval_id = source_ci_header_ptr -> common_ci_header.previous_id;
      else target_element_id.control_interval_id = source_ci_header_ptr -> common_ci_header.next_id;

      target_ci = target_element_id.control_interval_id;
      if target_ci = 0
      then call ERROR_RETURN (dm_error_$long_element);

      target_ci_ptr = addr (target_ci_buffer);

      call collection_manager_$setup_ci_buffer (index_opening_info.file_opening_id, index_opening_info.collection_id,
	 (target_ci), target_ci_ptr, length (target_ci_buffer), i_code);
      if i_code ^= 0
      then call ERROR_RETURN (i_code);

      call GET_ELEMENT (target_ci, 1, target_header_buffer, (0));

      target_ci_header_ptr = addr (target_header_buffer);
      if i_p_rotate_previous
      then target_element_id.index = target_ci_header_ptr -> common_ci_header.key_range.last;
      else target_element_id.index = target_ci_header_ptr -> common_ci_header.key_range.first;

      original_target_index = target_element_id.index;
      target_ci_was_empty = (original_target_index = 0);

      if i_p_rotate_previous
      then source_key_index = source_ci_header_ptr -> common_ci_header.key_range.first;
      else source_key_index = source_ci_header_ptr -> common_ci_header.key_range.last;

      temp_key_string_ptr = null;
      one_or_more_keys_were_rotated = "0"b;
      high_key_string_ptr = null;
      low_key_string_ptr = null;

      current_key_buffer_ptr = addr (key_buffer_1);
      old_key_buffer_ptr = addr (key_buffer_2);
      total_amount_of_storage_moved = 0;

      additional_storage_required = p_additional_storage_required;
      amount_of_storage_to_be_moved =
	 max (additional_storage_required,
	 divide (source_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction, 2, 24, 0));
   end INITIALIZE;
%page;
/* This procedure inserts a branch key into the source ci. */

INSERT_BRANCH_KEY_IN_SOURCE:
   proc ();

      if ^p_insert_new_key
      then call MODIFY_ELEMENT (p_key_id.control_interval_id, p_key_id.index, p_key_string);
      else call PUT_KEY (p_key_id.control_interval_id, p_key_id.index, length (p_key_string), addr (p_key_string),
	      source_ci_header_ptr, source_ci_header_has_changed, update_source_branches, total_storage_available);

      additional_storage_required = 0;

   end INSERT_BRANCH_KEY_IN_SOURCE;
%page;
/* This procedure sets the low_branch_id of the given ci_header to be the
branch_id of the branch_key in p_key_string.  This branch key is assumed to
have already been inserted in the source_ci at the location specified by
p_key_id_string, and therefore the key at p_key_id_string is deleted from the
source ci.
*/

INSERT_KEY_AS_LOW_BRANCH_ID:
   proc (ikalbi_p_ci_header_ptr, ikalbi_p_ci_header_has_changed);
      dcl	    ikalbi_p_ci_header_ptr ptr parameter;
      dcl	    ikalbi_p_ci_header_has_changed
			       bit (1) aligned parameter;

      ikalbi_p_ci_header_ptr -> branch_ci_header.low_branch_id = addr (p_key_string) -> branch_key.branch_id;
      ikalbi_p_ci_header_has_changed = "1"b;

/* If there is an old version of p_key_string, delete it. */

      if ^p_insert_new_key
      then call DELETE_KEY (p_key_id.control_interval_id, p_key_id.index, source_ci_header_ptr, length (p_key_string),
	      source_ci_header_has_changed, update_source_branches);
						/* length (p_key_string) is an approximation for the length of the old version of the key. */

      additional_storage_required = 0;

   end INSERT_KEY_AS_LOW_BRANCH_ID;
%page;
/* This procedure inserts a leaf key into the source ci at the slot index
given by ilkisc_p_key_index.  If ilkisc_p_key_index = p_key_id.index, then
ilkisc_p_key_string_ptr is set to point at p_key_string.
*/

INSERT_LEAF_KEY_IN_SOURCE_CI:
   proc (ilkisc_p_key_index, ilkisc_p_key_string_ptr);
      dcl	    ilkisc_p_key_index     fixed bin (18) unsigned unaligned parameter;
      dcl	    ilkisc_p_key_string_ptr
			       ptr parameter;

      if ^p_insert_new_key
      then call MODIFY_ELEMENT (source_ci, p_key_id.index, p_key_string);
      else call PUT_KEY (p_key_id.control_interval_id, p_key_id.index, length (p_key_string), addr (p_key_string),
	      source_ci_header_ptr, source_ci_header_has_changed, update_source_branches, total_storage_available);

      if p_key_id.index = ilkisc_p_key_index
      then call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (p_key_string),
	      ilkisc_p_key_string_ptr);

      additional_storage_required = 0;

   end INSERT_LEAF_KEY_IN_SOURCE_CI;
%page;
/* This procedure inserts a leaf key into the targe ci. It is prepared for
there to be insufficient room for the insertion.  If the insertion works,
ilktc_p_key_string_ptr is set to point at p_key_string.
*/

INSERT_LEAF_KEY_IN_TARGET_CI:
   proc (ilktc_p_target_element_id_adjustment_proc, ilktc_p_key_string_ptr);
      dcl	    ilktc_p_target_element_id_adjustment_proc
			       entry () variable parameter;
      dcl	    ilktc_p_key_string_ptr ptr parameter;

      dcl	    ilktc_key_doesnt_fit   bit (1) aligned init ("0"b);

      call ilktc_p_target_element_id_adjustment_proc ();

      call ALLOCATE_KEY_IN_TARGET_CI (ilktc_p_key_string_ptr, ilktc_key_doesnt_fit);
      if ilktc_key_doesnt_fit
      then call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);

   end INSERT_LEAF_KEY_IN_TARGET_CI;
%page;
/* This procedure modifies the value of an existing element. */

MODIFY_ELEMENT:
   proc (me_p_ci, me_p_index, me_p_buffer);

      dcl	    me_p_ci	       fixed bin (24) unsigned unaligned;
      dcl	    me_p_index	       fixed bin (12) unsigned unaligned;
      dcl	    me_p_buffer	       bit (*);
      dcl	    me_code	       fixed bin (35);
      dcl	    me_ci_ptr	       ptr;

      dcl	    1 me_element_id	       aligned like element_id based (addr (me_element_id_string));
      dcl	    me_element_id_string   bit (36) aligned;

      me_element_id.control_interval_id = me_p_ci;
      me_element_id.index = me_p_index;

      if use_source_and_target_ci_buffers & (me_p_ci = source_ci | me_p_ci = target_ci)
      then
         do;
	  if me_element_id.control_interval_id = source_ci
	  then me_ci_ptr = source_ci_ptr;
	  else me_ci_ptr = target_ci_ptr;

	  call collection_manager_$modify_in_ci_buffer (me_ci_ptr, index_opening_info.file_opening_id,
	       index_opening_info.collection_id, addr (me_p_buffer), length (me_p_buffer), me_element_id_string,
	       total_storage_available, me_code);
         end;
      else call collection_manager_$modify (index_opening_info.file_opening_id, index_opening_info.collection_id,
	      addr (me_p_buffer), length (me_p_buffer), me_element_id_string, total_storage_available, me_code);
      if me_code ^= 0
      then call ERROR_RETURN (me_code);

   end MODIFY_ELEMENT;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.next_id node (the target_ci).  This
procedure requires that the target_ci be empty, and that the nodes involved be
branch (as opposed to leaf) nodes.
*/

NEXT_ROTATION_INTO_EMPTY_BRANCH:
   proc;
      dcl	    nrieb_code	       fixed bin (35) init (0);

      if target_ci_header_ptr -> branch_ci_header.low_branch_id ^= 0
      then call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT, target_ci_header_ptr,
	      target_ci_header_has_changed);

      call ROTATE_NEXT_BRANCH ();

/* Update the parent key. */

      call SETUP_PARENT_KEY (target_ci_header_ptr, target_ci);

      if p_insert_parent_key
      then
         do;
	  call SETUP_PARENT_NODE_FOR_INSERTION (NEXT_ROTATION);

	  call MODIFY_HEADERS (BRANCH_NODE);

	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
	       unspec (branch_key), source_parent_id_string, nrieb_code);
	  if nrieb_code ^= 0
	  then call ERROR_RETURN (nrieb_code);
         end;
      else call REPLACE_PARENT_KEY (target_ci_header_ptr);

      p_additional_storage_required = additional_storage_required;
   end NEXT_ROTATION_INTO_EMPTY_BRANCH;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.next_id node (the target_ci).  This
procedure requires that the target_ci be empty, and that the nodes involved be
leaf (as opposed to branch) nodes.
*/

NEXT_ROTATION_INTO_EMPTY_LEAF:
   proc;
      dcl	    nriel_code	       fixed bin (35) init (0);

      call ROTATE_NEXT_LEAF ();

/* Update the parent key. */

      call SETUP_PARENT_KEY_FROM_LEAF_NODE (NEXT_ROTATION);

      if p_insert_parent_key
      then
         do;
	  call SETUP_PARENT_NODE_FOR_INSERTION (NEXT_ROTATION);

	  call MODIFY_HEADERS (LEAF_NODE);

	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
	       unspec (branch_key), source_parent_id_string, nriel_code);
	  if nriel_code ^= 0
	  then call ERROR_RETURN (nriel_code);
         end;
      else call REPLACE_PARENT_KEY (target_ci_header_ptr);

      p_additional_storage_required = additional_storage_required;

   end NEXT_ROTATION_INTO_EMPTY_LEAF;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.next_id node (the target_ci).  This
procedure requires that the target_ci has a low_branch_id > 0 and that the
nodes involved be branch (as opposed to leaf), i.e. is a
nonempty branch node.
*/

NEXT_ROTATION_INTO_NONEMPTY_BRANCH:
   proc;

      call CHECK_NODES_HAVE_SAME_PARENT;

/* Convert the low_branch_id "across" which the rotation will be done */
/* into a branch key. */

      call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT, target_ci_header_ptr,
	 target_ci_header_has_changed);

      call ROTATE_NEXT_BRANCH ();

/* Update the parent key. */

      if additional_storage_required = 0 | one_or_more_keys_were_rotated
      then
         do;
	  call SETUP_PARENT_KEY (target_ci_header_ptr, target_ci);
	  call REPLACE_PARENT_KEY (target_ci_header_ptr);
         end;

      p_additional_storage_required = additional_storage_required;
   end NEXT_ROTATION_INTO_NONEMPTY_BRANCH;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.next_id node (the target_ci).  Thi.
procedure requires that the target_ci contain at least one key
and that the nodes involved be leaf (as opposed to branch) nodes.
*/

NEXT_ROTATION_INTO_NONEMPTY_LEAF:
   proc;

      call CHECK_NODES_HAVE_SAME_PARENT;

      call ROTATE_NEXT_LEAF ();

/* Update the parent key. */
      if one_or_more_keys_were_rotated
      then
         do;
	  call SETUP_PARENT_KEY_FROM_LEAF_NODE (NEXT_ROTATION);
	  call REPLACE_PARENT_KEY (target_ci_header_ptr);
         end;

      p_additional_storage_required = additional_storage_required;
   end NEXT_ROTATION_INTO_NONEMPTY_LEAF;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.previous_id node (the target_ci).
This procedure requires that the target_ci be empty, and that the nodes
involved be branch (as opposed to leaf) nodes.
*/

PREVIOUS_ROTATION_INTO_EMPTY_BRANCH:
   proc;
      dcl	    prieb_code	       fixed bin (35) init (0);

      if target_ci_header_ptr -> branch_ci_header.low_branch_id = 0
      then
         do;
	  update_target_branches = "1"b;
	  target_ci_header_has_changed = "1"b;
	  target_ci_header_ptr -> branch_ci_header.low_branch_id =
	       source_ci_header_ptr -> branch_ci_header.low_branch_id;
	  source_ci_header_ptr -> branch_ci_header.low_branch_id = 0;
         end;
      else call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT, source_ci_header_ptr,
	      source_ci_header_has_changed);

      call ROTATE_PREVIOUS_BRANCH ();

      if p_insert_parent_key
      then
         do;
	  call SETUP_PARENT_NODE_FOR_INSERTION (PREVIOUS_ROTATION);

	  call MODIFY_HEADERS (BRANCH_NODE);

	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
	       unspec (branch_key), source_parent_id_string, prieb_code);
	  if prieb_code ^= 0
	  then call ERROR_RETURN (prieb_code);
         end;
      else call REPLACE_PARENT_KEY (source_ci_header_ptr);

      p_additional_storage_required = additional_storage_required;
   end PREVIOUS_ROTATION_INTO_EMPTY_BRANCH;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.previous_id node (the target_ci).
This procedure requires that the target_ci be empty, and that the nodes
involved be leaf (as opposed to branch) nodes.
*/

PREVIOUS_ROTATION_INTO_EMPTY_LEAF:
   proc;
      dcl	    priel_code	       fixed bin (35) init (0);

      call ROTATE_PREVIOUS_LEAF ();

/* Update the parent key. */

      call SETUP_PARENT_KEY_FROM_LEAF_NODE (PREVIOUS_ROTATION);

      if p_insert_parent_key
      then
         do;
	  call SETUP_PARENT_NODE_FOR_INSERTION (PREVIOUS_ROTATION);

	  call MODIFY_HEADERS (LEAF_NODE);

	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
	       unspec (branch_key), source_parent_id_string, priel_code);
	  if priel_code ^= 0
	  then call ERROR_RETURN (priel_code);
         end;
      else call REPLACE_PARENT_KEY (source_ci_header_ptr);

      p_additional_storage_required = additional_storage_required;

   end PREVIOUS_ROTATION_INTO_EMPTY_LEAF;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.previous_id node (the target_ci).
This procedure requires that the target_ci has a low_branch_id > 0
and that the nodes involved be branch (as opposed to leaf) nodes, i.e. that
the target_ci be a non-empty branch node.
*/

PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH:
   proc;
      dcl	    prinb_code	       fixed bin (35) init (0);

      call CHECK_NODES_HAVE_SAME_PARENT;

/* Convert the low_branch_id "across" which the rotation will be done */
/* into a branch key. */

      call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT, source_ci_header_ptr,
	 source_ci_header_has_changed);

      call ROTATE_PREVIOUS_BRANCH ();

      call REPLACE_PARENT_KEY (source_ci_header_ptr);

      p_additional_storage_required = additional_storage_required;
   end PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH;
%page;
/* This procedure attempts to insert p_key_string at
p_key_id_string after first making room for the insertion by rotating keys
from the p_key_id.control_interval_id node (the source_ci) into the
common_ci_header.previous_id node (the target_ci).
This procedure requires that the target_ci has at least one key in it
and that the nodes involved be leaf (as opposed to branch) nodes.
*/

PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF:
   proc;

      call CHECK_NODES_HAVE_SAME_PARENT;

      call ROTATE_PREVIOUS_LEAF ();

/* Update the parent key. */
      if one_or_more_keys_were_rotated
      then
         do;
	  call SETUP_PARENT_KEY_FROM_LEAF_NODE (PREVIOUS_ROTATION);
	  call REPLACE_PARENT_KEY (source_ci_header_ptr);
         end;

      p_additional_storage_required = additional_storage_required;

   end PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF;
%page;
/* This procedure replaces the buffered nodes, source_ci and target_ci, in the
index_collection.
*/

REPLACE_NODE_BUFFERS:
   proc ();
      dcl	    pcb_code	       fixed bin (35);

      if source_ci_has_changed
      then
         do;
	  call collection_manager_$replace_ci_buffer (index_opening_info.file_opening_id,
	       index_opening_info.collection_id, (source_ci), source_ci_ptr, length (source_ci_buffer), pcb_code);
	  if pcb_code ^= 0
	  then call ERROR_RETURN (pcb_code);
         end;
      if target_ci_has_changed
      then
         do;
	  call collection_manager_$replace_ci_buffer (index_opening_info.file_opening_id,
	       index_opening_info.collection_id, (target_ci), target_ci_ptr, length (target_ci_buffer), pcb_code);
	  if pcb_code ^= 0
	  then call ERROR_RETURN (pcb_code);
         end;

      use_source_and_target_ci_buffers, target_ci_has_changed, source_ci_has_changed = "0"b;

   end REPLACE_NODE_BUFFERS;
%page;
/* This procedure puts an element into a node. */

PUT_ELEMENT:
   proc (pe_p_element_id_string, pe_p_element_length, pe_p_element_ptr, pe_p_space_left);

      dcl	    pe_p_element_id_string bit (36) aligned;
      dcl	    pe_p_element_length    fixed bin (35);
      dcl	    pe_p_element_ptr       ptr;
      dcl	    pe_p_space_left	       fixed bin (35);
      dcl	    pe_p_element_was_allocated
			       bit (1) aligned;
      dcl	    pe_code	       fixed bin (35);
      dcl	    pe_ci_ptr	       ptr;
      dcl	    1 pe_element_id	       aligned like element_id based (addr (pe_element_id_string));
      dcl	    pe_element_id_string   bit (36) aligned;
      dcl	    pe_report_allocated    bit (1) aligned;

      pe_report_allocated = "0"b;
      goto PE_JOIN;

PUT_ELEMENT_TEST:
   entry (pe_p_element_id_string, pe_p_element_length, pe_p_element_ptr, pe_p_space_left, pe_p_element_was_allocated);
      pe_report_allocated = "1"b;
      pe_p_element_was_allocated = "1"b;
PE_JOIN:
      pe_element_id_string = pe_p_element_id_string;

      if use_source_and_target_ci_buffers
	 & (pe_element_id.control_interval_id = source_ci | pe_element_id.control_interval_id = target_ci)
      then
         do;
	  if pe_element_id.control_interval_id = source_ci
	  then pe_ci_ptr = source_ci_ptr;
	  else pe_ci_ptr = target_ci_ptr;

	  call collection_manager_$put_in_ci_buffer (pe_ci_ptr, index_opening_info.file_opening_id,
	       index_opening_info.collection_id, pe_p_element_ptr, pe_p_element_length, pe_element_id_string,
	       pe_p_space_left, pe_code);
         end;
      else call collection_manager_$put (index_opening_info.file_opening_id, index_opening_info.collection_id,
	      pe_p_element_ptr, pe_p_element_length, pe_element_id_string, pe_p_space_left, pe_code);
      if pe_code ^= 0
      then if (pe_report_allocated & pe_code = dm_error_$long_element)
	 then pe_p_element_was_allocated = "0"b;
	 else call ERROR_RETURN (pe_code);

   end PUT_ELEMENT;
%page;
PUT_KEY:
   proc (pk_p_control_interval_id, pk_p_index, pk_p_key_length, pk_p_key_ptr, pk_p_ci_header_ptr,
        pk_p_ci_header_has_changed, pk_p_update_branches, pk_p_total_storage_available);

      dcl	    pk_p_control_interval_id
			       fixed bin (24) unsigned unaligned parameter;
      dcl	    pk_p_index	       fixed bin (12) unsigned unaligned parameter;
      dcl	    pk_p_key_length	       fixed bin (35) parameter;
      dcl	    pk_p_key_ptr	       ptr parameter;
      dcl	    pk_p_ci_header_ptr     ptr parameter;
      dcl	    pk_p_ci_header_has_changed
			       bit (1) aligned parameter;
      dcl	    pk_p_update_branches   bit (1) aligned parameter;
      dcl	    pk_p_total_storage_available
			       fixed bin (35) parameter;

      dcl	    1 pk_p_ci_header       aligned like common_ci_header based (pk_p_ci_header_ptr);
      dcl	    1 pk_element_id	       aligned like element_id based (addr (pk_element_id_string));
      dcl	    pk_element_id_string   bit (36) aligned;

      pk_element_id.control_interval_id = pk_p_control_interval_id;
      pk_element_id.index = pk_p_index;

      call PUT_ELEMENT (pk_element_id_string, pk_p_key_length, pk_p_key_ptr, pk_p_total_storage_available);

      pk_p_ci_header.key_range.last = pk_p_ci_header.key_range.last + 1;
      pk_p_ci_header.key_tail_space_used_since_last_prefix_compaction =
	 pk_p_ci_header.key_tail_space_used_since_last_prefix_compaction + pk_p_key_length;

      pk_p_ci_header_has_changed = "1"b;

      if ^pk_p_update_branches
      then if pk_p_ci_header.key_range.last > pk_p_index
	 then pk_p_update_branches = "1"b;

   end PUT_KEY;
%page;
/* This procedure modifies the node headers in the nodes, using the global
header copies.
*/

MODIFY_HEADERS:
   proc (ph_p_is_leaf);
      dcl	    ph_p_is_leaf	       bit (1) aligned;

      if ph_p_is_leaf
      then
         do;
	  if source_ci_header_has_changed
	  then call MODIFY_ELEMENT (source_ci, 1, unspec (source_ci_header_ptr -> leaf_ci_header));
	  if target_ci_header_has_changed
	  then call MODIFY_ELEMENT (target_ci, 1, unspec (target_ci_header_ptr -> leaf_ci_header));
         end;
      else
         do;
	  if source_ci_header_has_changed
	  then call MODIFY_ELEMENT (source_ci, 1, unspec (source_ci_header_ptr -> branch_ci_header));
	  if target_ci_header_has_changed
	  then call MODIFY_ELEMENT (target_ci, 1, unspec (target_ci_header_ptr -> branch_ci_header));
         end;

      source_ci_has_changed = source_ci_header_has_changed;
      target_ci_has_changed = target_ci_header_has_changed;

      target_ci_header_has_changed, source_ci_header_has_changed = "0"b;

   end MODIFY_HEADERS;
%page;
/* This procedure replaces the old parent key splitting the target and source
nodes with a new parent key which has a value that correctly splits the
rotated contents of the target and source nodes.
*/

REPLACE_PARENT_KEY:
   proc (rpk_p_ci_header_ptr);
      dcl	    rpk_p_ci_header_ptr    ptr parameter;
      dcl	    1 rpk_p_ci_header      aligned based (rpk_p_ci_header_ptr) like common_ci_header;
      dcl	    1 rpk_p_parent_element_id
			       aligned like element_id based (addr (rpk_p_ci_header.parent_id_string));

      dcl	    rpk_code	       fixed bin (35);

      call GET_ELEMENT (rpk_p_parent_element_id.control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
	 addr (local_branch_ci_header) -> based_header_buffer, 0);
      call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), REPLACE_KEY, unspec (branch_key),
	 unspec (rpk_p_ci_header.parent_id_string), rpk_code);
      if rpk_code ^= 0
      then call ERROR_RETURN (rpk_code);
   end REPLACE_PARENT_KEY;
%page;
/* This procedure is the heart of the rotation algorithm.  It moves keys from
a source node into a target node.  The move is accomplished by copying the key
from source to target, then deleting the source copy.
*/

ROTATE:
   proc (r_p_rotate_previous);
      dcl	    r_p_rotate_previous    bit (1) aligned;
      dcl	    r_element_allocated    bit (1) aligned;

      r_element_allocated = "1"b;

ROTATE_KEY_LOOP:
      do rotate_idx = high_index to low_index by -1
	 while (r_element_allocated & total_amount_of_storage_moved < amount_of_storage_to_be_moved);

         if ^r_p_rotate_previous
         then source_key_index = rotate_idx;

         old_temp_key_string_ptr = temp_key_string_ptr;

         temp_key_string_ptr = current_key_buffer_ptr;

/* temp_key_string_ptr is just a convenient holder during the switch of old and current. */

         current_key_buffer_ptr = old_key_buffer_ptr;
         old_key_buffer_ptr = temp_key_string_ptr;

         call GET_ELEMENT (source_ci, source_key_index, current_key_buffer_ptr -> key_buffer, temp_key_string_length);

         temp_key_string_ptr = current_key_buffer_ptr;
         if r_p_rotate_previous
         then call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
	         high_key_string_ptr);
         else call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
	         low_key_string_ptr);

/* The target_element_id.index will be 0 if there were no keys already in the
target  node.  In this case, target_element_id.index must be set to the
default initial key slot value.
*/
         if target_element_id.index = 0
         then target_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
         else if r_p_rotate_previous
         then target_element_id.index = target_element_id.index + 1;

         call PUT_ELEMENT_TEST (target_element_id_string, temp_key_string_length, temp_key_string_ptr,
	    total_storage_available, r_element_allocated);
         if r_element_allocated
         then
	  do;
	     one_or_more_keys_were_rotated = "1"b;

/* If the target node was empty of keys, prior to rotation from the source,
then the key_range.first = 0. It is necessary to initialize key_range.first, 
in this case.
*/

	     if target_ci_header_ptr -> common_ci_header.key_range.first = 0
	     then target_ci_header_ptr -> common_ci_header.key_range.first,
		     target_ci_header_ptr -> common_ci_header.key_range.last = DEFAULT_INITIAL_KEY_SLOT;
	     else target_ci_header_ptr -> common_ci_header.key_range.last =
		     target_ci_header_ptr -> common_ci_header.key_range.last + 1;

	     target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction =
		target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction
		+ temp_key_string_length;

	     target_ci_header_has_changed = "1"b;
	     source_ci_header_has_changed = "1"b;
	     if r_p_rotate_previous
	     then update_source_branches = "1"b;
	     update_target_branches = "1"b;

	     total_amount_of_storage_moved = total_amount_of_storage_moved + temp_key_string_length;

	     if r_p_rotate_previous
	     then
	        do;
		 high_key_string_ptr = null;
		 call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
		      low_key_string_ptr);
	        end;
	     else
	        do;
		 low_key_string_ptr = null;
		 call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
		      high_key_string_ptr);
	        end;

	     call DELETE_KEY (source_ci, (source_key_index), source_ci_header_ptr, temp_key_string_length,
		source_ci_header_has_changed, update_source_branches);
	  end;

      end ROTATE_KEY_LOOP;


      there_is_more_room_in_target_ci = r_element_allocated;
      if r_p_rotate_previous
      then if there_is_more_room_in_target_ci
	 then p_key_id.index = rotate_idx;
	 else p_key_id.index = rotate_idx + 1;

      if internal_debug
      then
         do;
	  if ^there_is_more_room_in_target_ci
	  then rotate_idx = rotate_idx + 1;
	  call ioa_ ("^[Previous^;Next^] rotation into ^[^;non^]empty ^[leaf^;branch^] node (from ^d to ^d):
^10xKeys rotated - ^d out of ^d.
^10xBits rotated - ^d out of ^d.", r_p_rotate_previous, target_ci_was_empty,
	       source_ci_header_ptr -> common_ci_header.is_leaf, source_ci, target_ci, high_index - rotate_idx,
	       source_ci_header_ptr -> common_ci_header.key_range.last
	       - source_ci_header_ptr -> common_ci_header.key_range.first + 1 + high_index - rotate_idx,
	       total_amount_of_storage_moved, amount_of_storage_to_be_moved * 2);
         end;
   end ROTATE;
%page;
/* This procedure does the rotation of keys into the next branch node, then
attempts to insert p_key_string.
*/

ROTATE_NEXT_BRANCH:
   proc ();
      dcl	    rnb_code	       fixed bin (35);

      high_index = source_ci_header_ptr -> common_ci_header.key_range.last;
      if p_insert_new_key
      then low_index = p_key_id.index;
      else low_index = p_key_id.index + 1;


      call ROTATE (NEXT_ROTATION);


      if (p_insert_new_key & p_key_id.index > source_ci_header_ptr -> common_ci_header.key_range.last)
	 | (^p_insert_new_key & p_key_id.index = source_ci_header_ptr -> common_ci_header.key_range.last)
      then call INSERT_KEY_AS_LOW_BRANCH_ID (target_ci_header_ptr, target_ci_header_has_changed);
      else
         do;
	  if target_ci_header_ptr -> branch_ci_header.low_branch_id = 0
	  then call COMPRESS_LOW_BRANCH_ID (DONT_UPDATE_STORAGE_MOVED, target_ci, target_ci_header_ptr,
		  target_ci_header_has_changed, update_target_branches);
	  if total_amount_of_storage_moved >= additional_storage_required
	  then call INSERT_BRANCH_KEY_IN_SOURCE ();
	  else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
         end;


/* Replace the modified headers. */

      call MODIFY_HEADERS (BRANCH_NODE);

/* Update the "parent" threads of the children of the target and source CIs. */

      if update_source_branches
      then
         do;
	  call im_update_branches (source_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
	       source_ci_header_ptr, source_ci, (p_key_id.index), rnb_code);
	  if rnb_code ^= 0
	  then call ERROR_RETURN (rnb_code);
         end;

      call im_update_branches (target_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
	 target_ci_header_ptr, target_ci, 0, rnb_code);
      if rnb_code ^= 0
      then call ERROR_RETURN (rnb_code);

/* Replace the modified CI buffers. */

      call REPLACE_NODE_BUFFERS ();

   end ROTATE_NEXT_BRANCH;
%page;
/* This procedure rotates keys into the next leaf node and attempts to insert
p_key_string.
*/

ROTATE_NEXT_LEAF:
   proc ();

      high_index = source_ci_header_ptr -> common_ci_header.key_range.last;
      if p_insert_new_key
      then low_index = p_key_id.index;
      else low_index = p_key_id.index + 1;

      call ROTATE (NEXT_ROTATION);

      if total_amount_of_storage_moved >= additional_storage_required
      then call INSERT_LEAF_KEY_IN_SOURCE_CI (source_ci_header_ptr -> common_ci_header.key_range.last, low_key_string_ptr)
	      ;
      else if there_is_more_room_in_target_ci		/* Didn't move enough storage to put the new key into the
original ci, but there may be enough room in the target (or previous) ci. */
      then call INSERT_LEAF_KEY_IN_TARGET_CI (ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT, high_key_string_ptr);
      else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);

/* Replace the modified headers. */

      call MODIFY_HEADERS (LEAF_NODE);

/* Replace the modified CI buffers. */

      call REPLACE_NODE_BUFFERS ();

   end ROTATE_NEXT_LEAF;
%page;
/* This procedure rotates keys into the previous branch node and attempts to
insert p_key_string.
*/

ROTATE_PREVIOUS_BRANCH:
   proc ();
      dcl	    rpb_code	       fixed bin (35);

      high_index = p_key_id.index;
      low_index = source_ci_header_ptr -> common_ci_header.key_range.first + 1;
      call ROTATE (PREVIOUS_ROTATION);


      if p_key_id.index = source_ci_header_ptr -> common_ci_header.key_range.first
      then call INSERT_KEY_AS_LOW_BRANCH_ID (source_ci_header_ptr, source_ci_header_has_changed);
      else
         do;
	  if source_ci_header_ptr -> branch_ci_header.low_branch_id = 0
	  then
	     do;
	        call COMPRESS_LOW_BRANCH_ID (UPDATE_STORAGE_MOVED, source_ci, source_ci_header_ptr,
		   source_ci_header_has_changed, update_source_branches);
	        p_key_id.index = p_key_id.index - 1;
	     end;
	  if total_amount_of_storage_moved >= additional_storage_required
	  then call INSERT_BRANCH_KEY_IN_SOURCE ();
	  else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
         end;

      call MODIFY_HEADERS (BRANCH_NODE);

/* Update the parent threads of the children of the source and target CIs. */

      if update_source_branches
      then call im_update_branches (source_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
	      source_ci_header_ptr, source_ci, 0, rpb_code);
      else call im_update_branches$single (source_ci_ptr, index_opening_info.file_opening_id,
	      index_opening_info.collection_id, source_ci_header_ptr, source_ci, 0, rpb_code);
      if rpb_code ^= 0
      then call ERROR_RETURN (rpb_code);

      call im_update_branches (target_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
	 target_ci_header_ptr, target_ci, original_target_index, rpb_code);
      if rpb_code ^= 0
      then call ERROR_RETURN (rpb_code);

/* Replace the modified CI buffers. */

      call REPLACE_NODE_BUFFERS ();

/* Update the parent key. */

      call SETUP_PARENT_KEY (source_ci_header_ptr, source_ci);
   end ROTATE_PREVIOUS_BRANCH;
%page;
/* This procedure rotates keys into the previous leaf node and attempts to
insert the p_key_string.
*/

ROTATE_PREVIOUS_LEAF:
   proc ();
      high_index = p_key_id.index;
      low_index = source_ci_header_ptr -> common_ci_header.key_range.first + 1;

      call ROTATE (PREVIOUS_ROTATION);

      if total_amount_of_storage_moved >= additional_storage_required
      then call INSERT_LEAF_KEY_IN_SOURCE_CI (source_ci_header_ptr -> common_ci_header.key_range.first,
	      high_key_string_ptr);
      else if there_is_more_room_in_target_ci
      then call INSERT_LEAF_KEY_IN_TARGET_CI (ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT, low_key_string_ptr);
      else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);

/* Replace the modified headers. */

      call MODIFY_HEADERS (LEAF_NODE);

/* Replace the modified CI buffers. */

      call REPLACE_NODE_BUFFERS ();

   end ROTATE_PREVIOUS_LEAF;
%page;
/* This procedure sets ssp_p_key_string_ptr to point at the key value portion
of the key at ssp_p_key_ptr.
*/

SET_STRING_PTR:
   proc (ssp_p_is_leaf, ssp_p_key_ptr, ssp_p_key_string_ptr);
      dcl	    ssp_p_is_leaf	       bit (1);
      dcl	    ssp_p_key_ptr	       ptr;
      dcl	    ssp_p_key_string_ptr   ptr;

      bk_string_length, lk_string_length = 0;
      if ssp_p_is_leaf
      then ssp_p_key_string_ptr = addr (ssp_p_key_ptr -> leaf_key.string);
      else ssp_p_key_string_ptr = addr (ssp_p_key_ptr -> branch_key.string);

%include dm_im_key;
   end SET_STRING_PTR;
%page;
/* This procedure creates a parent key from the source and target leaf nodes. */

SETUP_PARENT_KEY_FROM_LEAF_NODE:
   proc (spkfln_p_rotate_previous);
      dcl	    spkfln_p_rotate_previous
			       bit (1) aligned;
      dcl	    spkfln_code	       fixed bin (35);

      if high_key_string_ptr = null
      then
         do;
	  if spkfln_p_rotate_previous
	  then call GET_ELEMENT (source_ci, (source_ci_header_ptr -> common_ci_header.key_range.first), key_buffer_3,
		  (0));
	  else call GET_ELEMENT (target_ci, (target_ci_header_ptr -> common_ci_header.key_range.first), key_buffer_3,
		  (0));
	  call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (key_buffer_3),
	       high_key_string_ptr);
         end;
      else if low_key_string_ptr = null
      then
         do;
	  if spkfln_p_rotate_previous
	  then call GET_ELEMENT (target_ci, (target_ci_header_ptr -> common_ci_header.key_range.last), key_buffer_3,
		  (0));
	  else call GET_ELEMENT (source_ci, (source_ci_header_ptr -> common_ci_header.key_range.last), key_buffer_3,
		  (0));

	  call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (key_buffer_3),
	       low_key_string_ptr);
         end;
      call im_make_parent_key (index_opening_info.field_table_ptr, low_key_string_ptr, ALL_FIELDS_PRESENT,
	 high_key_string_ptr, ALL_FIELDS_PRESENT, addr (parent_key_buffer), length (parent_key_buffer), null,
	 branch_key_ptr, bk_string_length, "0"b, spkfln_code);
      if spkfln_code ^= 0
      then call ERROR_RETURN (spkfln_code);

      if spkfln_p_rotate_previous
      then branch_key.branch_id = source_ci;
      else branch_key.branch_id = target_ci;

   end SETUP_PARENT_KEY_FROM_LEAF_NODE;
%page;
/* This procedure prepares the parent node of the source and target nodes for
the insertion of the new value parent key.
*/

SETUP_PARENT_NODE_FOR_INSERTION:
   proc (spnfi_p_rotate_previous);
      dcl	    spnfi_p_rotate_previous
			       bit (1) aligned;
      dcl	    spnfi_code	       fixed bin (35);
      dcl	    1 spnfi_element_id     aligned like element_id based (addr (spnfi_element_id_string));
      dcl	    spnfi_element_id_string
			       bit (36) aligned;

      if source_parent_id.control_interval_id > 0
      then
         do;
	  call GET_ELEMENT (source_parent_id.control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
	       addr (local_branch_ci_header) -> based_header_buffer, 0);

	  if spnfi_p_rotate_previous
	  then
	     do;
	        source_ci_header_has_changed = "1"b;
	        target_ci_header_has_changed = "1"b;	/* The "new" (target) node (produced by the split) */
						/* has as its parent key the key which was */
						/* the parent of the "old" (source) node. */
	        target_parent_id_string = source_parent_id_string;
						/* The "old" (source) node's new parent key */
						/* going to be just 1 position greater than */
						/* its old parent key. */
	        if source_parent_id.index = 0
	        then source_parent_id.index = DEFAULT_INITIAL_KEY_SLOT;
	        else source_parent_id.index = source_parent_id.index + 1;
	     end;
	  else
	     do;
	        target_ci_header_has_changed = "1"b;
	        if source_parent_id.index = 0
	        then target_parent_id.index = DEFAULT_INITIAL_KEY_SLOT;
	        else target_parent_id.index = target_parent_id.index + 1;
	     end;
         end;
      else
         do;
	  call im_init_branch_ci_header (addr (local_branch_ci_header));
	  call collection_manager_$allocate_control_interval (index_opening_info.file_opening_id,
	       index_opening_info.collection_id, new_ci, spnfi_code);
	  if spnfi_code ^= 0
	  then call ERROR_RETURN (spnfi_code);

	  if spnfi_p_rotate_previous
	  then local_branch_ci_header.low_branch_id = target_ci;
	  else local_branch_ci_header.low_branch_id = source_ci;

	  local_branch_ci_header.key_range = 0;
	  spnfi_element_id.control_interval_id = new_ci;
	  spnfi_element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
	  call PUT_ELEMENT (spnfi_element_id_string, length (unspec (local_branch_ci_header)),
	       addr (local_branch_ci_header), (0));

/* Record the new root control interval's location in the header. */

	  call im_update_opening_info$root_id (index_opening_info_ptr, new_ci, spnfi_code);
	  if spnfi_code ^= 0
	  then call ERROR_RETURN (spnfi_code);

/* Fix the ci_headers of the target and source control intervals to
"point" at the new root ci as their parent. */

	  spnfi_element_id.index = DEFAULT_INITIAL_KEY_SLOT;

	  if spnfi_p_rotate_previous
	  then source_parent_id_string = spnfi_element_id_string;
	  else target_parent_id_string = spnfi_element_id_string;

	  spnfi_element_id.index = 0;

	  if spnfi_p_rotate_previous
	  then target_parent_id_string = spnfi_element_id_string;
	  else source_parent_id_string = spnfi_element_id_string;
	  source_ci_header_has_changed, target_ci_header_has_changed = "1"b;
         end;
   end SETUP_PARENT_NODE_FOR_INSERTION;
%page;
/* This procedure builds a new parent key for splitting the rotated source and
target branch nodes.
*/

SETUP_PARENT_KEY:
   proc (spk_p_ci_header_ptr, spk_p_ci_id);
      dcl	    spk_p_ci_header_ptr    ptr parameter;
      dcl	    spk_p_ci_id	       fixed bin (24) unsigned unaligned parameter;
      dcl	    spk_code	       fixed bin (35);

      if addr (p_key_string) -> branch_key.branch_id = spk_p_ci_header_ptr -> branch_ci_header.low_branch_id
      then
         do;
	  branch_key_ptr = addr (p_key_string);
	  bk_string_length = length (p_key_string) - BRANCH_KEY_HEADER_LENGTH_IN_BITS;
         end;
      else
         do;
	  call FIND_SPLIT_KEYS (spk_p_ci_header_ptr -> branch_ci_header.low_branch_id, key_buffer_1, key_buffer_2);

	  call SET_STRING_PTR ("1"b, addr (key_buffer_1), low_key_string_ptr);
	  call SET_STRING_PTR ("1"b, addr (key_buffer_2), high_key_string_ptr);
	  call im_make_parent_key (index_opening_info.field_table_ptr, low_key_string_ptr, ALL_FIELDS_PRESENT,
	       high_key_string_ptr, ALL_FIELDS_PRESENT, addr (parent_key_buffer), length (parent_key_buffer), null,
	       branch_key_ptr, bk_string_length, "0"b, spk_code);
	  if spk_code ^= 0
	  then call ERROR_RETURN (spk_code);
         end;
      branch_key.branch_id = spk_p_ci_id;
   end SETUP_PARENT_KEY;
%page;
%include dm_im_key;
%page;
%include dm_element_id;
%page;
%include dm_im_ci_header;
%page;
%include dm_collmgr_entry_dcls;
%page;
%include dm_im_opening_info;
%page;
%include sub_err_flags;
   end im_rotate_insert;
