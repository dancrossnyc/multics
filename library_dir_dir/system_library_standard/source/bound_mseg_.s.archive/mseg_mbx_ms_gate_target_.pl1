/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-05-29,Palter), approve(86-02-20,MCR7345),
     audit(86-02-21,MSharpe), install(86-07-11,MR12.0-1092):
     Changed to not call mseg_$delete_seg after calling mseg_$close_seg on the
     target of the copy operation.  Said call would cause fatal process errors
     if the copy operation failed because the user did not have sufficient
     access to create the target.
  2) change(85-06-12,Palter), approve(86-02-20,MCR7345),
     audit(86-02-21,MSharpe), install(86-07-11,MR12.0-1092):
     Fix the bug in ex_acl_list which would trash the user's area when the
     mseg's ACL is empty and the user asks to list the entire ACL.
  3) change(85-07-19,Palter), approve(86-02-20,MCR7345),
     audit(86-02-21,MSharpe), install(86-07-11,MR12.0-1092):
     Fix wakeup_add_index and wakeup_aim_add_index to properly censor the
     results of sending the wakeup and to return the message ID whenever the
     message is added regardless of the success/failure of sending the wakeup.
  4) change(85-07-24,Palter), approve(86-02-20,MCR7345),
     audit(86-02-21,MSharpe), install(86-07-11,MR12.0-1092):
     Fix the old style read entrypoints to not change the caller's
     mseg_return_args structure if an appropriate message is not found.
  5) change(86-03-21,MSharpe), approve(86-05-12,MCR7403),
     audit(86-08-04,Lippard), install(86-08-06,MR12.0-1118):
     Fixed ms_acl_list entry to return the acl terms for caller-specified
     user_ids (when area_ptr = null).  If the caller has specified a null
     user_acl_ptr or a user_acl_count < 1, error_table_$argerr is returned.
  6) change(86-09-10,Dickson), approve(86-09-10,MCR7480),
     audit(86-09-12,Lippard), install(86-09-15,MR12.0-1156):
     Moved some initialization lines to before the clean_up handler is set in
     the $copy entrypoint so that the variable error_on_target gets set upon an
     early exit.
  7) change(86-09-30,Lippard), approve(86-11-24,MCR7578),
     audit(87-07-13,Dickson), install(87-08-06,MR12.1-1067):
     Changed to correctly diagnose entry names without valid suffixes and to
     use error_table_$bad_file_name instead of $badstar.
                                                   END HISTORY COMMENTS */

/* format: style3,idind30,linecom */
mseg_mbx_ms_gate_target_:
     procedure;

/* Modified for version 3 message segments by J. Stern, 11/01/74 */
/* Modified to add mbx_wakeup_add_index and mbx_accept_wakeups_index
   and mbx_set_max_length entries by Steve Herbst on 2/16/76 */
/* Modified 5/77 for the installation of version 4 message segments */
/* MCR 4171 Change default access on new mailboxes 12/14/79 S. Herbst */
/* Modified by Benson Margulies for conversion to unaligned character strings */
/* Modified 4/82 by E. N. Kittlitz to not delete through links */
/* Modified: February 1983 by G. Palter to add validation, copy and compaction entrypoints */
/* Modified: October 1983 by G. Palter to add get_uid_file and get_uid_index entrypoints */
/* Modified: November 1983 by G. Palter to make get_mode_file use hcs_$get_user_access_modes */
/* Modified: 84-05-07 BIM for get_process_access_class_ versus authorization */
/* Modified: August 1984 by G. Palter to fix the following errors from the message segment error list:
   #0001 -- mailbox_$create and message_segment_$create will add the ring-1 IACL to the ACL of the newly created
   mailbox/message segment.  The entries from the IACL will have null extended access.  These gates should ignore
   the ring-1 IACL;
   #0003 -- mailbox_$get_uid_file, mailbox_$get_mode_file, mailbox_$set_safety_switch, and
   mesage_segment_$set_safety_switch do not validate that their target is a mailbox or message segment as
   appropriate;
   #0005 -- When given a new ACL count of -1 or zero, mailbox_$mbx_acl_replace and message_segment_$ms_acl_replace will
   incorrectly attempt to allocate a local copy of the input ACL array using the new ACL count as the size for the
   array.  This attempted allocation causes an area condition and, eventually, a fatal process error; and
   #0006 -- mailbox_$copy and message_segment_$copy will create the target mailbox/message segment before validating
   that the user has sufficient access to copy the segment */
/* Modified 1984-10-11 BIM for new entrypoints, V5 */
/* Modified February 1985 by M. Pandolf to add calls to mseg_check_access_ */
/* Modified March 1985 by M. Pandolf to get mseg_ptr as soon as possible due to undependability of pathnames */
/* Modified April 1985 by M. Pandolf to get and hold access information */
/* Modified 1985-04-16, BIM: simplify get_mode,
   reduce use of validation level setting.
   MERGE MBX_MSEG_ with QUEUE_MSEG_ */

/****^ Gate target procedure for the mailbox_ and message_segment_ gates.
      This procedure is responsible for:

      argument copying
      access checking except for per-message AIM checks
      validation level management (for now)


      BASIC STRATEGY

      One procedure, "entry_common", is responsible for:

      copying standard arguments.
      calling mseg_check_access_ to check access for the operation.
      setting the validation level down (and suppressing audit).


      A single entrypoint serves both gates. The callerptr builtin
      is used to distinguish the calling gate and select accordingly.

      The entrypoints are classed into four groups:

      INDEX_ENTRY        called with an opening index
      FILE_ENTRY         called with a pathname which is initiated
      FILE_BRIEF_ENTRY   called with a pathname which is passed
		     to mseg_check_access_ and then to mseg_.
		     All neccessary data is returned in
		     the access_info substructure of the
		     mseg_operation structure.
      FILE_TEMP_ENTRY    called with a pathname, only because
		     there is no underlying ring 0 primitive
		     that will accept a pointer. These entries
		     all have windows that allow benign
		     hoaxing.


      entry_common is called as follows:

      call entry_common (entry_type, base_operation);

      entry_common set up the mseg_operation structure
      and calls mseg_check_access_. After that, the
      individual entrypoint is on its own.

*/

declare	(
	INDEX_ENTRY		init (1),
	FILE_ENTRY		init (2),
	FILE_BRIEF_ENTRY		init (3),
	FILE_TEMP_ENTRY		init (4)
	)			int static fixed bin options (constant);

declare	SUFFIX			(2) char (8) aligned varying init (".mbx", ".ms") int static options (constant);

dcl	(
	a_user_acl_count,				/* acl count */
	user_acl_count,
	a_ms_count,				/* message count */
	ms_count,
	a_mseg_index,				/* message segment index */
	i,
	read_entry_type
	)			fixed bin;

dcl	(a_max_length, max_length)	fixed bin (19);

dcl	a_ms_len			fixed bin (24);	/* bit length of message */

dcl	(
	a_code,					/* error code (argument) */
	code,					/* error code (internal) */
	error_table_$argerr		ext,
	error_table_$noalloc	ext,
	error_table_$no_append	ext,
	error_table_$null_info_ptr	ext,
	error_table_$unimplemented_version
				ext,
	error_table_$ai_restricted	ext,
	error_table_$action_not_performed
				ext,
	error_table_$bad_file_name	ext,
	error_table_$dirseg		ext,
	error_table_$inconsistent	ext,
	error_table_$invalid_lock_reset
				ext,
	error_table_$messages_deferred
				ext,
	error_table_$messages_off	ext,
	error_table_$moderr		ext,
	error_table_$no_info	ext,
	error_table_$not_seg_type	ext,
	error_table_$wakeup_denied	ext,
	error_table_$seg_unknown	ext
	)			fixed bin (35);

dcl	(a_event_channel, user_event_channel, event_message)
				fixed bin (71);

/* float bin */

dcl	a_compact_ratio		float bin;	/* % of garbage in mailbox to force compaction */

/* pointers */

dcl	(
	a_area_ptr,				/* pointer to user area */
	area_ptr,
	a_arg_ptr,				/* pointer to argument structure */
	arg_ptr,
	a_user_acl_ptr,				/* pointer to acl structures */
	user_acl_ptr,
	a_ms_ptr,					/* pointer to message */
	internal_acl_ptr,
	static_table_ptr		(2) int static init ((2) null ())
						/* ptr to mseg_table */
	)			ptr;

/* bit strings */

dcl	(
	error_on_target,
	copy_entry,				/* ON if mailbox copying entrypoint */
	a_error_on_target,				/* set ON/OFF depending on where copy failed */
	file_sw,					/* ON if file entry called */
	a_ms_wanted,				/* which incremental message wanted */
	ms_wanted,
	a_salv_bit,				/* salvaged bit */
	salv_bit,
	a_safety_switch,
	safety_switch,
	a_turn_off,				/* ON if to turn off, salvaged bit */
	turn_off,
	return_count,
	validation_set
	)			bit (1) aligned;

dcl	(
	a_dir,					/* direction of incremental read */
	dir
	)			bit (2) aligned;

dcl	(
	a_mode			aligned,		/* extended access mode */
	a_sw,					/* wakeup control arg */
	test_lock_id		aligned,		/* to test for valid lock id */
	sys_info$ring1_privilege	aligned external,
	sys_info$ipc_privilege	aligned external
	)			bit (36);

dcl	a_uid					/* mailbox UID */
				bit (36) aligned;

dcl	(
	a_access_class,
	a_ms_id,					/* message uid */
	ms_id
	)			bit (72) aligned;


/* character strings */

dcl	(
	a_dn,					/* directory name */
	a_en,					/* message segment name */
	a_target_dn,				/* for copying */
	a_target_en,				/* for copying */
	a_new_en,					/* for renaming */
	a_old_en					/* for renaming */
	)			char (*);

dcl	(new_en, old_en)		char (32);

/* structures */

dcl	1 operation		aligned like mseg_operation;
dcl	1 target_operation		aligned like mseg_operation;
						/* spare for copy */


declare	1 old_read_flags		unaligned,
	  2 incremental		bit (1),
	  2 incremental_direction	bit (2),		/* valid if incremental = "1"b */
	  2 first_or_last		bit (1),		/* valid if incremental is "0"b */
	  2 own			bit (1),
	  2 delete		bit (1),
	  2 pad			bit (30);

/* builtins */

dcl      (addr, index, length, null, reverse, rtrim, setwordno, string, substr, unspec)
				builtin;

/* conditions */

dcl	area			condition;
dcl	cleanup			condition;

/* area */

dcl	system_area		area based (get_system_free_area_ ());
dcl	user_area			area based (area_ptr);


/* external entries */

dcl	admin_gate_$admin_level_no_fs_audit
				entry (fixed bin (3) aligned);
dcl	aim_util_$get_access_class	entry (bit (72) aligned) returns (bit (72) aligned);
dcl	aim_util_$get_privileges	entry (bit (72) aligned) returns (bit (36) aligned);
dcl	aim_check_$greater_or_equal	entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl	aim_check_$greater		entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl	cu_$caller_ptr		entry returns (ptr);
dcl	get_process_authorization_	entry () returns (bit (72) aligned);
dcl	get_system_free_area_	ext entry returns (ptr);
dcl	hcs_$level_get		entry returns (fixed binary (3));
dcl	hcs_$level_set		entry (fixed binary (3));
dcl	hcs_$wakeup		ext entry (bit (36), fixed bin (71), fixed bin (71), fixed bin (35));


dcl	mseg_check_access_$audit_initiate_failure
				entry (pointer, fixed binary (35));
dcl	mseg_check_access_$check	ext entry (ptr, fixed bin (35));
dcl	mseg_check_access_$segment	ext entry (ptr, fixed bin (35));

dcl	set_lock_$lock		ext entry (bit (36) aligned, fixed bin (17), fixed bin (35));
dcl	sub_err_			entry () options (variable);


mseg_mbx_ms_gate_target_$validate:
     entry (a_dn, a_en, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_BRIEF_ENTRY, mseg_access_operations_$read_fs_attr_seg);
	call RETURN (code);


mseg_mbx_ms_gate_target_$create:
     entry (a_dn, a_en, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_BRIEF_ENTRY, mseg_access_operations_$create_seg);

	call mseg_$create_seg (addr (operation), null (), code);

	call RETURN (code);

mseg_mbx_ms_gate_target_$delete_mseg:
     entry (a_dn, a_en, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$delete_seg);

	file_sw = "0"b;				/* no need to clean this up */

	call mseg_$delete_seg (addr (operation), static_table_ptr (operation.type), code);
						/* it removes from the table, etc. */

	call RETURN (code);

mseg_mbx_ms_gate_target_$copy:
     entry (a_dn, a_en, a_target_dn, a_target_en, a_error_on_target, a_code);

	call entry_setup;

	target_operation = addr (mseg_data_$template_operation) -> mseg_operation;
	copy_entry = "1"b;				/* Set so that when general_clean_up */
						/* gets called, error_on_target gets copied */
	error_on_target = "0"b;

	on cleanup call general_clean_up;

	call entry_common (FILE_ENTRY, mseg_access_operations_$copy_seg);

	error_on_target = "1"b;			/* any problem now is with the target */

	target_operation.caller = operation.caller;	/* copy all fields that apply ... the caller */
	target_operation.call_admin_gate = operation.call_admin_gate;
						/* whether to use multi-class */
	target_operation.type = operation.type;		/* The type of segment */
	target_operation.dir_name = a_target_dn;
	target_operation.entryname = a_target_en;
	target_operation.mseg_pathname_valid = "1"b;
	target_operation.access_operation = mseg_access_operations_$create_seg;
	call mseg_check_access_$segment (addr (target_operation), code);
						/* Test those target dir RB's ! */
						/* and chase those links */
	if code ^= 0
	then call RETURN (code);

	call mseg_$create_seg (addr (target_operation), null (), code);
	if code ^= 0
	then call RETURN (code);

	call mseg_$initiate_seg (addr (target_operation), code);
						/* mseg_create_ does not initiate since an empty mseg is EMPTY */
	if code ^= 0
	then call RETURN (code);

	call mseg_$copy_seg (addr (operation), addr (target_operation), a_error_on_target, code);

	call RETURN (code);
%page;
mseg_mbx_ms_gate_target_$chname:
     entry (a_dn, a_en, a_old_en, a_new_en, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$modify_fs_attr_seg);

	old_en = a_old_en;
	new_en = a_new_en;

	if old_en ^= ""
	then do;
		call check_name (old_en, code);
		if code ^= 0
		then call RETURN (code);
	     end;
	if new_en ^= ""
	then do;
		call check_name (new_en, code);
		if code ^= 0
		then call RETURN (code);
	     end;

	call mseg_$chname_seg (addr (operation), old_en, new_en, code);
	call RETURN (code);


mseg_mbx_ms_gate_target_$get_uid_file:
     entry (a_dn, a_en, a_uid, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_BRIEF_ENTRY, mseg_access_operations_$read_fs_attr_seg);

	a_uid = operation.access_info.uid;		/* got the UID */
	call RETURN (code);


mseg_mbx_ms_gate_target_$get_uid_index:
     entry (a_mseg_index, a_uid, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_fs_attr_seg);

	a_uid = operation.access_info.uid;		/* got the UID */
	call RETURN (code);

mseg_mbx_ms_gate_target_$set_max_length_file:
     entry (a_dn, a_en, a_max_length, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$modify_fs_attr_seg);

	max_length = a_max_length;
	call mseg_$set_max_length_seg (addr (operation), max_length, code);
	a_max_length = max_length;
	call RETURN (code);


mseg_mbx_ms_gate_target_$set_safety_switch:
     entry (a_dn, a_en, a_safety_switch, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$modify_fs_attr_seg);

	safety_switch = a_safety_switch;

	call mseg_$set_safety_switch_seg (addr (operation), safety_switch, code);
	call RETURN (code);


mseg_mbx_ms_gate_target_$compact_file:
     entry (a_dn, a_en, a_compact_ratio, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$compact_seg);
compact:
	call mseg_$compact_seg (addr (operation), a_compact_ratio, code);
	call RETURN (code);


mseg_mbx_ms_gate_target_$compact_index:
     entry (a_mseg_index, a_compact_ratio, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$compact_seg);
	go to compact;

mseg_mbx_ms_gate_target_$open_if_full:
     entry (a_dn, a_en, a_salv_bit, a_ms_count, a_mseg_index, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$return_error (FILE_ENTRY, mseg_access_operations_$get_count_seg);
						/* error codes analyzed here .... */

/**** NOTE
      If the code is zero, we can return the count and the salv bit
      and only open if there is a non-zero count.
      If the code is moderr then we open the mseg
      and return 0 for the count and salv bit, and error_table_$moderr
      for the code.
      If the code is anything else we punt. */

	if code ^= 0 & code ^= error_table_$moderr
	then call RETURN (code);

	return_count = (code = 0);
	salv_bit = "0"b;
	ms_count = 0;

	if return_count
	then do;
		call mseg_$get_salvaged_flag_seg (addr (operation), salv_bit, (0));
		a_salv_bit = salv_bit;
		call mseg_$count_messages (addr (operation), ms_count, (0));
		a_ms_count = ms_count;
		if ms_count = 0
		then call RETURN (code);		/* which will terminate the mseg */
	     end;

	if ^return_count				/* we haven't seen any access yet */
	then do;
		operation.access_operation = mseg_access_operations_$open_seg;
		call mseg_check_access_$segment (addr (operation), code);
		if code ^= 0
		then call RETURN (code);
	     end;

	call mseg_$open_seg (addr (operation), static_table_ptr (operation.type), code);
	if code ^= 0
	then call RETURN (code);			/* no room at the inn, probably */
	file_sw = "0"b;				/* don't terminate that pointer! */

	a_mseg_index = operation.mseg_index;
	if ^return_count
	then code = error_table_$moderr;		/* no report if the salv bit fails */

	call RETURN (code);

mseg_mbx_ms_gate_target_$open:
     entry (a_dn, a_en, a_mseg_index, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$open_seg);
	call mseg_$open_seg (addr (operation), static_table_ptr (operation.type), code);
	if code ^= 0
	then call RETURN (code);
	file_sw = "0"b;				/* don't terminate that pointer */

	a_mseg_index = operation.mseg_index;
	call RETURN (code);

mseg_mbx_ms_gate_target_$close:
     entry (a_mseg_index, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$close_seg);

	if (operation.access_info.extended_access_modes & D_MBX_ACCESS) ^= ""b
	then call mseg_$compact_seg (addr (operation), 0.25e0, (0));
	call mseg_$close_seg (addr (operation), static_table_ptr (operation.type), code);
	call RETURN (code);


mseg_mbx_ms_gate_target_$ex_acl_add:
     entry (a_dn, a_en, a_user_acl_ptr, a_user_acl_count, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_TEMP_ENTRY, mseg_access_operations_$acl_modify_seg);

	user_acl_ptr = a_user_acl_ptr;
	user_acl_count = a_user_acl_count;

	call copy_acl (user_acl_ptr, user_acl_count);
	call mseg_$add_acl_entries_seg (addr (operation), acl_ptr, code);
	call RETURN (code);



mseg_mbx_ms_gate_target_$ex_acl_delete:
     entry (a_dn, a_en, a_user_acl_ptr, a_user_acl_count, a_area_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_TEMP_ENTRY, mseg_access_operations_$acl_modify_seg);

	user_acl_ptr = a_user_acl_ptr;
	user_acl_count = a_user_acl_count;

	call copy_acl$$delete (user_acl_ptr, user_acl_count);
	call mseg_$delete_acl_entries_seg (addr (operation), acl_ptr, code);
	call RETURN (code);



mseg_mbx_ms_gate_target_$ex_acl_list:
     entry (a_dn, a_en, a_user_acl_ptr, a_user_acl_count, a_area_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_TEMP_ENTRY, mseg_access_operations_$acl_list_seg);

	user_acl_ptr = a_user_acl_ptr;
	user_acl_count = a_user_acl_count;
	area_ptr = a_area_ptr;

	if area_ptr = null ()
	then do;
	          if (user_acl_ptr = null ()) | (user_acl_count < 1)
		then call RETURN (error_table_$argerr);

		call copy_acl (user_acl_ptr, user_acl_count);
		call mseg_$list_acl_entries_seg (addr (operation), acl_ptr, code);
		user_acl_ptr -> segment_acl_array = general_extended_acl.entries;
	     end;
	else do;
		call mseg_$list_acl_seg (addr (operation), acl_ptr, code);
		if code ^= 0
		then call RETURN (code);
		acl_count = general_extended_acl.count;
		on area
		     begin;
			code = error_table_$noalloc;
			call RETURN (code);
		     end;
		allocate segment_acl_array in (user_area) set (user_acl_ptr);
		revert area;
		do i = 1 to acl_count;		/* PL/I always copies at least 1 even if acl_count = 0 */
		     user_acl_ptr -> segment_acl_array (i) = general_extended_acl.entries (i);
		end;
		a_user_acl_ptr = user_acl_ptr;
		a_user_acl_count = acl_count;
	     end;
	call RETURN (code);

mseg_mbx_ms_gate_target_$ex_acl_replace:
     entry (a_dn, a_en, a_user_acl_ptr, a_user_acl_count, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_TEMP_ENTRY, mseg_access_operations_$acl_modify_seg);

	user_acl_ptr = a_user_acl_ptr;
	user_acl_count = a_user_acl_count;

	if user_acl_count > 0
	then call copy_acl (user_acl_ptr, user_acl_count);
	else acl_ptr = null ();

	call mseg_$replace_acl_seg (addr (operation), acl_ptr, code);

	if acl_ptr ^= null ()
	then user_acl_ptr -> segment_acl_array (*).status_code = general_extended_acl.entries (*).status_code;
	call RETURN (code);



mseg_mbx_ms_gate_target_$read_index:
     entry (a_mseg_index, a_area_ptr, a_ms_wanted, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_message);
old_read:
	area_ptr = a_area_ptr;
	arg_ptr = a_arg_ptr;
	ms_wanted = a_ms_wanted;
	ms_id = ""b;
	string (old_read_flags) = "0"b;
	old_read_flags.first_or_last = ms_wanted;
	call read_for_old_entrypoint (ms_id);
	call RETURN (code);


mseg_mbx_ms_gate_target_$delete_index:
     entry (a_mseg_index, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$delete_message);

delete:
	operation.message_info.ms_id = a_ms_id;
	operation.message_info_valid = "1"b;
	call mseg_$delete_message (addr (operation), code);
	call RETURN (code);


mseg_mbx_ms_gate_target_$read_delete_index:
     entry (a_mseg_index, a_area_ptr, a_ms_wanted, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_delete_message);

old_read_delete:
	area_ptr = a_area_ptr;
	ms_wanted = a_ms_wanted;
	arg_ptr = a_arg_ptr;
	string (old_read_flags) = ""b;
	ms_id = ""b;
	old_read_flags.first_or_last = ms_wanted;
	old_read_flags.delete = "1"b;
	call read_for_old_entrypoint (ms_id);
	call RETURN (code);

mseg_mbx_ms_gate_target_$admin_add_index:
     entry (a_mseg_index, a_arg_ptr, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (INDEX_ENTRY, mseg_access_operations_$admin_add_message);
						/* access check needs message access class */

/* This entry point, available through the privileged gate queue_admin_,
   adds a message with attributes specified in the mseg_message_info structure. */

admin_add:
	mseg_message_info_ptr = a_arg_ptr;
	operation.message_info = mseg_message_info;
	operation.message_info_valid = "1"b;
	operation.add_message_info_all_valid = "1"b;	/* This makes mseg_ respect all the fields as input */
	if operation.message_info.version ^= MSEG_MESSAGE_INFO_V1
	then call RETURN (error_table_$unimplemented_version);

	call mseg_check_access_$segment (addr (operation), code);
	if code ^= 0
	then call RETURN (code);

	call mseg_$add_message (addr (operation), code);

	if code = 0
	then do;
		a_ms_id = operation.message_info.ms_id;
		mseg_message_info = operation.message_info;
	     end;
	call RETURN (code);

mseg_mbx_ms_gate_target_$admin_add_file:
     entry (a_dn, a_en, a_arg_ptr, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (FILE_ENTRY, mseg_access_operations_$admin_add_message);
						/* access check needs message access class */

	go to admin_add;


mseg_mbx_ms_gate_target_$add_index:
     entry (a_mseg_index, a_ms_ptr, a_ms_len, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;

	call entry_common$$no_access_check (INDEX_ENTRY, mseg_access_operations_$add_message);

	operation.message_info.ms_access_class = aim_util_$get_access_class (operation.caller.authorization);

add:
	call mseg_check_access_$segment (addr (operation), code);
	if code ^= 0
	then call RETURN (code);
	operation.message_info.ms_ptr = a_ms_ptr;
	operation.message_info.ms_len = a_ms_len;
	operation.message_info_valid = "1"b;
	call mseg_$add_message (addr (operation), code);
	if code ^= 0
	then call RETURN (code);

	a_ms_id = operation.message_info.ms_id;
	call RETURN (code);



/**** WAKEUP entrypoints */

/****^ Error codes returned by these entry point:

   error_table_$ai_restricted
         an attempt to write down a message
         or write a message into an AIM inappropriate mseg.
   error_table_$action_not_performed
         normals not accepted, by urgents are.
   error_table_$no_append
        insufficient access to add a message.
   error_table_$wakeup_denied
        insufficient access to send a wakeup.
   error_table_$messages_deferred
        recipient has deferred messages.
   error_table_$messages_off
        recipient has not initialized for accepting messages.
   error_table_$no_info
        no information can be returned because recipient has higher authorization.
*/

mseg_mbx_ms_gate_target_$wakeup_add_index:
     entry (a_mseg_index, a_ms_ptr, a_ms_len, a_sw, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (INDEX_ENTRY, mseg_access_operations_$add_message);
	operation.message_info.ms_access_class = aim_util_$get_access_class (operation.caller.authorization);
	operation.message_info_valid = "1"b;
	call wakeup_add;

mseg_mbx_ms_gate_target_$wakeup_aim_add_index:
     entry (a_mseg_index, a_ms_ptr, a_ms_len, a_sw, a_access_class, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (INDEX_ENTRY, mseg_access_operations_$add_message);
	operation.message_info.ms_access_class = a_access_class;
	operation.message_info_valid = "1"b;
	call wakeup_add;

mseg_mbx_ms_gate_target_$wakeup_add_file:
     entry (a_dn, a_en, a_ms_ptr, a_ms_len, a_sw, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (FILE_ENTRY, mseg_access_operations_$add_message);
	operation.message_info.ms_access_class = aim_util_$get_access_class (operation.caller.authorization);
	operation.message_info_valid = "1"b;
	call wakeup_add;

mseg_mbx_ms_gate_target_$wakeup_aim_add_file:
     entry (a_dn, a_en, a_ms_ptr, a_ms_len, a_sw, a_access_class, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (FILE_ENTRY, mseg_access_operations_$add_message);
	operation.message_info.ms_access_class = a_access_class;
	operation.message_info_valid = "1"b;
	call wakeup_add;


wakeup_add:
     procedure ();

declare	user_accepting		bit (1) aligned;
declare	censor_wakeup_code		bit (1) aligned;
declare	wakeup			bit (1) aligned;
declare	wakeup_code		fixed bin (35);
dcl	1 switch			aligned,		/* wakeup control switches */
	  2 normal_wakeup		bit (1) unaligned,
	  2 urgent_wakeup		bit (1) unaligned,
	  2 always_add		bit (1) unaligned,
	  2 never_add		bit (1) unaligned,
	  2 pad			bit (32) unaligned;

	operation.message_info.ms_ptr = a_ms_ptr;
	operation.message_info.ms_len = a_ms_len;
	unspec (switch) = a_sw;

	wakeup = switch.normal_wakeup | switch.urgent_wakeup;

	if wakeup
	then call investigate_acceptance (user_accepting);
	else user_accepting = "0"b;

	if user_accepting
	then					/* implies that wakeup is set */
	     if aim_check_$greater_or_equal (operation.wakeup_state.access_class,
		operation.message_info.ms_access_class) /* acceptor is higher than planned access class of message */
	     then operation.message_info.ms_access_class = operation.wakeup_state.access_class;
						/* Upgrade, over-riding any user-specified access class */


/**** Now we are ready to check access.
      The user is requesting that we add a message. 

      1) Test to see if the message can be added.
      2) If it cannot be added, quit.
      3) If a wakeup is required, test to see if the wakeup can be sent. 
      4) If it cannot be sent, and always_add is not enabled, then quit.
      5) Add the message.
      6) If a wakeup can be sent, send it. */


/**** Has the user "a" access and is the AIM situation plausible ? */

	operation.access_operation = mseg_access_operations_$add_message;
	call mseg_check_access_$check (addr (operation), code);

	if code ^= 0
	then do;
		if ^switch.never_add
		then do;				/* Never add --> don't do anthing, so we shouldn't audit it. */
			call mseg_check_access_$segment (addr (operation), (0));
						/* Okay, audit */
		     end;
		if code = error_table_$moderr
		then code = error_table_$no_append;
		call RETURN (code);			/* and punt */
	     end;


/**** Now, can we send a wakeup? */

	if wakeup
	then do;
		wakeup_code = 0;
		if switch.normal_wakeup
		then operation.access_operation = mseg_access_operations_$send_normal_wakeup;
		else operation.access_operation = mseg_access_operations_$send_urgent_wakeup;

/**** This just makes the w/u mode checks. It makes NO aim checks */

		if switch.never_add
		then call mseg_check_access_$check (addr (operation), code);
		else call mseg_check_access_$segment (addr (operation), code);

		if code ^= 0
		then if switch.always_add
		     then wakeup_code = error_table_$wakeup_denied;
		     else call RETURN (error_table_$wakeup_denied);


/****  If the user lacks w/u, that lack governs the error code, as 
       calculated above. If the user has w/u, then the user is entitled
       to hear that there is noone accepting by getting messages_off. */

		if ^user_accepting & wakeup_code = 0
		then if switch.always_add
		     then wakeup_code = error_table_$messages_off;
		     else call RETURN (error_table_$messages_off);


/**** Now we have a little problem. We cannot tell if we will succeed
      at sending a wakeup on AIM grounds, since it will depend on
      the receiver's privilege situation. (and, or course, that
      cannot be investigated via admin gate, and could change at any time.)
      So we pretend that receiver IPC privilege don't exist,
      and demand either that we have ipc priv, that no priv is needed,
      or that always_add be on. This check does NOT audit. Turning off
      always add means "if I could send without an AIM error, send.
      If you cannot tell me that, then don't send and return ai_restricted"
      Note that if always_add is on, and we DO call hcs_$wakeup,
      it might return 0 due to target IPC priv. */

		if user_accepting & ^switch.always_add
		then if ((operation.caller.privileges & sys_info$ipc_privilege) = ""b)
		     then if ^aim_check_$greater_or_equal (operation.wakeup_state.access_class,
			     operation.caller.authorization)
			then call RETURN (error_table_$ai_restricted);

/**** From now on, if the acceptor is aim-greater than us, we censor
      all results to no-info. Why isn't this in the access kernel?
      Because it's just too hard to arrange. */

		if user_accepting
		then censor_wakeup_code =
			((operation.caller.privileges & sys_info$ring1_privilege) = ""b)
			& aim_check_$greater (operation.wakeup_state.access_class, operation.caller.authorization);
		else censor_wakeup_code = "0"b;

/**** Okay, now we have passed the per-se access control checks. Now we
      see if the acceptor of messages is willing to accept a message
      from this process. */

		if wakeup_code = 0 & user_accepting
		then do;

			if (switch.urgent_wakeup & ^operation.wakeup_state.accepting_urgent_wakeups)
			then if switch.always_add
			     then wakeup_code = error_table_$messages_deferred;
			     else call WAKEUP_RETURN (error_table_$messages_deferred);

			if (switch.normal_wakeup & ^operation.wakeup_state.accepting_normal_wakeups)
			then do;
				if operation.wakeup_state.accepting_urgent_wakeups
				then wakeup_code = error_table_$action_not_performed;
				else wakeup_code = error_table_$messages_deferred;
				if ^switch.always_add
				then call WAKEUP_RETURN (wakeup_code);

			     end;
		     end;
	     end;


/**** Okay, we are ready to actually do something. If we cannot send
      the wakeup, wakeup_code has the reason why, subject to censorship */

	if switch.never_add
	then do;
		operation.message_info.ms_id = ""b;
		code = 0;
	     end;


	else do;

/* add message */

		operation.access_operation = mseg_access_operations_$add_message;
		call mseg_check_access_$segment (addr (operation), (0));
						/* audit the add now */
		call mseg_$add_message (addr (operation), code);

/* send wakeup */

		if wakeup & code = 0 & wakeup_code = 0 & user_accepting
		then do;
			unspec (event_message) = operation.message_info.ms_id;
			call hcs_$wakeup ((operation.wakeup_state.process_id), operation.wakeup_state.event_channel,
			     event_message, wakeup_code);
			if wakeup_code ^= 0 & wakeup_code ^= error_table_$wakeup_denied
			then wakeup_code = error_table_$messages_off;
		     end;
	     end;

	if code = 0
	then do;					/* the message was added */
		a_ms_id = operation.message_info.ms_id;
		if wakeup
		then call WAKEUP_RETURN (wakeup_code);	/* ... tell the caller what happened to the wakeup (maybe) */
		else call RETURN (0);
	     end;

	else call RETURN (code);


investigate_acceptance:
     procedure (accepting);

declare	accepting			bit (1) aligned;

	accepting = "0"b;				/* until proven otherwise */

	call mseg_$get_wakeup_state_seg (addr (operation), code);

	if (code ^= 0) & (code ^= error_table_$messages_off)
	then call RETURN (code);			/* message segment kaboom */
	if code = 0
	then do;
		test_lock_id = operation.wakeup_state.lock_id;
		call set_lock_$lock (test_lock_id, 0, code);
		if code = 0 | code = error_table_$invalid_lock_reset
		then code = error_table_$messages_off;
		else code = 0;
	     end;
	if code = 0
	then do;
		accepting = "1"b;
		operation.wakeup_state_valid = "1"b;	/* used inside check-access later */
	     end;

	return;
     end investigate_acceptance;

WAKEUP_RETURN:
     procedure (w_code);

declare	w_code			fixed bin (35);

	if censor_wakeup_code
	then call RETURN (error_table_$no_info);
	else call RETURN (w_code);
     end WAKEUP_RETURN;

     end wakeup_add;


mseg_mbx_ms_gate_target_$accept_wakeups_index:
     entry (a_mseg_index, a_event_channel, a_sw, a_code);

	call entry_setup;
	on cleanup call general_clean_up;

	call entry_common$$no_access_check (INDEX_ENTRY, mseg_access_operations_$accept_wakeups_seg);
						/* access check requires the segment's wakeup state */

	call accept_wakeups;
	call RETURN (code);


accept_wakeups:
     procedure ();

dcl	1 switch			aligned,		/* wakeup control switches */
	  2 normal_wakeup		bit (1) unaligned,
	  2 urgent_wakeup		bit (1) unaligned;

	user_event_channel = a_event_channel;
	unspec (switch) = substr(a_sw,1,length(unspec(switch)));

	call mseg_$get_wakeup_state_seg (addr (operation), code);
	if (code ^= 0) & (code ^= error_table_$messages_off)
	then return;
	operation.wakeup_state_valid = (code = 0);

	call mseg_check_access_$segment (addr (operation), code);
	if code ^= 0
	then return;

	operation.wakeup_state.accepting_normal_wakeups = switch.normal_wakeup;
	operation.wakeup_state.accepting_urgent_wakeups = switch.urgent_wakeup;
	operation.wakeup_state.event_channel = user_event_channel;
	operation.wakeup_state_valid = "1"b;

	call mseg_$set_wakeup_state_seg (addr (operation), code);
	return;
     end accept_wakeups;


mseg_mbx_ms_gate_target_$incremental_read_index:
     entry (a_mseg_index, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_message);

old_incremental_read:
	area_ptr = a_area_ptr;
	dir = a_dir;
	ms_id = a_ms_id;
	arg_ptr = a_arg_ptr;
	string (old_read_flags) = ""b;
	old_read_flags.incremental = "1"b;
	old_read_flags.incremental_direction = dir;
	call read_for_old_entrypoint (ms_id);
	call RETURN (code);

mseg_mbx_ms_gate_target_$get_message_count_index:
     entry (a_mseg_index, a_ms_count, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$get_count_seg);

get_message_count:
	call mseg_$count_messages (addr (operation), ms_count, code);
	a_ms_count = ms_count;
	call RETURN (code);


mseg_mbx_ms_gate_target_$get_mode_index:
     entry (a_mseg_index, a_mode, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_fs_attr_seg);

get_mode:
	a_mode = operation.access_info.extended_access_modes;
	call RETURN (code);


mseg_mbx_ms_gate_target_$check_salv_bit_index:
     entry (a_mseg_index, a_turn_off, a_salv_bit, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	turn_off = a_turn_off;

	if ^turn_off
	then call entry_common (INDEX_ENTRY, mseg_access_operations_$read_attr_seg);
	else call entry_common (INDEX_ENTRY, mseg_access_operations_$reset_salvage_bit_seg);

check_salv_bit:
	call mseg_$get_salvaged_flag_seg (addr (operation), salv_bit, code);
	if code ^= 0
	then call RETURN (code);
	if turn_off
	then call mseg_$reset_salvaged_flag_seg (addr (operation), code);
	a_salv_bit = salv_bit;
	call RETURN (code);



mseg_mbx_ms_gate_target_$update_message_index:
     entry (a_mseg_index, a_ms_len, a_ms_id, a_ms_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$update_message);

update_message:
	operation.message_info.ms_len = a_ms_len;
	operation.message_info.ms_id = a_ms_id;
	operation.message_info.ms_ptr = a_ms_ptr;
	operation.message_info_valid = "1"b;
	call mseg_$update_message (addr (operation), code);
	call RETURN (code);


mseg_mbx_ms_gate_target_$read_file:
     entry (a_dn, a_en, a_area_ptr, a_ms_wanted, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$read_message);
	go to old_read;


mseg_mbx_ms_gate_target_$delete_file:
     entry (a_dn, a_en, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$delete_message);
	go to delete;



mseg_mbx_ms_gate_target_$read_delete_file:
     entry (a_dn, a_en, a_area_ptr, a_ms_wanted, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$read_delete_message);
	go to old_read_delete;


mseg_mbx_ms_gate_target_$add_file:
     entry (a_dn, a_en, a_ms_ptr, a_ms_len, a_ms_id, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common$$no_access_check (FILE_ENTRY, mseg_access_operations_$add_message);
	operation.message_info.ms_access_class = aim_util_$get_access_class (operation.caller.authorization);
	go to add;

mseg_mbx_ms_gate_target_$accept_wakeups_file:
     entry (a_dn, a_en, a_event_channel, a_code);

	call entry_setup;
	on cleanup call general_clean_up;

	call entry_common$$no_access_check (FILE_ENTRY, mseg_access_operations_$accept_wakeups_seg);
						/* access check requires segment's wakeup state */

	call accept_wakeups;
	call RETURN (code);

mseg_mbx_ms_gate_target_$incremental_read_file:
     entry (a_dn, a_en, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$read_message);
	go to old_incremental_read;

mseg_mbx_ms_gate_target_$get_message_count_file:
     entry (a_dn, a_en, a_ms_count, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$get_count_seg);
	go to get_message_count;

mseg_mbx_ms_gate_target_$get_mode_file:
     entry (a_dn, a_en, a_mode, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_BRIEF_ENTRY, mseg_access_operations_$read_fs_attr_seg);
	go to get_mode;


mseg_mbx_ms_gate_target_$check_salv_bit_file:
     entry (a_dn, a_en, a_turn_off, a_salv_bit, a_code);

	turn_off = a_turn_off;
	call entry_setup;
	on cleanup call general_clean_up;

	if ^turn_off
	then call entry_common (FILE_ENTRY, mseg_access_operations_$read_attr_seg);
	else call entry_common (FILE_ENTRY, mseg_access_operations_$reset_salvage_bit_seg);

	go to check_salv_bit;

mseg_mbx_ms_gate_target_$update_message_file:
     entry (a_dn, a_en, a_ms_len, a_ms_id, a_ms_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$update_message);
	go to update_message;

mseg_mbx_ms_gate_target_$o_read_index:
     entry (a_mseg_index, a_area_ptr, a_ms_wanted, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_own_message);

old_o_read:
	area_ptr = a_area_ptr;
	ms_wanted = a_ms_wanted;
	arg_ptr = a_arg_ptr;
	string (old_read_flags) = ""b;
	old_read_flags.first_or_last = ms_wanted;
	old_read_flags.own = "1"b;
	ms_id = ""b;
	call read_for_old_entrypoint (ms_id);
	call RETURN (code);


mseg_mbx_ms_gate_target_$o_incremental_read_index:
     entry (a_mseg_index, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (INDEX_ENTRY, mseg_access_operations_$read_own_message);

old_o_incremental_read:
	area_ptr = a_area_ptr;
	dir = a_dir;
	ms_id = a_ms_id;
	arg_ptr = a_arg_ptr;
	string (old_read_flags) = ""b;
	old_read_flags.incremental = "1"b;
	old_read_flags.incremental_direction = dir;
	old_read_flags.own = "1"b;
	call read_for_old_entrypoint (ms_id);
	call RETURN (code);

mseg_mbx_ms_gate_target_$o_read_file:
     entry (a_dn, a_en, a_area_ptr, a_ms_wanted, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$read_own_message);
	go to old_o_read;



mseg_mbx_ms_gate_target_$o_incremental_read_file:
     entry (a_dn, a_en, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	call entry_common (FILE_ENTRY, mseg_access_operations_$read_own_message);
	go to old_o_incremental_read;

mseg_mbx_ms_gate_target_$general_read_index:
     entry (a_mseg_index, a_area_ptr, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;
	read_entry_type = INDEX_ENTRY;

read:
	area_ptr = a_area_ptr;
	mseg_message_info_ptr = a_arg_ptr;
	operation.message_info = mseg_message_info;
	if operation.message_info.version ^= MSEG_MESSAGE_INFO_V1
	then do;
		code = error_table_$unimplemented_version;
		call RETURN (code);
	     end;

	if operation.message_info.delete & operation.message_info.own
	then call entry_common (read_entry_type, mseg_access_operations_$read_delete_own_message);
	else if operation.message_info.delete
	then call entry_common (read_entry_type, mseg_access_operations_$read_delete_message);
	else if operation.message_info.own
	then call entry_common (read_entry_type, mseg_access_operations_$read_own_message);
	else call entry_common (read_entry_type, mseg_access_operations_$read_message);

	operation.message_info_valid = "1"b;
	call mseg_$read_message (addr (operation), area_ptr, code);
	mseg_message_info = operation.message_info;
	call RETURN (code);

mseg_mbx_ms_gate_target_$general_read_file:
     entry (a_dn, a_en, a_area_ptr, a_arg_ptr, a_code);

	call entry_setup;
	on cleanup call general_clean_up;

	read_entry_type = FILE_ENTRY;
	go to read;

check_name:
     proc (entryname, code);

dcl	entryname			char (32);
dcl	code			fixed bin (35);
dcl	slength			fixed bin;
dcl	sindex			fixed bin;

	code = 0;
	slength = length (rtrim (entryname));
	sindex = index (reverse (rtrim (entryname)), ".");
	if sindex ^= 0 then
	     if substr (entryname, slength - sindex + 1) = SUFFIX (operation.type) then;
	     else code = error_table_$bad_file_name;
	else code = error_table_$bad_file_name;
	return;
     end check_name;

copy_acl:
     proc (p_acl_ptr, p_acl_count);

dcl	p_acl_ptr			ptr;
dcl	p_acl_count		fixed bin;

	if p_acl_count = 0 | p_acl_ptr = null ()
	then do;
		acl_count = 0;
		acl_ptr = null ();
	     end;

	acl_count = p_acl_count;
	allocate general_extended_acl set (internal_acl_ptr);
	acl_ptr = internal_acl_ptr;

	general_extended_acl.version = GENERAL_EXTENDED_ACL_VERSION_1;
	general_extended_acl.entries = p_acl_ptr -> segment_acl_array;

	return;

copy_acl$$delete:
     entry (p_acl_ptr, p_acl_count);

	if p_acl_ptr = null () | p_acl_count = 0
	then call RETURN (error_table_$null_info_ptr);

	if p_acl_count = -1
	then do;
		acl_ptr, internal_acl_ptr = null ();	/* null to the primitive means "delete all" */
		acl_count = 0;			/* never looked at */
		return;
	     end;

	acl_count = p_acl_count;
	allocate general_delete_acl set (internal_acl_ptr);
	acl_ptr = internal_acl_ptr;

	general_delete_acl.version = GENERAL_DELETE_ACL_VERSION_1;
	general_delete_acl.entries = p_acl_ptr -> delete_acl_array;
	return;

     end copy_acl;



free:
     procedure;

	if internal_acl_ptr ^= null
	then free internal_acl_ptr -> general_extended_acl in (system_area);
	return;

     end free;


set_admin_level:
     procedure;

	validation_set = "1"b;
	if operation.call_admin_gate
	then call admin_gate_$admin_level_no_fs_audit ((0));
						/* we already stored the caller level */
	else call hcs_$level_set (mseg_data_$execution_ring);
	return;
     end set_admin_level;

reset_admin_level:
     procedure;

	if validation_set
	then call hcs_$level_set (operation.caller.validation_level);
	validation_set = "0"b;
	return;
     end reset_admin_level;

general_clean_up:
     procedure;

	if file_sw
	then call mseg_$close_seg (addr (operation), table_ptr, (0));
	if copy_entry
	then call clean_up_copy;
	if internal_acl_ptr ^= null ()
	then do;
		if general_extended_acl.version = GENERAL_EXTENDED_ACL_VERSION_1
		then user_acl_ptr -> segment_acl_array (*).status_code = general_extended_acl.entries (*).status_code;
		else if general_delete_acl.version = GENERAL_DELETE_ACL_VERSION_1
		then user_acl_ptr -> delete_acl_array (*).status_code = general_delete_acl.entries (*).status_code;
		call free;
	     end;
	call reset_admin_level ();

clean_up_copy:
     procedure;

	call mseg_$close_seg (addr (target_operation), table_ptr, (0));
	a_error_on_target = error_on_target;
	return;
     end clean_up_copy;

     end general_clean_up;


RETURN_:
	call general_clean_up;
	if code = error_table_$dirseg
	then code = error_table_$not_seg_type;
	a_code = code;
	return;


EARLY_RETURN:
	if code = error_table_$dirseg
	then code = error_table_$not_seg_type;
	a_code = code;

	return;

read_for_old_entrypoint:
     procedure (a_ms_id);

declare	1 mra			aligned like mseg_return_args;
declare	a_ms_id			bit (72) aligned;

	operation.message_info.ms_id = a_ms_id;

	if ^old_read_flags.incremental
	then do;
		if old_read_flags.first_or_last
		then operation.message_info.message_code = MSEG_READ_LAST;
		else operation.message_info.message_code = MSEG_READ_FIRST;
	     end;
	else if old_read_flags.incremental_direction = "00"b
	then operation.message_info.message_code = MSEG_READ_SPECIFIED;
	else if old_read_flags.incremental_direction = "10"b
	then operation.message_info.message_code = MSEG_READ_BEFORE_SPECIFIED;
	else if old_read_flags.incremental_direction = "01"b
	then operation.message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
	else call RETURN (error_table_$inconsistent);	/* incr with bad direction */

	operation.message_info.own = old_read_flags.own;
	operation.message_info.delete = old_read_flags.delete;
	operation.message_info_valid = "1"b;
	call mseg_$read_message (addr (operation), area_ptr, code);
	if code = 0
	then do;
		mra.ms_ptr = operation.message_info.ms_ptr;
		mra.ms_len = operation.message_info.ms_len;
		mra.sender_id = operation.message_info.sender_id;
		mra.level = operation.message_info.sender_level;
		mra.ms_id = operation.message_info.ms_id;
		mra.sender_authorization = operation.message_info.sender_authorization;
		mra.access_class = operation.message_info.ms_access_class;
		arg_ptr -> mseg_return_args = mra;
	     end;
	return;
     end read_for_old_entrypoint;


entry_setup:
     procedure;

declare	(
	message_segment_$,
	mailbox_$,
	queue_admin_$
	)			bit (36) aligned ext static;

	operation = addr (mseg_data_$template_operation) -> mseg_operation;


/**** Callers may not have access to queue_admin_, so the following
      avoids touching it unneccessarily. */

	if setwordno (cu_$caller_ptr (), 0) = addr (mailbox_$)
	then operation.type = MSEG_TYPE_MBX;
	else if setwordno (cu_$caller_ptr (), 0) = addr (message_segment_$)
	then operation.type = MSEG_TYPE_MS;
	else if setwordno (cu_$caller_ptr (), 0) = addr (queue_admin_$)
	then operation.type = MSEG_TYPE_MS;
	else call sub_err_ (0, "mseg_mbx_ms_gate_target_", ACTION_CANT_RESTART, null (), (0),
		"Caller was not mailbox_, message_segment_, or queue_admin_");

	operation.caller.validation_level = hcs_$level_get ();
	operation.caller.authorization = get_process_authorization_ ();
	operation.caller.max_authorization = mseg_data_$process_max_authorization;
	operation.caller.privileges =
	   substr(aim_util_$get_privileges (operation.caller.authorization),1,length(operation.caller.privileges));
	operation.caller.group_id = mseg_data_$group_id;
	validation_set = "0"b;			/* no need to reset the level */
	operation.call_admin_gate = (mseg_data_$execution_ring = mseg_data_$admin_ring);
	copy_entry = "0"b;
	internal_acl_ptr = null ();
	file_sw = "0"b;

	return;
     end entry_setup;


entry_common:
     procedure (entry_type, base_operation);

declare	entry_type		fixed bin;
declare	base_operation		fixed bin;
declare	(return_code, dont_call_mca)	bit (1) aligned;

	dont_call_mca = "0"b;
	return_code = "0"b;
	go to COMMON;


entry_common$$no_access_check:
     entry (entry_type, base_operation);

	dont_call_mca = "1"b;
	return_code = "0"b;				/* not that it will ever be used */
	go to COMMON;


entry_common$$return_error:
     entry (entry_type, base_operation);

	dont_call_mca = "0"b;
	return_code = "1"b;


COMMON:
	operation.access_operation = base_operation;

/**** This next line sets the validation level to the ring of execution.
      If the ring of execution is 1, it also suppresses ring zero file
      system auditing. It would be better coding practice to reduce
      the scope of this to the minimum neccessary. However, this entire
      subsystem would need to be restructured to support that. */

	call set_admin_level ();

	if entry_type = INDEX_ENTRY
	then call index_setup;
	else if entry_type = FILE_ENTRY
	then call file_setup;
	else if entry_type = FILE_BRIEF_ENTRY
	then call file_brief_setup;
	else if entry_type = FILE_TEMP_ENTRY
	then call file_temp_setup;

	if dont_call_mca				/* caller isn't ready for mseg_check_access_ yet */
	then return;

	call mseg_check_access_$segment (addr (operation), code);
	if code ^= 0
	then if return_code
	     then return;
	     else call RETURN (code);

	return;


index_setup:
     procedure ();

	operation.mseg_index = a_mseg_index;		/* copy the parameter, all such gates have it */

	table_ptr = static_table_ptr (operation.type);
	if table_ptr = null ()
	then call RETURN (error_table_$seg_unknown);

	if operation.mseg_index < 1 | operation.mseg_index > mseg_table.table_length
	then call RETURN (error_table_$seg_unknown);

	operation.mseg_ptr = mseg_table.mseg_ptr (operation.mseg_index);

	if operation.mseg_ptr = null ()
	then call RETURN (error_table_$seg_unknown);

	operation.mseg_ptr_valid = "1"b;
	operation.mseg_index_valid = "1"b;

	return;

     end index_setup;


file_setup:
     procedure ();

	file_sw = "1"b;

	operation.dir_name = a_dn;			/* copy the parameters */
	operation.entryname = a_en;
	operation.mseg_pathname_valid = "1"b;

	call check_name (operation.entryname, code);
	if code ^= 0
	then call RETURN (code);

	call mseg_$initiate_seg (addr (operation), code);
	if code ^= 0
	then do;
		call mseg_check_access_$audit_initiate_failure (addr (operation), code);
		call RETURN (code);			/* must be sure to audit failure and censor code if needed */
	     end;

	return;

     end file_setup;


file_brief_setup:
     procedure ();

	operation.dir_name = a_dn;			/* copy the parameters */
	operation.entryname = a_en;
	operation.mseg_pathname_valid = "1"b;

	call check_name (operation.entryname, code);
	if code ^= 0
	then call RETURN (code);

	return;

     end file_brief_setup;


file_temp_setup:
     procedure ();

	operation.dir_name = a_dn;			/* copy the parameters */
	operation.entryname = a_en;
	operation.mseg_pathname_valid = "1"b;

	call check_name (operation.entryname, code);
	if code ^= 0
	then call RETURN (code);

	return;

     end file_temp_setup;

     end entry_common;


RETURN:
     procedure (return_error_code);

declare	return_error_code		fixed bin (35);

	code = return_error_code;
	go to RETURN_;

     end RETURN;

/* format: off */
%page; %include mseg_data_;
%page; %include mseg_return_args;
%page; %include mseg_message_info;
%page; %include mseg_operation;
%page; %include mseg_wakeup_state;
%page; %include entry_access_info;
%page; %include mseg_access_operations_;
%page; %include mlsys_mailbox_modes;
%page; %include mseg_index_table;
%page; %include sub_err_flags;
%page; %include mseg_entries;
%page; %include acl_structures;
     end mseg_mbx_ms_gate_target_;

