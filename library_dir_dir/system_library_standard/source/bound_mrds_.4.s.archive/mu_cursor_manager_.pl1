/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
mu_cursor_manager_: proc;

/*

                      BEGIN_DESCRIPTION
   This  routine  is used to manage the storage of cursors and their
   pointers.   Each cursor is associated with a relation-opening-id,
   a   collection-index   and  a  tuple-variable.  The  main   entry 
   mu_cursor_manager_$mu_cursor_manager_ should never be called

*******************************************************************************
*******************************************************************************
   Note that this entire module is now unnecessary with the advent of
   relation cursors.  The management of cursors has become simple enough
   that it can be handled in the same way that iocbs used to be handled.
   The only reason this module still exists is to expedite the conversion
   to relation cursors.  It will be deleted soon or significantly rewritten
   and simplified.
*******************************************************************************
*******************************************************************************

   The get entry  is  used to get the cursor associated with a given
   <rel_opening_id-collection_index-tupe-variable>.   If  the cursor
   has  not  yet been created a call to the relation_manager is made
   to  create  it.   After creation it is stored in the storage area
   for  future  reference.  The storage area will be either a simple
   array overlaid on a temp segment and sorted by <r-c-t> or a keyed
   sequential  file  with  keys  of <r-c-t>.  The first call to this
   procedure  on  behalf  of  a  database  index  should have a null
   storage pointer and a null area pointer input so that the storage
   and area will be created. This entry will also cause the relation
   to be opened if it is not already in the opened state.


   The  destroy_all_no_free  entry destroys the storage used to hold
   the  cursor  pointers,  and closes the relations that the cursors
   were  associated  with.  The  temp seg area where the cursors are
   stored is also deleted.


   The entry destroy_and_free_on_opening_id is used to  destroy  the
   storage   used   to   hold   the   cursor  pointers  for  cursors 
   associated  with a given opening id. It also destroys the cursors
   associated with the given opening id and closes the relation with
   the given opening id.


   The  cleanup_storage  entry  releases the temp segment area where
   the  cursors are allocated and destroyes the storage used to hold
   the  cursor  pointers.   It  assumes that the relations have been
   closed by some other means

   Known Bugs:

   Other Problems:

   History:
      82-09-13 Davids: written
    
      82-09-24 Donna Woodka : changed declaration of mcm_collection_index
      and cc_collection_id from fixed bin (35) to bit (36) aligned.

      82-09-29 Davids: added the destroy_and_free_on_opening_id
      entry and the move_chars internal proc. Changed the internal proc
      add_cursor_to_array to use move_chars instead of the faulty
      mu_mrl_. Also added the temp_space_begins element to the mcm_cursor_array
      structure and changed the size of the array to be a constant instead
      of a refers.

      82-10-15 Davids: Modified the get entry to create an area to alloacte
      the cursors in if the storage_ptr is null. Modified the 
      destroy_all_no_free entry to have the area_ptr as a parameter and to
      free the temp seg the area_ptr points to. Freeing is done via
      release_temp_segment_ because that is how mu_define_area creates the
      temp segment. All this makes the mcm_area_ptr an input/output
      parameter.

      82-10-18 Davids: Modified all entries to set the value of code to 0
      as the first thing they do so if no error occurs the code returned
      will be 0.

      82-11-24 Davids: Modified call to move_chars in delete_cursors_from_array
      to have the correct number of bytes to move.

      82-12-03 Davids: Modified to delete the temp seg that the cursor ptrs are
      stored in. This required storing a character representation of the dbi
      in the cursor_array structure so that only the temp seg associated with 
      the database being closed will be deleted.

      83-01-03 Davids: Added the cleanup_storage entry. The relations will be
      closed by running through the rm_rel_info structures and getting the
      opening_id instead of calling the destroy_all_no_free entry. The
      cleanup_storage entry was needed to neatly cleanup the storage used
      by mu_cursor_manager.
                      END_DESCRIPTION



       Naming  convension:  becuase  of the number of internal
       routines  and  the need for discriptive names variables
       declared  in  all  routines  (including the main entry)
       have  prefixes  that  are  the  initials of the routine
       name.   Global  variables  can be identified since they
       have  a  prefix  different  from  that derived from the
       routine  name.  Variables with the same name except for
       the  prefix  mean  the same thing.  Variables without a
       prefix  are  external to the module, i.e.  entry names,
       external  static,  builtins,  conditions,  etc.   These
       variables  are declared in the main routine.  Variables
       with  names  in  upper case (except for the prefix) are
       internal static constants.
*/

/* PARAMETERS */

	dcl     mcm_dbi		 fixed bin (35);	/* (input) database index */
	dcl     mcm_rmri_ptr	 ptr;		/* (input) pointer to the relation's rm_rel_info structure
                                                                       which contains the rel_opening_id and from which
                                                                       the path of the relation can be determined */
	dcl     mcm_opening_id	 bit (36) aligned;	/* (input) opening id for the relation */
	dcl     mcm_tuple_var_index	 fixed bin (35);	/* (input) tuple variable associated with the cursor */
	dcl     mcm_collection_index	 bit (36) aligned;	/* (input) this was used before the conversion to
						           relation cursors and is interm.  It is
							 not currently used by this routine. */
	dcl     mcm_relmgr_create_cursor entry;		/* (input) relation_manager entry for creating a cursor */
	dcl     mcm_relmgr_open	 entry;		/* (input) relation_manager entry for opening a relation */
	dcl     mcm_relmgr_close	 entry options (variable);
						/* (input) relation_manager entry for closing a relation */
	dcl     mcm_relmgr_destroy_cursor entry;	/* (input) relation_manager entry for destroying a cursor */
	dcl     mcm_area_ptr	 ptr;		/* (input / output) ptr to area where
                                                                                cursors are to be allocated */
	dcl     mcm_storage_ptr	 ptr;		/* (input / output) pointer to storage where the mapping
                                                                                between <r-c-t> and cursor_ptrs is kept */
	dcl     mcm_cursor_ptr	 ptr;		/* (output) pointer to a cursor */
	dcl     mcm_code		 fixed bin (35);	/* (output) standard error code */

/* AUTOMATIC */

	dcl     mcm_cursor_index	 fixed bin;	/* index in the cursor array of where the
                                                               cursor is (and wher it should be stored) */
	dcl     mcm_found		 bit (1);		/* "1"b ==> cursor was already in storage
                                                                        and may just be returned
                                                               "0"b ==> cursor not in storage and must be created */
	dcl     mcm_key		 char (12);	/* key identifing the cursor */
	dcl     mcm_unused1		 ptr;		/* unused output from vfile_search -
                                                               we know the value will be null */
	dcl     mcm_unused2		 bit (1);		/* unused output from vfile_search -
                                                               we know the cursor won't be found */

/* CONSTANTS */

	dcl     mcm_ARRAY		 fixed bin init (1) internal static options (constant);
						/* indicates that storage area is of type ARRAY */
	dcl     mcm_CURSOR_ARRAY_ELEMENT_SIZE fixed bin init (24) internal static options (constant);
						/* length in characters of a cursor element (key and pointer),
                                                               key is 12 chars or and the ptr 8 but there is a 4 char
                                                               (1 word) implicit pad to make the pointer
                                                               start on an even word */
	dcl     mcm_CURSOR_PTR_LENGTH	 fixed bin (21) init (8) internal static options (constant);
						/* length of a cursor ptr ==> 2 words or 8 bytes */
	dcl     mcm_MAX_NUM_FOR_ARRAY_STORAGE fixed bin init (1000) internal static options (constant);
						/* maximum number of cursors that can be stored as an
                                                               array before a keyed file becomes more efficient */
	dcl     mcm_PROC_NAME	 char (18) init ("mu_cursor_manager_") internal static options (constant);
	dcl     mcm_VFILE		 fixed bin init (2) internal static options (constant);
						/* indicates that storage area is of type VFILE */

/* BASED */

	dcl     mcm_b36b		 bit (36) unaligned based; /* bit 36 overlay */
	dcl     mcm_c4b		 char (4) based;	/* 4 character overlay */

	dcl     01 mcm_cursor_array	 unaligned based,
		02 version	 char (4),
		02 num		 fixed bin,
		02 dbi_char	 char (4),
		02 mbz		 bit (36),
		02 cursors	 (mcm_MAX_NUM_FOR_ARRAY_STORAGE),
		  03 key		 char (12),
		  03 cursor_ptr	 ptr aligned,
		02 temp_space_begins bit (1) aligned;

/* EXTERNAL STATIC */

	dcl     error_table_$end_of_info fixed bin (35) ext static;
	dcl     error_table_$no_record fixed bin (35) ext static;
	dcl     mrds_error_$unknown_cursor_storage fixed bin (35) external static;
	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;

/* ENTRIES */

	dcl     delete_$path	 entry (char (*), char (*), bit (6), char (*), fixed bin (35));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$delete_record	 entry (ptr, fixed bin (35));
	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
	dcl     iox_$read_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
	dcl     iox_$seek_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
	dcl     mrds_dsl_resultant_storage$get_opening_temp_dir
				 entry (fixed bin (35), fixed bin (35)) returns (char (168));
	dcl     mu_define_area	 entry (ptr, fixed bin (18), char (11), bit (1) aligned, bit (1) aligned, bit (1) aligned,
				 bit (1) aligned, fixed bin (35));
	dcl     mu_temp_segments$get_temp_segment entry (fixed bin (35), char (*), ptr, fixed bin (35));
	dcl     mu_temp_segments$delete_all_temp_segments entry (char (*), fixed bin (35));
	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
	dcl     sub_err_		 entry options (variable);
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));

/* BUILTINS */

	dcl     addr		 builtin;
	dcl     char		 builtin;
	dcl     divide		 builtin;
	dcl     fixed		 builtin;
	dcl     ltrim		 builtin;
	dcl     null		 builtin;
	dcl     pointer		 builtin;
	dcl     rel		 builtin;
	dcl     rtrim		 builtin;
	dcl     substr		 builtin;
	dcl     unspec		 builtin;

/* INCLUDES */
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_db_info;
%page;
%include iocb;

get: entry (mcm_dbi, mcm_rmri_ptr, mcm_tuple_var_index, mcm_collection_index,
	mcm_relmgr_create_cursor, mcm_relmgr_open, mcm_storage_ptr,
	mcm_area_ptr, mcm_cursor_ptr, mcm_code);





	mcm_code = 0;

	if mcm_rmri_ptr -> rm_rel_info.opening_id = "0"b
	then call open_relation (mcm_relmgr_open, mcm_rmri_ptr);

	if mcm_storage_ptr = null ()
	then do;
		call build_storage (mcm_dbi, mcm_ARRAY, mcm_storage_ptr);
		call mu_define_area (mcm_area_ptr, (sys_info$max_seg_size), "cursor_area",
		     "1"b, "0"b, "0"b, "0"b, mcm_code);
		if mcm_code ^= 0
		then call error_exit (mcm_code, "Could not get a temp seg for cursor storage.");
	     end;

	mcm_key = addr (mcm_rmri_ptr -> rm_rel_info.opening_id) -> mcm_c4b ||
	     addr (mcm_tuple_var_index) -> mcm_c4b;

	if storage_type (mcm_storage_ptr) = mcm_ARRAY
	then do;
		call array_search (mcm_key, mcm_storage_ptr, mcm_cursor_index, mcm_found);
		if ^mcm_found
		then do;
			call create_cursor (mcm_rmri_ptr -> rm_rel_info.opening_id, mcm_collection_index,
			     mcm_relmgr_create_cursor, mcm_area_ptr, mcm_cursor_ptr);
			if mcm_storage_ptr -> mcm_cursor_array.num = mcm_MAX_NUM_FOR_ARRAY_STORAGE
			then do;
				call convert_array_to_vfile (mcm_storage_ptr);
				call vfile_search (mcm_key, mcm_storage_ptr, mcm_unused1, mcm_unused2);
				call add_cursor_to_vfile (mcm_storage_ptr, mcm_cursor_ptr);
			     end;
			else call add_cursor_to_array (mcm_storage_ptr, mcm_key, mcm_cursor_ptr, mcm_cursor_index);
		     end;
		else mcm_cursor_ptr = mcm_storage_ptr -> mcm_cursor_array.cursors (mcm_cursor_index).cursor_ptr;
	     end;
	else do;
		call vfile_search (mcm_key, mcm_storage_ptr, mcm_cursor_ptr, mcm_found);
		if ^mcm_found
		then do;
			call create_cursor (mcm_rmri_ptr -> rm_rel_info.opening_id, mcm_collection_index,
			     mcm_relmgr_create_cursor, mcm_area_ptr, mcm_cursor_ptr);
			call add_cursor_to_vfile (mcm_storage_ptr, mcm_cursor_ptr);
		     end;
	     end;





	goto exit;

destroy_all_no_free: entry (mcm_storage_ptr, mcm_area_ptr, mcm_relmgr_close, mcm_code);





	mcm_code = 0;

	if storage_type (mcm_storage_ptr) = mcm_ARRAY
	then call close_rels_from_array (mcm_storage_ptr, mcm_relmgr_close);
	else call close_rels_from_vfile (mcm_storage_ptr, mcm_relmgr_close);

	call destroy_storage (mcm_storage_ptr);

/* mu_define_area uses get_temp_segment_ to get the temp seg the area is based on */

	call release_temp_segment_ ("cursor_area", mcm_area_ptr, mcm_code);
	if mcm_code ^= 0
	then call error_exit (mcm_code, "Could not release the temp seg used to store the cursors.");

	goto exit;













destroy_and_free_on_opening_id: entry (mcm_opening_id, mcm_area_ptr, mcm_storage_ptr,
	mcm_relmgr_destroy_cursor, mcm_relmgr_close, mcm_code);





	mcm_code = 0;

	if storage_type (mcm_storage_ptr) = mcm_ARRAY
	then call delete_cursors_from_array (mcm_opening_id, mcm_area_ptr, mcm_storage_ptr, mcm_relmgr_destroy_cursor);
	else call delete_cursors_from_vfile (mcm_opening_id, mcm_area_ptr, mcm_storage_ptr, mcm_relmgr_destroy_cursor);

	call mcm_relmgr_close (mcm_opening_id, mcm_code);
	if mcm_code ^= 0
	then call error_exit (mcm_code, "Could not close the open relation");

	goto exit;

cleanup_storage: entry (mcm_storage_ptr, mcm_area_ptr, mcm_code);





	mcm_code = 0;

	call destroy_storage (mcm_storage_ptr);

/* mu_define_area uses get_temp_segment_ to get the temp seg the area is based on */

	call release_temp_segment_ ("cursor_area", mcm_area_ptr, mcm_code);
	if mcm_code ^= 0
	then call error_exit (mcm_code, "Could not release the temp seg used to store the cursors.");

	goto exit;

exit:
	return;

open_relation: proc (or_relmgr_open, or_rmri_ptr);

/*
   This  procedure  calls  the  relation  manager  entry to open the
   relation.   it determines the path to the relation by obtaining a
   pointer  to  the rm_db_info structure which has as an element the
   database  path,  this  coupled  with the relation's name from the
   rm_rel_info  structure  gives  the  path.   The  pointer  to  the
   rm_db_info  structure  is  obtained by forming a pointer based on
   the  seg_no  of  the or_rmri_ptr pointer and a 0 bit offset, i.e.
   the  rm_rel_info structure is allocated in the static area set up
   in the rm_db_info structure.
*/

/* PARAMETERS */

	dcl     or_relmgr_open	 entry options (variable);
						/* (input) relation_manager entry used to open the realtion */
	dcl     or_rmri_ptr		 ptr;		/* (input) pointer to the relation's rm_rel_info structure */

/* AUTOMATIC */

	dcl     or_code		 fixed bin (35);	/* standard error code */
	dcl     or_rdbi_ptr		 ptr;		/* pointer to the database's rm_db_info structure */





	or_rdbi_ptr = pointer (or_rmri_ptr, 0);

	call or_relmgr_open (or_rdbi_ptr -> rm_db_info.db_path,
	     or_rmri_ptr -> rm_rel_info.model_name,
	     or_rmri_ptr -> rm_rel_info.opening_id,
	     or_code);
	if or_code ^= 0
	then call error_exit (or_code, "Could not open the relation " || or_rmri_ptr -> rm_rel_info.name);

	return;

     end /* open_relation */;

build_storage: proc (bs_dbi, bs_storage_type, bs_storage_ptr);

/* 
   This  procedure  goes out and gets the space that will be used to
   store the cursor pointers.  If the cursors are to be stored in an
   array  a  temp  segment  is  obtained  other wise a keyed file is
   attached  and  opened.   The location of the storage (temp seg or
   keyed  file)  will be in the opening temp dir.  If a temp segment
   is  used  than  this  routine  will also initialize the number of
   cursors to 0 and the version of the structure.  No initialization
   is needed for the keyed file.
*/

/* GLOBALS

   mcm_ARRAY		indicates a storage type of array
   mcm_PROC_NAME    	procedure's name
   mcm_dbi		data base index
   mcm_cursor_array	          structure containing the array of cursors to be overlaid on the temp_seg
*/

/* PARAMETERS */

	dcl     bs_dbi		 fixed bin (35);	/* (input) database index - used for array storage only */
	dcl     bs_storage_type	 fixed bin;	/* (input) indicates whether a temp_seg or
                                                                        keyed file is to be built */
	dcl     bs_storage_ptr	 ptr;		/* (output) either a ptr to the temp_seg or the file's iocb */

/* AUTOMATIC */

	dcl     bs_code		 fixed bin (35);	/* standard error code */
	dcl     bs_dbi_char		 char (4);	/* character representation of the database index */
	dcl     bs_temp_dir		 char (168);	/* path of the opening temp dir, dir
                                                               that will contain the storage area */

/* CONSTANTS */

	dcl     bs_KSQU		 fixed bin init (10) internal static options (constant);
						/* indicates an iox opening mode of keyed-sequential-update */

	if bs_storage_type = mcm_ARRAY
	then do;
		bs_dbi_char = ltrim (char (bs_dbi));
		call mu_temp_segments$get_temp_segment (mcm_dbi, mcm_PROC_NAME || bs_dbi_char, bs_storage_ptr, bs_code);
		if bs_code ^= 0
		then call error_exit (bs_code, "Could not get a temp_segment for cursor array storage");
		bs_storage_ptr -> mcm_cursor_array.num = 0;
		bs_storage_ptr -> mcm_cursor_array.version = "ARAY";
		bs_storage_ptr -> mcm_cursor_array.dbi_char = bs_dbi_char;
		bs_storage_ptr -> mcm_cursor_array.mbz = "0"b;
	     end;
	else do;
		bs_temp_dir = mrds_dsl_resultant_storage$get_opening_temp_dir (mcm_dbi, bs_code);
		if bs_code ^= 0
		then call error_exit (bs_code, "Could not get the opening temp dir");
		call iox_$attach_name (ltrim (char (mcm_dbi)) || ".mcm." || unique_chars_ ("0"b), bs_storage_ptr,
		     "vfile_ " || rtrim (bs_temp_dir) || ">" || ltrim (char (mcm_dbi)) ||
		     ".mcm." || unique_chars_ ("0"b),
		     null (), bs_code);
		if bs_code ^= 0
		then call error_exit (bs_code, "Could not attach a temp file for cursor storage");

		call iox_$open (bs_storage_ptr, bs_KSQU, "0"b, bs_code);
		if bs_code ^= 0
		then call error_exit (bs_code, "Could not open temp file for cursor storage");
	     end;

	return;

     end /* build_storage */;

destroy_storage: proc (ds_storage_ptr);

/*
This  procedure  destroys  the  storage space associated with the
cursor  pointer  storage.  For  array  storage  the  temp  seg is
delete. For  a  vfile,  it  closed  and  detached  and  the  iocb
destroyed and the MSF is deleted.
*/

/* GLOBALS

   mcm_ARRAY		indicates a storage type of array
   mcm_PROC_NAME		procedure's name
*/

/* PARAMETERS */

	dcl     ds_storage_ptr	 ptr;		/* (input / output) input => ptr to the storage structure */
						/*               output => null */

/* AUTOMATIC */

	dcl     ds_code		 fixed bin (35);	/* standard error code */
	dcl     ds_dir		 char (168);	/* path of dir containing the vfile that the
 cursor pointers were stored in */
	dcl     ds_entry		 char (32);	/* name of the vfile containing the cursor pointers */
	dcl     ds_path		 char (168);	/* path of the vfile containing the cursor pointers */

/* BASED */

	dcl     ds_c168b		 char (168) based;	/* path overlay */

	if storage_type (ds_storage_ptr) = mcm_ARRAY
	then do;
		call mu_temp_segments$delete_all_temp_segments
		     (mcm_PROC_NAME || ds_storage_ptr -> mcm_cursor_array.dbi_char, ds_code);
		if ds_code ^= 0
		then call error_exit (ds_code, "Could not delete temp seg containing the cursor array.");
	     end;
	else do;
		ds_path = substr (ds_storage_ptr -> iocb.attach_descrip_ptr -> ds_c168b, 12);
		call expand_pathname_ (ds_path, ds_dir, ds_entry, ds_code);
		if ds_code ^= 0
		then call error_exit (ds_code, "Could not get the path of the vfile containing the cursors.");
		call iox_$close (ds_storage_ptr, ds_code);
		if ds_code ^= 0
		then call error_exit (ds_code, "Could not close the vfile containing the cursors.");
		call iox_$detach_iocb (ds_storage_ptr, ds_code);
		if ds_code ^= 0
		then call error_exit (ds_code, "Could not detach the vfile containing the cursors.");
		call iox_$destroy_iocb (ds_storage_ptr, ds_code);
		if ds_code ^= 0
		then call error_exit (ds_code, "Could not destroy the iocb for the vfile containing the cursors.");
		call delete_$path (ds_dir, ds_entry, "100100"b, mcm_PROC_NAME, ds_code);
		if ds_code ^= 0
		then call error_exit (ds_code, "Could not delete the vfile containing the cursors.");
	     end;

	ds_storage_ptr = null ();

	return;

     end /* destroy_storage */;

storage_type: proc (st_storage_ptr) returns (fixed bin);

/*
   This  procedure  determines  what type of storage the storage_ptr
   points  to.  If the storage type is a keyed file then storage_ptr
   points to an iocb, the first element in the iocb structure is a 4
   character  version  containing the string "IOX2".  If the storage
   type  is  an  array  then storage_ptr points to a structure whose
   first element is a 4 character version (to be compatable with the
   iocb) containing "ARAY".  Any thing else will generate an error.
*/

/* GLOBALS

   mcm_ARRAY		indicates a storage type of array
   mcm_VFILE		indicates a storage type of keyed file
*/

/* PARAMETERS */

	dcl     st_storage_ptr	 ptr;		/* (input) either a ptr to the temp_seg or the file's iocb */

/* AUTOMATIC */

	dcl     st_return_type	 fixed bin;	/* indicats the type of storage that storage_ptr points to */

/* BASED */

	dcl     st_c4b		 char (4) based;	/* 4 character overlay for the version element */





	if st_storage_ptr -> st_c4b = "IOX2"
	then st_return_type = mcm_VFILE;
	else
	     if st_storage_ptr -> st_c4b = "ARAY"
	then st_return_type = mcm_ARRAY;
	else call error_exit (mrds_error_$unknown_cursor_storage, "A cursor storage pointer is bad.");

	return (st_return_type);

     end /* storage_type */;

array_search: proc (as_key, as_storage_ptr, as_index, as_found);

/*
   This  procedure  performs  a binary search on the cursor array to
   locate  a  given  cursor  or  determine where it should be placed
   after it is gotten from the relation_manager.  The case of a zero
   length  array  is special cased because the search algorithm will
   not  return the correct index in which to put the new element for
   this condition.
*/

/* GLOBALS

   mcm_cursor_array          	structure containing the array of cursors to be overlaid on the temp_seg
*/

/* PARAMETERS */

	dcl     as_key		 char (12);	/* (input) the key identifing which cursor is wanted */
	dcl     as_storage_ptr	 ptr;		/* (input) ptr to the temp_seg containing the cursor array */
	dcl     as_index		 fixed bin;	/* (output) index in the array of the requested cursor or
                                                                        index of where it should placed. */
	dcl     as_found		 bit (1);		/* (output) "1"b ==> cursor was found,
                                                                        "0"b ==> it needs to be gotten */

/* AUTOMATIC */

	dcl     as_higher_index	 fixed bin;	/* highest element of the binary search */
	dcl     as_key_larger	 bit (1) aligned;	/* "1"b => if as_key > key at as_middle_index */
	dcl     as_lower_index	 fixed bin;	/* lower index of the binary search */
	dcl     as_middle_index	 fixed bin;	/* middle element of the search */





	as_found = "0"b;
	as_index = 0;

	if as_storage_ptr -> mcm_cursor_array.num = 0
	then as_index = 1;
	else do;
		as_lower_index = 1;
		as_higher_index = as_storage_ptr -> mcm_cursor_array.num;
		do while (^as_found & as_lower_index <= as_higher_index);
		     as_middle_index = divide ((as_higher_index + as_lower_index), 2, 35, 0);
		     if as_key > as_storage_ptr -> mcm_cursor_array.cursors (as_middle_index).key
		     then do;
			     as_lower_index = as_middle_index + 1;
			     as_key_larger = "1"b;
			end;
		     else
			if as_key = as_storage_ptr -> mcm_cursor_array.cursors (as_middle_index).key
		     then as_found = "1"b;
		     else do;
			     as_higher_index = as_middle_index - 1;
			     as_key_larger = "0"b;
			end;
		end;
		as_index = as_middle_index;
		if as_key_larger & ^as_found
		then as_index = as_index + 1;
	     end;

	return;

     end /* array_search */;

vfile_search: proc (vs_key, vs_storage_ptr, vs_cursor_ptr, vs_found);

/*
   This  procedure  searches  the  keyed file for the key associated
   with the requested cursor.  If the key is not found it leaves the
   vfile  in  a  state  where  cursor  record  can be added with the
   correct key.
*/

/* GLOBALS

   error_table_$no_record     error returned if seek_key cannot find the key
   mcm_CURSOR_PTR_LENGTH	length of a cursor_ptr in bytes
*/

/* PARAMETERS */

	dcl     vs_key		 char (12);	/* (input) key identifing which cursor is wanted */
	dcl     vs_storage_ptr	 ptr;		/* (input) points to the iocb for the
                                                                       file containing the cursors */
	dcl     vs_cursor_ptr	 ptr;		/* (output) null if the key wasn't found or a cursor_ptr */
	dcl     vs_found		 bit (1);		/* (output) "1"b => the key was found,
                                                                        "0"b => the key was not found */

/* AUTOMATIC */

	dcl     vs_code		 fixed bin (35);	/* standard error code */
	dcl     vs_unused1		 fixed bin (21);	/* unused output parameter from iox_ calls */
	dcl     vs_vfile_key	 char (256) varying;/* type of key used by vfile */





	vs_found = "0"b;
	vs_cursor_ptr = null ();

	vs_vfile_key = vs_key;

	call iox_$seek_key (vs_storage_ptr, vs_vfile_key, vs_unused1, vs_code);
	if vs_code ^= 0
	then do;
		if vs_code ^= error_table_$no_record
		then call error_exit (vs_code, "Error while adding key to vfile.");
	     end;
	else do;
		vs_found = "1"b;
		call iox_$read_record (vs_storage_ptr, addr (vs_cursor_ptr), mcm_CURSOR_PTR_LENGTH,
		     vs_unused1, vs_code);
		if vs_code ^= 0
		then call error_exit (vs_code, "Unable to read a cursor record.");
	     end;

	return;

     end /* vfile_search */;

add_cursor_to_array: proc (acta_storage_ptr, acta_key, acta_cursor_ptr, acta_index);

/*
   This routine adds a <key cursor_ptr> element to the cursor array.
*/

/* GLOBALS

   mcm_CURSOR_ARRAY_ELEMENT_SIZE   number of bits used for a cursor element (key and pointer)
   mcm_cursor_array                structure containing the array of cursors to be overlaid on the temp_seg

/* PARAMETERS */

	dcl     acta_storage_ptr	 ptr;		/* (input) pointer to the cursor array structure */
	dcl     acta_key		 char (12);	/* (input) the cursor_ptr's key */
	dcl     acta_cursor_ptr	 ptr;		/* (input) the cursor pointer */
	dcl     acta_index		 fixed bin;	/* (input) index where the cursor should be placed */

/* AUTOMATIC */

	dcl     acta_move_length	 fixed bin (21);	/* number of chars that need to be moved */




	if acta_storage_ptr -> mcm_cursor_array.num >= acta_index
	then do;
		acta_storage_ptr -> mcm_cursor_array.num = acta_storage_ptr -> mcm_cursor_array.num + 1;
		acta_move_length = mcm_CURSOR_ARRAY_ELEMENT_SIZE *
		     (acta_storage_ptr -> mcm_cursor_array.num - acta_index);
		call move_chars (addr (acta_storage_ptr -> mcm_cursor_array.cursors (acta_index)), acta_move_length,
		     addr (acta_storage_ptr -> mcm_cursor_array.cursors (acta_index + 1)),
		     addr (acta_storage_ptr -> mcm_cursor_array.temp_space_begins));
	     end;
	else acta_storage_ptr -> mcm_cursor_array.num = acta_storage_ptr -> mcm_cursor_array.num + 1;

	acta_storage_ptr -> mcm_cursor_array.cursors (acta_index).key = acta_key;
	acta_storage_ptr -> mcm_cursor_array.cursors (acta_index).cursor_ptr = acta_cursor_ptr;

	return;

     end /* add_cursor_to_array */;

move_chars: proc (mc_source_ptr, mc_length, mc_target_ptr, mc_temp_space_ptr);

/*
   This routine shifts a string  of  mc_length  characters  starting
   from  mc_source_ptr  to  a  point starting with mc_target_ptr. It
   does this by copying the string into a temp area and then copying
   it back, this way there are no problems with  source  and  target
   strings overlaping.
*/

/* GLOBALS

   mcm_cursor_array		structure containing the array of cursors, or in this
			case the string of chars to eb shifted
*/

/* PARAMETERS */

	dcl     mc_source_ptr	 ptr;		/* (input) location of the first character to be moved */
	dcl     mc_length		 fixed bin (21);	/* (input) number of characters to be moved */
	dcl     mc_target_ptr	 ptr;		/* (input) location of the first character after the move */
	dcl     mc_temp_space_ptr	 ptr;		/* (input) location ofthe first character of the temp space */

/* BASED */

	dcl     mc_chars		 char (mc_length) based unaligned;




	mc_temp_space_ptr -> mc_chars = mc_source_ptr -> mc_chars;
	mc_target_ptr -> mc_chars = mc_temp_space_ptr -> mc_chars;

	return;

     end /* move_chars */;

add_cursor_to_vfile: proc (actv_storage_ptr, actv_cursor_ptr);

/*
   This  procedure  adds  the  cursor_ptr  record  to the keyed file
   storage  structure.   The  position in the keyed file has already
   been set up by the vfile_search procedure.
*/

/* GLOBALS

   mcm_CURSOR_PTR_LENGTH	length of a cursor_ptr in bytes
*/

/* PARAMETERS */

	dcl     actv_storage_ptr	 ptr;		/* (input) pointer to the keyed file's iocb */
	dcl     actv_cursor_ptr	 ptr;		/* (input) pointer to the cursor - the record to be written */

/* AUTOMATIC */

	dcl     actv_code		 fixed bin (35);	/* standard error code */





	call iox_$write_record (actv_storage_ptr, addr (actv_cursor_ptr), mcm_CURSOR_PTR_LENGTH, actv_code);
	if actv_code ^= 0
	then call error_exit (actv_code, "Error while loading key into vfile.");

	return;

     end /* add_cursor_to_vfile */;

convert_array_to_vfile: proc (catv_storage_ptr);

/*
   This procedure converts from a array storage type to a keyed file
   storage  type.   It first builds the keyed file storage space and
   then copies each element from the cursor array and writes it into
   the    keyed    file.     The    procedures    vfile_search   and
   add_cursor_to_vfile  are  used to eliminate code duplication that
   would  otherwise  be  required.   When  all the cursors have been
   moved the storage space associated with the array is destroyed.
*/

/* GLOBALS

   mcm_cursor_array           structure containing the array of cursors to be overlaid on the temp_seg
   mcm_PROC_NAME	          procedure's name
   mcm_VFILE		indicates a storage type of keyed file
*/

/* PARAMETERS */

	dcl     catv_storage_ptr	 ptr;		/* (input/output) input => ptr to the array storage */
						/*                output => ptr to the keyed file's iocb */

/* AUTOMATIC */

	dcl     catv_array_storage_ptr ptr;		/* pointer to array storage */
	dcl     catv_i		 fixed bin;	/* loop index */
	dcl     catv_unused1	 ptr;		/* unused output from vfile_search -
                                                               we know the value will be null */
	dcl     catv_unused2	 bit (1);		/* unused output from vfile_search -
                                                               we know the cursor won't be found */
	dcl     catv_vfile_storage_ptr ptr;		/* pointer to keyed file's iocb */

	catv_array_storage_ptr = catv_storage_ptr;

	call build_storage (0, mcm_VFILE, catv_vfile_storage_ptr);

	do catv_i = 1 to catv_array_storage_ptr -> mcm_cursor_array.num;
	     call vfile_search (catv_array_storage_ptr -> mcm_cursor_array.cursors (catv_i).key,
		catv_vfile_storage_ptr, catv_unused1, catv_unused2);
	     call add_cursor_to_vfile (catv_vfile_storage_ptr,
		catv_array_storage_ptr -> mcm_cursor_array.cursors (catv_i).cursor_ptr);
	end;

	catv_storage_ptr = catv_vfile_storage_ptr;

	call destroy_storage (catv_array_storage_ptr);

	return;

     end /* convert_array_to_vfile */;

create_cursor: proc (cc_rel_opening_id, cc_collection_id, cc_relmgr_create_cursor, cc_area_ptr, cc_cursor_ptr);

/*
   This procedure calls the relation_manager to get a cursor.
*/

/* PARAMETERS */

	dcl     cc_rel_opening_id	 bit (36) aligned;	/* (input) relation manager opening id for the relation */
	dcl     cc_collection_id	 bit (36) aligned;	/* (input) collection id of the collection to
                                                                       be associated with the cursor */
	dcl     cc_relmgr_create_cursor entry options (variable);
						/* (input) entry used to get the cursor */
	dcl     cc_area_ptr		 ptr;		/* (input) pointer to area where cursor is to be allocated */
	dcl     cc_cursor_ptr	 ptr;		/* (output) pointer to the cursor */

/* AUTOMATIC */

	dcl     cc_code		 fixed bin (35);	/* standard error code */





	call cc_relmgr_create_cursor (cc_rel_opening_id,
	     cc_area_ptr, cc_cursor_ptr, cc_code);
	if cc_code ^= 0
	then call error_exit (cc_code, "Could not obtain a cursor.");

	return;

     end /* create_cursor */;

close_rels_from_array: proc (crfa_storage_ptr, crfa_relmgr_close);

/*
   This  procedure closes the relations that are associated with the
   cursors whose pointers are in the cursor array.
*/

/* GLOBALS 

   mcm_cursor_array		structure containing the array of cursors
   mcm_b36b                   b36 overlay
*/

/* PARAMETERS */

	dcl     crfa_storage_ptr	 ptr;		/* (input) pointer to the array storage */
	dcl     crfa_relmgr_close	 entry options (variable); /* (input) entry used to close a relation */

/* AUTOMATIC */

	dcl     crfa_close_code	 fixed bin (35);	/* last non-zero error code returned from crfa_relmgr_close */
	dcl     crfa_code		 fixed bin (35);	/* standard error code */
	dcl     crfa_i		 fixed bin;	/* loop index */
	dcl     crfa_last_opening_id	 bit (36);	/* opening id of the last relation closed */
	dcl     crfa_opening_id	 bit (36);	/* opening id of the relation to be closed next */






	crfa_last_opening_id = "0"b;
	crfa_close_code = 0;
	do crfa_i = 1 to crfa_storage_ptr -> mcm_cursor_array.num;
	     crfa_opening_id = addr (crfa_storage_ptr -> mcm_cursor_array.cursors (crfa_i).key) -> mcm_b36b;
	     if crfa_last_opening_id ^= crfa_opening_id
	     then do;
		     call crfa_relmgr_close (crfa_opening_id, crfa_code);
		     if crfa_code ^= 0
		     then crfa_close_code = crfa_code;
		     crfa_last_opening_id = crfa_opening_id;
		end;
	end;

	if crfa_close_code ^= 0
	then call error_exit (crfa_close_code, "Error while closing relations, not all relations have been closed.");

	return;

     end /* close_rels_from_array */;

close_rels_from_vfile: proc (crfv_storage_ptr, crfv_relmgr_close);

/*
   This  procedure closes the relations that are associated with the
   cursors whose pointers are in the vfile.
*/

/* GLOBALS

   mcm_cursor_array
   mcm_b36
*/

/* PARAMETERS */

	dcl     crfv_storage_ptr	 ptr;		/* (input) points to the iocb for
                                                                       the file containing the cursors */
	dcl     crfv_relmgr_close	 entry options (variable);
						/* (input) entry used to close the relations */

/* AUTOMATIC */

	dcl     crfv_close_code	 fixed bin (35);	/* last non-zero error code returned from crfv_relmgr_close */
	dcl     crfv_code		 fixed bin (35);	/* standard error code */
	dcl     crfv_last_opening_id	 bit (36);	/* opening id of last relation closed */
	dcl     crfv_key		 char (256) varying;/* cursor_key returned from the vfile */
	dcl     crfv_unused1	 fixed bin (21);	/* unused output from the call to iox_$read_key */
	dcl     crfv_opening_id	 bit (36);	/* opening id of the next relation to be closed */

/* CONSTANTS */

	dcl     crfv_BOF		 fixed bin init (-1) internal static options (constant);
						/* indicates that the file is to be
                                                               positioned to the first record */
	dcl     crfv_SKIP_RECORD	 fixed bin init (0) internal static options (constant);

/* indicates that the file is to be
						   positioned down 1 record */

	call iox_$position (crfv_storage_ptr, crfv_BOF, 0, crfv_code);
	if crfv_code ^= 0
	then call error_exit (crfv_code, "Could not position to begining of key tree when destroying cursor pointers.");

	call iox_$read_key (crfv_storage_ptr, crfv_key, crfv_unused1, crfv_code);
	if crfv_code ^= 0 & crfv_code ^= error_table_$end_of_info
	then call error_exit (crfv_code, "Could not read key from key tree.");

	crfv_last_opening_id = "0"b;
	crfv_close_code = 0;

	do while (crfv_code = 0);
	     crfv_opening_id = addr (crfv_key) -> mcm_b36b;
	     if crfv_last_opening_id ^= crfv_opening_id
	     then do;
		     call crfv_relmgr_close (crfv_opening_id, crfv_code);
		     if crfv_code ^= 0
		     then crfv_close_code = crfv_code;
		     crfv_last_opening_id = crfv_opening_id;
		end;
	     call iox_$position (crfv_storage_ptr, crfv_SKIP_RECORD, 1, crfv_code);
	     if crfv_code ^= 0 & crfv_code ^= error_table_$end_of_info
	     then call error_exit (crfv_code, "Could not position to next record while closing relations.");

	     call iox_$read_key (crfv_storage_ptr, crfv_key, crfv_unused1, crfv_code);
	     if crfv_code ^= 0 & crfv_code ^= error_table_$end_of_info
	     then call error_exit (crfv_code, "Could not read key from key tree.");
	end;

	if crfv_close_code ^= 0
	then call error_exit (crfv_close_code, "Error while closing relations, not all relations have been closed.");
	return;

     end /* close_rels_from_vfile */;

delete_cursors_from_array: proc (dcfa_opening_id, dcfa_area_ptr, dcfa_storage_ptr, dcfa_relmgr_destroy_cursor);

/*
   This procedure destroys all  cursors  assocaiated  with  a  given
   opening id and removes the cursor_ptrs from the array.
*/

/* GLOBAL

   mcm_c4b		     4 character overlay
   mcm_cursor_array		     structure containing the array of cursors
   mcm_CURSOR_ARRAY_ELEMENT_SIZE   number of bits used for cursor element (key and pointer)
*/

/* PARAMETERS */

	dcl     dcfa_opening_id	 bit (36) aligned;	/* (input) opening id of cursors to be deleted */
	dcl     dcfa_area_ptr	 ptr;		/* (input) pointer to area where the
                                                                       cursors have been allocated */
	dcl     dcfa_storage_ptr	 ptr;		/* (input) pointer to cursor ptr storage structure */
	dcl     dcfa_relmgr_destroy_cursor entry options (variable);
						/* (input) relation manager entry to destroy a cursor */

/* AUTOMATIC */

	dcl     dcfa_code		 fixed bin (35);	/* error code */
	dcl     dcfa_cursor_index_1	 fixed bin;	/* index into the array of the first
                                                               cursor with the opening id */
	dcl     dcfa_cursor_index_2	 fixed bin;	/* index into the array of the last
                                                               cursor with the opening id */
	dcl     dcfa_key		 char (12);	/* key containing only the opening id, so that
                                                               a search will find the first key with that opening id. */
	dcl     dcfa_num_cursors_being_deleted fixed bin; /* number of cursors being deleted from the array */
	dcl     dcfa_unused1	 bit (1);		/* output from array_search, we know the key won't be found */

	unspec (dcfa_key) = "0"b;
	substr (dcfa_key, 1, 4) = addr (dcfa_opening_id) -> mcm_c4b;
	call array_search (dcfa_key, dcfa_storage_ptr, dcfa_cursor_index_1, dcfa_unused1);
	dcfa_cursor_index_2 = dcfa_cursor_index_1;
	do while ((addr (dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_2).key) -> mcm_c4b =
	     addr (dcfa_opening_id) -> mcm_c4b)
	     & (dcfa_cursor_index_2 <= dcfa_storage_ptr -> mcm_cursor_array.num));
	     call dcfa_relmgr_destroy_cursor (
		dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_2).cursor_ptr,
		dcfa_area_ptr, dcfa_code);
	     if dcfa_code ^= 0
	     then call error_exit (dcfa_code, "Could not destroy a cursor.");
	     dcfa_cursor_index_2 = dcfa_cursor_index_2 + 1;
	end;
	dcfa_num_cursors_being_deleted = dcfa_cursor_index_2 - dcfa_cursor_index_1;
	call move_chars (addr (dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_2)),
	     (dcfa_storage_ptr -> mcm_cursor_array.num - dcfa_cursor_index_2 + 1) * mcm_CURSOR_ARRAY_ELEMENT_SIZE,
	     addr (dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_1)),
	     addr (dcfa_storage_ptr -> mcm_cursor_array.temp_space_begins));
	dcfa_storage_ptr -> mcm_cursor_array.num =
	     dcfa_storage_ptr -> mcm_cursor_array.num - dcfa_num_cursors_being_deleted;

	return;

     end /* delete_cursors_from_array */;

delete_cursors_from_vfile: proc (dcfv_opening_id, dcfv_area_ptr, dcfv_storage_ptr, dcfv_relmgr_destroy_cursor);

/*
   This procedure destroys all cursors associated with a given
   opening id and removes the cursors from the vfile.
*/

/* GLOBAL 

   mcm_c4b		4 character overlay
   mcm_CURSOR_PTR_LENGTH	length of a cursor_ptr ==> 2 words or 8 bytes
*/

/* PARAMETERS */

	dcl     dcfv_opening_id	 bit (36) aligned;	/* (input) opening id of cursors to be deleted */
	dcl     dcfv_area_ptr	 ptr;		/* (input) pointer to area where the
                                                                       cursors have been allocated */
	dcl     dcfv_storage_ptr	 ptr;		/* (input) pointer to cursor ptr storage
                                                                       structure, an iocb in this case */
	dcl     dcfv_relmgr_destroy_cursor entry options (variable);
						/* (input) relation manager entry to destroy a cursor */

/* AUTOMATIC */

	dcl     dcfv_code		 fixed bin (35);	/* standard error code */
	dcl     dcfv_stored_cursor_ptr ptr;		/* cursor pointer that was stored in the vfile */
	dcl     dcfv_stored_key	 char (256) varying;/* key that was stored in the vfile */
	dcl     dcfv_unused1	 fixed bin (21);	/* unused output from iox_$read_key and read_record */
	dcl     01 dcfv_seek_head_info,		/* structure to control vfile seek_head operation */
		02 relation_type	 fixed bin init (1),/* will seek first key with a head >= given key */
		02 n		 fixed bin init (4),/* key head is 45 characters long */
		02 key		 char (256);	/* key head character string */

	dcfv_seek_head_info.key = addr (dcfv_opening_id) -> mcm_c4b;
	call iox_$control (dcfv_storage_ptr, "seek_key", addr (dcfv_seek_head_info), dcfv_code);
	do while (dcfv_code = 0);
	     call iox_$read_key (dcfv_storage_ptr, dcfv_stored_key, dcfv_unused1, dcfv_code);
	     if dcfv_code = 0
	     then do;
		     if addr (dcfv_stored_key) -> mcm_c4b = addr (dcfv_opening_id) -> mcm_c4b
		     then do;

			     call iox_$read_record (dcfv_storage_ptr, addr (dcfv_stored_cursor_ptr),
				mcm_CURSOR_PTR_LENGTH, dcfv_unused1, dcfv_code);
			     if dcfv_code = 0
			     then do;
				     call dcfv_relmgr_destroy_cursor (
					dcfv_stored_cursor_ptr,
					dcfv_area_ptr, dcfv_code);
				     if dcfv_code = 0
				     then call iox_$delete_record (dcfv_storage_ptr, dcfv_code);
				end;
			end;
		end;
	end;

     end /* delete_cursors_from_vfile */;

error_exit: proc (ee_code, ee_message);

/*
   This  procedure  is  used  in  case an error occurs.  It sets the
   value  of  the  error code to be returned to the caller and calls
   sub_err_ to report more completely to the user.  It also performs
   a non-local goto to return to the caller of mu_cursor_manager_ so
   this procedure itself never returns to its caller.
*/

/* GLOBALS

   mcm_code		standard error code to be returned to the caller of mu_cursor_manager_
   mcm_PROC_NAME              procedure's name

/* PARAMETERS */

	dcl     ee_code		 fixed bin (35);	/* (input) standard error code */
	dcl     ee_message		 char (*);	/* (input) message of what went
                                                                       wrong to be sent to the user */





	mcm_code = ee_code;
	call sub_err_ (mcm_code, mcm_PROC_NAME, "c", null (), 0, ee_message);

	goto exit;

     end /* error_exit */;

     end /* mu_cursor_manager_ */;
