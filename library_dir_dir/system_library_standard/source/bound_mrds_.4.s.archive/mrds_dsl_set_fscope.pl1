/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-10-17 by Jim
     Lippard (mrds #145, SCP-6258).
  2) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
     install(86-10-23,MR12.0-1199):
     Changed references to DEFAULT_WAIT to be mrds_data_$lock_wait_time.
  3) change(87-10-13,Dupuis), approve(87-10-13,MCR7777),
     audit(87-11-18,Brunelle), install(87-11-30,MR12.2-1006):
     Fixed a problem where the internal proc queue_scope was getting a null
     pointer fault trying to reference thru ul_ptr.
                                                   END HISTORY COMMENTS */


mrds_dsl_set_fscope: set_fscope: procedure;

/*   
	BEGIN_DESCRIPTION
   This procedure sets the user's scope of access to the database if it is open in the
   shared mode.  Calling sequence is:

   call dsl_$set_fscope (db_index,
   rel_name, permit_requests, prevent_requests, ...,
   rel_name, permit_requests, prevent_requests, wait_seconds[optional],  code);
	END_DESCRIPTION
   
   HISTORY:

   Written April 28, 1976 by R. G. Luebke

   Modified by O D Friesen July, 1977, to queue scope  requests  for
   the  user Changed to set_fscope by Oris D. Friesen - Sept. 1978 -
   to set scopes at file level instead of rel. level

   Modified by M.  Pierret  December  1979  for  the  following:  1.
   Redesigned  the queueing/wakeup system so that user must re-check
   her ability to set scope when awakened, and  be  responsible  for
   wakeing  the  next  elibible user in the queue and detecting dead
   processes in the  queue;  2.  Restructured  the  entire  program,
   adding  commentation;  3.  Coordinate  with  dl_scope the dbc and
   user_list entries that they share; 4. Made call to mu_empty_scope
   compatible with new changes.

   Modified by M. Pierret 13 April 1980 to remove priority queueing.

   Modified by M. Pierret 27 June 1980, changing fil  and  file_name
   to   rel   and  model_rel_name,  resolving  naming  discrepancies
   concerning submodels, and fixing various logic  errors  involving
   passive_sw, setting up fil_list and scope_info, and redecoratng.

   Modified by Jim Gray -  -  80-11-14,  to  put  common  code  into
   check_scope_and_access,      plus     adding     the     routines
   check_mrds_access, check_system_access, check_file_open,  and  to
   add mrds/system access checking at scope time, so that more scope
   than current access can not be granted,  and  to  put  the  vfile
   opening  for a relation at set_scope time, so that relations that
   are not having scope set will  not  be  opened,  plus  the  vfile
   opening  process  will  not  be  the  one  to  detect  any access
   violation.  Also  added  check  to  prevent  null  permit   scope
   requests,  so  null  access  on files can be detected. Also fixed
   set_scope_all bug by putting file ready  mode  checks  in  common
   check_mrds_access  routine,  so  that  now  can't get update when
   opened retrieve.

   80-12-11 Jim Gray : added use of include file mdbm_scope_requests
   as  part  of  change  from  r-u  to  r-s-m-d  type  scope  modes.
   mdbm_scope_info and mdbm_users include files also  changed  as  a
   result.  Added local declarations of actual/user_permits/prevents
   and   actual_conflict_detail.   The   later    was    added    to
   check_scope/conflict  interface to be able to report exact detail
   of why a set_scope failed. Changed the mrds_access conflcit check
   to   be   more   detailed,   The  routines  get_permit_scope  and
   get_rmds_access  were  added  for  error  detail.  The  calls  to
   store_scope,  plus the setting of the check_scope flag were moved
   to the common routine check_scope_and_access. Common code was put
   in  activate_or_queue.  A  bug  in  awakened was fixed that would
   cause a queued process to loop forever,  if  a  non-passive  dead
   process  was  created  while  he was still in the queue. now that
   update has been turned into 3 separate permissions.

   80-12-11 Jim Gray : found that MSF's could look  like  they  have
   "rw",  but have been set to just "w", and that is all that exists
   on the components. For cases  where  "r"  appears,  an  aditional
   check  on component 0 of the MSF was added to make sure it really
   was "r".

   80-12-12 Jim Gray : added initialization of fil_list  pad  areas,
   and  also  set update bit on according to whether one of a+m+d is
   on. Improved the system access conflict error message to give the
   required access for the requested scope.

   80-12-12 Jim Gray : Found that the wait_sec option was having  no
   effect,  even in default mode. No waiting was ever occuring. This
   was because the DEFAULT_WAIT was declared fixed  bin  (71),  then
   being  overlayed  with  a  fixed bin(35) number, getting only the
   upper (zeroed) half of the double word number.

   80-12-12 Jim Gray : Found that the awakened procedure did not set
   the  upper  bound  on  the  loop  through  the  scope_info  array
   properly, thus causing it to access beyond the end  of  the  dbcb
   segment  in the resultant model. Now it uses scope_info.nfiles as
   it should. This only happend when a queued waiter was woke up  by
   a scope deleter, and no further conflict existed.

   80-12-12 Jim Gray : Added debug message of SCOPE REQUEST GRANTED,
   that  is  issued  when a user that has been queued is awoken, and
   finds no conflict in being able to set his scope.

   80-12-15 Jim Gray : changed being  queued,  and  request  granted
   from   queue   informative   messages   from  sub_err_,  to  ioa_
   displayable via mrds_debug_tool with switch 1 being set for  this
   module.

   80-12-15 Jim Gray : Modified logic to  allow  null  permit  scope
   requests.  For  file  readying nothing is done in this case, same
   for system access checking. However, a true "null" scope tuple is
   set in the fil_list string and in the scope_info

   80-12-16 Jim Gray : added requirement that a null permit  request
   has  system  acl  to  the  relation  data  of "r", so that a user
   without sufficient access can not prevent  others  from  using  a
   relation he has no access to.

   81-1-11 Jim Gray : added handling of touched bit  in  scope_info,
   so that null scope requests can be displayed.

   81-01-27 Jim Gray : added call to  set_needed_access  for  system
   acl   failures,  so  that  DBA  types  will  never  fail  due  to
   insufficient access.

   81-06-17  Jim  Gray  :  removed  file  opening  logic,  now  that
   mu_open_iocb_manager handles it at first data reference time.

   81-07-23 Jim Gray : added check for the scope mode encoding being
   too large.

   81-12-15 R. Lackey : Modified to seach rel_array for full 32 character name. TR11887

   82-01-08 R. Lackey : Added check to detect relation names longer then 30 characters.

   82-09-22 Davids: added call to dbcb.relmgr_entries.set_scope in the
   activate_user_scope internal proc. This required changing the calling
   sequence of the internal procs store_scope and add_fil_list_entry to
   include the parameter rmri_ptr so that add_fil_list_entry can set the
   value of the relation's opening_id.

   82-10-04 Davids: added the internal proc scopes_by_this_process and
   placed a call to it activite_user_scopes right before the call to
   relmgr_entries.set_scope. scopes_by_this_process combines all the scopes
   that a process may have on a relation. A process could have more than
   once set of scopes if the database has been opened multiple times.

   82-10-14 Davids: added code to open a relation before the call to the
   relation manager set scope routine because that routine expects the
   relation to already be opened. 

   82-12-10 Davids: Modified the call to dbcb.relmgr_entries.open by
   enclosing the db_path and model name in ()s. This was needed because
   the declaration of the relation manager entries in the dbcb was changed
   from options variable to reality. The db_path and model_name are
   declared as character aligned in include files while the entry expects
   character unaligned.

   83-01-21 Kubicar: Added transaction code

   83-01-25 Davids: Added check of mstxn_code after the mrds_start_transaction
   include file to be sure that the transaction was started ok (if it had to
   be started). Also created the new entry point set_relmgr_scopes out of
   code that used to be in activate_user_scope. This new entry is called from
   both activate_user_scope and the clean_up procedure. The call in clean_up
   was needed to be sure that the relation manager scopes and mrds scopes
   matched. Corrected scope calculation in the internal procedure
   scopes_by_this_process.

   83-02-07 Davids: Modified the set_relmgr_scopes internal procedure to 
   create a copy of the rmri_ptr instead of using the copy in the fil_list
   structure. This is needed because the ring brackets of the db.control
   segment which is where the fil_list is kept may be 5,5,5 in which case the 
   pointer cannot be used to reference the rm_rel_info structure which is in
   the resultant and may have different ring brackets, i.e. 4,4,4.

   83-02-15 Davids: explicitly declared variables that were
   declared by context or implication and deleted declarations
   to variables that were not referenced.

   84-07-26 Thanh Nguyen: Modified the ioa_args of the call sub_err_ due to
   TR #phx17395, problem number 113 in the mrds error list.

   85-03-14 Thanh Nguyen: Modified the awakened procedure to handle the case
   of the conflict_sw is on and the ul_ptr is null after the call to 
   wakeup_next_waiter internal subroutine. (TR #phx19144).

   85-03-22 Thanh Nguyen: Modified the awakened procedure again to handle the 
   case of the timed-out.  It will try to lock the scope_lock no more than 3
   times before it will dequeue the timed-out user or will set the
   trouble_switch.(TR #19174).

   85-04-14 Thanh Nguyen: Modified code not to get the out of subrange while
   checking for the conflict of the scope.

   85-10-17 Jim Lippard: Changed to not set trouble switch when the scope_lock
   can't be set and to wait the user's specified wait time rather than
   mrds_data_$lock_wait_time.
*/
%page;
	entry_name = "set_fscope";			/* normal entry point */
	args_exp = 5;				/* 5 input arguments */
	num_filns = 0;
	dbc_ptr = null ();				/* initialize */
	call cu_$arg_count (nargs);			/* get number of args */
	if nargs < args_exp
	then signal arg_error;			/* must be at least args_exp args */
						/* signal is used here because we can't determine */
						/* where the error code argument is */

	if mod (nargs - 3, 3) = 0
	then do;
		call cu_$arg_ptr (nargs - 1, ws_ptr, arg_len, icode);
		if icode ^= 0
		then signal arg_error;
	     end;
	else ws_ptr = addr (mrds_data_$lock_wait_time);

common_label:
	mstxn_txn_id = "0"b;
	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* get pointer to last arg (code) */
	if icode ^= 0
	then signal arg_error;
	code = 0;

/* Set up condition handlers. Note that they come before the label pntr2, where dl_fscope_all_ptr enters.
   This entry is for now unused, and if used, it is assumed that handlers are provided by the caller */

	on cleanup call clean_up;
	on quit
	     begin;
		call clean_up;
		call continue_to_signal_ (icode);
	     end;


	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* get db_index */
	if icode ^= 0
	then call error (icode);
	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
						/* look up db's pointer */
	if dbcb_ptr = null ()			/* we don't know about this data base */
	then call error (mrds_error_$invalid_db_index);

pntr2:


	dbc_ptr = dbcb.dbc_ptr;			/* get pointer to data base control segment */
	if dbcb.scope_ptr = null
	then call error (mrds_error_$non_scope_ready);

	scope_ptr = dbcb.scope_ptr;
	rdbi_ptr = dbcb.rdbi_ptr;
	rmra_ptr = rm_db_info.ra_ptr;

	if scope_info.active_scopes > 0		/* all scope must be set at one time, so there */
	then call error (mrds_error_$scope_not_empty);	/* ..cannot be existing scope at this point */



	call set_lock_$lock (dbc.scope_lock, (wait_seconds), icode);
						/* lock scope portion of dbc */
	if icode = error_table_$invalid_lock_reset |
	     icode = error_table_$locked_by_this_process
	then icode = 0;
						/* ignore these error codes */
	if icode ^= 0
	then do;					/* somebody else has got it locked */
		call error (icode);

	     end;




	QUE_FREE = fixed (unspec (CHAR_Q_F), 71);	/* Set wakeup message constant */
	ALARM = fixed (unspec (CHAR_ALARM), 71);	/* Set time-out message constant */

	empty_on_err = ON;				/* Must empty scope on error (for cleanup purposes) */

/* Position to this user's user_list in dbc */

	ul_ptr = convert (dbc_ptr, dbc.open_users_ofs);
	this_ul_ptr = null;
	do while (ul_ptr ^= null);
	     if user_list.process_id = get_process_id_ ()
	     then do;
		     if user_list.rdbi_bits = addr (rdbi_ptr) -> ptr_bit_string
		     then do;
			     this_ul_ptr = ul_ptr;
			     ul_ptr = null;
			end;
		     else ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
		end;
	     else ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
	end;

	if this_ul_ptr = null			/* User is not in open list - DBC was probably reset */
	then call error (mrds_error_$invalid_db_index);

	ul_ptr = this_ul_ptr;

/* find out if the user is a DBA */

	call mrds_dm_authorization$get_user_class (rtrim (rm_db_info.db_path), addr (local_area),
	     mrds_authorization_structure_version, mrds_authorization_ptr, icode);
	if icode ^= 0 then call error (icode);

/* Initialize some variables. */

	user_list.queue_activ = OFF;
	user_list.bypass_count = 0;
	check_scope = ON;				/* OFF-> don't bother checking for conflict */
	conflict_sw = OFF;				/* ON -> a conflict was found */
	re_check = OFF;				/* ON -> a conflict was resolved, so try again */
	first_scope_triple = ON;			/* Processing firstrelation in scope request */

/*  Set up transactions */

	mstxn_transactions_needed = dbcb.transactions_needed;
	on cleanup
	     begin;
		call mstxn_cleanup;
		call clean_up;
	     end;
	on quit
	     begin;
		call clean_up;
		call mstxn_any_other;
	     end;
	on any_other call mstxn_any_other;

%include mrds_start_transaction;

	if mstxn_code ^= 0
	then call error (mstxn_code);

	dbcb.user_started_transaction = user_started_transaction;

/* Do one of the following blocks of code, as appropriate */

/* ************* Entry point is set_fscope ************* */

	if entry_name = "set_fscope"
	then do;

		num_tuples = divide (nargs - 2, 3, 17); /* calculate number of scope tuples */

		do i = 1 to num_tuples;		/* iterate once for each scope tuple */
		     arg_index = 3 * (i - 1) + 2;	/* position to ith scope tuple */
		     call cu_$arg_ptr (arg_index, rel_ptr, rel_len, icode);
						/* get rel_name */
		     if icode ^= 0
		     then call error (icode);



/* BEGIN 82-01-08 Roger Lackey ********************************************* */

		     if length (rtrim (rel_name)) > 30 then call error (mrds_error_$rel_name_too_long);

/* END   82-01-08 Roger Lackey ********************************************* */

/* BEGIN CHANGE 81-12-15 RDL ******************************************** */

		     rel_name_32 = rel_name;		/* Used for searching */
		     l = index (string (rm_rel_array.name), "!" || rel_name_32);

/* END   CHANGE 81-12-15 RDL ******************************************** */

/* find file (relation) and get it's model name and the permits-pervent */

		     if l = 0 then do;
			     call sub_err_ (mrds_error_$unknown_relation_name, caller_name, continue, info_ptr, return_value,
				"^/^a^a^a", "The relation name """, rel_name,
				""" was not found in the users view of the database.");
			     call error (mrds_error_$unknown_relation_name);
			end;
		     else do;
			     l = ((l - 1) / 33) + 1;	/* convert from char to array index */
			     submodel_rel_name = rm_rel_array.name.submodel (l);
			     model_rel_name = rm_rel_array.rel_data.model_name (l);
			     rmri_ptr = rm_rel_array.rel_data.ri_ptr (l);
			end;

/* ptr to file info */

		     call cu_$arg_ptr (arg_index + 1, permit_requests_ptr, arg_len, icode);
						/* get permit ops */
		     if icode ^= 0
		     then call error (icode);

		     call cu_$arg_ptr (arg_index + 2, prevent_requests_ptr, arg_len, icode);
						/* get prevent ops */
		     if icode ^= 0
		     then call error (icode);


/* assert whether we can successfully set scope without conflict by:
   checking user's scope tuples (conceived at ready time) to make
   sure scope hasn't been defined already by this user;
   and then to actually check for a conflict */

		     do pos_in_si = scope_info.nfiles to 1 by -1
			while (submodel_rel_name ^= scope_info.scope.sm_name (pos_in_si));
		     end;

		     if string (scope_info.scope.flags (pos_in_si))
						/* scope has already been defined for this file (relation) */
		     then call error (mrds_error_$duplicate_scope);


		     call check_scope_and_access (rmri_ptr);

		end;

		call activate_or_queue ();

	     end;

/* ************* Entry point is set_fscope_all or set_fscope_all_ptr ************* */

	if entry_name = "set_fscope_all" | entry_name = "set_fscope_all_ptr"
	then do;

		if entry_name = "set_fscope_all"
		then do;
			call cu_$arg_ptr (2, permit_requests_ptr, arg_len, icode);
						/* get permit ops */
			if icode ^= 0
			then call error (icode);

			call cu_$arg_ptr (3, prevent_requests_ptr, arg_len, icode);
						/* get prevent ops */
			if icode ^= 0
			then call error (icode);
		     end;

/* Iterate over each relation in scope_info */

		do pos_in_si = 1 to scope_info.nfiles;
		     model_rel_name = scope_info.scope.name (pos_in_si);
		     submodel_rel_name = scope_info.scope.sm_name (pos_in_si);

		     rmri_ptr = null ();
		     call check_scope_and_access (rmri_ptr);

		end;


		call activate_or_queue ();
	     end;


	code = 0;

	if dbc_ptr ^= null ()
	then
	     call set_lock_$unlock (dbc.scope_lock, code);/* unlock the scope table */
exit:

/* End the transaction */

	mftxn_code = code;
%include mrds_finish_transaction;
	if mftxn_code ^= 0
	then code = mftxn_code;

	return;
%page;
activate_or_queue: procedure ();

/* common routine for queueing user if he found a conflict to his request,
   or going ahead with giving him the permissions/prevents he asked for */

/* If there was a conflict, then add user to waiting queue and wait.
   If not, activate the user.  Use the scope already stored */

	if conflict_sw then do;
		call queue_scope (FIRST_QUEUE);	/* go to sleep  and when awakened, try it again */
		call awakened;
	     end;
	else call activate_user_scope;		/* no conflict, so go ahead */

     end;
%page;
mrds_dsl_set_fscope_all:
set_fscope_all:
     entry;

/*
   *
   *  call mrds_dsl_set_fscope_all (db_index, permit_requests, prevent_requests, wait_seconds[optional], code);
   *
*/


	entry_name = "set_fscope_all";
	args_exp = 4;				/* at least 4 -- maybe 5 -- arguments are expected
						   to be present */
	dbc_ptr = null;
	call cu_$arg_count (nargs);
	if nargs < args_exp
	then signal arg_error;
	if nargs = args_exp + 1
	then do;
		call cu_$arg_ptr (nargs - 1, ws_ptr, arg_len, icode);
		if icode ^= 0
		then signal arg_error;
	     end;
	else ws_ptr = addr (mrds_data_$lock_wait_time);
	goto common_label;
%page;
pntr:
set_fscope_all_pntr:
mrds_dsl_set_fscope_all_pntr:
     entry (a_dbcb_ptr, a_permit_requests_ptr, a_prevent_requests_ptr, a_ws_ptr, a_cd_ptr);

/*
   *
   *  entry point used to set scopes when data base has been opened in
   *   EXCLUSIVE mode -- pointer is used in place of data base index
   *
*/

	dcl     (
	        a_dbcb_ptr,				/* dbcb parameter */
	        a_permit_requests_ptr,		/* permit options parameter */
	        a_prevent_requests_ptr,		/* prevent options parameter */
	        a_ws_ptr,				/* wait_seconds parameter */
	        a_cd_ptr
	        )			 ptr;		/* return code parameter */


	entry_name = "set_fscope_all_ptr";
	dbc_ptr = null;
	args_exp = 5;				/* 5 arguments are expected to be present */
	if a_ws_ptr = null
	then ws_ptr = addr (mrds_data_$lock_wait_time);
	else ws_ptr = a_ws_ptr;
	dbcb_ptr = a_dbcb_ptr;
	permit_requests_ptr = a_permit_requests_ptr;
	prevent_requests_ptr = a_prevent_requests_ptr;
	cd_ptr = a_cd_ptr;
	goto pntr2;
%page;
check_scope_and_access: procedure (dummy_ptr);

/* routine to check for scope conflicts, and to   guarantee that scope granted does not exceed actual access
   the user currently has via either mrds or the system
   Also,  if this relation, has not yet had it's vfile opened, do so now */

	call check_mrds_access (dummy_ptr);
	call check_system_access (dummy_ptr);

	if dbc.active_users = 0 & dbc.waiting_users = 0	/* If there are no active or waiting scope users, */
	then check_scope = OFF;			/* no need to even check scope--you've got it */

/* check scope now */

	if check_scope & ^conflict_sw			/* if we have a conflict already, no need to check */
	then do;
		conflict_ul_ptr = null;
		re_check = ON;
	     end;

/* Check for conflict for this relation */

	do while (re_check);
	     re_check = OFF;

	     call mu_check_scope (dbc_ptr, addr (model_rel_name),
		(this_ul_ptr), permit_requests_ptr, prevent_requests_ptr,
		addr (actual_conflict_detail), conflict_sw, conflict_ul_ptr);

	     if conflict_sw then do;			/* there was a conflict */
		     call check_dead_proc (conflict_sw, status);
		     if ^conflict_sw then /* conflict was worked out */
			re_check = ON;
		     else do;			/* still a conflict */
			     conflict_user_id = conflict_ul_ptr -> user_list.ids.group_id;
			     conflict_relation = submodel_rel_name;
			     conflict_detail_known = ON;
			     if status = DEAD then do;/* non-passive dead process conflcit */
				     icode = mrds_error_$db_conflict_dead_process;
				     call report_conflict_detail (DEAD_PROC_REPORT);
				     call error (icode);
				end;
			end;
		end;
	end;

/* Whether there was a conflict or not, store the relevant information about this scope request. */
/* The information for each relation will be stored in a fil_list entry and an entry in the scope_info array. */

	call store_scope (dummy_ptr);

	declare dummy_ptr		 ptr;		/* communicates rmri_ptr between modules */
     end;
%page;
check_mrds_access: procedure (rmri_ptr);

/* routine to check that the access permission  bits in the resultant
   model are >= the scope that is being requested */

/* get the relation access permission bits */

	if rmri_ptr = null () then do;
		i = index (string (rm_rel_array.name), "!" || submodel_rel_name);
		i = ((i - 1) / 33) + 1;		/* convert from char to array index */
		rmri_ptr = rm_rel_array.rel_data.ri_ptr (i);
		model_rel_name = rm_rel_array.rel_data (i).model_name;
	     end;


/* check that the file was readied for scope_retrieve(ready_mode = 5),
   or scope_update(ready_mode = 6) and that if scope_retrieve, the requested
   permit op does not exceed the allowable of retrieve. */

	if rmri_ptr -> rm_rel_info.ready_mode < 5 then
	     call error (mrds_error_$non_scope_ready);

	if rmri_ptr -> rm_rel_info.ready_mode = 5 &
	     (permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple) then
	     call error (mrds_error_$update_not_allowed);

	if ^rmri_ptr -> rm_rel_info.mdbm_secured then
	     rel_append_perm, rel_delete_perm,
		attr_modify_perm, attr_retr_perm = ON;	/* model openings or un-secured submodel openings
						   always have correct mrds access */
	else do;					/* secured submodel opening */

/* always gather all mrds access permission, in case we have to display for error */

		attr_modify_perm, attr_retr_perm = OFF; /* init */

/* check for retrieve/modify permission on at least one attribute in the relation */

		do i = 1 to rmri_ptr -> rm_rel_info.num_attr while (^attr_retr_perm | ^attr_modify_perm);
		     rai_ptr = rmri_ptr -> rm_rel_info.attr_ptrs (i);
		     if ^attr_retr_perm then
			attr_retr_perm = rai_ptr -> rm_attr_info.read_perm; /* see if this attr has read permission */
		     if ^attr_modify_perm then
			attr_modify_perm = rai_ptr -> rm_attr_info.modify_perm; /* if attr has modify permission */
		end;

		attr_null_perm = (^(attr_retr_perm) & ^(attr_modify_perm));

/* check for either append_tuple or delte_tuple on the relation */

		rel_append_perm = rmri_ptr -> rm_rel_info.append_tuple_perm;
		rel_delete_perm = rmri_ptr -> rm_rel_info.delete_tuple_perm;
		rel_null_perm = (^(rel_append_perm) & (^rel_delete_perm));

	     end;

/* check for correct access from mrds to set this scope */

	if (permit_requests.read_attr & ^(attr_retr_perm)) |
	     (permit_requests.modify_attr & ^(attr_modify_perm)) |
	     (permit_requests.append_tuple & ^(rel_append_perm)) |
	     (permit_requests.delete_tuple & ^(rel_delete_perm)) then do;

		call sub_err_ (mrds_error_$scope_mrds_access_conflict, caller_name, continue, info_ptr, return_value,
		     "^/^a^a^a^a^a^a^a",
		     "The scope permission request of """, get_permit_scope (),
		     """ on relation """, rmri_ptr -> rm_rel_info.name,
		     """ exceeds the access granted by MRDS of """,
		     get_mrds_access (), """.");
		call error (mrds_error_$scope_mrds_access_conflict);
	     end;

/* check that the user is not requesting null access scope permissions, which have no meaning,
   and could cause an attemp to open a file for which the user has no access */

	null_permit_request = ^(permit_requests.read_attr | permit_requests.modify_attr |
	     permit_requests.append_tuple | permit_requests.delete_tuple);

	null_prevent_request = ^(prevent_requests.read_attr | prevent_requests.modify_attr |
	     prevent_requests.append_tuple | prevent_requests.delete_tuple);

	null_request = (null_prevent_request & null_permit_request);

/* BEGIN CHANGE 81-07-23 ************************************************* */

	if permit_requests_ptr -> fb35_ovrly > 15 | prevent_requests_ptr -> fb35_ovrly > 15 then do;
		call sub_err_ (error_table_$bad_arg, caller_name, continue, info_ptr, return_value,
		     "^/^a^a^a^/^a^/^a",
		     "The permit or prevent encodings summed to > 15 for relation """,
		     rm_rel_info.name, """",
		     "Allowed values are:",
		     "0(null), 1(read_attr), 2(append_tuple), 4(delete_tuple), 8(modify_attr)");
		call error (error_table_$bad_arg);
	     end;

/* END CHANGE 81-07-23 ****************************************** */


	declare fb35_ovrly		 fixed bin (35) based; /* overlay for checking encoding sum */
	declare error_table_$bad_arg	 fixed bin (35) ext;/* bad argument given */
	declare mrds_error_$scope_mrds_access_conflict fixed bin (35) ext; /* access permission < scope requested */
	declare (rmri_ptr, rai_ptr)	 ptr;		/* temporary ptrs for this routine */
	declare i			 fixed bin;	/* loop index */

     end;
%page;
check_system_access: procedure (rmri_ptr);

/* this routine checks whether the actual system acl's that user
   has for the relation's data vfile are sufficient to grant the requested
   scope request. "r" for r or n, "rw" for a or m or d */

	call mu_get_relation_acl (rtrim (rm_db_info.db_path), rtrim (model_rel_name),
	     mrds_authorization.administrator, read_access, write_access, error_code);
	if error_code ^= 0 then do;
		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
		     "^/^a^/^a^a",
		     "Unable to get access information on the MSF component ",
		     """" || rtrim (rm_db_info.db_path) || ">",
		     rtrim (model_rel_name) || ">0"".");
		call error (error_code);
	     end;

/* check for a system access violation by the requested scope */

	if ((permit_requests.read_attr | null_permit_request) & ^read_access) |
	     ((permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple) &
	     ^(write_access & read_access)) then do;

/* get a displayable form of system access */

		system_access = "";

		if read_access then
		     system_access = system_access || "r";

		if write_access then
		     system_access = system_access || "w";

		if system_access = "" then
		     system_access = "null";

/* get a displayable form of the required access
   for this scope request permit codes */

		if permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple then
		     required_access = "rw";
		else required_access = "r";

		call sub_err_ (mrds_error_$scope_system_access_conflict, caller_name,
		     continue, info_ptr, return_value,
		     "^/^a^a^a^a^a^a^a^a^a",
		     "The requested permit scope """, get_permit_scope (),
		     """ for relation """, rmri_ptr -> rm_rel_info.name,
		     """ requires """, required_access,
		     """ access, but this exceeds the users system access to the relation data of """,
		     system_access, """.");
		call error (mrds_error_$scope_system_access_conflict);
	     end;


	declare error_code		 fixed bin (35);	/* local version of error code */
	declare mu_get_relation_acl	 entry (char (*), char (*),
				 bit (1), bit (1), bit (1), fixed bin (35)); /* finds multics acls */
	declare required_access	 char (4) varying;	/* the access required by this scope request */
	declare system_access	 char (4) varying;	/* r, rw, w or null */
	declare mrds_error_$scope_system_access_conflict fixed bin (35) ext; /* acls not sufficient for scope */
	declare read_access		 bit (1);		/* on => has read access to relation data */
	declare write_access	 bit (1);		/* on => has write access to relation data */
	declare rmri_ptr		 ptr;		/* local temp ptr */

     end;
%page;
get_permit_scope: procedure () returns (char (80) varying);

/* routine to get displayable form of the scope permit modes
   that the user requested, for output in error messages */

	permit_scope = "";

	if permit_requests.read_attr then
	     permit_scope = permit_scope || "read_attr ";

	if permit_requests.modify_attr then
	     permit_scope = permit_scope || "modify_attr ";

	if permit_requests.append_tuple then
	     permit_scope = permit_scope || "append_tuple ";

	if permit_requests.delete_tuple then
	     permit_scope = permit_scope || "delete_tuple ";

	if permit_scope = "" then
	     permit_scope = "null ";

	return (permit_scope);

	declare permit_scope	 char (80) varying; /* message display format of scope */

     end;
%page;
get_mrds_access: procedure () returns (char (120) varying);

/* routine to get displayable form of current mrds acl's
   for reporting in error messages */

	mrds_access = "";

	if attr_null_perm then

	     mrds_access = mrds_access || "null on all attributes in the relation ";

	else do;

		if attr_retr_perm then
		     mrds_access = mrds_access || "read_attr ";

		if attr_modify_perm then
		     mrds_access = mrds_access || "modify_attr ";

		mrds_access = mrds_access || "on some attribute(s) in the relation ";

	     end;

	mrds_access = mrds_access || "and ";

	if rel_append_perm then
	     mrds_access = mrds_access || "append_tuple ";

	if rel_delete_perm then
	     mrds_access = mrds_access || "delete_tuple ";

	if rel_null_perm then
	     mrds_access = mrds_access || "null ";

	mrds_access = mrds_access || "on the relation";


	return (mrds_access);



	declare mrds_access		 char (120) varying;/* display form of mrds acl's  */

     end;
%page;
error:
     procedure (cd);

	dcl     cd		 fixed bin (35);

	code = cd;
	call clean_up;
	go to exit;

     end error;
%page;

store_scope: procedure (ss_rmri_ptr);

/*

   This routine stores the scope request information associated with
   a given relation.  The information updated is in the scope_info of
   the user's resultant model and the fil_list (list of relations)
   associated with the  user's user_list in the DBC.

*/

	dcl     ss_rmri_ptr		 ptr;		/* (input) needed to pass to add_fil_list_entry */

	scope_info.scope (pos_in_si).flags.touched = ON;

	if permit_requests.read_attr then
	     scope_info.scope (pos_in_si).flags.permits.read_attr = ON;

	if permit_requests.modify_attr then
	     scope_info.scope (pos_in_si).flags.permits.modify_attr = ON;

	if permit_requests.append_tuple then
	     scope_info.scope (pos_in_si).flags.permits.append_tuple = ON;

	if permit_requests.delete_tuple then
	     scope_info.scope (pos_in_si).flags.permits.delete_tuple = ON;

	if prevent_requests.read_attr then
	     scope_info.scope (pos_in_si).flags.prevents.read_attr = ON;

	if prevent_requests.modify_attr then
	     scope_info.scope (pos_in_si).flags.prevents.modify_attr = ON;

	if prevent_requests.append_tuple then
	     scope_info.scope (pos_in_si).flags.prevents.append_tuple = ON;

	if prevent_requests.delete_tuple then
	     scope_info.scope (pos_in_si).flags.prevents.delete_tuple = ON;

	scope_info.active_scopes = scope_info.active_scopes + 1;

	if first_scope_triple
	then do;
		flo_ptr = addr (user_list.fil_list_ofs);/* ptr to file list offset */
		first_scope_triple = OFF;
	     end;

	call add_fil_list_entry (flo_ptr, ss_rmri_ptr);

	flo_ptr = addr (fil_list.next_ofs);


	return;

     end store_scope;
%page;
add_fil_list_entry: proc (prev_ofs_ptr, afle_rmri_ptr);

/*  *  This routine adds an entry in a fil_list.  If the user is quiescing
   *  then default scope settings are assigned.  The user is also determined
   *  as a non-passive user here if the scope request is update. */

	dcl     prev_ofs_ptr	 ptr;		/* a pointer to the offset location which
						   currently points to nowhere -- indicating it is currently
						   the last file in the list */
	dcl     afle_rmri_ptr	 ptr;		/* (input) to relation's rm_rel_info structure */
	dcl     ophset		 bit (18) unal based; /* a based offset */


	allocate fil_list in (dbc.static_area);
	unspec (fil_list) = "0"b;			/* zero pad areas */
	fil_list.name = model_rel_name;
	fil_list.rmri_ptr = afle_rmri_ptr;

	if user_list.open_mode = mdbm_data_$quiesce_mode
	then do;
		fil_list.permits.read_attr = ON;
		fil_list.permits.modify_attr = ON;
		fil_list.permits.append_tuple = ON;
		fil_list.permits.delete_tuple = ON;

		fil_list.prevents.read_attr = ON;
		fil_list.prevents.modify_attr = ON;
		fil_list.prevents.append_tuple = ON;
		fil_list.prevents.delete_tuple = ON;
	     end;
	else do;
		fil_list.permits.read_attr = permit_requests.read_attr;
		fil_list.permits.modify_attr = permit_requests.modify_attr;
		fil_list.permits.append_tuple = permit_requests.append_tuple;
		fil_list.permits.delete_tuple = permit_requests.delete_tuple;

		fil_list.prevents.read_attr = prevent_requests.read_attr;
		fil_list.prevents.modify_attr = prevent_requests.modify_attr;
		fil_list.prevents.append_tuple = prevent_requests.append_tuple;
		fil_list.prevents.delete_tuple = prevent_requests.delete_tuple;
	     end;

	user_list.passive_sw = ON;
	if permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple then do;
		fil_list.permits.update = ON;
		user_list.passive_sw = OFF;		/* user wants to be permitted to do a store, a modify */
	     end;					/*          or a delete --- thus, is a non-passive user */
	if fil_list.prevents.modify_attr | fil_list.prevents.append_tuple | fil_list.prevents.delete_tuple then
	     fil_list.prevents.update = ON;

	fil_list.next_ofs = NULL_OFS;			/* this is last file in the list */
	prev_ofs_ptr -> ophset = rel (fl_ptr);		/* update previous last file */
     end add_fil_list_entry;
%page;
activate_user_scope: proc;

/*
   This procedure links a user to the list of active users.
   If this is a non-initial attempt to set scope (ie, user was queued), then
   this procedure delinks the user from the waiting list before adding the
   user to the active list. It also makes a call to set the relation manager
   scopes.
*/


	if info.msg = QUE_FREE			/* not the first time this request has been made */
						/* unlink from waiting list -- and from priority list */
	then call mu_de_queue_user (NO_DQ_OPEN, SAVE_FIL_LIST, dbc_ptr, (this_ul_ptr), icode);

/* Link user to active list */

	ulo_ptr = addr (dbc.active_users_ofs);
	ul_ptr = convert (dbc_ptr, dbc.active_users_ofs);
	do while (ul_ptr ^= null);
	     ulo_ptr = addr (user_list.next_active_ofs);
	     ul_ptr = convert (dbc_ptr, user_list.next_active_ofs);
	end;
	ulo_ptr -> ophset = rel (this_ul_ptr);		/* link user to active list */
	dbc.active_users = dbc.active_users + 1;
	ul_ptr = this_ul_ptr;
	user_list.active_sw = ON;
	user_list.waiting_sw = OFF;

	call set_relmgr_scopes;

     end activate_user_scope;
%page;
scopes_by_this_process: proc (sbtp_rel_name, sbtp_faul_ptr, sbtp_pid, sbtp_relmgr_my_permits, sbtp_relmgr_others_permits);

/*
   This procedure looks at each user with active scopes in the user_list
   and for each user with the same process id as the current it user it
   looks for a scope for the input relation. For each scope it finds it
   takes the union of the permit and prevent ops to come up with a "scope"
   that can be passed to the relation manager set_scope routine.
*/

/* PARAMETERS */

	dcl     sbtp_rel_name	 char (30);	/* (input) relation under consideration */
	dcl     sbtp_faul_ptr	 ptr;		/* (input) pointer to the first active_user user_list structure */
	dcl     sbtp_pid		 bit (36);	/* (input) process id of the current process */
	dcl     sbtp_relmgr_my_permits bit (2) aligned;	/* (input) */
						/*         bit 1 true => process has set a scope permit */
						/*               of read on at least 1 opening */
						/*         bit 2 true => process has set a scope permit of modify */
						/*               or delete or append on at least 1 opening */
	dcl     sbtp_relmgr_others_permits bit (2) aligned; /* (input) */
						/*         bit 1 false => process has set a scope prevent */
						/*                        of read on at least 1 of its openings */
						/*         bit 2 false => process has set a scope prevent of */
						/*                         at least modify or delete or append in each opening */
						/*                          and all 3 prevents are set at least once. */

/* AUTOMATIC */

	dcl     sbtp_aul_ptr	 ptr;		/* pointer to a active_user user_list structure */
	dcl     sbtp_fl_ptr		 ptr;		/* pointer to a file_list structure */
	dcl     sbtp_rel_found	 bit (1);		/* "1"b => current user has active scopes on the */
						/*         relation under consideration */
	dcl     sbtp_r_prevents	 bit (1);		/* true if the process as set an r prevent in any of its openings */
	dcl     sbtp_a_prevents	 bit (1);		/* true if the process as set an a prevent in any of its openings */
	dcl     sbtp_d_prevents	 bit (1);		/* true if the process as set an d prevent in any of its openings */
	dcl     sbtp_m_prevents	 bit (1);		/* true if the process as set an m prevent in any of its openings */

%page;
	sbtp_aul_ptr = sbtp_faul_ptr;
	sbtp_relmgr_my_permits = "00"b;
	sbtp_r_prevents = "0"b;
	sbtp_a_prevents = "0"b;
	sbtp_d_prevents = "0"b;
	sbtp_m_prevents = "0"b;
	do while (sbtp_aul_ptr ^= null ());
	     if sbtp_aul_ptr -> user_list.ids.process_id = sbtp_pid
	     then do;
		     sbtp_fl_ptr = convert (dbc_ptr, sbtp_aul_ptr -> user_list.offsets.fil_list_ofs);
		     sbtp_rel_found = "0"b;
		     do while ((sbtp_fl_ptr ^= null ()) & ^(sbtp_rel_found));
			if sbtp_fl_ptr -> fil_list.name = sbtp_rel_name
			then do;
				sbtp_rel_found = "1"b;
				sbtp_relmgr_my_permits =
				     sbtp_relmgr_my_permits |
				     sbtp_fl_ptr -> fil_list.permits.read_attr ||
				     sbtp_fl_ptr -> fil_list.permits.update;
				sbtp_r_prevents = sbtp_r_prevents | sbtp_fl_ptr -> fil_list.prevents.read_attr;
				sbtp_a_prevents = sbtp_a_prevents | sbtp_fl_ptr -> fil_list.prevents.append_tuple;
				sbtp_d_prevents = sbtp_d_prevents | sbtp_fl_ptr -> fil_list.prevents.delete_tuple;
				sbtp_m_prevents = sbtp_m_prevents | sbtp_fl_ptr -> fil_list.prevents.modify_attr;
			     end;
			else sbtp_fl_ptr = convert (dbc_ptr, sbtp_fl_ptr -> fil_list.next_ofs);
		     end;
		end;
	     sbtp_aul_ptr = convert (dbc_ptr, sbtp_aul_ptr -> user_list.offsets.next_active_ofs);
	end;

	sbtp_relmgr_others_permits = ^sbtp_r_prevents || ^(sbtp_a_prevents & sbtp_d_prevents & sbtp_m_prevents);

	return;

     end scopes_by_this_process;
%page;
set_relmgr_scopes: proc;

/*
   This  procedure  loops though each relation with scope set, opens
   the  relation  if its not yet open and determines the total scope
   the  calling  process  has  on  the  relation (if the database is
   opened  multiple  times  there can be different scopes).  It then
   tells the relation manager what this total scope is.
*/

/* AUTOMATIC */

	dcl     srs_relmgr_my_permits	 bit (2) aligned;	/* bit 1 true => process has set a scope permit */
						/*               of read on at least 1 opening*/
						/* bit 2 true => process has set a scope permit of modify */
						/*               or delete or append on at least 1 opening*/
	dcl     srs_relmgr_others_permits bit (2) aligned;/* bit 1 false => process has set a scope prevent */
						/*                of read on at least 1 of its openings */
						/* bit 2 false => process has set a scope prevent of */
						/*                at least modify or delete or append in each opening */
						/*                 and all 3 prevents are set at least once. */
	dcl     srs_first_ul_ptr	 ptr;		/* pointer to first user list element */
	dcl     srs_fl_ptr		 ptr;		/* points to a fil_list structure */
	dcl     srs_process_id	 bit (36);	/* process id of caller */
	dcl     srs_rmri_ptr	 ptr;		/* pointer to rm_rel_info structure */


	srs_first_ul_ptr = convert (dbc_ptr, dbc.active_users_ofs);
	srs_fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
	srs_process_id = get_process_id_ ();
	do while (srs_fl_ptr ^= null ());
	     srs_rmri_ptr = srs_fl_ptr -> fil_list.rmri_ptr;
	     srs_rmri_ptr = pointer (baseptr (baseno (srs_rmri_ptr)), rel (srs_rmri_ptr));
	     if srs_rmri_ptr -> rm_rel_info.opening_id = "0"b
	     then call open_relation (srs_rmri_ptr);
	     call scopes_by_this_process (srs_fl_ptr -> fil_list.name,
		srs_first_ul_ptr, srs_process_id,
		srs_relmgr_my_permits, srs_relmgr_others_permits);
	     call dbcb.relmgr_entries.set_scope (srs_rmri_ptr -> rm_rel_info.opening_id,
		srs_relmgr_my_permits, srs_relmgr_others_permits, icode);
	     if icode ^= 0
	     then call error (icode);
	     srs_fl_ptr = convert (dbc_ptr, srs_fl_ptr -> fil_list.next_ofs);
	end;

	return;

     end set_relmgr_scopes;

clean_up:
     proc;

	if dbc_ptr ^= null
	then do;
		if code ^= error_table_$lock_wait_time_exceeded
		then do;
						/* if a timeout then leave scope as is */

/* if this user is on either the active or waiting list --- then delink */
/* also, reset all counts , tallies, etc */

			if empty_on_err
			then do;
				call mu_empty_scope (dbcb.dbc_ptr, dbcb.scope_ptr, dbcb.rdbi_ptr, "1"b);
						/* delink */
				call set_relmgr_scopes;
			     end;
		     end;
		call set_lock_$unlock (dbc.scope_lock, icode);
	     end;
     end clean_up;
%page;
queue_scope:
     proc (first_time_asleep);

	dcl     first_time_asleep	 bit (1);

	ul_ptr = this_ul_ptr;
	if first_time_asleep
	then do;
		call ipc_$create_ev_chn (user_list.ev_chn_id, state);
						/* create an event channel on which we can
						   receive a wakeup message
						   or a timer runout message */
		if state ^= 0
		then call error (mrds_error_$unable_to_create_channel);
		wait_list.chn_id = user_list.ev_chn_id;
		wait_list.nchn = 1;
		user_list.priority_high = OFF;
		user_list.waiting_sw = ON;
		user_list.active_sw = OFF;
		user_list.allowance_count = dbc.active_users + dbc.waiting_users + WAIT;
		ulo_ptr = addr (dbc.waiting_users_ofs);
		ul_ptr = convert (dbc_ptr, dbc.waiting_users_ofs);
		do while (ul_ptr ^= null);
		     ulo_ptr = addr (user_list.next_waiting_ofs);
		     ul_ptr = convert (dbc_ptr, user_list.next_waiting_ofs);
		end;
		ulo_ptr -> ophset = rel (this_ul_ptr);	/* link user to waiting list */
		dbc.waiting_users = dbc.waiting_users + 1;
		ul_ptr = this_ul_ptr;

		call set_lock_$unlock (dbc.scope_lock, icode);

		wait_sec_fb71 = wait_seconds;		/* move to fixed bin (71) variable */
		call timer_manager_$alarm_wakeup (wait_sec_fb71, REL_SEC, user_list.ev_chn_id);
						/* set max wait time */
		icode = 0;			/* not a real error, just reporting */
		call report_conflict_detail (BEING_QUEUED_REPORT);
	     end;

	else do;
		user_list.event_signal_sw = OFF;
		user_list.queue_activ = OFF;
		call set_lock_$unlock (dbc.scope_lock, icode);
	     end;

	call ipc_$block (addr (wait_list), addr (info), state);
						/* go blocked */
	if state ^= 0
	then call error (mrds_error_$unable_to_queue_user);


     end queue_scope;
%page;
awakened: proc;

/* There are two possible ways we could have been awakened:
   if we ran out of time (message of ALARM), or by set/dl_fscope (msg of QUE_FREE)
   If we timed out, we must give up with an error message; if awakened by dl_fscope then scope has been freed so
   we're going to try again. Note that the scope lock must be re-locked in order for us to check for a conflict */

	dcl     idx		 fixed bin;

	if info.msg = ALARM				/* timed-out, so quit */
	then do;
		user_list.event_signal_sw = OFF;
		icode = error_table_$lock_wait_time_exceeded;
						/* Try 3 times before we give it up.  If we get the lock then we can dequeue */
		do idx = 1 to 3 while (icode ^= 0);
		     call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
		     if icode = error_table_$invalid_lock_reset |
			icode = error_table_$locked_by_this_process
		     then icode = 0;
		end;
		if icode ^= 0 then
		     /* Some one hung the scope queue, so DBA should check at it. */
		     dbc.trouble_switch = ON;
		icode = mrds_error_$db_busy;
		call report_conflict_detail (TIME_OUT_REPORT);
		call error (icode);
	     end;

	call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
	if icode = error_table_$invalid_lock_reset |
	     icode = error_table_$locked_by_this_process
	then icode = 0;				/* these error codes are expected */

	if icode ^= 0
	then do;
		dbc.trouble_switch = ON;
		call error (icode);
	     end;

	if info.msg = QUE_FREE			/* awakened by dl_fscope */
	then do;
		ul_ptr = this_ul_ptr;
		user_list.queue_activ = ON;

		if user_list.dead_proc_conflict
		then call error (mrds_error_$db_conflict_dead_process);


		conflict_sw = OFF;			/* re-check for conflict */
		do idx = 1 to scope_info.nfiles while (^conflict_sw);
		     re_check = ON;
		     do while (re_check);
			re_check = OFF;
			model_rel_name = scope_info.scope.name (idx);
			submodel_rel_name = scope_info.scope.sm_name (idx);

			unspec (remembered_permits), unspec (remembered_prevents) = "0"b; /* init */

			remembered_permits.read_attr =
			     scope_info.scope (idx).flags.permits.read_attr;
			remembered_permits.modify_attr =
			     scope_info.scope (idx).flags.permits.modify_attr;
			remembered_permits.append_tuple =
			     scope_info.scope (idx).flags.permits.append_tuple;
			remembered_permits.delete_tuple =
			     scope_info.scope (idx).flags.permits.delete_tuple;

			remembered_prevents.read_attr =
			     scope_info.scope (idx).flags.prevents.read_attr;
			remembered_prevents.modify_attr =
			     scope_info.scope (idx).flags.prevents.modify_attr;
			remembered_prevents.append_tuple =
			     scope_info.scope (idx).flags.prevents.append_tuple;
			remembered_prevents.delete_tuple =
			     scope_info.scope (idx).flags.prevents.delete_tuple;

			call mu_check_scope (dbc_ptr, addr (model_rel_name), ul_ptr, addr (remembered_permits),
			     addr (remembered_prevents), addr (actual_conflict_detail),
			     conflict_sw, conflict_ul_ptr);

			if conflict_sw then do;
				call check_dead_proc (conflict_sw, status);
				if ^conflict_sw then /* conflict was worked out */
				     re_check = ON;
				else do;
					conflict_user_id = conflict_ul_ptr -> user_list.ids.group_id;
					conflict_relation = submodel_rel_name;
					conflict_detail_known = ON;
					if status = DEAD then do; /* non-passive dead_proc remains */
						icode = mrds_error_$db_conflict_dead_process;
						call report_conflict_detail (DEAD_PROC_REPORT);
						call error (icode);
					     end;
				     end;
			     end;
		     end;
		end;

		if conflict_sw then do;
			call wakeup_next_waiter;
			if ul_ptr ^= null then do;
				user_list.event_signal_sw = OFF;
				user_list.bypass_count = user_list.bypass_count + 1;
			     end;
			if dbc.wakeup_waiters > 0 then
			     dbc.wakeup_waiters = dbc.wakeup_waiters - 1;
			call queue_scope (QUEUE_AGAIN);
		     end;
		else do;
			if substr (db_mrds_dsl_set_fscope, 1, 1) = "1"b then /* debug display on */
			     call ioa_ ("^/Scope request granted from queue.");
			call activate_user_scope;
			dbc.wakeup_waiters = dbc.wakeup_waiters - 1;
			user_list.event_signal_sw = OFF;
			if ^(prevent_requests.append_tuple &
			     prevent_requests.delete_tuple &
			     prevent_requests.modify_attr &
			     prevent_requests.read_attr)
						/* If user is preventing anyone from doing anything,
						   useless to wakeup someone */
			then call wakeup_next_waiter; /* Here such is not the case */
		     end;
	     end;

     end awakened;
%page;
wakeup_next_waiter:
     proc;

/*
   This routine looks through the waiting queue for a user that can be awakened to set scope.
   It looks for only one such user; it is the responsible of the newly awakened user to wake up the next (as
   this processis doing now).
*/

	wakeup = OFF;
	ul_ptr = convert (dbc_ptr, dbc.waiting_users_ofs);

	do while (ul_ptr ^= null & ^wakeup);
	     if ^user_list.event_signal_sw
	     then do;

/* Check each relation (file). */

		     fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
		     wakeup = ON;
		     conflict_sw = OFF;

		     do while (fl_ptr ^= null & ^conflict_sw);

			model_rel_name = fil_list.name;

			unspec (actual_permits), unspec (actual_prevents) = "0"b; /* init */

			actual_permits.read_attr = fil_list.permits.read_attr;
			actual_permits.modify_attr = fil_list.permits.modify_attr;
			actual_permits.append_tuple = fil_list.permits.append_tuple;
			actual_permits.delete_tuple = fil_list.permits.delete_tuple;

			actual_prevents.read_attr = fil_list.prevents.read_attr;
			actual_prevents.modify_attr = fil_list.prevents.modify_attr;
			actual_prevents.append_tuple = fil_list.prevents.append_tuple;
			actual_prevents.delete_tuple = fil_list.prevents.delete_tuple;

			call mu_check_scope (dbc_ptr, addr (model_rel_name), ul_ptr, addr (actual_permits),
			     addr (actual_prevents), addr (unused_conflict_detail),
			     conflict_sw, conflict_ul_ptr);

/* If there was a conflict, see if it is because of a dead process.
   If there is a dead process that was passive, it will be de-queued and this process will continue checkin the files;
   Otherwise it will give up on this user. */

			if conflict_sw then do;
				call check_dead_proc (conflict_sw, status);
				if conflict_sw then
				     wakeup = OFF;
			     end;
			else fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
		     end;

		     if wakeup
		     then do;
			     call hcs_$wakeup (user_list.process_id, user_list.ev_chn_id, QUE_FREE, state);
			     if state ^= 0
			     then wakeup = OFF;
			     else do;
				     user_list.event_signal_sw = ON;
				     dbc.wakeup_waiters = dbc.wakeup_waiters + 1;
				end;
			end;

		     if ^wakeup
		     then do;
			     user_list.bypass_count = user_list.bypass_count + 1;
			     if user_list.bypass_count > user_list.allowance_count
			     then user_list.priority_high = ON;
			end;
		end;

	     ul_ptr = convert (dbc_ptr, user_list.next_waiting_ofs);
	end;

     end wakeup_next_waiter;
%page;
check_dead_proc:
     proc (conflict_sw, status);

/*
   This routine checks for a potential stiff (dead process pointed to by conflict_ul_ptr) and does what it can about it.
   If the process is dead and was a passive user, that process is de-queued.
   If dead and non_passive then it alerts the dbc to the fact that the db might be in an inconsistent state.
*/

	dcl     conflict_sw		 bit (1);
	dcl     status		 bit (1);

/* Find out if conflicting proc is dead or alive. */

	if conflict_ul_ptr -> user_list.dead_proc
	then status = DEAD;
	else do;
		call set_lock_$lock ((conflict_ul_ptr -> user_list.db_lock_id), 0, state);
		if state = 0
		then status = ALIVE;
		else if state = error_table_$invalid_lock_reset
		then status = DEAD;
		else if state = error_table_$locked_by_this_process
		     | state = error_table_$lock_wait_time_exceeded
		then status = ALIVE;
		else call error (state);
	     end;

/* Now try and de-queue if dead/passive, quit if dead/non-passive, nothing if alive. */

	if status = DEAD
	then if conflict_ul_ptr -> user_list.passive_sw
	     then do;
		     conflict_sw = OFF;
		     call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, conflict_ul_ptr, icode);
		     if icode ^= 0
		     then call error (icode);
		end;
	     else do;
		     dbc.dead_proc_flag = ON;
		     conflict_ul_ptr -> user_list.dead_proc = ON;
		     user_list.dead_proc_conflict = ON;
		end;

	return;

     end check_dead_proc;
%page;
convert:
     proc (a_ptr, ofs) returns (ptr);

	dcl     a_ptr		 ptr;
	dcl     ofs		 bit (18) unal;

	if ofs = NULL_OFS
	then return (null);
	else return (ptr (a_ptr, ofs));

     end convert;
%page;
open_relation: proc (or_rmri_ptr);

/*
   This procedure opens a relation, it assumes that the relation is
   not yet opened, i.e. rm_rel_info.opening_id = "0"b
*/

/* PARAMETERS */

	dcl     or_rmri_ptr		 ptr;		/* (input) pointer to the rm_rel_info of the relation to be opened */

/* AUTOMATIC */

	dcl     or_code		 fixed bin (35);	/* standard error code */
	dcl     or_rdbi_ptr		 ptr;		/* pointer to the database's rm_db_info structure */




	or_rdbi_ptr = pointer (or_rmri_ptr, 0);

	call dbcb.relmgr_entries.open ((or_rdbi_ptr -> rm_db_info.db_path),
	     (or_rmri_ptr -> rm_rel_info.model_name),
	     or_rmri_ptr -> rm_rel_info.opening_id,
	     or_code);
	if or_code ^= 0
	then call error (or_code);

	return;

     end open_relation;
%page;
report_conflict_detail: procedure (report_type);

/* report the detail of the conflict preventing this scope request
   from being granted. reports are at three times, upon being queued for the first
   time, upon time out after waiting in the queue, and upon detection
   of a non-passive dead process */

	if substr (db_mrds_dsl_set_fscope, 1, 1) = "1"b then do; /* if debug display on */
		if report_type = DEAD_PROC_REPORT then
		     report_reason = "A non passive dead process is blocking scope requests.";
		else if report_type = BEING_QUEUED_REPORT then
		     report_reason = "You are queued until a conflict is overcome, or wait time is exceeded.";
		else if report_type = TIME_OUT_REPORT then
		     report_reason = "Your wait time elapsed without being able to resolve the conflict.";

		call ioa_ ("^/^a", report_reason);

	     end;

	if conflict_detail_known &
	     (report_type ^= BEING_QUEUED_REPORT | substr (db_mrds_dsl_set_fscope, 1, 1) = "1"b) then do;

		permit_conflict = "";

		if actual_conflict_detail.permits.read_attr then
		     permit_conflict = permit_conflict || "read_attr ";

		if actual_conflict_detail.permits.modify_attr then
		     permit_conflict = permit_conflict || "modify_attr ";

		if actual_conflict_detail.permits.append_tuple then
		     permit_conflict = permit_conflict || "append_tuple ";

		if actual_conflict_detail.permits.delete_tuple then
		     permit_conflict = permit_conflict || "delete_tuple ";

		if permit_conflict = "" then
		     permit_conflict = "null ";

		prevent_conflict = "";

		if actual_conflict_detail.prevents.read_attr then
		     prevent_conflict = prevent_conflict || "read_attr ";

		if actual_conflict_detail.prevents.modify_attr then
		     prevent_conflict = prevent_conflict || "modify_attr ";

		if actual_conflict_detail.prevents.append_tuple then
		     prevent_conflict = prevent_conflict || "append_tuple ";

		if actual_conflict_detail.prevents.delete_tuple then
		     prevent_conflict = prevent_conflict || "delete_tuple ";

		if prevent_conflict = "" then
		     prevent_conflict = "null ";

		call sub_err_ (icode, caller_name, continue, info_ptr, return_value,
		     "^/^a^a^a^a^a^/^a^a^a^a^a",
		     "The user """, conflict_user_id, """ has prevents conflicting with requested permits of """,
		     permit_conflict, """", "and/or permits conflicting with requested prevents of """,
		     prevent_conflict, """ on relation """, conflict_relation, """.");

		return;


		declare (permit_conflict, prevent_conflict) char (80) varying; /* extra scope that was not present */
		declare report_type		 fixed bin; /* encoding for caller */
		declare report_reason	 char (120) varying; /* detail about caller */

	     end;

     end;
%page;
/***********
*
*   These routines are used by the transaction processing include files.
*   Restore_significant_data is called to reinitialize variables in case
*   of a rollback.  Should_rollback determines whether a transaction should
*   be rolled back or aborted on error.  Currently, it is always aborted.
*
**********/


restore_significant_data:
     proc;
	user_list.queue_activ = OFF;
	user_list.bypass_count = 0;
	check_scope = ON;				/* OFF-> don't bother checking for conflict */
	conflict_sw = OFF;				/* ON -> a conflict was found */
	re_check = OFF;				/* ON -> a conflict was resolved, so try again */
	first_scope_triple = ON;			/* Processing firstrelation in scope request */
     end restore_significant_data;



should_rollback:
     proc returns (bit (1));
	return ("0"b);
						/* No rollbacks requested or desired */
     end should_rollback;

%page;
/* Based */
	dcl     db_index		 fixed bin (35) based (dbi_ptr),
						/* index of data base to perform set_fscope upon */
	        rel_name		 char (rel_len) based (rel_ptr);
						/* relation name part of scope tuple */

	dcl     code		 fixed bin (35) based (cd_ptr);
						/* standard return code */

/* Automatic structures */

	dcl     1 wait_list,
		2 nchn		 fixed bin,	/* one event channel */
		2 chn_id		 (1) fixed bin (71);/* channel id */

	dcl     1 info,				/* event information */
		2 chn_id		 fixed bin (71),
		2 msg		 fixed bin (71),	/* message from process doing the awakening */
		2 sender		 bit (36),	/* process id of the process doing the awakening */
		2 origin,
		  3 dev_sig	 bit (18) unal,	/* device signal */
		  3 ring		 bit (18) unal,	/* ring  id */
		2 chn_index	 fixed bin;	/* index of the channel id */
	dcl     ptr_bit_string	 bit (72) based;	/* bit string value of a pointer variable */
	dcl     state		 fixed bin (35);	/* return code from set_lock and ipc_  */
	dcl     empty_on_err	 bit (1) aligned init ("0"b);
						/* ON if we are to empty scope in case of error */
	dcl     check_scope		 bit (1);		/* OFF=>don't bother checking for conflict: either */
						/* ..there are no active users to contend with, or */
						/* ..there are active users and we are trying to set */
						/* ..an exclusive setting; thus cannot succeed */
	dcl     re_check		 bit (1);		/* ON if we are to re-check for conflict */
	dcl     first_scope_triple	 bit (1);		/* ON if we are still
						   processing the first rel of scope request */
	dcl     wakeup		 bit (1);		/* ON if we are to wake this waiting user up */
	dcl     conflict_sw		 bit (1) unal;	/* ON => conflict between
						   desired scope and scope in effect now */
	dcl     status		 bit (1) unal;	/* status code of DEAD or ALIVE */
	dcl     wait_seconds	 fixed bin (35) based (ws_ptr);
						/* seconds this user is willing to wait */
	dcl     wait_sec_fb71	 fixed bin (71);	/* fixed bin (71) format for wait_seconds param. */
	dcl     entry_name		 char (32);	/* name by which this procedure was called */
	dcl     model_rel_name	 char (30);	/* name of relation in model for which scope is to be set */
	declare submodel_rel_name	 char (32);	/* submodel version of rel name */
	dcl     (
	        nargs,				/* number of arguments passed */
	        arg_len,
	        num_tuples,				/* number of scope tuples to be defined */
	        i,
	        l,
	        pos_in_si,
	        args_exp,				/* number of args in the calling argument list */
	        arg_index,				/* index to 1st arg of current tuple in arg list */
	        rel_len
	        )			 fixed bin;	/* length of rel_name in chars */

	dcl     icode		 fixed bin (35);	/* internal status code */


	dcl     rel_name_32		 char (32);	/* Used for searching rel_array */
	dcl     ophset		 bit (18) unal based;
						/* a based offset */

	dcl     (
	        cd_ptr,				/* pointer to code */
	        dbi_ptr,				/* pointer to db_index */
	        ws_ptr,				/* ptr to wait time in seconds */
	        conflict_ul_ptr,			/* ptr to a user who conflicts with requested scope */
	        rel_ptr,				/* pointer to rel_name */
	        ulo_ptr,				/* ptr to the last 'next' offset in the user_list */
	        flo_ptr,				/* ptr to the last 'next' offset
						   in the fil_list(list of rels) */
	        this_ul_ptr				/* ptr to a given user list entry */
	        )			 ptr;		/* pointer to prevent ops */


	dcl     (any_other, cleanup, quit, arg_error)
				 condition;

	dcl     (addr, divide, length, mod,
	        null, pointer, rel, baseno, baseptr)
				 builtin;


/*                    Multics subroutines                     */

	dcl     cu_$arg_count	 entry (fixed bin),
	        cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35)),
	        get_process_id_	 entry returns (bit (36)),
	        ipc_$block		 entry (ptr, ptr, fixed bin (35)),
	        ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35)),
	        timer_manager_$alarm_wakeup
				 entry (fixed bin (71), bit (2), fixed bin (71)),
	        hcs_$wakeup		 entry (bit (*), fixed bin (71), fixed bin (71), fixed bin (35)),
	        set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));

/*                    Other subroutines                    */

	dcl     mu_empty_scope	 entry (ptr, ptr, ptr, bit (1) unal),
	        mu_database_index$get_resultant_model_pointer
				 entry (fixed bin (35), ptr),
	        mu_check_scope	 entry (ptr, ptr, ptr, ptr, ptr, ptr, bit (1), ptr),
	        mu_de_queue_user
				 entry (bit (1), bit (1), ptr, ptr, fixed bin (35));

/*                    External data                    */
	dcl     error_table_$lock_wait_time_exceeded
				 fixed bin (35) ext,
	        error_table_$locked_by_this_process
				 fixed bin (35) ext,
	        error_table_$invalid_lock_reset
				 fixed bin (35) ext,
	        mdbm_data_$quiesce_mode
				 fixed bin (35) ext,
	        mrds_data_$lock_wait_time
				 fixed bin (35) ext,
	        mrds_error_$unable_to_create_channel
				 fixed bin (35) ext,
	        mrds_error_$duplicate_scope
				 fixed bin (35) ext,
	        mrds_error_$invalid_db_index
				 fixed bin (35) ext,
	        mrds_error_$rel_name_too_long
				 fixed bin (35) ext,
	        mrds_error_$scope_not_empty
				 fixed bin (35) ext,
	        mrds_error_$unknown_relation_name
				 fixed bin (35) ext,
	        mrds_error_$non_scope_ready
				 fixed bin (35) ext,
	        mrds_error_$db_conflict_dead_process
				 fixed bin (35) ext,
	        mrds_error_$db_busy	 fixed bin (35) ext,
	        mrds_error_$unable_to_queue_user
				 fixed bin (35) ext,
	        mrds_error_$update_not_allowed
				 fixed bin (35) ext,
	        sys_info$max_seg_size	 fixed bin (35) ext;

	dcl     NULL_CHAR		 char (8) init ("");
	dcl     OFF		 bit (1) init ("0"b) static internal options (constant);
	dcl     ON		 bit (1) init ("1"b) static internal options (constant);

/* sub_err_ declarations */

	declare sub_err_		 entry options (variable); /* reports error detail */
	declare continue		 char (1) init ("c"); /* dont stop after printing */
	declare caller_name		 char (32) init ("mrds_dsl_set_fscope"); /* name of calling routine */
	declare info_ptr		 ptr init (null ());/* unused */
	declare return_value	 fixed bin (35) init (0); /* unused */
	declare 1 (actual_permits, actual_prevents, remembered_permits, remembered_prevents) like common;
	declare attr_retr_perm	 bit (1);		/* on => retr access permission */
	declare attr_modify_perm	 bit (1);		/* on => modify on some attr */
	declare attr_null_perm	 bit (1);		/* on => null on some attr */
	declare rel_append_perm	 bit (1);		/* on => append-tuple access permission */
	declare rel_delete_perm	 bit (1);		/* on => delete tuple access permission */
	declare rel_null_perm	 bit (1);		/* on => null tuple access permission */
	declare 1 actual_conflict_detail,		/* detail of scope denial */
		2 permits		 like common,
		2 prevents	 like common;
	declare 1 unused_conflict_detail,		/* thorw away detail */
		2 permits		 like common,
		2 prevents	 like common;
	declare TIME_OUT_REPORT	 fixed bin init (1);/* report reason for last conflict before time out */
	declare BEING_QUEUED_REPORT	 fixed bin init (2);/* report for first conflict forcing queueing  */
	declare DEAD_PROC_REPORT	 fixed bin init (3);/* report detail on non-passive dead proc conflict */
	declare conflict_detail_known	 bit (1) init ("0"b); /* on => conflict_detail data set up */
	declare conflict_user_id	 char (32);	/* user id of user causing conflict */
	declare conflict_relation	 char (32);	/* name of relation conflict occured at */
	declare ioa_		 entry options (variable); /* reports debug display info */
	declare null_request	 bit (1);		/* on => no permits/prevents requested */
	declare null_permit_request	 bit (1);		/* on => no permits specified */
	declare null_prevent_request	 bit (1);		/* on => no prevents specified */
	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* DBA detecter */
	declare local_area		 area (100);	/* space for DBA info */
	dcl     empty		 builtin;
	dcl     fixed		 builtin;
	dcl     index		 builtin;
	dcl     ptr		 builtin;
	dcl     rtrim		 builtin;
	dcl     string		 builtin;
	dcl     substr		 builtin;
	dcl     unspec		 builtin;
%page;
%include mdbm_scope_requests;
%page;
%include mrds_debug_names;
%page;
%include mrds_dbcb;
%page;
%include mdbm_dbc;
%page;
%include mdbm_users;
%page;
%include mdbm_scope_info;
%page;
%include mdbm_rm_db_info;
%page;
%include mdbm_rm_rel_array;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mrds_authorization;
%page;


     end mrds_dsl_set_fscope;


