/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-10-01,JRGray), approve(86-10-01,MCR7507),
     audit(86-10-27,RWaters), install(86-11-12,MR12.0-1202):
     Modified to change argument passing conventions. This is part of the
     changes for calling via the new subroutine "alm_".
                                                   END HISTORY COMMENTS */


mexp_$ignore: procedure ();
	return;

/* This program is a simple macro expander for alm programs. */

/* Last modified to list skipped iftarget code as comments by E. N. Kittlitz on 8/17/83 */
/* Last modified for changes requested by MTR 175 by EBush on 3/26/81 */
/* Modified to implement "iftarget" and "intarget" by EBush on 2/5/81 */
/* First written "about '70, '71" by Steve Webber, as stand-alone program. */
/* Integrated with ALM, fully EIS-ed, resubroutinized by Bernard Greenberg 3/25/77
   Also implemented functions 14-22 at that time, and shared-seg buffer stack. */


dcl  next fixed bin (21),
     code fixed bin (35),
     entry_no fixed bin (21),
     WHITE char (2) static init ("	 ") options (constant),
     ENDS char (4) static init ("();
") options (constant),
     TERMS char (2) static init (";
") options (constant),
     discard fixed bin,
     vc char (12) var,
     convert_binary_integer_$octal_string entry (fixed bin) returns (char (12) var),
     cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin),
     c char (1) aligned,
    (addr, substr, ptr, unspec, index, null, length) builtin,
     gtsname char (32) static options (constant) init ("ALM macro expander"),
    (no_exargs, no_ifargs) fixed bin,
     alm_finished_the_line bit (1) aligned,
     cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
     cu_$arg_list_ptr entry returns (ptr),
     error_table_$noarg fixed bin(35) external,
     ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1) aligned, bit (1) aligned),
     targ char (128) var,
     cbuf1 char (200), cb1b char (cb1l) based (addr (cbuf1)), cb1l fixed bin,
     temp_ap ptr, temp_al fixed bin (21),
     input_arg char (temp_al) based (temp_ap),
     arg_1 char (args (1).len) based (substaddr (il, args (1).start)),
     QUOTE char (1) aligned static init (""""),
     max_char_count fixed bin (21),
     sys_info$max_seg_size ext static fixed bin (35),
     COMMA_NL char (2) static init (",
") options (constant),
     NL char (1) static init ("
") options (constant),
     SIGNATURE char (14) static init ("ALM assembly: ") options (constant);

/* 

   TABLE OF MEXP CONTROL CODES and INDICES.

   Keep the vars HERE_FOR_DOCU(1 2) declared under MEXP_CTL_CHARS.
   They document the char/index relation.

*/
dcl  MEXP_CTL_CHARS char (22) init ("1puni()xUAlKk&=[];sFfR") static options (constant);
dcl  HERE_FOR_DOCU1 char (22) init ("0000000001111111111222") static options (constant);
dcl  HERE_FOR_DOCU2 char (22) init ("1234567890123456789012") static options (constant);
dcl  TRIVIAL_ENCODES char (9) init ("punxUKksR") static options (constant);
dcl  COMPARISON_CHARS char (4) init ("^=><") static options (constant);
dcl  COMPARISON_ENCODE char (12) init ("= ^=< <=> >=") static options (constant);
dcl (EQ init (1), NE init (2), LT init (3), LE init (4), GT init (5), GE init (6)) static options (constant);
dcl  type_NORMAL fixed bin static options (constant) init (1);
dcl  type_PREV_UNIQUE fixed bin static options (constant) init (2);
dcl  type_UNIQUE fixed bin static options (constant) init (3);
dcl  type_NEXT_UNIQUE fixed bin static options (constant) init (4);
dcl  type_ITERATE fixed bin static options (constant) init (5);
dcl  type_OPEN fixed bin static options (constant) init (6);
dcl  type_CLOSE fixed bin static options (constant) init (7);
dcl  type_ITER_INDEX fixed bin static options (constant) init (8);
dcl  type_SPEC_UNIQUE fixed bin static options (constant) init (9);
dcl  type_COMMAND_ARG fixed bin static options (constant) init (10);
dcl  type_LENGTH fixed bin static options (constant) init (11);
dcl  type_NARGS fixed bin static options (constant) init (12);
dcl  type_NITER fixed bin static options (constant) init (13);
dcl  type_NULL fixed bin static options (constant) init (14);
dcl  type_COMPARE fixed bin static options (constant) init (15);
dcl  type_STARTCOND fixed bin static options (constant) init (16);
dcl  type_ENDCOND fixed bin static options (constant) init (17);
dcl  type_ELSE fixed bin static options (constant) init (18);
dcl  type_SELECT fixed bin static options (constant) init (19);
dcl  type_FARGS_MACRO fixed bin static options (constant) init (20);
dcl  type_FARGS_ITER fixed bin static options (constant) init (21);
dcl  type_RANGECTL fixed bin static options (constant) init (22);
dcl  type_MAXTYPE fixed bin static options (constant) init (22);

/* WARNING: All internal procedures other than deferr, experr, and genabort must be kept quick, especially
   substaddr. This implies that the three above-named routines, which have formline_ arguments,
   and must therefore be non-quick, must never call any subroutines in this program, or they become
   non-quick. */



/*  */

/*  Declarations for ALM environment integration. */

dcl (envp, sfap) ptr;
dcl  acode fixed bin (35);				/* return code for Multics errors */
dcl  hashx fixed bin (17);				/* macro name hash index */

dcl 1 bct based (envp) aligned,			/* control structure */
    2 sfap ptr init (null ()),			/* ptr to system_free_area */
    2 nsegs fixed bin init (2),			/* number of tempsegs gotten */
    2 curexpseg fixed bin init (2),			/* cur seg for expansions */
    2 macroptr (0:126) ptr,				/* non-initted hash table of macros */
    2 hashx_used bit (127) aligned init ("0"b),		/* 0 => macroptr(x) not valid */
    2 curlevel fixed bin init (0),			/* level of macros handed out */
    2 macfree fixed bin init (0),			/* rel index to macro free def seg */
    2 outstack (100),				/* segx-ptr of macros handed out */
      3 segx fixed bin (13) unal,			/* seg index of expansion buffer */
      3 charx fixed bin (21) unal,			/* index of first char of that exp. */
    2 segarray (10) ptr init ((10) null ()),		/* temp seg array */
    2 segarray_free (10) fixed bin (21) init ((10) 1),	/* charx of first unused char in each buffer tempseg */
    2 unique_generator fixed bin init (0),
    2 unique_generator1 fixed bin init (0),
    2 unique_changed bit (1) init ("0"b);		/* "1"b if used &U in this expansion */

dcl 1 arguments(eb_data_$alm_arg_count) based(eb_data_$alm_arg_ptr),
     2 arg_ptr ptr,
     2 arg_len fixed bin(21);

dcl  segarray_of_one (1) ptr auto;
dcl  segarray_of_two ptr dim (2) based (addr (bct.segarray));
dcl  system_free_area area based (sfap);

dcl  get_system_free_area_ entry returns (ptr);
dcl (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr, fixed bin (35));

dcl (inputs_$run_statement, inputs_$run_statement_nolist, inputs_$next_statement, inputs_$next_statement_nolist) ext entry;
dcl  inputs_$get_ptr entry (ptr, fixed bin (21), fixed bin (21), bit (1) aligned);
dcl  alm_include_file_$macro entry (ptr, fixed bin (21)),
     alm_include_file_$pop entry;

dcl  prnter_$macro_error entry (char (*), char (*));
dcl  prnter_$general_abort entry (char (*));
dcl  eb_data_$mexp_env_ptr ptr external,
     eb_data_$macro_linect fixed bin ext,
     eb_data_$mexp_argno fixed bin ext,
     eb_data_$alm_arg_count fixed bin ext,
     eb_data_$alm_arg_ptr ptr ext;

%include system_types;
%include varcom;

/*  */
mexp_$init: entry (acode);

/* Called by ALM at pass1/pass2 init. Allocate control structure, get 2 temp segs. First
   contains macro definition blocks, second is first expansion output buffer. */

	sfap = get_system_free_area_ ();		/* set up to alloc bct */
	allocate bct in (system_free_area);
	bct.sfap = sfap;				/* for later free */
	eb_data_$mexp_env_ptr = envp;
	eb_data_$macro_linect = 0;
	call get_temp_segments_ (gtsname, segarray_of_two, acode);
	return;

mexp_$cleanup: entry;				/* relinquish temp segs */

/* Called by ALM at pass1/pass2 end, and on cleanup condition. Release control structure and
   temp segs. */

	envp = eb_data_$mexp_env_ptr;
	if envp = null then return;
	call release_temp_segments_ (gtsname, bct.segarray, (0));
	sfap = bct.sfap;
	free bct in (system_free_area);
	eb_data_$mexp_env_ptr = null ();
	return;

/*  */

dcl (nparens, i, ci, start, stop, j, iterate) fixed bin (21),
     found_number bit (1) aligned,
     si fixed bin (21),
     mbptr ptr,					/* Ptr to macro structure */
     save_free fixed bin (21),
     val fixed bin,
     semict fixed bin,				/* Count of ALM statements by which to run ALM */
     t fixed bin (21),
     type fixed bin,
     nargs fixed bin,				/* Number of macro args */
     nchars fixed bin (21),
     ia fixed bin,
     ml char (macro_len) based (mp),			/* The Macro Definition Text. */
     macro_len fixed bin (21),
     ob char (max_char_count) based (obp),		/* The Output Buffer */
     currob char (next - 1) based (obp),		/* Currently filled portion of Output Buffer */
     il char (nchars) based (tp),			/* The Input Source */
     end_index fixed bin (21),
    (save_segx, save_segx1, save_curlev) fixed bin, (save_charx, save_charx1) fixed bin (21),
     match bit (1) aligned,
     iftarget_cond bit (1) aligned,
    (var_start, var_end) fixed bin (21),
     opcode char (32) aligned,
     iftarget_str  char(24) varying,
     iftarget_error  fixed bin(35),
     iftarget_value fixed bin(17),
     system_type_ external entry(char(*), char(*), fixed bin(17), fixed bin(35)),
     com_err_      external entry options(variable),
     eb_data_$who_am_I   external static char(12),
     iterate_arg_no fixed bin (21),
    (obp, mp, tp) ptr;

/*  */

/* Data structure used by expander---  macro is structure in temp seg (1). */

dcl 1 ifargs (0: 99) aligned like args;			/* Ptr/len array for pseudoop args */

dcl 1 iterargs (0: 99) aligned like args based (iap), iap ptr; /* Bound to either args or exargs for &( */

dcl 1 exargs (0: 99) aligned like args;			/* Ptr/len array for decomposed argument */

dcl 1 args (0: 99) aligned,				/* Ptr/len array for macro args */
    2 start fixed bin (21),
    2 len fixed bin (21);

dcl 1 macro based (mbptr) aligned,			/* Definition of a macro, in tempseg (1) */
    2 next_macro ptr unal,				/* Hash thread on name. */
    2 startchar fixed bin (21),			/* charx of 1st char, for exp-time err recov. */
    2 sourcelen fixed bin (21),			/* Length of def in chars, for ditto. */
    2 sourcep ptr unal,				/* Ptr to sourceseg/expansion of def */

    2 pad bit (14) unal,
    2 num_entries fixed bin (21) unal,			/* Number of entries in macro.entry */

    2 name char (32),				/* Macro name */
    2 entry (1000),					/* One entry for control seq and tex up to it. */
      3 type fixed bin,				/* Type of control sequence, see tbl above */
      3 value_1 fixed bin (13) unal,			/* Encoded info, value depends on type of ctl seq */
      3 first_char fixed bin (21) unal,			/* charx of text preceding ctl seq, always valid */

      3 value_2 fixed bin (13) unal,			/* Encoded info, value depends on type of ctl seq */
      3 n_chars fixed bin (21) unal;			/* Number of chars of text preceding ctl seq, c/b 0. */

/*  */

mexp_$define_macro: entry (a_opcode);			/* define a macro. */

/* Define a macro. ALM has already picked up the name, and passed it to us, and validated the syntax
   of the statement, which means that inputs_ is at the end of the statement. We let ALM decompose the
   "macro" statement so that ALM's rules on valid symbols and delimiters, which will be used when
   macro is used as opcode, can be applied. */

	envp = eb_data_$mexp_env_ptr;			/* access control frame */

	do i = 1 to bct.curlevel;			/* If source for definition lies in macro expansion,
						   make sure than no buffer space occupied by
						   outstanding macro expansions is ever freed/re-used. */
						/* This ensures the validity of ptr/len's to be encoded. */
	     bct.outstack.segx (i) = bct.curexpseg;
	     bct.outstack.charx (i) = bct.segarray_free (bct.curexpseg);
	end;

	call get_ptrs;				/* Find out where alm is, oughtta be next sta. */

	call get_hashx ((a_opcode));			/* Compute hash index */

	call define_macro (a_opcode, (tp), stop + 1, nchars - stop); /* do it */
	return;

/*  */
define_macro: proc (mname, mpstart, cistart, amacrolen);

dcl  mp ptr, cifin fixed bin (21);
dcl  bad_macro bit (1);
dcl (almpos, lasteralmpos) fixed bin (21);
dcl  amacrolen fixed bin (21);
dcl  condthread fixed bin, condstack (10) fixed bin;
dcl  mname char (*), cistart fixed bin (21), mpstart ptr, ciprev fixed bin (21);

dcl  ml char (macro_len) based (mp) aligned;
dcl (condlevel, itercondlevel) fixed bin;
dcl  c2 char (2);

dcl  start fixed bin (21);
dcl  in_iteration fixed bin;


	     in_iteration = 0;			/* Not inside ()'s */
	     bad_macro = "0"b;			/* No known problems, don't trash def. */
	     condthread = -1;			/* Not in []'s */
	     condlevel = 0;				/* Zero levels of outsdg []'s */
	     macro_len = amacrolen;			/* random arg copy, is remaining source len. */

	     eb_data_$macro_linect = 1;		/* Triggers inputs_ to increment this,
						   and prwrd_ to print it when > 0. */
	     mbptr = ptr (bct.segarray (1), bct.macfree); /* This is where def block goes. */
	     macro.name = mname;			/* Copy name to defblock */

	     mp = mpstart;				/* Copy to automatic */
	     macro.sourcep = mp;			/* All parms in def block rel to this value */

	     almpos, macro.startchar = cistart;		/* Almpos for deferr, startchar for experr. */
	     lasteralmpos = -1;			/* For deferr. */
	     ci = cistart - 1;			/* Prime scan. */

/* Break up macro definition text into control sequences separated by text. Each element in
   macro.entry defines a control sequence and the text preceding it. */

	     do entry_no = 1 by 1;			/* iterate until macro defined */

/* Locate the next &--- countrol sequence. If there's none, &end must be missing. */

		start = ci+1;			/* get start of the current element */
		t = index (substr (ml, start), "&");
		if t = 0 | t = macro_len - start + 1 then do;
		     call deferr ("No &end");
		     go to FIN_MACRO;
		end;

		ci = ci + t;

		macro.entry (entry_no).first_char = start;

/* Encode the location (rel to macro.sourcep) and length (could be 0) of fixed text which
   PRECEDES control sequence, for each sequence. */

		macro.entry (entry_no).n_chars = ci-start;

		c = substr (ml, ci+1, 1);		/* copy next character -- might be argument number */
		si = 2;				/* More general case */

		type = index (MEXP_CTL_CHARS, c);	/* Find type index */
		if type <= type_NORMAL then do;
		     type = type_NORMAL;		/* Try for number> */
		     si = 1;
		     macro.entry (entry_no).value_1 = get_numeric_value_could_be_0 ();
		     if ^found_number then do;
			if substr (ml, ci, 4) = "&end" then go to FIN_MACRO;
			t = index (COMPARISON_CHARS, c);
			if t > 0 then go to compare_op;
			else call deferr_g ("Undefined substitution type: &^a", c);
		     end;
		     if macro.entry (entry_no).value_1 = 0 then call deferr_g ("&0 is not supported");
		     ci = ci - 1;			/* Back up  a little. */
		end;
		else if index (TRIVIAL_ENCODES, c) > 0 then; /* All work done here. */
		else if type = type_ITERATE then if in_iteration <= 0 then
			call deferr_g ("""&i"" occured outside of iteration bounds");
		     else;
		else if type = type_COMPARE then do;
compare_op:	     c2 = substr (ml, ci + 1, 2);
		     if c2 = "^=" | c2 = ">=" | c2 = "<=" then ci = ci + 1;
		     if c = "^" & c2 ^= "^=" then
			call deferr_g ("Illegal conditional construct: &^a", c2);
		     if substr (c2, 2, 1) ^= "=" then substr (c2, 2, 1) = " ";
		     macro.entry (entry_no).value_1 = (index (COMPARISON_ENCODE, c2) + 1)/2;
		     type = type_COMPARE;
		end;
		else if type = type_STARTCOND then do;	/* [ */
		     if condlevel >= hbound (condstack, 1) then
			call deferr_g ("Conditional depth exceeds ^d", hbound (condstack, 1));
		     condlevel = condlevel + 1;

/* Save previous cond-thread in condstack at appropriate level. Start a thread of ['s and ;'s at this
   level, so that we can back-fill entry.val_1 in [ or ; to next ; or ], so expander can skip. */

		     condstack (condlevel) = condthread;
		     condthread = entry_no;
		end;
		else if type = type_ENDCOND then do;	/* ] */
		     if condlevel = 0 then call deferr_g ("Unbalanced brackets");
		     macro.entry (condthread).value_1 = entry_no;
		     macro.entry (entry_no).value_1 = -1;
		     condthread = condstack (condlevel);
		     condlevel = condlevel - 1;
		     if in_iteration >0 & condlevel + 1 = itercondlevel then go to icerr;
		end;
		else if type = type_ELSE then do;	/* ; */
		     if condlevel = 0 then call deferr_g ("Semicolon outside of brackets");
		     macro.entry (condthread).value_1 = entry_no;
		     condthread = entry_no;
		     if in_iteration > 0 & itercondlevel = condlevel then go to icerr;
		end;
		else if type = type_OPEN then do;	/* Start of iteration */
		     save_free = entry_no;
		     macro.entry (entry_no).value_1 = get_numeric_value ();
		     if in_iteration > 0 then call deferr_g ("Illegal recursive iteration");
		     in_iteration = 1;
		     itercondlevel = condlevel;
		end;
		else if type = type_CLOSE then do;	/* end of iteration */
		     in_iteration = in_iteration - 1;
		     if in_iteration < 0 then call deferr_g ("Unbalanced iteration clause");
		     if itercondlevel ^= condlevel then
icerr:			call deferr_g ("Illegal intertwining of conditionals and iteration");
		     macro.entry (entry_no).value_1 = save_free;
		     macro.entry (save_free).value_2 = entry_no;
		end;
		else if type = type_COMMAND_ARG | type = type_LENGTH
						/* Required simple number, &A, &l */
		then macro.entry (entry_no).value_1 = get_numeric_value ();
		else if type = type_NULL
		then macro.entry (entry_no).n_chars = macro.entry (entry_no).n_chars + 1;

		else if type = type_FARGS_MACRO | type = type_FARGS_ITER then do; /* sequence of args */
		     c = substr (ml, ci + 2, 1);
		     if c = "q" | c = "Q" then do;
			ci = ci + 1;
			macro.entry (entry_no).value_2 = 1;
		     end;
		     else macro.entry (entry_no).value_2 = 0;
		     macro.entry (entry_no).value_1 = get_numeric_value ();
		     if type = type_FARGS_ITER & in_iteration <= 0 then call deferr_g ("&f used outside of iteration");
		end;
		else call genabort ("ALM internal problem. Contact assembler maintainers.");

deferr_nlexit:	macro.entry (entry_no).type = type;
		ci = ci + 1;

	     end;


FIN_MACRO:
	     if in_iteration ^= 0 then call deferr ("Unbalanced iteration");
	     if condlevel > 0 then call deferr ("Unbalanced conditional");
	     cifin = ci + 1;			/* Prime the loop */
	     macro.sourcelen = cifin - cistart + 1;	/* Used by experr to count lines */

/* Figure out where ALM input scanner is, in case deferr ran some statements by, and run all
   remaining ALM statements in macro definition by, until the statement with the &end has been run by. */

	     call get_ptrs;				/* set ci to 1st char after invoc */
	     do while (tp = mpstart & cifin >= ci);
		call inputs_$run_statement;		/* Skip stuff for ALM */
		ciprev = ci;			/* save beginning of line previous line */
		call get_ptrs;
	     end;
	     eb_data_$macro_linect = 0;		/* no more macrodef */

	     macro.entry (entry_no).n_chars = macro.entry (entry_no).n_chars - (cifin - ciprev) + 1;
						/* This causes partial line to &end to be skipped. */
	     if bad_macro then do;			/* Any problems => null definition */
		entry_no = 1;
		macro.entry (1).n_chars = 0;
	     end;

	     macro.entry (entry_no).type = type_NULL;	/* indicates no expansion */
	     macro.num_entries = entry_no;
	     macro.next_macro = bct.macroptr (hashx);

/* Thread macro definition into correct hash bucket. */

	     bct.macroptr (hashx) = mbptr;
	     bct.macfree = fixed (rel (addr (macro.entry (entry_no + 1))));
	     return;


get_numeric_value: proc returns (fixed bin);

		return (max (1, get_numeric_value_could_be_0 ()));

	     end get_numeric_value;

get_numeric_value_could_be_0: proc returns (fixed bin);

/* Collect up-to-3-digit decimal number at il|ci+(1 0r 2) to that + 2. */

dcl  c char (1) aligned;

		i = 0;				/* initialize return value */
		found_number = "0"b;
		do ci = ci to ci+2;
		     c = substr (ml, ci+si, 1);
		     if c < "0" | c > "9" then go to r;
		     found_number = "1"b;
		     i = i*10 + bin (unspec (c), 9) - 48;
		end;
r:		if i > hbound (args, 1) then do;
		     call deferr ("Definition time parameter (^d) may not be larger than ^d", i, hbound (args, 1));
		     i = 0;
		end;
		return (i);

	     end;

/*  */

deferr:	     proc options (variable, non_quick);	/* general def error. */

/* Report any problem in definition. Run ALM past any statments in definition that haven't been
   so run yet, so that D error comes out on right line. Set "bad_macro" sw, so that null
   definition results, so expander won't blow up on known bad definition. Calling deferr_g
   causes non-local go-to to next definition control sequence. */

		gsw = "0"b;

deferr_g:		entry options (variable);


dcl  jx fixed bin (21), cha char (1);
dcl  gsw bit (1) init ("1"b);

		call ioa_$general_rs (cu_$arg_list_ptr (), 1, 2, cbuf1, cb1l, "0"b, "0"b);
						/* generate remark */

		do while ("1"b);
		     jx = search (substr (ml, almpos), TERMS);
		     if jx = 0 then cha = NL; else cha = substr (ml, almpos + jx - 1, 1);
		     if cha = NL & almpos + jx > ci then do;
			eb_data_$erflgs_overlay.prntd = 1;
			if lasteralmpos ^= almpos then call inputs_$run_statement;
			eb_data_$erflgs_overlay.prntd = 0; /* could be pass 1, ya know */
						/* so keep errs off coll. tape */
			lasteralmpos = almpos;
			bad_macro = "1"b;
			call prnter_$macro_error
			     ("Macro definition error: " || cb1b || " in macro " || rtrim (macro.name) || ".",
			     "**** **** **** ERROR IN MACRO DEFINITION: " || cb1b || ".");
			if gsw then go to deferr_nlexit;
			else return;
		     end;
		     if lasteralmpos ^= almpos then call inputs_$run_statement;
		     almpos = almpos + jx;
		end;

	     end deferr;

	end define_macro;
						/*  */
mexp_$mexp_: entry (a_opcode, errflag, target_value, no_target_given, first_time_thru );
	   dcl a_opcode            char(*),
	       errflag             fixed bin(1),
                 target_value        fixed bin(17),
	       (no_target_given,
	       first_time_thru)     bit (1),      parameter;

/* Called by pass1_/pass2_. The input scanner (inputs_) has scanned an opcode, and the break after it.
   ALM opcode-looker (oplook_) does not know, or claims not to know about the opcode. Value of
   opcode is a parameter to us. The vbl "errflag" is used to tell ALM that we never heard of it
   either. Target_value comes all the way from alm_ and is used to decide iftarget conditionals. */


	opcode = a_opcode;				/* Get into stack */
	errflag = 0;				/* Set up for ALM. */
	envp = eb_data_$mexp_env_ptr;
	semict = 0;				/* ALM lines to skip */

	call get_ptrs;
	var_start = -1;				/* Set up for no var field */
	if ^alm_finished_the_line then do;		/* If line not done, ... */
	     call skip_to_next_line;

	     ci = start;				/* initialize scanning index */
	     call sob;				/* skip over blanks */

	     c = substr (il, ci, 1);			/* pick up the next character of the line */

	     if ^(c = QUOTE | c = NL | c = ";") then do;
		var_start = ci;			/* save start of var field */
		call soc;				/* skip over non-white characters */
		var_end = ci - 1;			/* save last char of variable field */
		if ci > stop then var_end = var_end - 1;
	     end;
	end;

/* See if the opcode is a macro name */

	call get_hashx (opcode);

	do mbptr = bct.macroptr (hashx) repeat macro.next_macro while (mbptr ^= null);
	     if macro.name = opcode then do;		/* we have found a macro to expand */
		call make_new_outbuf;
		call expand_macro;			/* mbptr implied arg */
		call push_mexp_output_upon_alm;
		return;
	     end;
	end;


/*  */
/* See if the opcode is conditional-assembly pseudo-op */

	if opcode = "ife" | opcode = "ine" | opcode = "ifarg" | opcode = "ifint" | opcode = "inint"
	| opcode = "inarg" | opcode = "iftarget" | opcode = "intarget" then do;

/* Get extents of argument list, collect them. Run ALM past all of argument-list statements. */

	     iftarget_cond = substr (opcode, 3) = "target";
	     if var_start < 0 then goto BAD_PSEUDO;	/* must have args for INE and IFE */
	     call make_new_outbuf;
	     j = index (substr (il, stop), "ifend");	/* search for end of conditional data */
	     if j <= 0 then do;			/* bad use of pseudo-op */
BAD_PSEUDO:	eb_data_$erflgs_overlay.prntf = 1;
		return;
	     end;
	     if bct.curlevel = 0 then call inputs_$next_statement;
	     else call inputs_$next_statement_nolist;
	     end_index = stop + j;			/* save position of ifend */
	     call scan_args (ifargs, no_ifargs, var_start, var_end-var_start+1, code);
	     do j = 1 to semict;
		if bct.curlevel = 0 then call inputs_$run_statement;
		else call inputs_$run_statement_nolist;
	     end;
	     if code ^= 0 then go to BAD_PSEUDO;

/* Based upon the opcode, figure out if code is to be skipped or output. Set "match" accordingly. */

	     targ = substr (il, ifargs (1).start, ifargs (1).len);
	     if opcode = "ifarg" | opcode = "inarg" then do; /* Check command arg */
		match = "0"b;			/* default is no match */
		do ia = eb_data_$mexp_argno + 1 to eb_data_$alm_arg_count while (^match);
		     temp_ap = arguments(ia).arg_ptr;
		     temp_al = arguments(ia).arg_len;
		     if input_arg = targ then match = "1"b;
		end;
		if opcode = "inarg" then match = ^match;
	     end;
	     else if opcode = "ifint" | opcode = "inint" then do;
		discard = cv_dec_check_ ((targ), code); /* check for decimal number */
		match = (code = 0);			/* match if arg is decimal integer */
		if opcode = "inint" then match = ^match;
	     end;
	     else if opcode = "iftarget" | opcode = "intarget" then do;

		if no_target_given
		    then do;
		            if tpass1 = 1
			       then prnta = 1;
			  target_value = L68_SYSTEM;
			  if first_time_thru
			       then do;
			             call com_err_(0,eb_data_$who_am_I,"Attempted use of ""iftarget"" or ""intarget"" without providing a value via ""-target"".");
				   first_time_thru = "0"b;
				  end;
                             end;
		iftarget_str = targ;
		call system_type_((iftarget_str),(""),iftarget_value,iftarget_error);
		if iftarget_error ^=0 & tpass1 = 1
		    then do;
		            eb_data_$erflgs_overlay.prntf = 1;
			  iftarget_value = L68_SYSTEM;
		         end;
		match = (target_value = iftarget_value);
		if opcode = "intarget"
		    then match = ^match;
               end;
	     else do;
		if targ = substr (il, ifargs (2).start, ifargs (2).len) then
		match = "1"b; else match = ""b;
		if opcode = "ine" then match = ^match;	/* inverse meaning for INE case */
	     end;

/* Having figured out whether code will be skipped or output, run ALM past the conditional
   code, outputting ALM statements if code is to be output. */

	     call skip_to_next_line;			/* Prime the loop. */
	     do while (stop <= end_index);		/* Stop when ifend line eaten. */
		if ^match & iftarget_cond then call outptr (addr (QUOTE), 1);
		if match | iftarget_cond then call outptr (substaddr (il, start), stop - start + 1);
		call skip_to_next_line;
		call inputs_$run_statement_nolist;
	     end;
	     call inputs_$run_statement_nolist;
	     if iftarget_cond then do;
		call outptr (addr (QUOTE), 1); 
		call outptr (substaddr (il, start), stop - start + 1);
	     end;
	     if substr (il, end_index + 4, 5) = "_exit" & match & bct.curlevel > 0
	     then do;				/* pop curr. macro. */

/* This  save-and-restore song and dance is needed for the following reason: Calling
   alm_include_file$pop will cause the top regnant expansion (the one the ifend_exit alludes to)
   to pop available buffer space to start below that expansion, which is below the
   expansion we just produced, which isn't regnant yet.  We can't push our ife output
   until this old thing is off the stack, or they'd pop in the wrong order. */

		save_segx = bct.curexpseg;
		save_charx = bct.segarray_free (save_segx);
		call alm_include_file_$pop;		/* pop mexp and alm */
		save_segx1 = bct.curexpseg;
		save_charx1 = bct.segarray_free (save_segx1);
		save_curlev = bct.curlevel;
		bct.curexpseg = save_segx;
		bct.segarray_free (save_segx) = save_charx;
		call push_mexp_output_upon_alm;	/* Do it. */
		if bct.curlevel ^= save_curlev then do; /* Make it ss that pop this pops hole. */
		     bct.outstack (bct.curlevel).segx = save_segx1;
		     bct.outstack (bct.curlevel).charx = save_charx1;
		end;
		return;
	     end;
	     call push_mexp_output_upon_alm;
	     return;
	end;

/*  */


	if opcode = "warn" then do;			/* Assembly-time msg */
	     if var_start > 0 then call scan_args (args, nargs, var_start, var_end - var_start +1, code);
	     else args (1).len = 0;
	     if var_start ^> 0 | code ^= 0 then eb_data_$erflgs_overlay.prntf = 1;
	     call inputs_$next_statement;
	     do j = 1 to semict;
		call inputs_$run_statement;
	     end;
	     temp_ap = addr (arg_1); temp_al = length (arg_1);
						/* This little bit of obscurity
						   keeps substaddr from being non-quicked,
						   cause compiler would call it after
						   stack was extended for catenate. */
	     call prnter_$macro_error (SIGNATURE || input_arg, input_arg);
	     return;
	end;


/* No macros or pseudos match, return an error. */

	errflag = 1;
	return;

/*  */

expand_macro: procedure;

/* The value of "opcode" has been found to be a macro name. The vbl "mbptr" points
   to the macro definition block.  The output buffer "ob" has been setup. Run ALM
   past the invocation, and produce the expansion into ob. */

dcl  selector_eno fixed bin;
dcl  tcode fixed bin (35);
dcl  arg_offset fixed bin;
dcl (outstanding_select, outstanding_range) bit (1);
dcl (selector_ob_charpos, range_ob_charpos) fixed bin (21);
dcl  select_answer fixed bin;
dcl  found_d_error_lying_there bit (1);

	     mp = macro.sourcep;
	     outstanding_select, outstanding_range = "0"b;
	     found_d_error_lying_there = (eb_data_$erflgs_overlay.prntd ^= 0);
						/* If this is pass2, all errors that we are going to find
						   were already found by us in pass1,  and collated
						   on coll. tape entry for 1st sta of invoc. */
	     call inputs_$next_statement;		/* Skip over first line of invocation. */

	     if bct.unique_changed then do;		/* did we use it last macro? */
		bct.unique_generator1 = bct.unique_generator1 + 1;
		bct.unique_changed = ""b;
	     end;

/* Now pick off any args from the input source, save pointers to them */

	     if var_start > 0 then call scan_args (args, nargs, var_start, var_end-var_start+1, tcode);
	     else args (*).len, nargs, tcode = 0;

	     do j = 1 to semict;			/* Run ALM over breaks scan_args saw. */
		call inputs_$run_statement;
	     end;
	     if tcode ^= 0 then do;
		eb_data_$erflgs_overlay.prntf = 1;
		return;
	     end;
	     args.len (0) = 0;			/* For good luck. */
	     iterate = 0;				/* in case &x is used and iteration isn't */

/* Now expand each element in array- first the text, then the expansions. */

	     do entry_no = 1 to macro.num_entries;
		call outptr (substaddr (ml, (macro.entry (entry_no).first_char)),
		     (macro.entry (entry_no).n_chars));
		val = macro.entry (entry_no).value_1;	/* extract value for this type of element */
		type = macro.entry (entry_no).type;	/* also extract type of element */
		if type < 1 | type > type_MAXTYPE then
		     call genabort ("ALM internal error. Contact assembler maintainers.");
		go to XP (type);
XP (1):						/* Normal argument expansion (&1, &2, etc.) */
		if val <= nargs
		then call outptr (substaddr (il, args.start (val)), args.len (val));
		go to A;

XP (2):						/* Previous unique (&p) */
		i = bct.unique_generator;
		go to UNIQUE;
XP (3):						/* Unique symbol (&u) */
		bct.unique_generator = bct.unique_generator + 1;
		i = bct.unique_generator;		/* get value for symbol */
UNIQUE:		call ouch ("...");
UNIQUE1:		vc = convert_binary_integer_$octal_string (i + 1e27b); /* convert to char */
		call ouch (substr (vc, 6, 5));
		go to A;
XP (4):						/* next unique (&n) */
		i = bct.unique_generator + 1;
		go to UNIQUE;
XP (5):						/* iterate arg (&i) */
		call outptr (substaddr (il
		     , iterargs (iterate + arg_offset).start),
		     iterargs (iterate + arg_offset).len);
		go to A;
XP (6):						/* Start of iteration (&() */
		save_free = entry_no;
		iterate = 1;			/* Value of &x, index ito iter set. */
		if outstanding_range then do;		/* &R was used, iter over mac arglist. */
		     iap = addr (args);		/* use real args */
		     call get_ob_rangeargs (arg_offset, no_exargs);
		     if arg_offset > 0 then arg_offset = arg_offset - 1;
		     if no_exargs = 0 then no_exargs = 99999;
		     else if no_exargs < arg_offset - 1 then no_exargs = 1;
		     else no_exargs = no_exargs - arg_offset;
		     no_exargs = min (no_exargs, nargs - arg_offset);
		end;
		else do;				/* No &R, iterate over pieces of macro arg */
		     iterate_arg_no = val;
		     i = args (iterate_arg_no).len;
		     if i > 0 then do;
			call scan_args (exargs, no_exargs, args (iterate_arg_no).start, i, tcode);
			if tcode ^= 0 then call experr
			     ("Internal unbalanced parentheses in arg ^d in iteration", iterate_arg_no);
		     end;
		     else no_exargs = 0;		/* null arg => no iterations */
		     iap = addr (exargs);
		     arg_offset = 0;
		end;
ANY_ARGS_Q:	if no_exargs < iterate then
		     entry_no = macro.entry (save_free).value_2;
		go to A;
XP (7):						/* End of iteration (&)) */
		iterate = iterate + 1;
		entry_no = save_free;
		go to ANY_ARGS_Q;
XP (8):						/* Iteration index (&x) */
		call outnum ((iterate));
		go to A;
XP (9):						/* Special unique (&U) */
		i = bct.unique_generator1;
		call ouch (".._");
		bct.unique_changed = "1"b;
		go to UNIQUE1;
XP (10):						/* Command arg (&A) */
		if val <= eb_data_$mexp_argno | val > eb_data_$alm_arg_count then code = error_table_$noarg;
		else do;
		     temp_ap = arguments(val + eb_data_$mexp_argno).arg_ptr;
		     temp_al = arguments(val + eb_data_$mexp_argno).arg_len;
		     call outptr (temp_ap, temp_al);
		  end;
		go to A;
XP (11):						/* Arg length (&l) */
		call outnum (args (val).len);
		go to A;
XP (12):						/* Number of args (&K) */
		call outnum ((nargs));
		go to A;
XP (13):						/* Number of iteration args (&k) */
		call outnum ((no_exargs));
		go to A;
XP (14):						/* Null expansion (&& or end of macro) */
		go to A;
XP (15):						/* Comparison ops */
XP (19):						/* Selector ops (&s)  */
		if outstanding_select then call experr ("Unused selection");
		outstanding_select = "1"b;
		selector_ob_charpos = next;		/* Save for evaluator. */
		selector_eno = entry_no;
		go to A;
XP (16):						/* Open conditional (&[) */
		if ^outstanding_select then do;
		     call experr ("Brackets with no previous selector operation");
		     select_answer = 1;
		end;
		else call pull_apart_select_input;
		do i = 1 by 1 while (i < select_answer);
		     if macro.entry (entry_no).value_1 <= 0 then i = select_answer;
		     else entry_no = macro.entry (entry_no).value_1;
		end;
		go to A;
XP (17):						/* End of conditional (&])  */
		go to A;
XP (18):						/* Select else (&;) */
		do entry_no = entry_no repeat (macro.entry (entry_no).value_1)
			while (macro.entry (entry_no).value_1 > 0);
		end;
		go to A;
XP (20):						/* Fargs-macro (&F)  */
		call output_fargs (args, nargs);
		go to A;
XP (21):						/* Fargs-iter (&f) */
		call output_fargs (exargs, no_exargs);
		go to A;
XP (22):						/* Iter over args. (&R) */
		if outstanding_range
		then call experr ("Unused range specifier");
		outstanding_range = "1"b;
		range_ob_charpos = next;
		go to A;
A:
	     end;

	     return;

/*  */
output_fargs:  proc (aaray, ct);

/* Used to output sequence of args, for &F and &f requests. val2 is 1 for FQ/fq */


dcl 1 aaray (0:99) aligned,
    2 start fixed bin (21),
    2 len fixed bin (21);

dcl  ct fixed bin;
dcl  qsw bit (1);
dcl  k fixed bin;

		qsw = (macro.entry (entry_no).value_2 = 1);
		do k = macro.entry (entry_no).value_1 to ct by 1;
		     if qsw then call ouch ("(");
		     call outptr (substaddr (il, aaray (k).start), (aaray (k).len));
		     if qsw then call ouch (")");
		     if k < ct then call ouch (",");
		end;
	     end output_fargs;

/*  */

pull_apart_select_input: proc;			/* Gets stuff out of output buffer to make selector clauses. */

/* Used to get whatever input is needed out of expansion (ob) for &[. Defines based/adjustable "ebuf"
   as portion of ob between where it was when selector appeared (selector_ob_charpos) and the &[. */

dcl  ep ptr, ebuf char (elen) based (ep), elen fixed bin (21);
dcl (s, t1, t2) fixed bin;
dcl  comx fixed bin;

		ep = substaddr (ob, selector_ob_charpos);
		elen = length (currob) - selector_ob_charpos + 1;

		if macro.entry (selector_eno).type = type_SELECT then
		     select_answer = collect_ob_num (1, elen);
		else do;
		     comx = index (ebuf, ",");
		     if comx = 0 then do;
			call experr ("No comma for conditional after expansion");
			select_answer = 0;
		     end;
		     else do;
			s = macro.entry (selector_eno).value_1; /* Type of comparison */
						/* Remember that EQ and NE are char, others num. */
			if s <= NE then do;		/* String compares, &=, &^= */
			     if substr (ebuf, 1, comx - 1) = substr (ebuf, comx + 1) then select_answer = 1;
			     else select_answer = 2;
			     if s = NE then select_answer = 3 - select_answer; /* NE inverts test */
			end;
			else do;			/* Numeric compares, EQ and NE dont get used. */
			     t1 = collect_ob_num (1, comx - 1);
			     t2 = collect_ob_num (comx + 1, elen);
			     if ((t1 = t2) & s = EQ) | ((t1 ^= t2) & s = NE) | ((t1 < t2) & s = LT)
			     | ((t1 <= t2) & s = LE) | ((t1 > t2) & s = GT) | ((t1 >= t2) & s = GE)
			     then select_answer = 1;	/* TRUE */
			     else select_answer = 2;	/* FALSE */
			end;
		     end;
		end;
		next = selector_ob_charpos;
		outstanding_select = "0"b;
		return;

get_ob_rangeargs:	entry (v1, v2);			/* collect m and n, as in &Rm,n into v1, v2 */

dcl (v1, v2) fixed bin;

		ep = substaddr (ob, range_ob_charpos);
		elen = length (currob) - range_ob_charpos + 1;
		comx = index (ebuf, ",");
		if comx = 0 then comx = elen + 1;
		v1 = collect_ob_num (1, comx - 1);
		v2 = collect_ob_num (comx + 1, elen);
		next = range_ob_charpos;
		outstanding_range = "0"b;
		return;

/*  */
collect_ob_num:	proc (fx, lx) returns (fixed bin);

/* This routine collects a decimal number at ebuf|fx until ebuf|lx, returning it. Note
   that cases of no digits, bad input, and large number of leading zeros are handled. */

dcl (i, fx, lx) fixed bin (21);
dcl  d fixed bin init (0), c char (1) aligned;

		     do i = fx to lx;
			c = substr (ebuf, i);
			if c < "0" | c > "9" then do;
			     call experr ("Bad numeric input to selector");
			     return (0);
			end;
			d = 10*d + fixed (unspec (c), 9) - 48;
		     end;
		     return (d);

		end collect_ob_num;

	     end pull_apart_select_input;

experr:	     proc options (variable, non_quick);	/* expansion error */

/* Called by all expansion-time errors with formline_ arguments.   Tries to figure out what
   _l_i_n_e of macro def contains the  error, as ALM lists the expanded lines way after we have
   the whole expansion out the door, and user needs some hint.  For this purpose
   only is macro.startchar maintained. */


dcl  apos fixed bin (21), alct fixed bin (18);
dcl  vs char (200) varying;
dcl  nlx fixed bin (21);
dcl  mdef char (macro.sourcelen + macro.startchar - 1) based (macro.sourcep);
dcl  zzzzz9 pic "zzzzz9";
dcl  errpos fixed bin (21);

		if ^found_d_error_lying_there		/* if this is news, .e., pass 1 */
		then eb_data_$erflgs_overlay.prntd = 1; /* then make an error */

		call ioa_$general_rs (cu_$arg_list_ptr (), 1, 2, cbuf1, cb1l, "0"b, "0"b);

		errpos = macro.entry (entry_no).first_char + macro.entry (entry_no).n_chars;
		apos = macro.startchar;
		nlx = index (substr (mdef, apos), NL);
		do alct = 1 by 1 while (^(nlx = 0 | apos + nlx > errpos));
		     nlx = index (substr (mdef, apos), NL);
		     apos = apos + nlx;
		end;

		zzzzz9 = alct;
		vs = cb1b || " in line " || ltrim (zzzzz9) || " of macro " || rtrim (macro.name) || ".";
		call prnter_$macro_error ("Macro expansion error: " || vs,
		     "**** **** **** MACRO EXPANSION ERROR: " || vs);
		return;

	     end experr;

	end expand_macro;
						/*  */
mexp_$reset_macro: entry;

/* ALM calls this when the ALM input scanner, inputs_, runs off the end of something that was
   given to him by push_mexp_output_upon_alm below. */


	envp = eb_data_$mexp_env_ptr;
	call pop_mexp_level;
	return;


push_mexp_output_upon_alm: procedure;

/* Redefine free space in segment containing ob not to include ob. Stack  the description
   of what free space will be when this is popped (which is what it is now). Tell ALM
   to push the string "ob" upon its input stack. ALM will call mexp_$reset_macro
   when he (the input scanner, inputs_) runs off the end of it. */


	     if bct.curlevel >= hbound (bct.outstack, 1) then
		call genabort ("Macro depth exceeds ^d.", bct.curlevel);
	     if length (currob) <= 0 then return;	/* Don't output empty buffers */
	     if substr (currob, length (currob), 1) ^= NL then call ouch (NL);
						/* Make sure lines dont spill, listing happens. */
	     call alm_include_file_$macro (addr (currob), length (currob));
	     bct.curlevel = bct.curlevel + 1;
	     bct.outstack (bct.curlevel).segx = bct.curexpseg;
	     bct.outstack (bct.curlevel).charx = bct.segarray_free (bct.curexpseg);
	     bct.segarray_free (bct.curexpseg) = bct.segarray_free (bct.curexpseg) + length (currob);
	     return;

	end push_mexp_output_upon_alm;

pop_mexp_level: procedure;

/* Return current expansion's space to free space in its segment. If this brings us
   to bottom of segment other than the first, go back a segment, for free space now starts
   there. */


	     if bct.curlevel = 0 then
		call genabort ("Macro stack underflow. Contact assembler maintainers.");

	     bct.curexpseg = bct.outstack (bct.curlevel).segx;
	     bct.segarray_free (bct.curexpseg) = bct.outstack (bct.curlevel).charx;
	     bct.curlevel = bct.curlevel - 1;
	     if bct.curexpseg > 2 & bct.segarray_free (bct.curexpseg) = 1
	     then bct.curexpseg = bct.curexpseg - 1;
	     return;

	end pop_mexp_level;


/*  */


/* This procedure, with all its entries, generates all text in the
   output buffer, ob. It takes responsibility for moving it when it
   must be grown. */

outptr:	proc (aoutp, aoutl);			/* Output aoutp->char(aoutl) to ob */

dcl (aoutp, outp) ptr;
dcl  outstring char (outl) based (outp);
dcl  save_obp ptr, save_obl fixed bin (21);
dcl (aoutl, outl) fixed bin (21);
dcl  str char (*);
dcl  num fixed bin (21);
dcl  zzzzzzz9 picture "zzzzzzz9";
dcl  cbuf char (8);

	     outl = aoutl;
	     outp = aoutp;
	     go to outpr_join;

ouch:	     entry (str);				/* Output value of "str" to ob */

	     outl = length (str);
	     outp = addr (str);
	     go to outpr_join;

outnum:	     entry (num);				/* Output canonical number to ob */

	     zzzzzzz9 = num;
	     outl = length (ltrim (zzzzzzz9));
	     cbuf = ltrim (zzzzzzz9);
	     outp = addr (cbuf);


outpr_join:
	     if length (outstring) = 0 then return;

	     if length (currob) + length (outstring) > length (ob) then do;
		save_obp = addr (currob);
		save_obl = length (currob);
		call make_new_outbuf$force;
		next = save_obl + 1;
		currob = save_obp -> currob;
	     end;

	     substr (ob, next, length (outstring)) = outstring;
	     next = next + length (outstring);

	     return;

	end outptr;

/* 
*/
substaddr: proc (chs, ix) returns (ptr);
dcl  chxa (length (chs)) char (1) unal based;		/* for char addressing */
dcl  chs char (*), ix fixed bin (21);
	     return (addr (addr (chs) -> chxa (ix)));
	end substaddr;

make_new_outbuf: proc;

/* This procedure  defines the based/adjustable output buffer "ob" as the remainder of the
   current output buffer segment. If $force is called, it is because a string that
   outptr/ouch/outnum wants to put in ob won't fit. So ob is redefined to the next
   buffer segment, and the old ob copied. The vbl "next" is the next available char pos
   in current ob. */


dcl  segx fixed bin;
dcl  force bit (1);

	     force = "0"b;
	     go to mnob_join;

make_new_outbuf$force: entry;

	     force = "1"b;
mnob_join:

	     segx = bct.curexpseg;
	     if force then segx, bct.curexpseg = segx + 1;
	     if bct.segarray (segx) = null then do;
		call get_temp_segments_ (gtsname, segarray_of_one, (0));
		bct.segarray (segx) = segarray_of_one (1);
	     end;
	     obp = substaddr (bct.segarray (segx) -> ob, bct.segarray_free (segx));
	     max_char_count = sys_info$max_seg_size * 4 - bct.segarray_free (segx) + 1;
	     next = 1;

	end make_new_outbuf;
						/*  */

scan_args: proc (array, no_args, firstx, count, acode);

/* This routine scans the "count" chars at il|firstx according to the rules of
   macro arguments. Processing of nested parens, line breaks and continuations, and
   commas is all done here. */


dcl 1 array (0: 99) aligned,
    2 first fixed bin (21),
    2 size fixed bin (21);

dcl  acode fixed bin (35);

dcl  c2 char (2) aligned;

dcl  no_args fixed bin,
    (firstx, count, arg_start, last) fixed bin (21);

	     array (*).size = 0;
	     acode = 0;
	     arg_start, ci = firstx;
	     last = ci + count - 1;
	     no_args = 0;
GET_ANOTHER_ARG:
	     c2 = substr (il, ci-1, 2);
	     if c2 = COMMA_NL | c2 = ", " | c2 = ",	" | c2 = ",""" | c2 = ",;" then do;
						/* Continue on next ALM statement. */
		if addr (array) ^= addr (exargs) then	/* At top level */
		     call skip_to_next_line;
		else do;
		     stop = stop - 1;
		     start = ci + 1;
		end;
		if stop > nchars then return;
		semict = semict + 1;		/* schedule almrunning */
		if stop > nchars then return;
		t = verify (substr (il, start, stop-start+1), WHITE)-1; /* skip white space */
		if t < 0 then ci = stop+1;
		else ci = start + t;
		arg_start = ci;			/* save start of variable field */
		call soc;				/* skip to end of variable field */
		if stop = ci-1 then last = ci-2;
		else last = ci-1;
		ci = arg_start;
		goto GET_ANOTHER_ARG;
	     end;

	     else if substr (il, ci, 1) = "(" then do;	/* watch out for args with parens */
		nparens = 1;			/* skip till no more parens at this level */
		do ci = ci+1 to last while (nparens > 0);
		     if substr (il, ci, 1) = "(" then nparens = nparens + 1;
		     else if substr (il, ci, 1) = ")" then nparens = nparens - 1;
		end;
		if nparens > 0 then do;
		     acode = 1;
		     return;
		end;

		no_args = no_args + 1;
		array.first (no_args) = arg_start+1;	/* copy information about where the arg is */
		array.size (no_args) = ci - arg_start - 2;
		goto NEXT_ARG;
	     end;

	     else do;				/* argument didn' start with paren */
		t = index (substr (il, ci, last-ci+1), ",")-1;
		if t < 0 then ci = last + 1;
		else ci = ci + t;

		no_args = no_args + 1;
		array.first (no_args) = arg_start;
		array.size (no_args) = ci - arg_start;
NEXT_ARG:		ci, arg_start = ci+1;
		if arg_start <= last+1 then goto GET_ANOTHER_ARG;
	     end;
	     return;


	end scan_args;
						/*  */


skip_to_next_line: proc;

/* This procedure sets "stop" to be the charindex of the last char of the
   (possibly multi-ALM-statement) macro or pseudoop invocation.  The
   only legal ALM-statement breaks are those in parens. The vbl "semict" is incremented
   to tell larger routines how many times to call inputs_$run/next_statement to
   skip ALM's input scanner (inputs_) over that many ALM statements. Note:
   If _w_e don't know that some semicolon-containing thing is actually an ACC string
   etc., ALM doesn't know _e_i_t_h_e_r, annd considers it a statement break, 'cause
   he's skipping statements, not semanticating them. */


	     start = stop+1;			/* get start of next line */
dcl  nparens fixed bin;

	     nparens = 0;
	     stop = start;
more:	     t = search (substr (il, stop), ENDS)-1;
	     if t < 0 then do;
		stop = nchars + 1;
		return;
	     end;
	     stop = stop + t;
	     if substr (il, stop, 1) = "(" then nparens = nparens + 1;
	     else if substr (il, stop, 1) = ")" then nparens = nparens - 1;
	     else if substr (il, stop, 1) = ";" & nparens > 0 then semict = semict + 1;
	     else if substr (il, stop, 1) = NL & nparens > 0 then semict = semict + 1;
						/* Ignore statement breaks inside parens */
	     else return;
	     stop = stop + 1;
	     go to more;

	end;

get_hashx: procedure (name);				/* Generate hash index */

dcl  name char (32) aligned;
dcl  fb35 fixed bin (35), (mod, abs) builtin;

	     unspec (fb35) = bool (substr (unspec (name), 1, 36), bool (substr (unspec (name), 37, 36),
		bool (substr (unspec (name), 73, 36), substr (unspec (name), 109, 36), "0110"b), "0110"b), "0110"b);

	     hashx = abs (mod (fb35, 127));
	     if ^substr (bct.hashx_used, hashx + 1, 1) then do;
		substr (bct.hashx_used, hashx + 1, 1) = "1"b;
		bct.macroptr (hashx) = null;
	     end;
	     return;

	end;
						/*  */
sob:	proc;

/* This procedure moves ci to first non-white character. */


	     t = verify (substr (il, ci, stop-ci+1), WHITE)-1;
	     ci = ci + t;
	     return;

	end;
soc:	proc;

/* This procedure moves ci over non-white characters to next whitespace. */


dcl  nparens fixed bin;

	     nparens = 0;
more:	     t = search (substr (il, ci, stop-ci+1), "()	 """)-1;
	     if t < 0 then do;
		ci = stop+1;
		return;
	     end;
	     ci = ci + t;
	     c = substr (il, ci, 1);
	     if c = "(" then nparens = nparens + 1;
	     else if c = ")" then nparens = nparens - 1;
	     else if nparens = 0 then return;
	     ci = ci + 1;
	     goto more;

	end;



get_ptrs:	proc;					/* Set mexp ptrs from ALM */

/* This procedure sets our variables from ALM's input scanner, inputs_. Inputs_
   usually scans up to and beyond a break. We set variables to first char he hasn't
   scanned. "alm_finished_the_line" is inputs_'s "ibrk = inl" state, in which
   he has scanned the last semi/nl on a statement, but inputs_$next_statement
   hasn't been called yet. */


dcl (offset, sourcelen) fixed bin (21);

	     call inputs_$get_ptr (tp, offset, sourcelen, alm_finished_the_line);

	     nchars = offset + sourcelen;
	     stop = offset;
	     ci, start = stop + 1;
	     return;
	end get_ptrs;

/*  */

genabort:	proc options (variable, non_quick);

	     call ioa_$general_rs (cu_$arg_list_ptr (), 1, 2, cbuf1, cb1l, "0"b, "0"b);
	     call prnter_$general_abort (cb1b);
	end genabort;
						/*  */
%include erflgs;
     end mexp_$ignore;
