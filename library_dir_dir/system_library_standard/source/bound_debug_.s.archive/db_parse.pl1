/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


db_parse: procedure (input_buffer_ptr, input_line_len, arg_auto_ptr, arg_stat_ptr);


/* Modified 10/ by S. Barr to recognize COBOL data types and the size field with the print request. */
/* Modified 771116 by PG to add el & fl output modes */
/* Changed "Version 1 symbol table" msg to say "this language not supported" 10/14/83 S. Herbst */

/*	Parameters	*/

dcl  input_buffer_ptr ptr,

     input_line_len fixed bin,

     arg_auto_ptr ptr,

     arg_stat_ptr ptr;


/*	Default  variables.  	*/

dcl (data_ptr ptr,
     offset fixed bin (18),
     stack_depth fixed bin,
     data_id char (1) aligned,			/* segment id corresponds to data_ptr (t, s, i, l) */
     input_type char (1) aligned,			/* type of input.  Used to decide what
						   *  default to use for db_assign.
						   *  v = variable
						   *  a = address
						   *  * = indirect
						   *  % = temporary
						   */
     data_format char (6) aligned) internal static;


dcl  continue bit (1) unal;
dcl  break_action_code fixed bin,
     break_data_len fixed bin,
     break_data_line char (236),
     break_return fixed bin,
     reg_val bit (72);

dcl  temp_reg_val fixed bin (71);

dcl  goto_label label;

dcl 1 label_map based aligned,
    2 pp ptr,
    2 sp ptr;

dcl  err_no_linkage fixed init (1);
dcl  err_no_stack fixed init (2);
dcl  err_no_sym_tab fixed init (3);
dcl  err_no_static fixed init (4);
dcl  err_mess (4) char (40) int static init (
     "no linkage section",				/* err_no_linkage */
     "no stack frame",				/* err_no_stack */
     "no symbol table",				/* err_no_sym_tab */
     "no internal static");				/* err_no_static */

dcl
     com_err_ ext entry options (variable),
     cu_$cp ext entry (ptr, fixed bin, fixed bin),
     cu_$gen_call ext entry (ptr, ptr),
     cv_oct_check_ ext entry (char (*), fixed bin) returns (fixed bin (35)),
     db_assign ext entry (char (132) aligned, fixed bin, fixed bin, ptr, ptr, ptr, fixed bin,
     fixed bin, fixed bin, fixed bin, bit (1)),
     db_break$global ext entry (fixed bin, fixed bin, char (236), fixed bin),
     db_break$print_bseg ext entry (fixed bin),
     db_break$print_default ext entry,
     db_break$set_break ext entry (ptr, fixed bin, ptr, fixed bin),
     db_break$set_default ext entry (ptr),
     db_break$set_skips ext entry (fixed bin, fixed bin),
     db_break$sub_global ext entry (fixed bin, fixed bin, char (236), fixed bin),
     db_break$single ext entry (fixed bin, fixed bin, fixed bin, char (236), fixed bin),
     db_parse_condition$set ext entry (char (132) aligned, fixed bin, fixed bin, fixed bin, char (236), fixed bin),
     db_get_count ext entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin),
     db_get_count$dec ext entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin),
     db_get_count$double entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin (71)),
     db_get_sym ext entry (ptr),
     db_print ext entry (ptr, char (*) aligned, ptr, char (*) aligned, fixed bin, fixed bin, ptr,
     fixed bin, fixed bin),
     db_regs$get ext entry (ptr, char (4) aligned, bit (72), fixed bin),
     db_regs$print ext entry (ptr, char (4) aligned, fixed bin),
     db_regs$assign ext entry (ptr, char (4) aligned, bit (72), fixed bin),
     db_fill_snt ext entry (ptr, ptr),
     db_fill_snt$proc_ptr entry (ptr, ptr),
     db_sym ext entry (char (72) var, ptr, ptr, fixed bin (18), fixed bin, char (1) aligned, char (*) aligned,
     fixed bin, fixed bin, fixed bin),
     decode_descriptor_ entry (ptr, fixed bin, fixed bin, bit (1) aligned,
     fixed bin, fixed bin, fixed bin),
     expand_path_ ext entry (ptr, fixed bin, ptr, ptr, fixed bin),
     hcs_$fs_get_path_name ext entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin),
     hcs_$fs_get_seg_ptr entry (char (*), ptr, fixed bin),
     hcs_$initiate entry (char (*) aligned, char (*) aligned, char (*), fixed bin (1), fixed bin (2),
     ptr, fixed bin),
     hcs_$make_ptr ext entry (ptr, char (*) aligned, char (*) aligned, ptr, fixed bin),
     ioa_$ioa_stream entry options (variable),
     ioa_$rsnnl ext entry options (variable),
     iox_$close ext entry (ptr, fixed bin (35)),
     iox_$detach_iocb ext entry (ptr, fixed bin (35)),
     iox_$attach_ioname ext entry (char (*), ptr, char (*), fixed bin (35)),
     iox_$find_iocb ext entry (char (*), ptr, fixed bin (35)),
     iox_$open ext entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
     list_arg_ ext entry (fixed bin, char (1) aligned, ptr),
     db_parse_arg ext entry (char (132) aligned, fixed bin, fixed bin, ptr, fixed bin, fixed bin),
     stu_$get_location ext entry (ptr, fixed bin, fixed bin (18));

dcl  is_condition_frame_ entry (ptr) returns (bit (1) aligned);

dcl  db_find_mc entry (ptr, bit (1) aligned, ptr);

dcl  find_condition_info_ entry (ptr, ptr, fixed bin);

dcl  stu_$get_runtime_location entry (ptr, fixed bin) returns (fixed bin (18));

dcl  db_parse_arg$ptr_offset entry (char (132) aligned, fixed bin, fixed bin, fixed bin,
     ptr, fixed bin, fixed bin);



dcl  error_table_$segknown ext fixed bin;


dcl  code35 fixed bin (35);
dcl  fboff fixed bin (9),
     code fixed bin,
     d_type fixed bin,
     itemp fixed bin,
    (max_stack, new_type, line_number) fixed bin,
    (pc, i, j) fixed bin,
     temp1 fixed bin (18),
    (ct, nv) fixed bin,
    (lin, ill) fixed bin,
    (size, scale, ndims) fixed bin,
     exec fixed bin;
dcl  offset_incr fixed bin;				/* increment to be added to offset and working pointer */

dcl  dol fixed bin;
dcl  max_size fixed bin;

dcl  based_bit72 bit (72) based;

dcl  based_fix fixed bin based aligned;


dcl  arglist (21) ptr,
     based_ptr ptr based (sp),
     ptr_array (1) based ptr,
    (pp, ilp, tp, tpp) ptr;




dcl  switch bit (1) aligned;


dcl  new_line char (1) aligned static init ("
"),

     il char (132) aligned,
     reg_name char (4) aligned,
     str char (exec) based aligned,
     str1 char (ill) based aligned,
     sym_name char (72) var,
    (c1, c2) char (1) aligned,
     dir_name char (168) aligned,
     pathname char (168),
    (ent_name, ref_name) char (32) aligned,
     cmc char (1) aligned;
dcl  char char (1) aligned;				/* character being used for parse */

dcl (attach,					/* 1 = switch_name attached */
     open) bit (1) unaligned;				/* 1 = switch_name opened */
dcl  dec_default bit (1);				/* 1 = use dec_default for temporaries (%) */
dcl  switch_name char (32);				/* switch_name for ".si" request */

dcl  entry_name char (32) aligned;


dcl  desc_area (11) bit (36) internal static
     init ((11) (1) "100000100000000000000000000000000001"b);

dcl  desc_ptr ptr init (addr (desc_area));

dcl 1 desc (11) aligned based (desc_ptr),
   (2 flag bit (1),
    2 type bit (6),
    2 packed bit (1),
    2 n_dims bit (4),
    2 size fixed bin (23)) unaligned;

dcl  dummy_desc bit (36) aligned static init
    ("101010100000000000000000000000100000"b);		/* char(32) */

dcl  return_desc bit (36) aligned static init
    ("100000100000000000000000000000000001"b);		/* fixed bin, 1 word */



dcl (addr, addrel, baseno, baseptr, bit, max, null, ptr, rel, substr, index, search, verify) builtin;
dcl (binary, divide, hbound, length, min, reverse) builtin;


dcl 1 ff aligned based,
    2 (w0, w1) fixed bin;


dcl 1 bi aligned based,
    2 ts (132) fixed bin (8) unaligned;			/* character codes used as subscripts to type array */


dcl 1 lot (0: 1023) aligned based,
    2 segno bit (18) unaligned,
    2 offset bit (18) unaligned;

/* constants */

dcl  NUMBER char (11) int static init ("0123456789&");
dcl  MODES (21) char (6) var int static init (
     "a",
     "b",
     "p",
     "P",
     "i",
     "I",
     "l",
     "s",
     "o",
     "h",
     "d",
     "el",
     "fl",
     "f",
     "e",
     "g",
     "x",
     "comp-5",
     "comp-6",
     "comp-7",
     "comp-8");

dcl 1 cond_info aligned,
%include cond_info;
%include db_ext_stat_;
%include iocb;
/*  */
%include db_common_auto;
/*  */
%include db_common_static;
/*  */
%include db_snt;
/*  */
%include db_arg_list;
/*  */
%include its;
/*  */
%include stack_header;
%include stack_frame;
/*
   
   use of big label arrays

   label_1		label_2		label_3

   0		syntax_error	syntax_error	syntax_error
   1 (:)		colon0		colon		colon
   2 (%)		per_cent		syntax_error	syntax_error
   3 (/)		namel		syntax_error	syntax_error
   4 ($)		reg		relative_offset	syntax_error
   5 (n)		offset1		relative_offset	syntax_error
   6 (+ -)	relative_offset	relative_offset	syntax_error
   7 (,)		set_mode		set_mode		set_mode
   8 (=)		assign		assign		assign
   9 (<)		set		set		set
   10 (>)		go		go		go
   11 ( )		----		----		----
   12 (;)		rskip		print		print
   13 (&)		amper		amper		syntax_error
   l4 (letter)	offsetl		offsetl		syntax_error
   15 (nl)	print		print		print
   16 (*)		star		star		syntax_error
   17 (.)		com		syntax_error	syntax_error
   */
/*  */
/*	Initialize data needed to parse the command line.	  */


     com_auto_ptr = arg_auto_ptr;

	com_stat_ptr = arg_stat_ptr;


	lin = 1;
	ill = input_line_len;
	ilp = addr (il);
	ilp -> str1 = input_buffer_ptr -> str1;

	if first_call_flag = 0

	then do;
	     data_ptr = stack_ptr_array (max_sp_x);
	     offset = 0;
	     stack_depth = max_sp_x;
	     data_id = "s";
	     data_format = "h";
	     input_type = "";
	     first_call_flag = 1;
	end;

	sntp = snt_ptr;
	max_stack = max_sp_x;
	sb = ptr (stack_ptr_array (max_stack), 0);


depth_1:

	if get_char (lin, lin, char) then do;
	     d_type = 0;
	     pc = 1;				/* default is print one item */
	     go to label_1 (type (ilp -> bi.ts (lin)));
	end;
	else goto print;

/* come here (depth 2) when the procedure name has been established
   and associated defaults set up */

depth_2:
	if get_char (lin, lin, char) then do;		/* PL1 bug 1497 */
	     goto label_2 (type (ilp -> bi.ts (lin)));
	end;
	else goto print;

/* come here after the following have been set up
   data_ptr
   offset
   output mode

   must either print out a value (or values), set a break, restart execution,
   or assign a value (or values) */

depth_4:
	if get_char (lin, lin, char) then do;		/* PL1 bug 1497 */
	     goto label_3 (type (ilp -> bi.ts (lin)));
	end;
	else goto print;
						/*  */
						/* come here if we are at start of a symbolic name */

label_1 (14):
label_2 (14):
offsetl:
	nv = 0;					/* initialize depth count */
	do i = lin to ill;				/* scan over variable name */
	     cmc = substr (il, i, 1);			/* pick up current character */
	     j = type (ilp -> bi.ts (i));		/* get type of current character */
	     if j = 4 | j = 5 | j = 14 | j = 11 | cmc = "." then go to endl;
	     if cmc = "(" then nv = nv + 1;
	     else if cmc = ")" then do;
		if nv > 0 then nv = nv - 1;
	     end;
	     else if cmc = "-" then do;
		if substr (il, i+1, 1) = ">" then i = i+1; /* scan over arrow */
		else if nv = 0 then go to donel;	/* done if not in parens */
	     end;
	     else if nv = 0 then go to donel;
endl:	end;
donel:
	sym_name = substr (il, lin, i-lin);
	lin = i;
	new_type = 0;
	call db_sym (sym_name, sntp, data_ptr, offset, d_type, data_id, data_format, pc, max_size, code);
	if data_format ^= "a" & data_format ^= "b" then pc = 1;
	if code = 0 then do;			/* continue if no error */
	     input_type = "v";
	     goto relative_offset;
	end;
	if code > 100 then do;
	     i = code - 100;			/* a parameter */
	     cmc = "?";
	     go to list_arg;
	end;
	call sym_err;				/* print message and goto rskip */

/*  */
/* come here when a colon is encountered in the scan */

label_1 (1):
	ct = 0;					/* no return value */
	go to colon_join;
label_2 (1):
label_3 (1):
	ct = 1;					/* return value requested */
colon_join:
	if substr (il, lin+1, 1) ^= "=" then go to syntax_error; /* check for following = */
	if ^get_char (lin + 2, lin, "") then goto syntax_error;
	do i = lin to ill while (is_name (ilp -> bi.ts (i))); /* skip to end of procedure name */
	end;
	ent_name = substr (il, lin, i-lin);		/* pick up segment procedure name */
	if substr (il, i, 1) = "$" then do;		/* secondary entry point given */
	     do lin = i+1 to ill while (is_name (ilp -> bi.ts (lin))); /* skip to end of entry name */
	     end;
	     ref_name = substr (il, i+1, lin-1-i);	/* copy entry point name */
	     end; else do;				/* if no entry point name, use same */
	     ref_name = ent_name;
	     lin = i;
	end;
	call hcs_$make_ptr (null, ent_name, ref_name, tp, code); /* get pointer to the entry */
	if code ^= 0 | tp = null then do;
	     call ioa_$rsnnl ("^a$^a", ent_name, i, ent_name, ref_name);
	     call com_err_ (code, "debug", ent_name);
	     go to rskip;
	end;

	if ^get_char (lin, lin, "") then goto make_call;
	i = 0;
	if substr (il, lin, 1) ^= "(" then go to make_call; /* check for no args */
	lin = lin + 1;
argl:	i = i + 1;				/* go to next arg */
	if ct + i > 11 then do;			/* watch for too many args */
	     call ioa_$ioa_stream (debug_output, "Too many arguments.");
	     go to rskip;
	end;

	call db_parse_arg (il, lin, ill, addr (dummy_arg (i)), j, exec); /* pick up the next arg */
	if substr (il, lin, 1) = "," then lin = lin + 1;	/* skip over "," */
	arglist (i+1) = addr (dummy_arg (i));		/* set up default arglist pointer */
	if j = 0 then do;				/* a variable as the argument */
	     sym_name = addr (dummy_arg (i)) -> str;	/* get returned symbol name */
	     call db_sym (sym_name, sntp, pp, temp1, j, c1, c2, pc, max_size, code);
	     if code = 0 then do;			/* no error, variable */
		arglist (i+1) = pp ;		/* stuff pointer to var in arglist */
		exec = pc;
		go to make_desc;
	     end;
	     if code > 100 then arglist (i+1) = snt.sp -> stack_frame.arg_ptr -> ptr_array (code - 99);
	     else call sym_err;
	end;
	if j > 0 then do;
make_desc:     desc (i).type = bit (binary (j, 6), 6);
	     desc (i).size = binary (exec, 23);
	     arglist (i + 11) = addr (desc (i));
	end;
	else if j = -1 then do;			/* no arg, all done */
	     do j = 1 to i-1;			/* loop through all arguments */
		arglist (j+i+ct) = arglist (11+j);	/* move descriptor pointers down */
	     end;
make_call:     addr (arglist) -> arg_list.num_args = binary (i+ct-1, 17);
	     addr (arglist) -> arg_list.num_desc = binary (i+ct-1, 17);
	     if ct ^= 0 then do;
		arglist (i + 1) = data_ptr;
		arglist (2*i + 1) = addr (return_desc);
	     end;
	     addr (arglist) -> arg_list.code = (16) "0"b || "100"b;
	     addr (arglist) -> arg_list.fill = "0"b;

	     in_debug = "0"b;			/* pass all conditions on */
	     call cu_$gen_call (tp, addr (arglist));	/* call the specified procedure */
	     in_debug = "1"b;			/* turn handler on */
	     go to skip;
	end;
	else if j = -2 then do;			/* syntax error */
	     call ioa_$ioa_stream (debug_output, "Syntax error in argument ^d.", i);
	     go to rskip;
	end;
	else if j = -3 then arglist (i+11) = addr (dummy_desc); /* "%" in arg position */
	else call ioa_$ioa_stream (debug_output, "??");
	go to argl;

/*  */
/* come here to print out dummy args */

label_1 (2):
	input_type = "%";
	nv = db_get_count$dec (il, lin+1, lin);		/* get correct dummy arg */
	if nv < 1 | nv > 10 then go to syntax_error;	/* make sure it's valid */
	data_ptr = addr (dummy_arg (nv));		/* set data ptr to point to the dummy arg */
	data_format = "h";				/* set print default to octal */
	go to star1;				/* merge with indirect code */


/*  */
/* come here if we are at start of a stack procedure name */

label_1 (3):
namel:
	do i = lin+1 to ill while (substr (il, i, 1) ^= "/");
	end;
	if i = ill+1 then go to syntax_error;
	nv = cv_oct_check_ (substr (il, lin+1, i-lin-1), code);
	if code = 0 then do;
	     if nv < hcs_count then do;		/* check for hardcore segment number */
		call ioa_$ioa_stream (debug_output, "Hardcore segment number.");
		go to rskip;
	     end;
	     pp = baseptr (nv);
	     call hcs_$fs_get_path_name (pp, dir_name, itemp, ent_name, code);
	     if code ^= 0 then do;			/* signaller if trouble */
		ent_name = "signaller";
		dir_name = "signaller_directory";
	     end;
	     pathname, entry_name = ent_name;		/* if given number use primary name */
	end;
	else do;
	     pathname = substr (il, lin+1, i-lin-1);

/* find out if it's of form seg$entry */

	     dol = index (pathname, "$");
	     if dol > 0 then do;			/* it is */
		entry_name = substr (pathname, dol + 1);
		pathname = substr (pathname, 1, dol - 1);
	     end;
	     else entry_name = pathname;

	     j = index (reverse (entry_name), ">");
	     if j > 0 then entry_name = substr (entry_name, 32 -j);

	     if substr (pathname, 1, 2) = "&n" then do;
		pathname = substr (pathname, 3);
		lin = lin + 2;
	     end;
	     call expand_path_ (addr (pathname), i-lin-1, addr (dir_name), addr (ent_name), code);
	     if code ^= 0 then do;
com1:		call com_err_ (code, "debug", pathname);
		go to rskip;
	     end;
	     call hcs_$fs_get_seg_ptr (pathname, pp, code); /* is segment already known ? */
	     if pp ^= null then do;			/* yes, get real names for the segment */
		call hcs_$fs_get_path_name (pp, dir_name, itemp, ent_name, code);
		go to check1;
	     end;
	     call hcs_$initiate (dir_name, ent_name, "", 0, 0, pp, code); /* no, initiate it */
	     if code ^= 0 then if code ^= error_table_$segknown then go to com1;
	end;
check1:
	lin = i+1;
	do i = max_stack to 0 by -1;			/* search the stack for the procedure pointer */
	     sp = stack_ptr_array (i);		/* get current stack pointer */
	     call db_fill_snt$proc_ptr (sp, tpp);
	     if tpp ^= null ()
	     then if baseno (pp) = baseno (tpp) then do;	/* we've found a good segment */
		     stack_depth = i;		/* set index into stack */
		     call db_fill_snt (sp, sntp);	/* Get data about working segment. */
		     if snt.ent_pt_name = entry_name then do; /* make sure it's really right frame */
			data_ptr = sp;		/* set defaults */
			data_id = "s";
found3:			offset = 0;
			data_format = "h";

			input_type = "a";
			go to depth_2;
		     end;
		end;
	end;

	snt.symp = null;
	snt.symflag = "1"b;				/* set flag saying we haven't got symp yet */
	snt.pp = pp;
	snt.sp = null;
	snt.lp = ptr (baseptr (stack_header.lot_ptr -> lot (binary (baseno (pp))).segno), stack_header.lot_ptr -> lot (binary (baseno (pp))).offset);
	snt.ent_name = ent_name;
	snt.dir_name = dir_name;
	snt.ent_pt_name = entry_name;			/* use reference name for symbol table */
	data_ptr = pp;
	stack_depth = -1;				/* stack depth is undefined */
	data_id = "t";
	go to found3;
						/*  */

/* come here when a star is encountered */

label_1 (16):
label_2 (16):
	lin = lin+1;
	if data_ptr -> its.its_mod ^= "100011"b then do;
	     call ioa_$ioa_stream (debug_output, "Cannot indirect through ^w ^w.", data_ptr -> ff.w0, data_ptr -> ff.w1);
	     go to rskip;
	end;
	data_ptr = data_ptr -> based_ptr;		/* indirect once through ptr */
	input_type = "*";
star1:	offset = binary (rel (data_ptr), 17);		/* set up offset variable */
	snt.symp = null;				/* fill in snt structure */
	snt.symflag = "1"b;
	snt.pp = ptr (data_ptr, 0);
	snt.sp = null;
	snt.lp = ptr (baseptr (stack_header.lot_ptr -> lot (binary (baseno (data_ptr))).segno), stack_header.lot_ptr -> lot (binary (baseno (data_ptr))).offset);
	call hcs_$fs_get_path_name (data_ptr, snt.dir_name, itemp, snt.ent_name, code);
	snt.ent_pt_name = snt.ent_name;
	stack_depth = -1;
	data_id = "t";
	go to relative_offset;

/* come here if a syntax error is encountered while scanning the command line */

label_1 (0): label_2 (0): label_3 (0): go to syntax_error;
label_2 (2): label_3 (2): go to syntax_error;
label_2 (3): label_3 (3): go to syntax_error;
label_3 (16):
label_2 (17): label_3 (17):
label_3 (4):
label_3 (14):
label_3 (5): label_3 (6):
label_3 (13):
syntax_error: call ioa_$ioa_stream (debug_output, "Syntax error");


label_1 (12):
rskip:
	db_action_code = 1;
	return;

skip:	i = index (substr (il, lin, ill-lin+1), ";");
	if i > 0 then do;
	     lin = lin + i;
	     if lin < ill then go to depth_1;
	end;
	lin = ill;
	return;


/*  */
/*  come here on "."   */


label_1 (17):
	if lin + 1 >= ill then go to no_comm;
	cmc = substr (il, lin+1, 1);
	if verify (cmc, "0123456789") = 0 then do;	/* no command name, set stack frame */
	     stack_depth = db_get_count$dec (il, lin+1, lin); /* pick up desired stack depth */
	     i = stack_depth;			/* in case error, set frame to 0 */
	     go to set_stack;
	end;
	nv = type (ilp -> bi.ts (lin+2));		/* get type of character after command */
	if cmc = "t" then call stack_trace;
	else if cmc = "+" | cmc = "-" then do;		/* pop or push stack */
	     i = db_get_count$dec (il, lin+1, lin);
	     stack_depth = stack_depth + i;
set_stack:     if stack_depth < 0 | stack_depth > max_stack then do;
		call ioa_$ioa_stream (debug_output, "^d not in stack range.", stack_depth);
		stack_depth = stack_depth - i;
		go to rskip;
	     end;
	     call db_fill_snt (stack_ptr_array (stack_depth), sntp); /* get data for this new frame */
	     if snt.pp = null () then call ioa_$ioa_stream (debug_output, "Cannot get text section for stack frame.");
	     data_ptr = snt.sp;
	     data_id = "s";
	     data_format = "h";
	     offset = 0;
	end;
	else if cmc = "|" | cmc = "." then do;
	     substr (il, 1, lin+1) = " ";

	     in_debug = "0"b;			/* pass all conditions on */
	     call cu_$cp (ilp, ill, i);
	     in_debug = "1"b;
	     return;
	end;
	else if cmc = "d" then do;
	     fboff = binary (addr (data_ptr) -> its.bit_offset, 9);
	     call ioa_$ioa_stream (debug_output, "^d  /^a/^o(^d)&^a,^a  ^o", stack_depth, snt.ent_name, offset, fboff, data_id, data_format,
		binary (baseno (snt.pp), 18));
	end;
	else if cmc = "D" then do;
	     fboff = binary (addr (data_ptr) -> its.bit_offset, 9);
	     call ioa_$ioa_stream (debug_output, "^d  /^a>^a/^o(^d)&^a,^a  ^o", stack_depth, snt.dir_name, snt.ent_name, offset, fboff,
		data_id, data_format, binary (baseno (snt.pp), 18));
	end;
	else if cmc = "m" then do;			/* output mode */
	     if substr (il, lin+2, 1) = "b" then print_mode = 0;
	     else if substr (il, lin+2, 1) = "l" then print_mode = 1;
	     else go to syntax_error;
	end;

	else if cmc = "c" then do;
	     cmc = substr (il, lin+2, 1);		/* get next character */
	     if cmc = "t" then do;			/* into temporary break mode */
		lin = lin + 1;
		temp_break_mode = 1;
	     end;
	     else if cmc = "r" then do;		/* regular break mode */
		lin = lin + 1;
		temp_break_mode = 0;
	     end;
	     if substr (il, lin+2, 1) = "," then num_skips = db_get_count$dec (il, lin+3, lin) + 1;
	     else num_skips = 1;			/* num_skips is times to skip the break */

	     db_action_code = 3;
	     return;
	end;
	else if cmc = "q" then do;
	     db_action_code = 2;
	     return;
	end;
	else if cmc = "b" then do;			/* some type of break command */
	     i = lin + 2;
	     cmc = substr (il, i, 1);			/* get the particular break command name */
	     if cmc = "g" then do;			/* global break request */
		cmc = substr (il, i+1, 1);		/* get the command char */
		if cmc = "t" then do;		/* .bge  set up global exec line */
		     i = i + 2;			/* get index of first character of exec line */
		     temp_comd_len = ill-i+1;
		     if temp_comd_len = 1 then temp_comd_len = 0;
		     else temp_comd_line = substr (il, i, temp_comd_len); /* copy string to execute into static */
		     return;			/* read next request line */
		end;
		lin = i + 2;			/* point past request type */
		call get_break_action_code;
		if break_action_code = 0
		then goto skip;
		else call db_break$global (break_action_code, break_data_len, break_data_line, print_mode);
		if break_return = 1 then lin = ill;
		goto skip;
	     end;
	     if cmc = "d" then do;			/* change default break segment */
		if ^get_char (i+1, lin, char) then do;
		     call db_break$print_default;
		     go to skip;
		end;
		pathname = substr (il, lin, ill-lin);	/* get name of segment */
		nv = cv_oct_check_ (pathname, code);	/* see if number was given */
		if code = 0 then do;
		     tp = baseptr (nv);		/* get pointer to break seg */
		end;
		else do;
		     if substr (pathname, 1, 2) = "&n" then do;
			pathname = substr (pathname, 3);
			lin = lin + 2;
		     end;

		     call expand_path_ (addr (pathname), ill-lin, addr (dir_name), addr (ent_name), code);
		     call hcs_$fs_get_seg_ptr (pathname, tp, code);
		     if tp ^= null then go to got_seg;	/* if refence name is known */
		     call hcs_$initiate (dir_name, ent_name, "", 0, 0, tp, code);
		     if tp = null then go to com1;
		end;
got_seg:		call db_break$set_default (tp);	/* set up default seg */
		return;
	     end;
	     if cmc = "p" then do;			/* print break segs */
		call db_break$print_bseg (print_mode);
		go to skip;
	     end;
	     if ^get_char (i + 1, i, "") then do;
		lin = i;
		call get_break_action_code;
		if break_action_code > 0 then do;
		     call db_break$sub_global (break_action_code, break_data_len, break_data_line, print_mode);
		     if break_return > 0 then lin = ill;
		end;

		goto skip;
	     end;
	     nv = db_get_count$dec (il, i, lin);	/* Get break number. */
	     if nv <= 0 then do;			/* and make sure it's okay */
		call ioa_$ioa_stream (debug_output, "Invalid break number.");
		go to rskip;
	     end;

	     if cmc = "s" then do;
		i = db_get_count$dec (il, lin+1, lin);
		call db_break$set_skips (nv, i);
		go to skip;
	     end;
	     call get_break_action_code;
	     if break_action_code = 0
	     then goto skip;
	     else call db_break$single (nv, break_action_code, break_data_len, break_data_line, print_mode);
	     if break_return = 1 then lin = ill;
	     goto skip;
	end;
						/*  */
	else if cmc = "a" then do;
	     if snt.sp = null then do;		/* must have stack frame for arglist print out */
nost:		call ioa_$ioa_stream (debug_output, "No argument list available.");
		go to rskip;
	     end;
	     if snt.sp -> stack_frame.prev_sp -> stack_frame_flags.signaller then go to nost;
	     if snt.sp -> stack_frame.arg_ptr = null () then go to nost;
	     if nv = 7 then do;			/* if comma, use mode specified and do all args */
		cmc = substr (il, lin+3, 1);
		i = -1;
	     end;
	     else if nv = 5 | nv = 13 then do;
		i = db_get_count$dec (il, lin+2, lin);
		if substr (il, lin, 1) = "," then cmc = substr (il, lin+1, 1);
		else cmc = "?";
	     end;
	     else if nv = 12 | nv = 15 then do;
		i = -1;
		cmc = "?";
	     end;
list_arg:	     call list_arg_ (i, cmc, snt.sp -> stack_frame.arg_ptr);
	end;
	else if cmc = "f"				/* get pointer to fault conditions */
	then call db_find_mc (snt.sp, "0"b, db_mc_ptr);

	else if cmc = "C"				/* get pointer to crawlout conditions */
	then call db_find_mc (snt.sp, "1"b, db_mc_ptr);


	else if cmc = "s" then do;
	     attach, open = "0"b;
	     if substr (il, lin+2, 1) = "i" then j = 1;
	     else if substr (il, lin+2, 1) = "o" then j = 2;
	     else go to skip;
	     lin = lin + 3;
	     i = verify (substr (il, lin, ill-lin+1), " ");
	     if i > 1 then do;
		lin = lin + i - 1;

		i = search (substr (il, lin, ill-lin+1), " ;
");
		if i = 0 then i = ill;
		else i = lin + i -2;
		switch_name = substr (il, lin, i-lin+1);
		call check_switch;
		call iox_$find_iocb (switch_name, pp, code35);
		if code35 ^= 0 then goto switch_err;
		if pp -> iocb.attach_descrip_ptr = null then do;
		     call ioa_$ioa_stream (debug_output, "^a switch not attached", switch_name);
		     goto skip;
		end;
		if pp -> iocb.open_descrip_ptr = null then do;
		     call ioa_$ioa_stream (debug_output, "^a switch not open", switch_name);
		     goto skip;
		end;
	     end;
	     else do;
		if j = 1 then switch_name = "debug_input";
		else switch_name = "debug_output";
		call check_switch;			/* Is this the same switch? */
		call iox_$find_iocb (switch_name, pp, code35);
		if code35 ^= 0 then go to switch_err;
		if pp -> iocb.attach_descrip_ptr = null then do;
		     call iox_$attach_ioname (switch_name, pp, "syn_ user_i/o", code35);
		     if code35 ^= 0 then go to switch_err;
		     attach = "1"b;
		end;

		if pp -> iocb.open_descrip_ptr = null then do;
		     call iox_$open (pp, j, "0"b, code35);
		     if code35 ^= 0 then go to switch_err;
		     open = "1"b;
		end;
	     end;

	     if debug_io_open (j) then call iox_$close (debug_io_ptr (j), code35);
	     if debug_io_attach (j) then call iox_$detach_iocb (debug_io_ptr (j), code35);
	     debug_io_ptr (j) = pp;
	     debug_io_attach (j) = attach;
	     debug_io_open (j) = open;
	     if j = 1 then debug_input = switch_name;
	     else debug_output = switch_name;

	     go to skip;

switch_err:    call com_err_ (code35, "debug");
	     go to skip;
	end;

	else
no_comm:	call ioa_$ioa_stream (debug_output, "db");

	go to skip;

/*  */
/* come here if we are looking at a register command */

label_1 (4):
	do i = lin+1 to lin+4 while (is_name (ilp -> bi.ts (i)));
	end;
	reg_name = substr (il, lin+1, i-lin-1);
	do i = lin+1 to ill while (substr (il, i, 1) ^= ";" & substr (il, i, 1) ^= "=");
	end;
	if i >= ill | substr (il, i, 1) ^= "=" then do;
	     if ill = lin + 1 then if substr (il, ill, 1) = new_line then goto syntax_error; /* avoid "$(nl)" */
	     call db_regs$print (db_mc_ptr, reg_name, print_mode);
	     go to skip;
	end;
	if ^get_char (i + 1, i, "") then goto syntax_error;
	temp_reg_val = db_get_count$double (il, i, lin);	/* is an assignment */
	if i = lin then goto syntax_error;
	if substr (il, lin, 1) = "|" then do;		/* pointer value, parse it */
	     call db_parse_arg$ptr_offset (il, lin, ill, binary (temp_reg_val, 17),
		addr (temp_reg_val), d_type, nv);
	     if d_type ^= 13 then go to syntax_error;
	end;

	reg_val = addr (temp_reg_val) -> based_bit72;
	call db_regs$assign (db_mc_ptr, reg_name, reg_val, print_mode); /* assign a value to the register */
	go to skip;

/*  */
/* . handlers */

label_1 (13): label_2 (13):
	cmc = substr (il, lin+1, 1);
	if lin >= ill then go to syntax_error;
	if cmc = "d" | cmc = "o" then go to offset1;
	if cmc = "n" then do;			/* next char escaped */
	     lin = lin+2;
	     go to offsetl;
	end;
	if cmc ^= data_id then new_type = 1; else new_type = 0;
	goto relative_offset;


/*  */
/* come here to set a break point */

label_1 (9): label_2 (9): label_3 (9):
	if data_id = "s" then tp = ptr (snt.pp, binary (rel (data_ptr))-binary (rel (snt.sp)));
	else tp = data_ptr;				/* force pointer to text if in stack */
	call db_break$set_break (tp, 0, sntp, print_mode); /* set the break */
	go to skip;

/*  */
/* come here when restarting a program */

label_1 (10): label_2 (10): label_3 (10):
	if stack_depth > max_stack | stack_depth < 0 then call ioa_$ioa_stream (debug_output, "No stack frame for given segment.");
	else do;
	     addr (goto_label) -> label_map.pp = data_ptr;
	     addr (goto_label) -> label_map.sp = snt.sp;
	     goto goto_label;
	end;
	go to rskip;


/* come here if scanning a number in a type 1 command */

label_1 (5):
	input_type = "a";				/* user typed an offset */
offset1:	offset = 0;
	goto relative_offset;

/*  */
/* come here when 'offset' has been established.  Search for an optional relative offset */

label_2 (4): label_2 (5):
label_1 (6): label_2 (6):
relative_offset:

	code = 0;
	continue = "1"b;
	do while (code = 0 & continue);
	     if ^get_char (lin, lin, char) then continue = "0"b;
	     else do;

		if char = "&" then do;
		     char = substr (il, lin+1, 1);
		     if char = "d" | char = "o" then do;
			offset = offset + db_get_count (il, lin, lin);
			call set_data_ptr (data_id);
		     end;
		     else do;
			if char ^= data_id then new_type = 1;
			else new_type = 0;
			if new_type = 1 then data_format = "h";
			if char = "p" then call parse_parameter (lin, code);
			else if char = "a" then call parse_source (lin, code);
			else if char = "n" then do;
			     lin = lin +2;
			     if lin >= ill then goto syntax_error;
			     goto namel;
			end;
			else do;
			     call set_data_ptr (char);
			     if code = 0 then data_id = char;
			     lin = lin +2;
			end;
		     end;
		end;

		else do;
		     if char = "+" then offset_incr = db_get_count (il, lin + 1, lin);
		     else if char = "-" then offset_incr = - db_get_count (il, lin + 1, lin);
		     else if verify (char, NUMBER) = 0 then offset_incr = db_get_count (il, lin, lin);

		     else if char = "$" then do;
			do i = lin+1 to lin+4 while (is_name (ilp -> bi.ts (i)));
			end;
			reg_name = substr (il, lin+1, i-lin-1);
			lin = i;
			call db_regs$get (db_mc_ptr, reg_name, reg_val, print_mode);
			offset_incr = binary (reg_val);
		     end;

		     else continue = "0"b;		/* must not be a relative offset */
		     if continue then do;
			offset = offset + offset_incr;
			call set_data_ptr (data_id);
		     end;
		end;
	     end;
	end;

	if code ^= 0 then do;
	     if code > 0 then call ioa_$ioa_stream (debug_output, "^a for ^a", err_mess (code), snt.ent_name);
	     goto rskip;
	end;

	go to depth_4;


/* come here if changing output mode :	, [print mode] [amount to print] */

label_1 (7): label_2 (7): label_3 (7):

	call parse_print;
	goto print;

label_2 (12): label_3 (12):
label_1 (15): label_2 (15): label_3 (15):
print:
	if data_format = "n" then go to skip;
	pp = data_ptr;
	if data_id = "s" then nv = binary (rel (pp)) - binary (rel (snt.sp));
	else if data_id = "l" then nv = binary (rel (pp)) - binary (rel (snt.lp));
	else if data_id = "i" then nv = binary (rel (pp)) - binary (rel (snt.static_ptr));
	else nv = binary (rel (pp));

	call db_print (debug_io_ptr (2), debug_output, pp, data_format, nv, pc, sntp, d_type, max_size);
	go to skip;

/* come here when an equal sign is encountered */

label_1 (8): label_2 (8): label_3 (8):
	lin = lin + 1;
	pp = data_ptr;

/*	If the assignment is not to a program variable the default is octal.
   */
	if input_type = "v" then dec_default = "1"b;
	else dec_default = "0"b;
	call db_assign (il, lin, ill, pp, sntp, db_mc_ptr, d_type, pc, max_size, print_mode, dec_default);
	go to skip;


/*  INTERNAL PROCEDURES */
is_name:	proc (b9) returns (bit (1) aligned);

dcl  b9 fixed bin (8) unal, t fixed bin;

	     t = type (b9);
	     if t ^= 14 then if t ^= 5 then return ("0"b);
	     return ("1"b);

	end;
						/*  */
get_break_action_code: proc;

	     break_data_len,
		break_action_code,
		break_return = 0;
	     break_data_line = " ";


	     if cmc = "l" then break_action_code = 1;

	     else if cmc = "r" then break_action_code = 2;

	     else if cmc = "o" then break_action_code = 3;

	     else if cmc = "n" then break_action_code = 4;

	     else if cmc = "e"
	     then do;
		break_action_code = 5;
		break_data_len = ill-lin+1;
		if break_data_len = 1 then break_data_len = 0;
		else break_data_line = substr (il, lin, break_data_len);
		break_return = 1;
	     end;

	     else if cmc = "c"
	     then do;
		break_action_code = 6;
		call db_parse_condition$set (il, lin, ill, break_data_len, break_data_line, code);
		if code = 100 then goto syntax_error;
		if code ^= 0 then call ioa_$ioa_stream (debug_output, "Symbol error in conditional break.");
	     end;

	     else call ioa_$ioa_stream (debug_output, "Unknown break request");
	end get_break_action_code;

type:	proc (n) returns (fixed bin);

dcl  n fixed bin (8) unal;
dcl  table (0: 127) fixed bin static init
    ((10)0, 15, (21)0, 11, 0, 14, 0, 4, 2, 13, (3)0, 16, 6, 7, 6, 17, 3, (10)5, 1,
     12, 9, 8, 10, (2)0, (26)14, (4)0, 14, 0, (26)14, 0, 17, (3)0);

/* The table array has the following meaning:
   0 = illegal
   1 = :
   2 = %
   3 = /
   4 = $
   5 = number
   6 = + or -
   7 = ,
   8 = =
   9 = <
   10 = >
   11 = blank
   12 = ;
   13 = &
   14 = letter
   15 = new-line
   16 = *
   17 = | or . */

	     if n > -1 then if n < 128 then return (table (n)); /* legal ascii value */
	     call ioa_$ioa_stream (debug_output, "invalid character ""^a""", substr (il, n, 1));
	     go to rskip;				/* error return */

	end type;


check_switch: proc;

/* 	This procedure compares the old switch name and the new switch name.  If they are the same
   *	a message is printed and the procedure exits to skip which looks for the next request.
   */
		if j = 1 then if switch_name ^= debug_input then return; else;
	     else if switch_name ^= debug_output then return;
	     call ioa_$ioa_stream (debug_output, "Switch already set to ^a", switch_name);
	     goto skip;

	end check_switch;

/*  This procedure prints the error message for db_sym and exits to rskip to
   *   find the next db request.
*/

sym_err:	proc;

dcl  mess char (80) var;

	     mess = "";
	     if code = 1 then mess = "Symbol " || sym_name || " not found for " || snt.ent_name;
	     else if code = 2 then mess = "No symbol table for " || snt.ent_name;
	     else if code = 3 then mess = "No linkage section for " || snt.ent_name;
	     else if code = 4 then mess = "No stack frame for " || snt.ent_name;
	     else if code = 5 then mess = "Cannot get address of " || sym_name;
	     else if code = 6 then mess = "Cannot get size of " || sym_name;
	     else if code = 7 then go to syntax_error;
	     else if code = 8 then mess = "Subscripting error in " || sym_name;
	     else if code = 9 then mess = "Invalid subscript in " || sym_name;
	     else if code = 10 then mess = "Based variable error in " || sym_name;
	     else if code = 11 then mess = "Too many structure levels in " || sym_name;
	     else if code = 12 then mess = "Symbol is too long " || sym_name;
	     else if code = 13 then mess = "Reference is ambiguous " || sym_name;
	     else if code = 14 then mess = sym_name || " is entry constant; not supported";
	     else if code = 15 then mess = "Symbol table for this language is not supported by debug.";

	     if mess ^= "" then call ioa_$ioa_stream (debug_output, mess);
	     go to rskip;

	end sym_err;

/*  This procedure searches for the next non-blank character in the line beginning with index.
   It returns "0"b if the rest of the line is blank.  Otherwise it returns "1"b, the index and the character
   found.
*/
get_char:	proc (index_in, index_out, char_out) returns (bit (1));

dcl  index_in fixed bin;
dcl  index_out fixed bin;
dcl  char_out char (1) aligned;
dcl  i fixed bin;

	     index_out = index_in;
	     if index_out < ill then do;
		i = verify (substr (il, index_out, ill - index_out +1), " ");

		if i > 0 then do;
		     index_out = index_out + i -1;
		     char_out = substr (il, index_out, 1);
		     if char_out ^= ";" & char_out ^= new_line then return ("1"b);
		end;
		else index_out = ill;
	     end;

	     return ("0"b);

	end get_char;

/*  */

parse_print: proc;

dcl  i fixed bin;
dcl  size fixed bin;
dcl (have_mode, have_size, have_count) bit (1);

	     have_mode, have_size, have_count = "0"b;

	     do while (get_char (lin+1, lin, char));

/* (<size>)  */
		if char = "(" then do;
		     if ^have_size then do;
			have_size = "1"b;
			i = db_get_count$dec (il, lin+1, lin);
			if i > 0 then do;
			     if get_char (lin, lin, char) then do;
				if char = ")" then do;
				     size = i;
				     goto next;
				end;
			     end;
			end;
		     end;
		     goto syntax_error;
		end;

/* <amount to print>  */
		else if index (NUMBER, char) > 0 then do;
		     if have_count then goto syntax_error;
		     pc = db_get_count$dec (il, lin, lin);
		     pc = max (pc, 1);
		     have_count = "1"b;
		     lin = lin -1;
		end;

/* <mode>   Set mode and default size.  A change in mode causes the amount to print to be set to 1 */
		else do;
		     if substr (il, lin, 1) = "n" then goto skip;
		     do i = 1 to hbound (MODES, 1)
			     while (substr (il, lin, length (MODES (i))) ^= MODES (i));
		     end;
		     if i > hbound (MODES, 1) then do;
			call ioa_$ioa_stream (debug_output, "Undefined output mode ""^a""", substr (il, lin, 1));
			goto rskip;
		     end;
		     data_format = MODES (i);
		     lin = lin + length (MODES (i)) -1;
		     if data_format = "p" then max_size = 72;
		     else if data_format = "comp-7" then max_size = 18;
		     else if data_format = "el" | data_format = "fl" then max_size = 72;
		     else max_size = 36;
		     if ^have_count then pc = 1;
		end;
next:
	     end;

/* data_format and pc have been set.  Only set size if it is valid.  */

	     if have_size then do;
		if data_format = "p" & ^(size = 36 | size = 72) then do;
		     call ioa_$ioa_stream (debug_output, "Invalid size for pointer.  Use 36 or 72");
		     goto rskip;
		end;
		else if data_format = "comp-8" | data_format = "comp-5" then max_size = divide (size*9, 2, 17, 0);
		else max_size = size;
	     end;
	end parse_print;

/*  */
/*  This procedure parses &p requests and sets the data_ptr and offset and pc (data size).
   code = 0			Pointer was found to the argument.
   code = err_no_stack		No stack frame, so no parameter list.
   code = -1			Illegal number for argument poaition.

   index			(input) Set to start of string "&p"
   (output) Set to first character not used in parse
*/
parse_parameter: proc (index, code);

dcl  index fixed bin;
dcl  code fixed bin;

	     i = db_get_count$dec (il, index+2, index);
	     if snt.sp = null then code = err_no_stack;
	     else do;
		if snt.sp -> stack_frame.arg_ptr = null then code = err_no_stack;
		else do;
		     if i <= 0 | i > binary (snt.sp -> stack_frame.arg_ptr -> arg_list.num_args, 17) then do;
			call ioa_$ioa_stream (debug_output, "No parameter ^d.", i);
			code = -1;		/* no error message, but error return */
		     end;
		     else do;
			call decode_descriptor_ (snt.sp -> stack_frame.arg_ptr, i, code, switch, ndims, size, scale);
			data_ptr = snt.sp -> stack_frame.arg_ptr -> arg_list.args (i);
			offset = binary (rel (data_ptr), 18);
						/* COBOL data codes */
			if code = 38 | code = 39 | code = 41 then do;
			     pc = 1;
			     if code = 41 then data_format = "comp-8";
			     else data_format = "comp-5";
			     if code = 38 then size = divide (size*9, 2, 17, 0);
			     else size = divide ((size+1)*9, 2, 17, 0);
			end;
			else if code > 0 then do;
			     data_format = substr ("dhffdhfhhhhhphpphbbaah", code, 1); /* decode type into mode */
			     if code = 2 then pc = 2; /* if double precision fixed point */
			     else if code = 5 then pc = 2; /* complex fixed short */
			     else if code = 7 then pc = 2; /* complex float short */
			     else if code = 15 then pc = 2; /* label variable */
			     else if code = 16 then pc = 2; /* entry variable */
			     else if data_format = "a" then do;
				if code = 22 then pc = max (0, addrel (data_ptr, -1) -> based_fix);
				else pc = size;
			     end;
			     else if data_format = "b" then if code = 19 then pc = size;
				else pc = max (0, addrel (data_ptr, -1) -> based_fix);
			     data_id = "p";
			end;
			code = 0;
		     end;
		end;
	     end;
	     return;

	end parse_parameter;
						/*  */
						/*  This procedure sets offset and data_ptr to the text beginning at a given source line.
						   code = 0		Was able to set the pointer to object code for line number.

						   data_ptr  = location of first instruction on the line.
						   data_format = "s"   (db_print mode for source code )
						   data_id   = "t"   (segment_ID is &t for text )

						   code = no_sym_tab	The procedure was not compiled with the table option.
						   code = -1		No code generated for 10 lines after the line number requested.
						   */
parse_source: proc (index, code);

dcl  index fixed bin;
dcl  code fixed bin;

	     line_number = db_get_count$dec (il, index+2, index);
	     if snt.symflag then call db_get_sym (sntp);
	     tp = snt.symp;				/* get pointer to symbol table */
	     if (^snt.std & tp = null) | snt.headp = null then code = err_no_sym_tab;
	     else do;
		switch = "0"b;
		do line_number = line_number to line_number + 10 while (code = 0);
		     if snt.std then offset = stu_$get_runtime_location (snt.headp, line_number);
		     else call stu_$get_location (snt.symp, line_number, offset);
		     if offset = -2 then code = err_no_sym_tab;
		     else do;
			if offset >= 0 then do;	/* if positive offset, ok */
			     data_id = "t";
			     data_ptr = ptr (snt.pp, offset);
			     data_format = "s";
			     if switch then call ioa_$ioa_stream (debug_output, "Using line number ^d.", line_number);
			     return;
			end;
			else switch = "1"b;
		     end;
		end;
		if code = 0 then do;
		     code = -1;
		     call ioa_$ioa_stream (debug_output, "debug: No code generated for 10 lines after ^d.", line_number - 11);
		end;
	     end;

	     return;

	end parse_source;
						/*  */
set_data_ptr: proc (segment_id);

dcl  segment_id char (1) aligned;

	     if segment_id = "t" then data_ptr = ptr (snt.pp, offset);
	     else if segment_id = "s" then do;
		if snt.sp = null then code = err_no_stack;

		else do;
		     data_ptr = addrel (snt.sp, offset);
		end;

	     end;
	     else if segment_id = "l" then do;
		if snt.pp = null () then code = err_no_linkage;
		else do;
		     snt.lp = ptr (baseptr (stack_header.lot_ptr -> lot (binary (baseno (snt.pp))).segno),
			stack_header.lot_ptr -> lot (binary (baseno (snt.pp))).offset);
		     if rel (snt.lp) = "0"b then code = err_no_linkage;
		     else do;
			data_ptr = addrel (snt.lp, offset);
		     end;
		end;
	     end;

	     else if segment_id = "i" then do;
		if snt.pp = null () then code = err_no_static;
		else do;
		     snt.static_ptr = ptr (baseptr (stack_header.isot_ptr -> lot (binary (baseno (snt.pp))).segno),
			stack_header.isot_ptr -> lot (binary (baseno (snt.pp))).offset);
		     if rel (snt.static_ptr) = "0"b then code = err_no_static;
		     else do;
			data_ptr = addrel (snt.static_ptr, offset);
		     end;
		end;
	     end;

	     else do;
		call ioa_$ioa_stream (debug_output, "bad segment ID ""^a""", segment_id);
		code = -1;
	     end;
	end set_data_ptr;

/*  */
/* * This procedure parses the trace stack request.
   *	.tN,M	where N is the number of the first frame to print and M is the number of frames to be printed.
   *
   * It uses global variables:
   *	lin	input	= index of "." on line
   *		output	= index of last character used for trace stack request
*/
stack_trace: proc ();

dcl (i, start, last) fixed bin;
dcl  ent_name char (32) aligned;
dcl 1 trace_snt aligned like snt;
dcl  trace_snt_ptr ptr;

	     trace_snt_ptr = addr (trace_snt);
	     start = 0;
	     last = max_stack;

	     lin = lin + 2;
	     if verify (substr (il, lin, 1), NUMBER) = 0 then start = db_get_count$dec (il, lin, lin);
	     if substr (il, lin, 1) = "," then last = start + db_get_count$dec (il, lin+1, lin) -1;
	     start = max (0, start);
	     start = min (start, max_stack);
	     last = min (last, max_stack);

	     if print_mode = 1
	     then call ioa_$ioa_stream (debug_output, "^/DEPTH  SEGNO  OFFSET  ^5xNAME^20xCONDITION^/");

	     do i = start to last;
		call db_fill_snt (stack_ptr_array (i), trace_snt_ptr); /* get data for this stack frame */
		if is_condition_frame_ (trace_snt.sp) then do;
		     call find_condition_info_ (trace_snt.sp, addr (cond_info), code);
		     ent_name = cond_info.condition_name;
		end;
		else ent_name = "";
		call ioa_$ioa_stream (debug_output, " ^4d  ^5o  ^6o  ^a|^o^2-^a",
		     i, binary (baseno (trace_snt.pp), 15), binary (rel (trace_snt.sp), 18),
		     trace_snt.ent_pt_name, binary (rel (trace_snt.pp), 18), ent_name);
	     end;

	end stack_trace;

     end db_parse;
