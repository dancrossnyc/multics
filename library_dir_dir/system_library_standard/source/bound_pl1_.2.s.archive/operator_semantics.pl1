/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-07-10,RWaters), approve(89-07-10,MCR8121), audit(89-08-09,Vu),
     install(89-09-22,MR12.3-1073):
     Changed references to error msg 134 to msg 135.
                                                   END HISTORY COMMENTS */


/* 	Modified: 15 Feb 1978 by PCK to implement options(main) and the stop statement
	Modified: 9 August 1978 by PCK to fix bug 1753
	Modified: 15 August 1978 by PCK to fix bug 1708
	Modified: 25 August 1978 by PCK to fix bugs 1779 and 1730
	Modified: 23 April 1979 by PCK to implement 4-bit decimal
	Modified 790606 by PG to add byte and rank builtins
	Modified 800103 by RAB to fix 1860 in which passing a label constant
		as arg somtimes fails.
	Modified: 1 July 1980 by PCK to fix 1975 (substr of an aligned string
		is passed by reference when it is the target of an assignment
		whose LHS is a function returning an aligned string
		of the same length
	Modified: 2 June 1981 by EBush to fix bug 1851 (faulting on multiply
		declared entries)
	Modified: 06 June 89 by RWaters changed references to error
                    message 134 to 135
*/

/* format: style2,^indattr,ifthendo,ifthen,^indnoniterdo,^elsestmt,dclind9 */
operator_semantics:
     proc (blk, stmnt, input_tree, context) returns (ptr);

/* parameters */
	dcl      blk ptr parameter;
	dcl      stmnt ptr parameter;
	dcl      input_tree ptr parameter;

/* automatic */

	dcl      (a, after_ret) ptr;
	dcl      (b, bb, c) ptr;
	dcl      desc ptr;
	dcl      e ptr;
	dcl      es ptr;
	dcl      expr ptr;
	dcl      (first, last) ptr;
	dcl      jump_stmnt ptr;
	dcl      last_jump ptr;
	dcl      length (2:3) ptr;
	dcl      next ptr;
	dcl      old_rand (2:3) ptr;
	dcl      orig_stmnt_ptr ptr;
	dcl      qq ptr;
	dcl      ref ptr;
	dcl      rv ptr;
	dcl      size ptr;
	dcl      sym ptr;
	dcl      signal_stmnt_ptr ptr;
	dcl      tree ptr;
	dcl      target ptr;

	dcl      (n, k, q, s, math_libe_no) fixed bin (15);
	dcl      (i, m, p, r) fixed bin (31);
	dcl      (rprec, rscale) fixed bin (31);
	dcl      c_length (2:3) fixed bin (31);
	dcl      prec (3) fixed bin (31);
	dcl      value_of_y fixed bin (71);

	dcl      decimal_result bit (1) aligned;
	dcl      first_time bit (1) aligned;
	dcl      m_set bit (1) aligned;
	dcl      end_statement_flag bit (1) aligned;
	dcl      label_attached bit (1) aligned;
	dcl      make_operator bit (1) aligned;

	dcl      (opcode, s_opcode) bit (9) aligned;
	dcl      result_type bit (36) aligned;
	dcl      integer fixed bin (15) based;
	dcl      cond_name char (16);
	dcl      based_char char (16) based;
	dcl      float_dec_target ptr;
	dcl      hold_abort_label label variable;

/* external static */
	dcl      pl1_stat_$abort_label label ext static;
	dcl      pl1_stat_$cur_statement ptr ext static;
	dcl      pl1_stat_$error_flag bit (1) ext static;
	dcl      pl1_stat_$multi_type bit (1) ext static;
	dcl      pl1_stat_$root ptr ext static;
	dcl      pl1_stat_$stmnt_unreachable bit (1) ext static;

/* structures */

	dcl      1 atype like type;
	dcl      1 btype like type;
	dcl      1 ctype like type;
	dcl      1 rtype like type;

/* builtins */

	dcl      (abs, addr, bin, bool, divide, fixed, index, max, min, null, sign, string, substr, unspec) builtin;

/* internal static */

	dcl      TRUE bit (1) int static options (constant) init ("1"b);
	dcl      FALSE bit (1) int static options (constant) init ("0"b);

	dcl      action_index (20, 0:15) fixed bin (15) int static init (0, 1, 1, 1, 1, 2, 3, (9) - 1,
						/* class 1 */
		    0, (5) 4, (10) - 1, 0, 5, (2) - 1, 0, -1, 13, -1, 0, -1, (6) - 1, (4) - 1, (6) 6, (6) - 1, 0,
		    (9) 7, (6) - 1,			/* class 5 */
		    0, 0, -1, 9, -1, 10, -1, 0, 13, 15, 15, 11, -1, -1, 0, -1, (4) 19, (12) - 1, (7) 12, -1, -1, 14,
		    14, (4) - 1, 12, (16) - 1, (11) - 1, 8, (4) - 1,
						/* class 10 */
		    15, (4) 0, (11) - 1, (2) 0, (14) - 1, (4) - 1, (3) 21, (9) - 1, 12, 12, 20, 0, (11) - 1, 0, 0,
		    (14) 16, -1,			/* class 15 */
		    (7) 16, (5) - 1, (4) 0, (2) 0, 11, 18, 18, (9) 16, 17, 0, (4) 16, (2) - 1, 2, 0, (7) - 1, 0,
		    (16) - 1, (16) - 1);		/* class 20 */
%page;
/* begin */
	tree = input_tree;

	if tree = null then
	     goto ret;
	if tree -> node.type ^= operator_node then
	     goto ret;
	if tree -> operator.processed then
	     goto ret;

	this_context = "0"b;
	n, m = 0;
	a, b, c, e, next, qq, ref, size, sym, length (2), length (3) = null;
						/* safety first */

	k = tree -> operator.number;

	opcode = tree -> operator.op_code;

	if opcode < std_arg_list then
	     call extract;

	goto action (action_index (fixed (substr (opcode, 1, 5), 5), fixed (substr (opcode, 6, 4), 4)));

%page;
/*
 * This operator should not be seen by this procedure.
 */
action (-1):
	call semantic_translator$abort (52, null);
%page;
/*
 * This operator requires no action by this procedure.
 */
action (0):
	goto ret;
%page;
/*
 * This code is executed for the arithmetic operators + - / *
 */
action (1):
	if b -> node.type = label_node | c -> node.type = label_node then
	     call semantic_translator$abort (78, null);

	if btype.bit then
	     string (btype) = integer_type;
	if ctype.bit then
	     string (ctype) = integer_type;
	if btype.char then
	     string (btype) = dec_integer_type;
	if ctype.char then
	     string (ctype) = dec_integer_type;
	if btype.picture then
	     if b -> symbol.complex then
		if b -> symbol.pic_float then
		     string (btype) = float_decimal_complex_mask;
		else
		     string (btype) = fixed_decimal_complex_mask;
	     else if b -> symbol.pic_float then
		string (btype) = float_decimal_real_mask;
	     else
		string (btype) = fixed_decimal_real_mask;
	if ctype.picture then
	     if c -> symbol.complex then
		if c -> symbol.pic_float then
		     string (ctype) = float_decimal_complex_mask;
		else
		     string (ctype) = fixed_decimal_complex_mask;
	     else if c -> symbol.pic_float then
		string (ctype) = float_decimal_real_mask;
	     else
		string (ctype) = fixed_decimal_real_mask;

	if ^(btype.fixed | btype.float) then
	     call semantic_translator$abort (227, null);
	if ^(ctype.fixed | ctype.float) then
	     call semantic_translator$abort (227, null);

	if btype.binary & ctype.decimal then
	     string (ctype) = string (ctype) & ^decimal_mask | binary_mask;
	if btype.decimal & ctype.binary then
	     string (btype) = string (btype) & ^decimal_mask | binary_mask;
	if btype.complex | ctype.complex then
	     result_type = complex_mask;
	else
	     result_type = real_mask;

	if btype.binary then do;
	     if btype.fixed & ctype.float then
		string (btype) = string (btype) & ^fixed_mask | float_mask;
	     if btype.float & ctype.fixed then
		string (ctype) = string (ctype) & ^fixed_mask | float_mask;

	     call converter;

	     p = b -> symbol.c_dcl_size;
	     q = b -> symbol.scale;
	     r = c -> symbol.c_dcl_size;
	     s = c -> symbol.scale;
	     if b -> symbol.fixed then do;
		result_type = result_type | binary_mask | fixed_mask | aligned_mask;
		if opcode = add | opcode = sub then do;
		     m = min (max_p_fix_bin_2, max (p - q, r - s) + max (q, s) + 1);
		     n = max (q, s);
		     goto create_temp;
		end;
		if opcode = mult then do;
		     m = min (max_p_fix_bin_2, p + r + 1);
		     n = q + s;
		     goto create_temp;
		end;
		if opcode = div then do;
		     m = max_p_fix_bin_2;
		     n = m - p + q - s;
		     goto create_temp;
		end;
	     end;
	     else do;
		result_type = result_type | binary_mask | float_mask | aligned_mask;
		m = max (p, r);
		goto create_temp;
	     end;
	end;
	else do;
	     call converter;

	     p = b -> symbol.c_dcl_size;
	     q = b -> symbol.scale;
	     r = c -> symbol.c_dcl_size;
	     s = c -> symbol.scale;
	     if b -> symbol.fixed & c -> symbol.fixed then do;
		result_type = result_type | decimal_mask | fixed_mask | aligned_mask;
		if opcode = add | opcode = sub then do;
		     m = min (max_p_dec, max (p - q, r - s) + max (q, s) + 1);
		     n = max (q, s);
		     goto create_temp;
		end;
		if opcode = mult then do;
		     m = min (max_p_dec, p + r + 1);
		     n = q + s;
		     goto create_temp;
		end;
		if opcode = div then do;
		     m = max_p_dec;
		     n = m - p + q - s;
		     goto create_temp;
		end;
	     end;
	     else do;
		result_type = result_type | decimal_mask | float_mask | aligned_mask;
		m = max (p, r);
		goto create_temp;
	     end;
	end;
%page;
/*
 * This code is executed for the negate and the prefix_plus operator.
 */
action (2):
	if opcode = prefix_plus then
	     call extract;
	if b -> node.type = label_node then
	     call semantic_translator$abort (78, null);

	if btype.bit then
	     string (btype) = integer_type;
	if btype.char then
	     string (btype) = dec_integer_type;
	if btype.picture then
	     if b -> symbol.complex then
		if b -> symbol.pic_float then
		     string (btype) = float_decimal_complex_mask;
		else
		     string (btype) = fixed_decimal_complex_mask;
	     else if b -> symbol.pic_float then
		string (btype) = float_decimal_real_mask;
	     else
		string (btype) = fixed_decimal_real_mask;

	if ^(btype.fixed | btype.float) then
	     call semantic_translator$abort (227, null);

	call converter;

	if opcode = prefix_plus then do;
	     tree = tree -> operand (2);
	     goto ret;
	end;

	m = b -> symbol.c_dcl_size;
	n = b -> symbol.scale;
	result_type = string (btype) & ^unaligned_mask | aligned_mask;
	goto create_temp;
%page;
/*
 * This code is executed for the ** operator.
 */
action (3):
	if b -> node.type = label_node | c -> node.type = label_node then
	     call semantic_translator$abort (78, null);

	old_rand (2) = tree -> operand (2);
	old_rand (3) = tree -> operand (3);

	if btype.bit | btype.char then
	     string (btype) = integer_type;
	if ctype.bit | ctype.char then
	     string (ctype) = integer_type;

	if btype.picture then
	     if b -> symbol.complex then
		if b -> symbol.pic_float then
		     string (btype) = float_decimal_complex_mask;
		else
		     string (btype) = fixed_decimal_complex_mask;
	     else if b -> symbol.pic_float then
		string (btype) = float_decimal_real_mask;
	     else
		string (btype) = fixed_decimal_real_mask;

	if ctype.picture then
	     if c -> symbol.complex then
		if c -> symbol.pic_float then
		     string (ctype) = float_decimal_complex_mask;
		else
		     string (ctype) = fixed_decimal_complex_mask;
	     else if c -> symbol.pic_float then
		string (ctype) = float_decimal_real_mask;
	     else
		string (ctype) = fixed_decimal_real_mask;

	if ^(btype.fixed | btype.float) then
	     call semantic_translator$abort (227, null);
	if ^(ctype.fixed | ctype.float) then
	     call semantic_translator$abort (227, null);

	decimal_result = btype.decimal & ctype.decimal;
	m_set = FALSE;

	string (ctype) = string (ctype) & ^decimal_mask | binary_mask;

	if ctype.fixed & ctype.real & c -> node.type = token_node then do;
	     m_set = TRUE;
	     c, e = convert ((old_rand (3)), string (ctype));
	     c = c -> reference.symbol;

	     value_of_y = constant_value (c);

	     if value_of_y > 0 & c -> symbol.scale = 0 then do;
		tree -> operand (3) = e;

		if btype.complex then
		     string (btype) = string (btype) & ^fixed_mask & ^decimal_mask | float_mask | binary_mask;

		tree -> operand (2), b = convert ((old_rand (2)), string (btype));
		if b -> node.type = operator_node then
		     b = b -> operand (1);
		b = b -> reference.symbol;

		p = b -> symbol.c_dcl_size;
		q = b -> symbol.scale;
		r = c -> symbol.c_dcl_size;
		s = c -> symbol.scale;

		m = max (p, r);
		n = 0;

		if btype.fixed & btype.real then do;
		     m = (p + 1) * value_of_y - 1;
		     n = q * value_of_y;

		     if m > max_p_fix_bin_2 | m > max_p_dec & btype.decimal then do;
			b, tree -> operand (2) = convert ((old_rand (2)), real_type);
			if b -> node.type = operator_node then
			     b = b -> operand (1);
			b = b -> reference.symbol;
			string (btype) = string (b -> symbol.attributes) & ^dimensioned_mask;
			p = b -> symbol.c_dcl_size;
			m = max (p, r);
		     end;
		end;
	     end;

	     else do;
		if value_of_y = 0 then do;
		     tree -> operand (3) = declare_constant$integer (0);
		     c = tree -> operand (3) -> reference.symbol;
		end;
		else do;
		     string (btype) = string (btype) & ^fixed_mask | float_mask;
		     string (ctype) = string (ctype) & ^fixed_mask | float_mask;

		     if btype.complex then
			string (ctype) = string (ctype) & ^real_mask | complex_mask;

		     c, tree -> operand (3) = convert ((old_rand (3)), string (ctype));
		     if c -> node.type = operator_node then
			c = c -> operand (1);
		     c = c -> reference.symbol;
		end;

		b, tree -> operand (2) = convert ((old_rand (2)), string (btype));
		if b -> node.type = operator_node then
		     b = b -> operand (1);
		b = b -> reference.symbol;

		p = b -> symbol.c_dcl_size;
		q = c -> symbol.c_dcl_size;
		m = max (p, q);
		n = 0;
	     end;

	     if ^btype.decimal then
		goto create_exp_call;
	end;

	rtype = btype;
	string (btype) = string (btype) & ^fixed_mask | float_mask;

	if ctype.float | c -> symbol.scale ^= 0 then do;
	     string (btype) = string (btype) & ^decimal_mask | binary_mask;
	     string (ctype) = string (ctype) & ^fixed_mask | float_mask;
	end;

	if btype.complex then do;
	     string (btype) = string (btype) & ^decimal_mask | binary_mask;

	     if ctype.float | ctype.decimal | ctype.complex then
		string (ctype) = string (ctype) & ^real_mask & ^fixed_mask | complex_mask | float_mask;
	end;
	else if ctype.complex then do;
	     string (btype) = string (btype) & ^decimal_mask & ^real_mask | binary_mask | complex_mask;
	     string (ctype) = string (ctype) & ^fixed_mask | float_mask;
	end;

	if btype.decimal then do;
	     float_dec_target = create_symbol (blk, null, by_compiler);
	     float_dec_target -> symbol.float, float_dec_target -> symbol.decimal, float_dec_target -> symbol.real,
		float_dec_target -> symbol.temporary = TRUE;
	     float_dec_target -> symbol.c_dcl_size = max_p_dec;

	     call declare (float_dec_target);

	     float_dec_target = float_dec_target -> symbol.reference;

	     tree -> operand (3) = convert ((old_rand (3)), string (ctype));
						/*   c can only be integer_type by now   */

	     if tree -> operand (3) -> node.type = operator_node then
		c = tree -> operand (3) -> operand (1) -> reference.symbol;
	     else
		c = tree -> operand (3) -> reference.symbol;

	     if ^m_set then do;
		b = convert ((old_rand (2)), string (btype));
		if b -> node.type = operator_node then
		     b = b -> operand (1);
		b = b -> reference.symbol;
		m = max (b -> symbol.c_dcl_size, c -> symbol.c_dcl_size);
	     end;

	     tree -> operand (2) = convert$to_target ((old_rand (2)), float_dec_target);
	     if tree -> operand (2) -> node.type = reference_node then
		if tree -> operand (2) -> reference.symbol -> symbol.c_dcl_size ^= max_p_dec then do;
		     b = create_operator (assign, 2);
		     b -> operand (1) = float_dec_target;
		     b -> operand (2) = tree -> operand (2);
		     tree -> operand (2) = b;
		end;

	     if tree -> operand (2) -> node.type = operator_node then
		b = tree -> operand (2) -> operand (1) -> reference.symbol;
	     else
		b = tree -> operand (2) -> reference.symbol;

	end;
	else
	     call converter;

	p = b -> symbol.c_dcl_size;
	q = c -> symbol.c_dcl_size;
	rprec = m;
	rscale = n;
	m = max (p, q);
	n = 0;

	if btype.decimal then do;
	     math_libe_no = 195;			/* decimal_exp_ */

	     if q > max_p_fix_bin_1 then do;
		math_libe_no = math_libe_no + 1;	/* decimal_exp2_ */
		m = max_p_dec;
	     end;

	     goto make_call;
	end;

	if ctype.fixed then
	     m = p;
	else if m > max_p_flt_bin_1 then do;
	     if p <= max_p_flt_bin_1 then
		tree -> operand (2) = convert$to_target ((old_rand (2)), (c -> symbol.reference));

	     if q <= max_p_flt_bin_1 then
		tree -> operand (3) = convert$to_target ((old_rand (3)), (b -> symbol.reference));
	end;

create_exp_call:
	if ctype.fixed then
	     if q <= max_p_fix_bin_1 then
		math_libe_no = 17;			/* xp2_ */
	     else
		math_libe_no = 197;			/* xp22_ */
	else
	     math_libe_no = 21;			/* xp3_ */

	if btype.float then
	     if m > max_p_flt_bin_1 then
		math_libe_no = math_libe_no + 1;
	     else
		;
	else if m > max_p_fix_bin_1 then
	     math_libe_no = math_libe_no + 1;

	if btype.complex then
	     math_libe_no = math_libe_no + 2;

	if btype.fixed & btype.real then
	     if m > max_p_fix_bin_1 then
		math_libe_no = 171;			/* diexp_*/
	     else
		math_libe_no = 147;			/*  iexp_ */

	if math_libe_no = 17 | math_libe_no = 18 | math_libe_no = 21 | math_libe_no = 22 | math_libe_no = 147
	     | math_libe_no = 171 then do;
	     if c -> symbol.constant then
		if constant_value (c) = 0 then do;
		     string (btype) = string (btype) & ^fixed_mask | float_mask;
		     m = min (b -> symbol.c_dcl_size, max_p_flt_bin_2);
		     tree = declare_constant ("000000010100"b || (60)"0"b, string (btype), m, 0);
						/*   representation of 1.0e0   */

		     goto ret;
		end;

	     tree -> operand (1) = declare_temporary (string (btype), m, n, null);
	     goto check_decimal;
	end;

make_call:
	qq = create_operator ((std_call), 3);
	qq -> operand (1) = declare_temporary (string (btype), m, n, null);
	qq -> operand (2) = reserve$declare_lib (math_libe_no);
	qq -> operand (2) -> reference.symbol -> symbol.irreducible = FALSE;
	qq -> operand (2) -> reference.symbol -> symbol.reducible = TRUE;
	qq -> operand (3) = create_operator (std_arg_list, 3);

	qq -> operand (3) -> operand (1) = declare_temporary (storage_block_type, 8, 0, null);
	qq -> operand (3) -> operand (2), e = create_list (3);

	e -> element (1) = tree -> operand (2);
	e -> element (2) = tree -> operand (3);

	tree = qq;

	qq -> operand (1), e -> element (3) = copy_expression (qq -> operand (1));
	e -> element (3) -> reference.shared = FALSE;
	e -> element (3) -> reference.ref_count = 2;

check_decimal:
	if decimal_result then do;
	     if math_libe_no = 195 | math_libe_no = 196 /* decimal_exp_ | decimal_exp2_ */ then do;
		m = rprec;
		n = rscale;
		btype = rtype;
	     end;
	     else if btype.fixed then do;
		m = divide (bin (m, 15, 0) * 100 + 331, 332, 15, 0) + 1;
		n = divide (abs (n) * 100 + 331, 332, 15, 0) * sign (n);
	     end;
	     else do;
		m = divide (bin (m, 15, 0) * 100 + 331, 332, 15, 0);
		n = 0;
	     end;

	     qq = create_operator (assign, 2);
	     qq -> operand (1) = declare_temporary (string (btype) & ^binary_mask | decimal_mask, m, n, null);
	     qq -> operand (2) = tree;

	     tree = qq;
	end;

	goto ret;
%page;
/*
 * This code is executed for the string operators ^ | & ||
 */
action (4):
	if b -> node.type = label_node then
	     call semantic_translator$abort (78, null);

	if k > 2 then
	     if c -> node.type = label_node then
		call semantic_translator$abort (78, null);

	if opcode = cat_string & ^(btype.bit & ctype.bit) then
	     result_type, string (btype), string (ctype) = char_type;
	else
	     result_type, string (btype), string (ctype) = bit_type;

	call converter;

	do i = 2 to k;
	     if tree -> operand (i) -> node.type = operator_node then
		ref = tree -> operand (i) -> operand (1);
	     else
		ref = tree -> operand (i);

	     if ref -> reference.varying_ref then do;
		c_length (i) = 0;
		length (i) = create_length_fun ((tree -> operand (i)));
		length (i) -> operand (1) = copy_expression (length (i) -> operand (1));
		length (i) -> operand (1) -> reference.shared = FALSE;
	     end;
	     else do;
		c_length (i) = ref -> reference.c_length;
		length (i) = ref -> reference.length;
	     end;

	     if length (i) = null then
		prec (i) = max_length_precision;
	     else if length (i) -> node.type = operator_node then
		prec (i) = length (i) -> operand (1) -> reference.symbol -> symbol.c_dcl_size;
	     else
		prec (i) = length (i) -> reference.symbol -> symbol.c_dcl_size;
	end;

	if opcode = not_bits then do;
	     m = c_length (2);
	     size = share_expression (length (2));
	     goto create_temp;
	end;

	if length (2) = null & length (3) ^= null then
	     length (2) = declare_constant$integer (c_length (2));

	if length (3) = null & length (2) ^= null then
	     length (3) = declare_constant$integer (c_length (3));

	if length (2) = null then
	     if opcode = cat_string then
		m = c_length (2) + c_length (3);
	     else
		m = max (c_length (2), c_length (3));
	else do;
	     make_operator = TRUE;

	     if opcode = cat_string then do;
		s_opcode = add;
		prec (1) = min (max_p_fix_bin_1, max (prec (2), prec (3)) + 1);
	     end;
	     else do;
		if length (2) = length (3) | compare_expression (length (2), length (3)) then
		     make_operator = FALSE;
		else do;
		     s_opcode = max_fun;
		     prec (1) = min (max_p_fix_bin_1, max (prec (2), prec (3)));
		end;
	     end;

	     if make_operator then do;
		size = create_operator (s_opcode, 3);
		size -> operand (1) = declare_temporary (integer_type, prec (1), 0, null);
		size -> operand (2) = share_expression (length (2));
		size -> operand (3) = share_expression (length (3));
		size -> operator.processed = TRUE;
	     end;
	     else
		size = share_expression (length (2));
	end;

	goto create_temp;
%page;
/*
 * This code is executed for the assignment operator.
 */
action (5):
	if a -> node.type = label_node then
	     call semantic_translator$abort (135, null);

/* check for assignments to file or entry constants, but allow assignments
 * of addr to a file constant.  These are produced by the declaration
 * processor to initialize the file constant.
 */

	if a -> symbol.constant then
	     if ^(a -> symbol.file & blk -> block.prologue_flag) | tree -> operand (2) -> node.type ^= operator_node
		then
		call semantic_translator$abort (135, null);
	     else if tree -> operand (2) -> op_code ^= addr_fun then
		call semantic_translator$abort (135, null);

/* If the right side is a token, convert it to the type of the left side,
 * unless the left side has no type
 */

	if b -> node.type = token_node then
	     if string (atype) ^= "0"b then do;
		if tree -> operand (1) -> reference.varying_ref | a -> symbol.dcl_size ^= null
		     | tree -> operand (1) -> reference.length ^= null then
		     tree -> operand (2) = convert (b, string (atype));
		else
		     tree -> operand (2) = convert$to_target (b, (tree -> operand (1)));

		if tree -> operand (2) -> node.type = operator_node then
		     b = tree -> operand (2) -> operand (1) -> reference.symbol;
		else
		     b = tree -> operand (2) -> reference.symbol;

		string (btype) = string (b -> symbol.attributes);
	     end;
	     else do;
		b, tree -> operand (2) = convert ((tree -> operand (2)), string (btype));
		if b -> node.type = operator_node then
		     b = b -> operand (1);
		b = b -> reference.symbol;
	     end;

/* If the left side is a temporary with no data type, it is to acquire
 * the data type of the right side.
 */

	if a -> symbol.temporary & string (a -> symbol.data_type) = "0"b then do;
	     if b -> node.type = label_node then do;
		string (atype), substr (string (a -> symbol.attributes), 1, 36) = label_mask;

		call declare (a);
	     end;
	     else do;
		string (atype), substr (string (a -> symbol.attributes), 1, 36) =
		     substr (string (b -> symbol.attributes), 1, 36);
		a -> symbol.scale = b -> symbol.scale;

		a -> symbol.initialed, a -> symbol.overlayed, a -> symbol.position = FALSE;

		if b -> symbol.array = null then do;
		     a -> symbol.c_word_size = b -> symbol.c_word_size;
		     a -> symbol.c_bit_size = b -> symbol.c_bit_size;
		     a -> symbol.word_size = b -> symbol.word_size;
		     a -> symbol.bit_size = b -> symbol.bit_size;
		end;
		else do;
		     a -> symbol.c_word_size = b -> symbol.array -> array.c_element_size;
		     a -> symbol.c_bit_size = b -> symbol.array -> array.c_element_size_bits;
		     a -> symbol.word_size = b -> symbol.array -> array.element_size;
		     a -> symbol.bit_size = b -> symbol.array -> array.element_size_bits;
		end;

		if atype.char | atype.bit then do;
		     ref = tree -> operand (2);
		     if ref -> node.type = operator_node then
			ref = ref -> operand (1);
		     a -> symbol.c_dcl_size = ref -> reference.c_length;
		     a -> symbol.dcl_size = ref -> reference.length;
		     a -> symbol.exp_extents = ref -> reference.length ^= null;

		     if ^ref -> reference.varying_ref then do;
			a -> symbol.reference -> reference.c_length = ref -> reference.c_length;
			a -> symbol.reference -> reference.length = share_expression ((ref -> reference.length));
			a -> symbol.varying = FALSE;

			call get_size (a);
		     end;
		     else
			a -> symbol.reference -> reference.length, a -> symbol.dcl_size =
			     create_length_fun ((tree -> operand (2)));

		     a -> symbol.exp_extents = a -> symbol.reference -> reference.length ^= null;
		end;
		else do;
		     a -> symbol.pix = b -> symbol.pix;
		     a -> symbol.c_dcl_size = b -> symbol.c_dcl_size;
		     a -> symbol.general = b -> symbol.general;
						/* for offsets and picture */

		     if tree -> operand (2) -> node.type = reference_node then
			a -> symbol.reference -> reference.c_length = tree -> operand (2) -> reference.c_length;
		     else
			a -> symbol.reference -> reference.c_length =
			     tree -> operand (2) -> operand (1) -> reference.c_length;
		end;
	     end;

	     a -> symbol.dimensioned = FALSE;
	     string (a -> symbol.storage_class) = "0"b;
	     a -> symbol.temporary = TRUE;
	end;

/* If this assignment is to a char(*) or bit(*) return parameter,
 * then generate code to fill in the descriptor and then replace the
 * assignment with the expression converted to conform to the type
 * etc of the return parameter.
 */

	if def_context.return & a -> symbol.star_extents & a -> symbol.dcl_size ^= null & (atype.bit | atype.char)
	then do;
	     ref, tree = convert ((tree -> operand (2)), string (atype));

	     if ref -> node.type = operator_node then
		ref = ref -> operand (1);

	     if ref -> reference.varying_ref then
		c = create_length_fun (tree);

	     else if ref -> reference.length = null then
		c = declare_constant$integer ((ref -> reference.c_length));
	     else
		c = share_expression ((ref -> reference.length));

	     e = copy_expression (input_tree -> operand (1) -> reference.symbol -> symbol.descriptor);
	     e -> reference.shared = FALSE;
	     e -> reference.ref_count = 1;
	     desc =
		declare_constant$desc (
		string (e -> reference.symbol -> symbol.descriptor -> symbol.initial -> descriptor (0).bit_type));
	     call make (3, make_desc, e, desc, c);
	     stmnt -> statement.processed = TRUE;

	     goto ret;
	end;

/* If this assignment is a by_value argument, the left side is to
 * be replaced by a temporary whose data type is derived from the argument
 * descriptor.  The extents are given by the descriptor unless the
 * descriptor has star_extents, in the latter case the extents are
 * derived from the right side.
 */

	if def_context.arg_list & a -> symbol.param_desc then do;
	     n = a -> symbol.scale;

	     if atype.area then
		size = a -> symbol.dcl_size;

	     result_type = string (atype);

	     if atype.fixed | atype.float | atype.area then
		m = a -> symbol.c_dcl_size;
	     else if atype.bit | atype.char | atype.picture then
		if a -> symbol.star_extents & a -> symbol.dcl_size ^= null then do;
		     expr, ref = tree -> operand (2);

		     if ref -> node.type = operator_node then
			ref = ref -> operand (1);

		     if ref -> node.type ^= reference_node then
			call semantic_translator$abort (78, null);

		     if ^(ref -> reference.symbol -> symbol.bit | ref -> reference.symbol -> symbol.char) then
			expr, ref = convert ((tree -> operand (2)), string (atype));

		     if ref -> node.type = operator_node then
			ref = ref -> operand (1);

		     if ref -> reference.varying_ref then
			size = create_length_fun (expr);

		     else if ref -> reference.length ^= null then
			size = share_expression ((ref -> reference.length));
		     else
			m = ref -> reference.c_length;
		end;
		else
		     m = a -> symbol.c_dcl_size;

	     tree -> operand (1) = declare_temporary (result_type, m, n, size);

	     if a -> symbol.picture then do;
		tree -> operand (1) -> reference.symbol -> symbol.general = a -> symbol.general;
		tree -> operand (1) -> reference.symbol -> symbol.pix = a -> symbol.pix;
	     end;

	     a = tree -> operand (1) -> reference.symbol;
	end;

/* transform x = 0 into assign_zero(x)  */

	if b -> symbol.constant & btype.fixed & btype.binary & btype.real & b -> symbol.c_dcl_size <= max_p_fix_bin_1
	     then
	     if b -> symbol.initial -> integer = 0 & atype.fixed & atype.binary & atype.real
		& a -> symbol.c_dcl_size <= max_p_fix_bin_1 & a -> symbol.scale = 0 & ^a -> symbol.packed
		& ^a -> symbol.unaligned then do;
		tree -> operator.op_code = assign_zero;
		tree -> operator.number = 1;
		goto force_store;
	     end;


/* If the size condition is enabled, assignments to arithmetic values must
 * be done using a size_ck operator.  If the stringsize condition is enabled,
 * assignments to bit or character data must be done with the size_ck
 * operator.  No additional optimizations can be performed.
 */

	if substr (stmnt -> statement.prefix, 6, 1) & (atype.fixed | atype.float)
	     | substr (stmnt -> statement.prefix, 9, 1) & (atype.bit | atype.char | atype.picture) then
	     tree -> operator.op_code = assign_size_ck;

/* If the left side is a varying_ref then fill in the length fields with
 * the max length.
 */

	if tree -> operand (1) -> reference.varying_ref then do;
	     if a -> symbol.reference = tree -> operand (1) then do;
		tree -> operand (1), e = copy_expression (a -> symbol.reference);
		e -> reference.shared = FALSE;
		e -> reference.ref_count = 1;
	     end;

	     tree -> operand (1) -> reference.c_length = a -> symbol.c_dcl_size;

	     if a -> symbol.dcl_size ^= null then do;
		e = copy_expression (a -> symbol.dcl_size);
		if a -> symbol.refer_extents then
		     call refer_extent (e, (tree -> operand (1) -> reference.qualifier));
		e = expression_semantics ((a -> symbol.block_node), stmnt, (e), this_context);
		tree -> operand (1) -> reference.length = convert$to_integer (e, integer_type);
	     end;
	end;

	if b -> node.type = symbol_node then
	     if a -> symbol.picture | b -> symbol.picture & ^a -> symbol.char then
		tree -> operand (2) = convert$to_target ((tree -> operand (2)), (tree -> operand (1)));

/* If the right side is an operator whose output temporary has the
 * same attributes as the left side then replace the temp with a
 * reference to the left side.
 */

	if tree -> operand (2) -> node.type = operator_node & tree -> op_code = assign & ^def_context.return then do;
	     e = tree -> operand (2);

	     if e -> op_code = add | e -> op_code = sub then do;
		sym = e -> operand (1) -> reference.symbol;

		if sym -> symbol.fixed & sym -> symbol.binary & sym -> symbol.real & sym -> symbol.scale = 0
		     & atype.fixed & atype.binary & atype.real & a -> symbol.scale = 0
		     &
		     bool (sym -> symbol.c_dcl_size <= max_p_fix_bin_1, a -> symbol.c_dcl_size <= max_p_fix_bin_1,
		     "1001"b) then
		     goto replace;
	     end;

/* If the operator is a call then
 * the return temp is replaced with the left side reference.
 */

	     if compare_declaration ((tree -> operand (1)), (e -> operand (1)), e -> op_code ^= std_call) then do;
		if e -> op_code = std_call then do;
		     if tree -> operand (1) -> reference.substr
			& tree -> operand (1) -> reference.symbol -> symbol.aligned then
			goto force_store;

		     e = e -> operand (3) -> operand (2);

		     rv = e -> list.element (e -> list.number) -> reference.symbol;
		     if rv -> symbol.return_value then
			goto force_store;
		     if rv -> symbol.dimensioned then
			goto force_store;
		     if rv -> symbol.structure then
			goto force_store;

		     if tree -> operand (1) -> reference.symbol -> symbol.temporary then
			if tree -> operand (1) -> reference.shared then do;
			     tree -> operand (1) = copy_expression (tree -> operand (1));
			     tree -> operand (1) -> reference.shared = FALSE;
			     tree -> operand (1) -> reference.ref_count = 1;
			end;

		     e -> list.element (e -> list.number) = share_expression ((tree -> operand (1)));
		     tree -> operand (1) -> reference.symbol -> symbol.passed_as_arg = TRUE;
		end;
replace:
		e = tree -> operand (2);
		if e -> operand (1) -> reference.length ^= null then
		     call adjust_count ((e -> operand (1) -> reference.length));
		e -> operand (1) = tree -> operand (1);
		tree = e;
	     end;
	end;

/* If this is an assignment done because of by_value argument passing
 * insure that the output temporary has a ref_count of at least one.
 * This insures that the code generator will store the result into it.
 */

force_store:
	if def_context.arg_list then
	     if tree -> operand (1) -> reference.symbol -> symbol.temporary then
		if tree -> operand (1) -> reference.shared then do;
		     e = create_reference ((tree -> operand (1)));
		     e -> reference = tree -> operand (1) -> reference;
		     e -> reference.shared = FALSE;
		     e -> reference.ref_count = 1;
		     tree -> operand (1) = e;
		end;

	if tree -> op_code ^= assign & tree -> op_code ^= assign_size_ck then
	     goto ret;

	if a -> symbol.constant then
	     goto ret;

/* Pointer <--> Offset two-way conversion */

	if a -> symbol.offset & b -> symbol.ptr | b -> symbol.offset & a -> symbol.ptr then do;
	     if a -> symbol.offset then do;
		if b -> symbol.constant then do;

/* operand(2) is "null", turn it into "nullo" */

		     n = -1;
		     tree -> operand (2) = declare_constant (unspec (n), offset_mask, 0, 0);
		     goto ret;
		end;

		opcode = off_fun;
		c = copy_expression (a -> symbol.general);
		if c = null then
		     call semantic_translator$abort (435, a);
	     end;
	     else do;
		opcode = ptr_fun;
		c = copy_expression (b -> symbol.general);
		if c = null then
		     if ^b -> symbol.constant then do;
			if pl1_stat_$cur_statement -> statement.root -> op_code ^= allot_var then
			     call semantic_translator$abort (435, b);
			else if pl1_stat_$cur_statement -> statement.root -> operand (1) -> reference.qualifier
			     ^= tree then
			     call semantic_translator$abort (435, b);
		     end;
		     else do;
			tree -> operand (2) = declare_constant (unspec (c), pointer_type, 0, 0);
			goto ret;
		     end;
	     end;

	     c = expression_semantics (blk, stmnt, c, "0"b);

	     e = create_operator ((opcode), 3);		/* by value for efficiency */
	     e -> operand (1) = tree -> operand (1);
	     e -> operand (2) = tree -> operand (2);
	     e -> operand (3) = c;

	     tree = e;

	     goto ret;
	end;

/* If this is an assignment of an entry constant to an entry variable the
 * procedure identified by the entry constant cannot share its containing
 * block's stack frame.
 */
	if b -> node.type = symbol_node then
	     if btype.entry & b -> symbol.constant & b -> symbol.equivalence ^= null then do;
		b -> symbol.equivalence -> block.why_nonquick.assigned_to_entry_var = TRUE;
		b -> symbol.equivalence -> block.no_stack = FALSE;
	     end;

/* check the validity of the conversion implied by this assignment.  */

	if ^tree -> operator.processed then
	     call convert$validate ((tree -> operand (2)), (tree -> operand (1)));

	if a -> symbol.entry then
	     if b -> symbol.constant then
		if b -> symbol.internal then
		     do e = b -> symbol.block_node repeat e -> block.father while (e ^= null);
			e -> block.flush_at_call = TRUE;
		     end;

/* Area assignment is converted into a call to area_$assign(addr(a1),addr(a2)) */

	if atype.area then do;
	     e = create_list (2);

	     do i = 1 to 2;
		e -> element (i) = create_operator (addr_fun, 2);
		e -> element (i) -> operand (1) = declare_temporary (pointer_type, 0, 0, null);
		e -> element (i) -> operand (2) = tree -> operand (i);
	     end;

	     tree, pl1_stat_$cur_statement -> statement.root = create_operator ((std_call), 3);
	     tree -> operand (2) = reserve$declare_lib (161);
						/* area_assign_ */
	     tree -> operand (3) = create_operator (std_arg_list, 3);
	     tree -> operand (3) -> operand (1) = declare_temporary (storage_block_type, 8, 0, null);
	     tree -> operand (3) -> operand (2) = e;
	end;

	goto ret;
%page;
/*
 * This code is executed for the relational operators.
 */
action (6):
	call convert_relationals;
	result_type = bit_type;
	m = 1;
	goto create_temp;
%page;
/*
 * This code is executed for the transfer operators.
 */
action (7):
	if a -> node.type = label_node then do;
	     if a -> label.used_as_format then
		call semantic_translator$abort (196, null);
	     a -> label.used_in_goto = TRUE;
	end;
	else if ^atype.label then
	     call semantic_translator$abort (229, null);

	if opcode ^= jump then do;
	     if opcode > jump_false then do;
		call convert_relationals;
	     end;

	     else if opcode = jump_true | opcode = jump_false then do;
		string (btype) = bit_type;
		call converter;

/* warn about ^ <expr> where <expr> is not bit(1) */

		if tree -> operand (2) -> node.type = operator_node then
		     if tree -> operand (2) -> operator.op_code = not_bits then
			if ^constant_length ((tree -> operand (2) -> operand (1)), 1) then
			     call semantic_translator$error (156, null);
	     end;

	     target = tree -> operand (1);

/* following block of code added by R. Barnes to fix 1542 & 1546 11/05/76 */

	     if target -> node.type ^= label_node then do;
		if target -> node.type = reference_node then
		     if target -> reference.qualifier = null & target -> reference.offset = null then
			goto ret;

/* exprs in the label ref must not be evaluated unless jump taken */

		next = create_list (2);
		tree -> operand (1), next -> element (2) = create_label (blk, null, by_compiler);

		tree -> operator.op_code = jump_complement (fixed (substr (opcode, 6, 4), 4));

		call make (1, jump, target, null, null);
		call make (0, null_statement, next, null, null);

		pl1_stat_$cur_statement = stmnt;
	     end;
	end;
	goto ret;
%page;
/*
 * This code :-) is executed for the length_fun
 */
action (8):
	goto ret;
%page;
/*
 * This code is executed for the std_call_operator.
 */
action (9):
	k = 2;
	call extract;
	if ^btype.entry then
	     call semantic_translator$abort (223, null);
	tree = function (blk, stmnt, tree, b, context);
	goto ret;
%page;
/*
 * This code is executed for the std_entry_operator.
 */
action (10):
	orig_stmnt_ptr = stmnt;

	if stmnt -> statement.statement_type = entry_statement then do;
	     qq = create_statement (goto_statement, (stmnt -> statement.back), null, (stmnt -> statement.prefix));
	     qq -> statement.root = create_operator (jump, 1);

	     next = create_list (2);
	     next -> list.element (2), qq -> statement.root -> operand (1) = create_label (blk, null, by_compiler);

	     qq = create_statement (null_statement, stmnt, next, (stmnt -> statement.prefix));
	     next -> list.element (2) -> label.statement = qq;
	     qq -> statement.reference_count = 1;
	end;

/* create assignment statements to all automatic pointers used to
 * qualify parameters or return values which appear in more than one position.
 */

	do i = 1 to k;
	     if tree -> operand (i) -> node.type ^= reference_node then
		goto ret;
	     a = tree -> operand (i) -> reference.symbol;

	     if tree -> operand (i) -> reference.varying_ref then do;
		tree -> operand (i) -> reference.c_length = a -> symbol.c_dcl_size;
		if a -> symbol.dcl_size ^= null then do;
		     tree -> operand (i) -> reference.length = copy_expression (a -> symbol.dcl_size);
		     tree -> operand (i) -> reference.length =
			expression_semantics (blk, stmnt, (tree -> operand (i) -> reference.length), "0"b);
		end;
	     end;

	     if a -> symbol.allocated then do;		/* if parameters appear in different positions */
		call make (3, param_ptr, (tree -> operand (i) -> reference.qualifier), declare_constant$integer (i),
		     blk);
		if a -> symbol.star_extents then
		     call make (3, param_desc_ptr,
			(tree -> operand (i) -> reference.symbol -> symbol.descriptor -> reference.qualifier),
			declare_constant$integer (i), blk);
	     end;
	end;

/* If the block has multiple return types create an assignment to the
 * automatic integer to identify which type is required when returning
 * from an invocation of the this entry.  Entries which do not return
 * values set the variable to zero.
 */

	if blk -> block.return_count ^= null then do;
	     if orig_stmnt_ptr -> statement.labels -> list.element (2) -> reference.symbol -> symbol.dcl_size = null
		then
		a = null;				/* from here on we want a to be the return value; if none, a = null	*/

	     i = 0;
	     b = blk -> block.return_values;

	     do while (b ^= null);
		if b -> list.element (2) = a then
		     goto hit;
		b = b -> list.element (1);
		i = i + 1;
	     end;
hit:
	     call make (2, assign, (blk -> block.return_count), declare_constant$integer (i), null);

/* The following call is because operator_semantics is the only person in
 * the compiler who makes an assign of zero into a store zero, for better code
 */

	     if i = 0 then
		stmnt -> statement.root = operator_semantics (blk, stmnt, (stmnt -> statement.root), this_context);
	end;

/* create an execute prologue operator. */

	call make (0, ex_prologue, null, null, null);

	pl1_stat_$cur_statement = stmnt;

	goto ret;
%page;
/*
 * This code is executed for the return_value operator
 * and also the std_return operator.
 */
action (11):
	signal_stmnt_ptr = null;

	if stmnt -> statement.statement_type = end_statement then do;
	     if blk -> block.block_type = begin_block | blk -> block.block_type = on_unit then
		goto ret;
	     end_statement_flag = TRUE;
	end;
	else
	     end_statement_flag = FALSE;

/* The following test checks for the case of an unreachable end
 * statement. We do not want to produce any checks for return value
 * compatablility; indeed we want to do as little as possible because the
 * optimizer and code generator will make it produce NO code, anyway.
 */

	if pl1_stat_$stmnt_unreachable then
	     if stmnt -> statement.labels = null then
		if end_statement_flag then
		     goto ret;

	if tree -> operator.op_code = return_value then
	     e = tree -> operand (1);
	else
	     e = null;

	do bb = blk repeat bb -> block.father while (bb -> block.block_type = begin_block);
	end;

	a = bb -> block.return_values;
	if a ^= null then				/* will be null if block entry was multiply declared */
	     if bb -> block.return_count = null & a -> list.element (2) = null then
		if e = null then
		     goto ret;
		else
		     call semantic_translator$abort (53, null);

	stmnt -> statement.statement_type = null_statement;
	stmnt -> statement.generated = TRUE;

	tree = null;

	i = 0;
	jump_stmnt, next = null;

	if bb -> block.return_count ^= null then
	     if e ^= null then
		call prepare (e);

	first_time = TRUE;
	after_ret = stmnt -> statement.next;
	pl1_stat_$multi_type = bb -> block.return_count ^= null;
	if pl1_stat_$multi_type then do;
	     hold_abort_label = pl1_stat_$abort_label;	/* pl1_stat_$abort_label is used in other */
	     pl1_stat_$abort_label = continue;		/* programs and must be saved & restored. */
	end;

	do a = a repeat a -> element (1) while (a ^= null);
	     pl1_stat_$error_flag = FALSE;
	     if pl1_stat_$multi_type then
		if a -> element (1) ^= null then do;
		     next = create_list (2);
		     next -> list.element (2) = create_label (blk, null, by_compiler);
		     call make (3, jump_if_ne, (next -> list.element (2)), (bb -> block.return_count),
			declare_constant$integer (i));
		     last_jump = jump_stmnt;
		     jump_stmnt = stmnt;
		end;
		else
		     next = null;			/* if no next element, there is no need for a 	*/
						/* compare because the indeces MUST be equal, since	*/
						/* all the previous tests must have failed and	*/
						/* there are no more possibilities.	*/
	     first = stmnt;
	     last = stmnt -> statement.next;

/*
 * The following code handles the case of "return;", where there is no
 * return value.
 */

	     if e = null then
		if a -> list.element (2) = null then do;
		     call make (0, std_return, null, null, null);
		     goto end_of_ret_assignment_loop;
		end;
		else do;
		     if pl1_stat_$multi_type | end_statement_flag then
			goto make_signal_statement;
		     else
			call semantic_translator$abort (356, null);
		end;

/* the following handles the case of "return(value);" where the
 * entry entered through expected NO return_value, but just a
 * simple "return;"
 */

	     if a -> list.element (2) = null then
		goto make_signal_statement;

/* The rest of the loop handles the case of "return(value);" where
 * the entry did expect a return_value.
 */

	     ref = a -> list.element (2);
	     b = create_operator (assign, 2);
	     b -> operand (1) = copy_expression (ref -> symbol.reference);
	     b -> operand (1) = expression_semantics (blk, stmnt, (b -> operand (1)), this_context);

	     if first_time then
		b -> operand (2) = e;
	     else
		b -> operand (2) = copy_ref (e);

	     first_time = FALSE;

	     def_this_context.return = TRUE;
	     def_this_context.RHS_aggregate = ref -> symbol.structure | ref -> symbol.reference -> reference.array_ref;

	     if ref -> symbol.structure | ref -> symbol.dimensioned then do;
		stmnt = stmnt -> statement.next;
		b = expand_assign (blk, stmnt, b, this_context, null);
		stmnt = stmnt -> statement.back;

		if ref -> symbol.star_extents then do;
		     if b -> node.type = operator_node then do;
			es = b -> operand (1) -> reference.symbol;
			qq = b -> operand (1) -> reference.qualifier;
		     end;
		     else
			es = b -> reference.symbol;

		     if es -> symbol.packed then do;
			opcode = return_bits;
			if es -> symbol.bit_size = null then
			     size = declare_constant$integer ((es -> symbol.c_bit_size));
			else
			     size = es -> symbol.bit_size;
		     end;
		     else do;
			opcode = return_words;
			if es -> symbol.word_size = null then
			     size = declare_constant$integer ((es -> symbol.c_word_size));
			else
			     size = es -> symbol.word_size;
		     end;

		     size = copy_expression ((size));

		     if es -> symbol.refer_extents then
			call refer_extent (size, qq);

		     size = expression_semantics (blk, stmnt, size, this_context);

		     call make (2, (opcode), b, size, null);
						/* by value for efficiency */
		end;
		else
		     call make (0, std_return, null, null, null);

		goto continue;
	     end;

	     if def_context.aggregate then
		call semantic_translator$abort (50, null);

	     b = operator_semantics (blk, stmnt, b, this_context);

	     if ref -> symbol.star_extents then do;
		if b -> node.type = operator_node & b -> op_code = assign then do;
		     do qq = b -> operand (2) repeat qq -> operand (1) while (qq -> node.type = operator_node);
		     end;

		     if qq -> reference.symbol -> symbol.char then
			b = b -> operand (2);
		end;

		call make (2, return_string, b, null, null);
	     end;
	     else do;

/* Place the output of operator semantics directly into the statement.
 * Since the operator may be assign (2 operands) or
 * ptr_fun|off_fun (3 operands), we cannot use the internal procedure "make".
 */

		qq = create_statement (assignment_statement, stmnt, null, (stmnt -> statement.prefix));
		qq -> statement.generated = TRUE;
		qq -> statement.root = b;
		if pl1_stat_$multi_type then
		     qq -> statement.suppress_warnings = TRUE;
		stmnt = stmnt -> statement.next;
		call make (0, std_return, null, null, null);
	     end;

continue:
	     if pl1_stat_$error_flag then do;
make_signal_statement:
		qq = first -> statement.next;

		do while (qq ^= last);
		     qq = qq -> statement.next;
		     call free_node ((qq -> statement.back));
		end;

		first -> statement.next = last;
		if last ^= null then
		     last -> statement.back = first;

		if signal_stmnt_ptr = null then do;
		     qq = create_token ("return_conversion_error", identifier);

		     if qq -> token.declaration = null then do;
			ref = create_symbol (pl1_stat_$root, qq, by_compiler);
			ref -> symbol.condition = TRUE;
			call declare (ref);
		     end;
		     else
			ref = qq -> token.declaration;

		     stmnt = create_statement (signal_statement, first, null, (first -> statement.prefix));
		     stmnt -> statement.root = create_operator (signal_on, 2);
		     stmnt -> statement.root -> operand (1) = ref -> symbol.reference;
		     label_attached = FALSE;
		     signal_stmnt_ptr = stmnt;

/* now generate a garbage return, which can never be executed because this
 * signal never returns, but which is used to tell the cg that there is
 * no fall-through here, so you dont have to reload regs.
 */

		     call make (0, std_return, null, null, null);
		end;
		else do;
		     if ^label_attached then do;
			qq = create_list (2);
			qq -> element (2) = create_label (blk, null, by_compiler);
			qq -> element (2) -> label.statement = signal_stmnt_ptr;
			signal_stmnt_ptr -> statement.reference_count = 1;
			signal_stmnt_ptr -> statement.labels = qq;

/* from now on signal_stmnt_ptr points to the label of the stmnt to raise
 * the conv error, whereas previously it pointed to the statement itself.
 */

			signal_stmnt_ptr = qq -> list.element (2);
			label_attached = TRUE;
		     end;

/* We would like to do some optimizations which are
 * only valid if we previously generated a jump_if_ne and if
 * we are the last entry point conversion being processed.
 */

		     if jump_stmnt = null | a -> element (1) ^= null then do;
			stmnt = create_statement (goto_statement, first, null, (first -> statement.prefix));
			stmnt -> statement.root = create_operator (jump, 1);
			stmnt -> statement.root -> operator.operand (1) = signal_stmnt_ptr;
			signal_stmnt_ptr -> label.statement -> statement.reference_count =
			     signal_stmnt_ptr -> label.statement -> statement.reference_count + 1;
		     end;
		     else if jump_stmnt -> statement.root -> operand (1) -> label.statement = stmnt then do;
			if jump_stmnt -> statement.next -> statement.statement_type = goto_statement then
			     if jump_stmnt -> statement.next -> statement.root -> operand (1) -> label.statement
				-> statement.statement_type = signal_statement then do;

/* This block of code is for the sole purpose of optimizing
 * the case where the end of the statement looks like:
 *		jump to l1 if ^= 2
 *		do conversion
 *	l1:	jump to l2 if ^= 1
 *		goto <raise signal>
 *	l2:	goto <raise signal>
 *
 * and changing it to look like:
 * 		jump to <raise_signal> if ^= 2
 * 		do conversion
 *				
 * which is of course vastly preferable code.
 */

				last_jump -> statement.root -> operand (1) = signal_stmnt_ptr;
				if after_ret ^= null then
				     after_ret -> statement.back = jump_stmnt -> statement.back;
				jump_stmnt -> statement.back -> statement.next = after_ret;

/* we needn't reset ptrs cause we can never reenter loop */

				stmnt = jump_stmnt -> statement.back;
			     end;
			     else
				goto normal_sig;
			else
			     goto normal_sig;
		     end;
		     else do;
normal_sig:
			jump_stmnt -> statement.root -> operator.operand (1) = signal_stmnt_ptr;
			signal_stmnt_ptr -> label.statement -> statement.reference_count =
			     signal_stmnt_ptr -> label.statement -> statement.reference_count + 1;
			jump_stmnt, next = null;
		     end;
		end;
	     end;

end_of_ret_assignment_loop:
	     i = i + 1;

	     if next ^= null then do;
		call make (0, null_statement, next, null, null);
		stmnt -> statement.save_temps = TRUE;
	     end;
	end;

	if pl1_stat_$multi_type then
	     pl1_stat_$abort_label = hold_abort_label;

	pl1_stat_$multi_type = FALSE;
	pl1_stat_$cur_statement = stmnt;

	goto ret;
%page;
/*
 * This code is executed for operators whose operands must be binary integers
 * and whose output is a binary integer.
 */
action (12):
	do i = 2 to k;
	     tree -> operand (i) = convert$to_integer ((tree -> operand (i)), integer_type);
	end;

	result_type = integer_type;
	m = default_fix_bin_p;
	goto create_temp;
%page;
/*
 * This code is executed for operators whose operands must be integers
 * but whose output can be anything.
 */
action (13):
	do i = 2 to k;
	     tree -> operand (i) = convert$to_integer ((tree -> operand (i)), integer_type);
	end;
	goto ret;
%page;
/*
 * This code is executed for operators whose operands can be anything
 * but whose result is a binary integer.
 */
action (14):
	result_type = integer_type;
	m = max_offset_precision;
	goto create_temp;
%page;
/*
 * This code is executed for operators whose operands can be anything
 * but whose result is a pointer.
 */
action (15):
	result_type = pointer_type;
	goto create_temp;
%page;
/*
 * This code is executed for I/O operators.
 */
action (16):
	call io_semantics (blk, stmnt, tree);

	goto ret;
%page;
/*
 * This code is executed for DO operators.
 */
action (17):
	call do_semantics (blk, stmnt, tree);
	tree = null;

	goto ret;
%page;
/*
 * This code is executed for allocate and free operators.
 */
action (18):
	call alloc_semantics (blk, stmnt, tree);
	goto ret;
%page;
/*
 * This code is executed for mod_bit, mod_byte, mod_half, and
 * for mod_word operators.
 */
action (19):
	do i = 1 to 2;
	     tree -> operand (i) = declare_temporary (integer_type, default_fix_bin_p, 0, null);
	end;
	goto ret;
%page;
/*
 * This code is executed for the loop operator
 */
action (20):
	if tree -> operand (1) -> node.type = token_node then do;
	     string (atype) = decoded_type (fixed (tree -> operand (1) -> token.type));
	     tree -> operand (1) = convert ((tree -> operand (1)), string (atype));
	end;

	do i = 3 to 4;
	     tree -> operand (i) = convert$to_integer ((tree -> operand (i)), integer_type);
	end;

	goto ret;
%page;
/*
 * This code is required for on-, revert-, and signal-statements
 */
action (21):
	if tree -> operand (1) -> node.type = label_node then
	     call semantic_translator$abort (78, null);

	if ^tree -> operand (1) -> reference.symbol -> symbol.condition then
	     call semantic_translator$abort (268, (tree -> operand (1)));

	if tree -> operand (2) ^= null then
	     if tree -> operand (2) -> node.type = label_node then
		call semantic_translator$abort (78, null);
	     else if ^tree -> operand (2) -> reference.symbol -> symbol.file then
		call semantic_translator$abort (477, (tree -> operand (2)));

	if opcode = enable_on then
	     do e = blk repeat e -> block.father while (e ^= null);
		e -> block.flush_at_call = TRUE;
	     end;

	if opcode = signal_on then do;
	     qq = tree -> operand (1) -> reference.symbol -> symbol.general -> reference.symbol;
	     cond_name = substr (qq -> symbol.initial -> based_char, 1, qq -> symbol.c_dcl_size);

	     do i = 1 to 19;
		if condition_name (i) = cond_name then do;
		     if i > 10 then
			i = i - 10;
		     if substr (stmnt -> statement.prefix, i, 1) = "0"b then do;
			tree = create_operator (nop, 0);
			stmnt -> statement.statement_type = null_statement;
			goto ret;
		     end;
		end;
	     end;
	end;

	else do;
	     blk -> block.why_nonquick.condition_statements = TRUE;
	     blk -> block.no_stack = FALSE;
	end;

	goto ret;
%page;
/*
 * This code is executed by almost everybody.
 */
create_temp:
	tree -> operand (1) = declare_temporary (result_type, m, n, size);
	goto ret;
%page;
/*
 * subroutine to make an operator and a statement.
 */
make:
     procedure (n, code, a, b, c);

	dcl      n fixed bin (15) parameter;
	dcl      code bit (9) aligned parameter;
	dcl      (a, b, c) ptr parameter;

	dcl      (labels, p, q) ptr;
	dcl      stype bit (9) aligned;

	p, labels = null;
	stype = assignment_statement;
	if code = jump_if_ne then
	     stype = if_statement;
	else if code = jump then
	     stype = goto_statement;
	else if code = return_string | code = return_bits | code = return_words | code = std_return then
	     stype = return_statement;

	if code = null_statement then do;
	     stype = code;
	     labels = a;
	end;
	else do;
	     p = create_operator (code, n);
	     if n > 0 then
		p -> operand (1) = a;
	     if n > 1 then
		p -> operand (2) = b;
	     if n > 2 then
		p -> operand (3) = c;
	end;

	q = create_statement (stype, stmnt, labels, (stmnt -> statement.prefix));

	q -> statement.generated = TRUE;

	if code = null_statement then
	     if labels ^= null then do;
		labels -> list.element (2) -> label.statement = q;
		q -> statement.reference_count = 2;
	     end;
	     else if pl1_stat_$multi_type then
		q -> statement.suppress_warnings = TRUE;

	q -> statement.root = p;
	stmnt = stmnt -> statement.next;

     end make;
%page;
/*
 * subroutine to force the proper conversions of relational operators.
 */
convert_relationals:
     procedure ();

	dcl      i fixed bin (15);

	if b -> node.type = label_node then
	     if c -> node.type = label_node then
		return;
	     else if ctype.label then
		return;
	     else
		call semantic_translator$abort (229, null);
	if c -> node.type = label_node then
	     if b -> node.type = label_node then
		return;
	     else if btype.label then
		return;
	     else
		call semantic_translator$abort (229, null);
	if btype.area | ctype.area then
	     call semantic_translator$abort (51, null);
	if btype.ptr & ctype.offset then do;
	     tree -> operand (3) = convert ((tree -> operand (3)), pointer_type);
	     tree -> operand (3) -> operator.processed = FALSE;
	     tree -> operand (3) = operator_semantics (blk, stmnt, (tree -> operand (3)), "0"b);
	     tree -> operand (3) -> operator.processed = TRUE;
	     return;
	end;
	if btype.offset & ctype.ptr then do;
	     if c -> symbol.constant then do;

/* convert "null" to "nullo" */

		i = -1;
		tree -> operand (3) = declare_constant (unspec (i), offset_mask, 0, 0);
	     end;
	     else do;
		tree -> operand (2) = convert ((tree -> operand (2)), pointer_type);
		tree -> operand (2) -> operator.processed = FALSE;
		tree -> operand (2) = operator_semantics (blk, stmnt, (tree -> operand (2)), "0"b);
		tree -> operand (2) -> operator.processed = TRUE;
	     end;
	     return;
	end;

picture_redo:
	if btype.bit & ctype.bit then
	     goto conv;
	if btype.char & ctype.char then
	     goto conv;
	if btype.bit & ctype.char then do;
	     string (btype) = string (btype) & ^bit_mask | char_mask;
	     goto conv;
	end;
	if btype.char & ctype.bit then do;
	     string (ctype) = string (ctype) & ^bit_mask | char_mask;
	     goto conv;
	end;
	if (btype.bit | btype.char) & (ctype.fixed | ctype.float) then do;
	     string (btype) = string (ctype);
	     goto conv;
	end;
	if (ctype.bit | ctype.char) & (btype.fixed | btype.float) then do;
	     string (ctype) = string (btype);
	     goto conv;
	end;

	if btype.picture then do;
	     if b -> symbol.pic_char then
		string (btype) = char_mask;
	     else if b -> symbol.complex then
		if b -> symbol.pic_float then
		     string (btype) = float_decimal_complex_mask;
		else
		     string (btype) = fixed_decimal_complex_mask;
	     else if b -> symbol.pic_float then
		string (btype) = float_decimal_real_mask;
	     else
		string (btype) = fixed_decimal_real_mask;

	     goto picture_redo;
	end;

	if ctype.picture then do;
	     if c -> symbol.pic_char then
		string (ctype) = char_mask;
	     else if c -> symbol.complex then
		if c -> symbol.pic_float then
		     string (ctype) = float_decimal_complex_mask;
		else
		     string (ctype) = fixed_decimal_complex_mask;
	     else if c -> symbol.pic_float then
		string (ctype) = float_decimal_real_mask;
	     else
		string (ctype) = fixed_decimal_real_mask;

	     goto picture_redo;
	end;

	if btype.binary & ctype.decimal then
	     string (ctype) = string (ctype) & ^decimal_mask | binary_mask | aligned_mask;
	if btype.decimal & ctype.binary then
	     string (btype) = string (btype) & ^decimal_mask | binary_mask | aligned_mask;
	if btype.binary then do;
	     if btype.fixed & ctype.float then
		string (btype) = string (btype) & ^fixed_mask | float_mask | aligned_mask;
	     if btype.float & ctype.fixed then
		string (ctype) = string (ctype) & ^fixed_mask | float_mask | aligned_mask;
	end;
	if btype.complex then
	     string (ctype) = string (ctype) & ^real_mask | complex_mask;
	if ctype.complex & ^btype.complex then
	     string (btype) = string (btype) & ^real_mask | complex_mask;

	if index (string (btype), "1"b) ^= index (string (ctype), "1"b) & ^(btype.decimal & ctype.decimal) then
	     call semantic_translator$abort (186, null);

conv:
	if index (string (btype), "1"b) > 5 | btype.complex then
	     if opcode ^= equal & opcode ^= not_equal & opcode ^= jump_if_eq & opcode ^= jump_if_ne then
		call semantic_translator$abort (198, null);

	call converter;

     end convert_relationals;
%page;
/*
 * subroutine to force a conversion.
 * and set the strings "btype" and "ctype" accordingly
 */
converter:
     procedure ();

	dcl      r ptr;

	if k > 1 then do;
	     if tree -> operand (2) -> node.type = token_node then
		tree -> operand (2) = convert ((tree -> operand (2)), string (btype));
	     else if btype.decimal & b -> symbol.decimal then
		;
	     else if btype.binary & b -> symbol.binary & btype.real = b -> symbol.real & btype.fixed = b -> symbol.fixed
		then
		;
	     else do;
		if (string (btype) & arithmetic_mask) ^= "0"b then
		     string (btype) = string (btype) & ^unaligned_mask | aligned_mask;
		tree -> operand (2) = convert ((tree -> operand (2)), string (btype));
	     end;

	     r = tree -> operand (2);
	     if r -> node.type = operator_node then
		r = r -> operand (1);

	     b = r -> reference.symbol;
	end;

	if k > 2 then do;
	     if tree -> operand (3) -> node.type = token_node then
		tree -> operand (3) = convert ((tree -> operand (3)), string (ctype));
	     else if ctype.decimal & c -> symbol.decimal then
		;
	     else if ctype.binary & c -> symbol.binary & ctype.real = c -> symbol.real & ctype.fixed = c -> symbol.fixed
		then
		;
	     else do;
		if (string (ctype) & arithmetic_mask) ^= "0"b then
		     string (ctype) = string (ctype) & ^unaligned_mask | aligned_mask;
		tree -> operand (3) = convert ((tree -> operand (3)), string (ctype));
	     end;

	     r = tree -> operand (3);
	     if r -> node.type = operator_node then
		r = r -> operand (1);

	     c = r -> reference.symbol;
	end;

     end converter;
%page;
/*
 * subroutine to extract pointers to the first 1 2 or 3 operand's symbol nodes
 */
extract:
     procedure ();

	if k > 0 then do;
	     a = tree -> operand (1);

	     if a ^= null then do;
		if a -> node.type = operator_node then
		     a = a -> operand (1);

		if a -> node.type = token_node then
		     string (atype) = decoded_type (fixed (a -> token.type));

		if a -> node.type = label_node then
		     string (atype) = "0"b;

		if a -> node.type = reference_node then do;
		     a = a -> reference.symbol;
		     if a -> node.type = symbol_node then
			string (atype) = string (a -> symbol.attributes) & ^dimensioned_mask;
		     else
			string (atype) = "0"b;
		end;

		if a -> node.type = symbol_node then
		     if atype.arg_descriptor & opcode ^= assign & opcode ^= make_desc then do;
			qq = create_operator (assign, 2);
			qq -> operand (1) = declare_temporary (integer_type, default_fix_bin_p, 0, null);
			qq -> operand (2) = tree -> operand (1);
			qq -> operator.processed = TRUE;

			a = qq -> operand (1) -> reference.symbol;
			string (atype) = integer_type;
			tree -> operand (1) = qq;
		     end;
	     end;
	end;

	if k > 1 then do;
	     b = tree -> operand (2);

	     if b ^= null then do;
		if b -> node.type = operator_node then
		     b = b -> operand (1);

		if b -> node.type = token_node then
		     if b -> token.type = dec_integer & k > 2 then
			string (btype) = dec_integer_type;
		     else
			string (btype) = decoded_type (fixed (b -> token.type));

		if b -> node.type = label_node then
		     string (btype) = "0"b;

		if b -> node.type = reference_node then do;
		     b = b -> reference.symbol;
		     string (btype) = string (b -> symbol.attributes) & ^dimensioned_mask;
		end;

		if b -> node.type = symbol_node then
		     if btype.arg_descriptor & opcode ^= assign & opcode ^= make_desc then do;
			qq = create_operator (assign, 2);
			qq -> operand (1) = declare_temporary (integer_type, default_fix_bin_p, 0, null);
			qq -> operand (2) = tree -> operand (2);
			qq -> operator.processed = TRUE;

			b = qq -> operand (1) -> reference.symbol;
			string (btype) = integer_type;
			tree -> operand (2) = qq;
		     end;
	     end;
	end;

	if k > 2 then do;
	     c = tree -> operand (3);

	     if c ^= null then do;
		if c -> node.type = operator_node then
		     c = c -> operand (1);

		if c -> node.type = token_node then
		     if c -> token.type = dec_integer then
			string (ctype) = dec_integer_type;
		     else
			string (ctype) = decoded_type (fixed (c -> token.type));

		if c -> node.type = label_node then
		     string (ctype) = "0"b;

		if c -> node.type = reference_node then do;
		     c = c -> reference.symbol;
		     string (ctype) = string (c -> symbol.attributes) & ^dimensioned_mask;
		end;

		if c -> node.type = symbol_node then
		     if ctype.arg_descriptor & opcode ^= assign & opcode ^= make_desc then do;
			qq = create_operator (assign, 2);
			qq -> operand (1) = declare_temporary (integer_type, default_fix_bin_p, 0, null);
			qq -> operand (2) = tree -> operand (3);
			qq -> operator.processed = TRUE;

			c = qq -> operand (1) -> reference.symbol;
			string (ctype) = integer_type;
			tree -> operand (3) = qq;
		     end;
	     end;
	end;

     end extract;
%page;
/*
 * This procedure creates a separate assignment statement for an operator,
 * if it finds one, in the expression to be returned, because that is
 * the only way to force the order of evaluation so that the expression
 * will be eval'ed before the tests which determine which assignment,
 * in the case of multiple return statements and entry points are made.
 */
prepare:
     procedure (pt);

	dcl      pt ptr parameter;
	dcl      p ptr;

	p = pt;

	if p -> node.type = operator_node then do;
	     if p -> op_code = param_ptr | p -> op_code = param_desc_ptr then
		return;

	     stmnt = create_statement (assignment_statement, stmnt, null, (stmnt -> statement.prefix));
	     stmnt -> statement.root = share_expression (p);
	end;
	else do;
	     if p -> node.type ^= reference_node then
		return;

	     if p -> reference.qualifier ^= null then
		call prepare ((p -> reference.qualifier));

	     if p -> reference.offset ^= null then
		call prepare ((p -> reference.offset));

	     if p -> reference.length ^= null then
		call prepare ((p -> reference.length));
	end;

     end prepare;
%page;
copy_ref:
     procedure (pt) returns (ptr);

	dcl      pt ptr parameter;
	dcl      (p, q) ptr;


/* If the input is an unshared reference, get a unique value,
 * otherwise, use share_expression
 */

	p = pt;

	if p -> node.type = reference_node then do;
	     if p -> reference.shared then
		return (p);

	     q = create_reference (null);
	     q -> reference = p -> reference;
	     q -> reference.ref_count = 1;

	     if q -> reference.qualifier ^= null then
		q -> reference.qualifier = share_expression ((q -> reference.qualifier));
	     if q -> reference.offset ^= null then
		q -> reference.offset = share_expression ((q -> reference.offset));
	     if q -> reference.length ^= null then
		q -> reference.length = share_expression ((q -> reference.length));

	     return (q);
	end;

	else
	     return (share_expression (p));

     end copy_ref;
%page;
/*
 * subroutine to create a length_fun operator and return a ptr to it
 */
create_length_fun:
     procedure (op2) returns (ptr);

	dcl      op2 pointer parameter;
	dcl      p pointer;

	p = create_operator (length_fun, 2);
	p -> operand (1) = declare_temporary (integer_type, max_length_precision, 0, null);
	p -> operand (2) = share_expression (op2);
	return (p);
     end create_length_fun;
%page;

ret:
	if tree ^= null then
	     if tree -> node.type = operator_node then
		tree -> operator.processed = TRUE;

	return (tree);
%page;
/*
 * get the initial value of a fixed binary variable with a scale
 * factor of zero
 */
constant_value:
     procedure (sym_ptr) returns (fixed bin (71));

	dcl      sym_ptr ptr parameter;

	dcl      integer_1 based fixed bin (35);
	dcl      integer_2 based fixed bin (71);
	dcl      initial_value fixed bin (71);

	if sym_ptr -> symbol.c_dcl_size > max_p_fix_bin_1 then
	     initial_value = sym_ptr -> symbol.initial -> integer_2;
	else
	     initial_value = sym_ptr -> symbol.initial -> integer_1;

	return (initial_value);

     end constant_value;
%page;
%include condition_name;
%page;
%include semant;
%page;
%include array;
%page;
%include symbol;
%page;
%include pl1_symbol_type;
%page;
%include symbol_bits;
%page;
%include operator;
%page;
%include mask;
%page;
%include label;
%page;
%include list;
%page;
%include block;
%page;
%include block_types;
%page;
%include statement;
%page;
%include reference;
%page;
%include semantic_bits;
%page;
%include op_codes;
%page;
%include statement_types;
%page;
%include nodes;
%page;
%include system;
%page;
%include token;
%page;
%include token_types;
%page;
%include declare_type;
%page;
%include decoded_token_types;
%page;
%include jump_complement;
%page;
%include pl1_descriptor;

     end operator_semantics;
