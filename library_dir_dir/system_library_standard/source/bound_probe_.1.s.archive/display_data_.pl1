

/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(1988-05-20,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Modified code in the internal procedure 'set_globals_for_probe' to allow
     more than one level of indirection to be printed. Modified the internal
     procedure 'get_symbol_name' to return a null string if the first character
     in the name is a !.  Modified the internal procedure 'do_symbol_and_sons'
     to print a single value if the 'son_ptr' is not null, the symbol type is
     pointer and the language is C.
  2) change(1988-05-20,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Changed code in the internal proc 'set_globals_for_probe' to allow
     various levels of C_INDIRECTION to be printed. Changed code in the
     internal proc 'do_symbol_and_sons' to print only one symbol if:
       A) the 'son_ptr' is not null,
       B) the symbol type is pointer and
       C) the language is C.
     Modified the internal proc 'get_symbol_name' to strip off any leading
     underscores in the symbol name.
  3) change(1988-05-27,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Added code to test the reference node field 'subscript_ptr' for a
     null value. This pointer is set to null when the reference node
     represents the result of the & operator in C.
  4) change(1988-06-01,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Changed 'get_string_info' to get the number of characters to be printed.
     The length is determined by the character offset of the first null
     character relative to the address supplied. If a null is not encountered
     within the first 256 characters, 256 is used.
  5) change(1988-07-20,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Modified 'get_value_info' to compute the offset of a structure element
     and add it to the base address.
  6) change(1988-07-20,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     The 'globals.calculate_address' value is always set to "0"b in
     'set_globals_for_probe'.
  7) change(1988-08-15,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Added code in 'get_value_info' to compute and add the offset of each array
     element for symbols occuring within structures or unions but being
     printed individually.
  8) change(1988-08-26,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Added enum type support by including the procedure 'display_c_enum'.
  9) change(1988-08-26,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Added support for subranges of aggregates.
 10) change(1988-09-07,WAAnderson), approve(1988-09-30,MCR7952),
     audit(1988-09-30,JRGray), install(1988-10-24,MR12.2-1184):
     Added format control comment to make the source more readable.
 11) change(1988-10-28,WAAnderson), approve(1988-10-28,MCR7952),
     audit(1988-11-03,RWaters), install(1988-11-11,MR12.2-1210):
     Added code to evaluate character pointers as described in the MTB.
     
     Consider the following declaration:
     
      char *ptr;
     
     The following are possible references to the pointer 'ptr' and the
     manner in which the reference is interpreted by probe:
     
     *ptr      - refers to a single character at the address specified
                 by the contents of 'ptr'.
      ptr      - refers to the address in 'ptr'.
      ptr[]    - refers to the contiguous series of characters beginning
                 with the character specified by the address in 'ptr'
                 and ending with the first occurence of a null.
      ptr[N]   - refers to the single character whose address is computed
                 by taking the contents of 'ptr' and adding N bytes to that
                 address.
      ptr[N:M] - refers to the characters from ptr+N to ptr+M where
                 N and M are byte offsets.
 12) change(1988-10-28,WAAnderson), approve(1988-10-28,MCR7952),
     audit(1988-11-03,RWaters), install(1988-11-11,MR12.2-1210):
     Took the code immediately following the 'for_probe' entrypoint and made it
     an internal procedure.  Now the 'for_azm' and 'for_probe' entrypoints both
     call this procedure. The 'for_azm' entrypoint passes a flag that indicates
     the only action to take is initialize the variables referenced throughout
     display_data_.  The new procedure is called 'common_c_setup'.
 13) change(2017-02-23,GDixon), approve(2017-02-23,MCR10035),
     audit(2017-02-28,Swenson), install(2017-02-28,MR12.6f-0022):
     Change order of initialization to prevent display_data_$for_azm from using
     code that references parameters passed only to the $for_probe entrypoint.
     An example is the Preference parameter.  Code paths remain that are shared
     by both entrypoints, and uses the Preference parameter.  Most of these are
     protected by if expressions that fail when the $for_azm entrypoint was
     called.  All references to probe_info.xxx were removed from shared code
     paths.  For example, probe_info.language_type was replaced by
     global.language_type in all code paths.  The two entrypoints are supposed
     to copy pertinent parameter information into the global structure, so that
     shared code paths are not referencing through undefined parameters. A few
     earlier changes to code did not follow this rule.
                                                   END HISTORY COMMENTS */

/* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

display_data_:
  proc ();

  return;

  /* *	DISPLAY_DATA_ -- Display data according to runtime symbol table info.
   *	  $FOR_PROBE  -- Display all Multics language datatypes, for use by 
   *                       probe.
   *	  $FOR_AZM    -- Display PL/I datatypes, for use by analyze_multics,
   *		       providing specialized interpretations as 
   *                       appropriate.
   *
   *      Modification history:
   *	04 Mar 85, Steve Herbst: 
   *         Fixed some string-formatting bugs and reinstated printing fb>52 as
   *	   dtm for azm.
   *	27 Feb 85, Steve Herbst:
   *         Fixed to print null string as "".
   *	29 Nov 84, Steve Herbst:
   *	   Fixed to handle "size" by skipping to next structure element.
   *	16 Jul 84, S. Herbst: 
   *	   Fixed $for_azm to set global.azm_info_ptr from input arg
   *	   (ala azm_display_data_).
   *	24 Jun 84, B. Braun: 
   *	   Fixed bug incorrectly reporting the base addr of a substructure.
   *	21 May 84, S. Herbst: 
   *	   "modes truncate_strings", do truncation & trimming to all lang
   *	   strings.
   *	09 Feb 84, S. Herbst:
   *	   Changed to handle hexfp, extended, generic types.
   *	02 Nov 83, S. Herbst: 
   *	   Fixed bug that reversed array indices while printing.
   *	11 Oct 83, S. Herbst:
   *	   Changed algorithm for printing duplicate array elements -
   *	   "A (n) and/through A (m) = value"
   *	06 Oct 83, S. Herbst:
   *         Added version strings to runtime_symbol_info_ structures.
   *      14 Aug 83, WOS:
   *         Retrofitted Pascal changes into display_data_. Required fixing
   *	   all places where "constant" symbols might be referenced to check
   *	   for value_symbol_ptr = null.
   *      03 Aug 83, WOS:
   *	   Renamed entypoints to display_data_$for_probe, $for_azm.
   *      20 Jun 83, J. M. Athane: 
   *	   Modified for Pascal (as probe_print_value_).  Calls
   *	   probe_print_pascal_$value for typical Pascal values.  Uses
   *	   runtime_symbol_info_ subroutine instead of runtime_symbol 
   *	   structure.
   *	11 Jun 83, WOS: 
   *	   Added "apropos" feature (matching names)
   *      10 Jun 83, WOS: 
   *	   Added bit(1) summary output for azm, fixed integers to display
   *	   with full precision, added clock heuristic for azm and long
   *	   integers.
   *      09 Jun 83, WOS: 
   *	   Added compact output mode for azm.
   *	04 Jun 83, WOS: 
   *	   Added duplicate suppression for arrays.
   *      02 Jun 83, WOS: 
   *	   Merged constant printing back into main line so constants could
   *	   be printed using the usual heuristics.
   *	01 Jun 83, WOS: 
   *         Clever (octal/hex) bitstring printer.
   *	31 May 83, WOS: 
   *	   Converted to display_data_ for analyze_multics.
   *      01 Jan 83, S. Herbst: 
   *	   Limit string printout to 200 characters.
   * 	27 Jul 82, S. Herbst: 
   *	   Diagnose zero extent arrays.
   *	26 Apr 82, S. Herbst: 
   *	   Display strings properly for Fortran (using " or ').
   *	17 Dec 81, S. Herbst: 
   *	   Check for overlength (out of bounds) string lengths.
   * 	28 Sep 81, S. Herbst:
   *	   Diagnose invalid refer extents (<= 0).
   *      09 Sep 81, S. Herbst: 
   *	   Print formerly inhibited subscripts for non-top-level structure
   *	   references.
   * 	24 Aug 81, Steve Herbst:
   *	   Requote character strings, fix bugs.
   * 	31 Jul 81, Melanie B. Weaver:
   *	   Print names of algol68 data types.
   *      15 Sep 79, JRD:
   *	   Treat constants differently from symbols, COBOL fixes, allow
   *         negative scale factor.
   *	12 Jul 79, JRD: 
   *	   For 4.2 probe.
   *      01 Jun 79, JRD: 
   *	   Abbreviate [pd] for pointers.
   *      08 Mar 79, JRD: 
   *	   Remember that precision of strings may exceed 16383.
   * 	12 Jan 79, JRD: 
   *	   First real probe version.
   *      22 Sep 78, James R. Davis:
   *	   Initial coding.
   */

  dcl P_iocb_ptr		parameter pointer;
  dcl P_display_format	parameter bit (*) aligned;
  dcl P_match_names		(*) parameter char (*) varying;
  dcl P_match_name_count	parameter fixed bin;
  dcl P_amu_info_ptr	parameter pointer;
  dcl P_data_ptr		parameter pointer;
  dcl P_data_size		parameter fixed bin (18);
  dcl P_start_ptr		parameter pointer;
  dcl P_symbol_ptr		parameter pointer;
  dcl P_subscripts		(2, *) parameter fixed bin (24);
  dcl P_n_subscripts	parameter fixed bin;
  dcl P_code		parameter fixed bin (35);
  dcl P_probe_info_ptr	parameter pointer;
  dcl 1 P_reference		parameter aligned like reference_node;

  dcl STRING_LIMIT		fixed bin internal static
			options (constant) init (200);
  dcl MINIMUM_TRIM		fixed bin internal static
			options (constant) init (20);

  dcl 1 global		aligned automatic,
				/* Global info for internal procedures */
       2 output_info	aligned,	/* Info about output format */
        3 output_switch	pointer init (null ()),
				/* Switch for printing */
        3 line_length	fixed bin init (72),
				/* max length of output lines */
        3 short_names	bit (1) aligned init ("0"b),
				/* whether to print names in short form or long form */
        3 compress_output	bit (1) aligned init ("0"b),
				/* whether to collect bits, put multiple things on a line */
        3 use_match_names	bit (1) aligned init ("0"b),
				/* whether to pay attention to P_match_names */

       2 amu_info_ptr	pointer init (null ()),
				/* name/address translation info for $for_azm */
       2 orig_symbolp	pointer init (null ()),
				/* pointer to original symbol node */
       2 blockp		pointer init (null ()),
				/* block symbol was dcl 'd in */

       2 base_ptr		pointer init (null ()),
				/*  the original address of the data */
       2 max_offset		fixed bin (18) init (262143),
				/* Maximum offset allowed for data */
       2 start_ptr		pointer init (null ()),
				/* The alleged address where the display started */
       2 n_orig_indices	fixed bin,/* Number of original indices we were given */

       2 stackp		pointer init (null ()),
				/* to the stack frame for this variable */
       2 linkp		pointer init (null ()),
				/* to the Linkage section */
       2 language_type	fixed bin init (PL1_lang_type),
				/* language type for deciding how to print things */
       2 probe_sw		bit (1) aligned init ("0"b),
				/* "1"b => probe_print_value_ */

       2 probe_options	aligned,	/* Things used only by probe */
        3 octal_sw		bit (1) aligned init ("0"b),
				/* if we print in octal */
        3 invert_sw		bit (1) aligned init ("0"b),
				/* FORTRAN arrays are backwards */
        3 calculate_address	bit (1) aligned init ("0"b),
				/* used to decide to print name */
        3 truncate_strings	bit (1) aligned init ("0"b),
				/* probe "mode truncate_strings" */
        3 print_names	bit (1) aligned init ("0"b),
				/* whether to print symbol names */
        3 no_handle_faults_sw bit (1) aligned init ("0"b),
				/* whether to allow "size" to be signalled */

       2 variable_info	aligned,	/* Things which vary as we traverse structures and arrays */
        3 n_bounds		fixed bin,/* Number of total array bounds in use */
        3 bounds		(2, 16) fixed bin (24),
				/* Current array bounds */
        3 indices		(16) fixed bin (24),
				/* full subscripts needed to get address */

        3 father		(64) pointer;
				/* to symbol node for every level of a structure */

  dcl 1 output_info_template	aligned internal static options (constant),
				/* Information about output buffering */
       2 header		aligned,
        3 on_bits,			/* pointers to the lsits of bit names */
         4 first		pointer init (null ()),
				/* for printing when we've finished */
         4 last		pointer init (null ()),
        3 off_bits,
         4 first		pointer init (null ()),
         4 last		pointer init (null ()),

       2 buffer		char (300) varying init ("");
				/* The actual buffer */

  dcl dont_print_me_this_time bit (1);

  dcl 1 bit_buffer		aligned based,
				/* Structure used when accumulating bits */
       2 str		char (300) varying,
       2 next		pointer;

  dcl 1 global_output_info	aligned like output_info_template automatic;

  dcl error_code		fixed bin (35);
				/* global error code */
  dcl done_with_pascal	bit (1);	/* return value from probe_print_pascal_$value */
  dcl level_1_c_struct_ndims	fixed bin;
  dcl level_1_c_struct_dims_ptr
			ptr;
  dcl print_the_data	bit (1);
  dcl double_override	bit (1);

  dcl system_area_ptr	pointer;
  dcl system_area		area aligned based (system_area_ptr);

  dcl probe_et_$dim_limit	fixed bin (35) external static;
  dcl probe_et_$recorded_message
			fixed bin (35) external static;
  dcl probe_et_$no_address	fixed bin (35) external static;

  dcl iox_$user_output	pointer external static;
  dcl sys_info$max_seg_size	fixed bin (19) external static;

  dcl probe_error_$record	entry options (variable);
  dcl get_size_in_bits_	entry (fixed bin, fixed bin (35),
			bit (1) aligned) returns (fixed bin);
  dcl probe_increment_indices_
			entry (bit (1) aligned, (*) fixed bin (24),
			(2, *) fixed bin (24), fixed bin,
			bit (1) aligned, bit (1) aligned);
  dcl probe_modes_mgr_$excludep
			entry (pointer, pointer)
			returns (bit (1) aligned);
  dcl probe_print_pascal_$value
			entry (pointer, pointer, fixed bin (35),
			bit (1));

  dcl assign_$computational_	entry (ptr, ptr, fixed bin (35));
  dcl convert_status_code_	entry (fixed bin (35), char (8) aligned,
			char (100) aligned);
  dcl date_time_$format	entry (char (*), fixed bin (71), char (*),
			char (*)) returns (char (250) var);
  dcl display_file_value_	entry (pointer, file, fixed bin (35));
  dcl format_pointer_$its	entry (pointer, bit (1) aligned, pointer)
			returns (char (256) varying);
  dcl format_pointer_$packed	entry (unaligned pointer, bit (1) aligned,
			pointer) returns (char (256) varying);
  dcl get_line_length_$switch entry (pointer, fixed bin (35))
			returns (fixed bin);
  dcl get_system_free_area_	entry () returns (pointer);
  dcl ioa_$ioa_switch	entry options (variable);
  dcl ioa_$ioa_switch_nnl	entry options (variable);
  dcl ioa_$rsnnl		entry options (variable);
  dcl requote_string_	entry (char (*)) returns (char (*));
  dcl stu_$block_dcld_in	entry (pointer) returns (pointer);
  dcl stu_$decode_runtime_value_extended
			entry (fixed bin (35),
			pointer, pointer, pointer, pointer, pointer,
			pointer, fixed bin (35))
			returns (fixed bin (35));
  dcl stu_$get_runtime_address
			entry (pointer, pointer,
			pointer, pointer, pointer, pointer, pointer)
			returns (pointer);
  dcl stu_$offset_to_pointer	entry (pointer, pointer,
			pointer, pointer, pointer, pointer)
			returns (pointer);
  dcl stu_$find_runtime_symbol
			entry (ptr, char (*) aligned, ptr, fixed bin)
			returns (pointer);
  dcl valid_decimal_	entry (fixed bin, pointer, fixed bin (35))
			returns (bit (1) aligned);

  dcl TOP_LEVEL		bit (1) aligned internal static
			options (constant) init ("1"b);
  dcl NOT_TOP_LEVEL		bit (1) aligned internal static
			options (constant) init ("0"b);

  dcl (addr, addrel, binary, character, clock, convert, copy, divide, high)
			builtin;
  dcl (hbound, fixed, index, length, low, ltrim, max, maxlength, min, mod)
			builtin;
  dcl (null, nullo, pointer, rel, rtrim, substr, translate, unspec)
			builtin;

  dcl (conversion, overflow, sub_error_)
			condition;


%page;
common_c_setup:
  proc ();

  dcl temp_stuff_ptr	ptr;

  double_override = "0"b;
  print_the_data = "0"b;
  level_1_c_struct_ndims = 0;
  level_1_c_struct_dims_ptr = null ();

  if global.language_type ^= C_lang_type
  then return;

  /* P_reference parameter is supplied only with the $for_probe entrypoint.  */
  /* But $for_azm entrypoint always specifies PL1_lang_type.  So code below  */
  /* only runs in the $for_probe entrypoint has been called.	       */

  if P_code = 1 | P_reference.flags.c_sub_c_ptr then do;
      print_the_data = "1"b;
      double_override = "1"b;
      P_code = 0;
    end;

  if (P_reference.symbol_ptr ^= null ()) then do;
      temp_stuff_ptr = P_reference.symbol_ptr;
      do while (fixed (temp_stuff_ptr -> runtime_symbol.type) = pointer_dtype
	 |
	 fixed (temp_stuff_ptr -> runtime_symbol.type) = c_typeref_dtype);
        temp_stuff_ptr =
	   addrel (temp_stuff_ptr,
	   fixed (temp_stuff_ptr -> runtime_symbol.son));
      end;
      if fixed (temp_stuff_ptr -> runtime_symbol.type) = structure_dtype |
	 fixed (temp_stuff_ptr -> runtime_symbol.type) = c_union_dtype
        then
	   double_override = "1"b;
      if ((fixed (P_reference.symbol_ptr -> runtime_symbol.type) = structure_dtype |
	 fixed (P_reference.symbol_ptr -> runtime_symbol.type) = c_union_dtype    )  &
	 P_reference.n_subscripts = 0) then do;

	begin;

	  dcl nameptr		ptr;
	  dcl steps		fixed bin;
	  dcl found_ptr		ptr;
	  dcl t_ptr		ptr;

	  nameptr =
	       addrel (P_reference.symbol_ptr,
	       fixed (P_reference.symbol_ptr -> runtime_symbol.name));
	  if (P_reference.name
	       ^=
	       substr (nameptr -> acc.string, 1, nameptr -> acc.num_chars))
	    then do;
	      t_ptr =
		 stu_$find_runtime_symbol (P_reference.source_info_ptr
		 -> source_info.block_ptr, (P_reference.name), found_ptr,
		 steps);
	      if (t_ptr ^= null ())
	        then
		   if (^t_ptr -> runtime_symbol.bits.simple) then do;
		       level_1_c_struct_ndims =
			  convert (level_1_c_struct_ndims,
			  t_ptr -> runtime_symbol.ndims);
		       level_1_c_struct_dims_ptr = t_ptr;
		     end;
	    end;
	end;
        end;
    end;

  end common_c_setup;
%page;
display_data_$for_azm:
  entry (P_iocb_ptr, P_display_format, P_match_names, P_match_name_count,
       P_amu_info_ptr,
       P_data_ptr, P_data_size, P_start_ptr, P_symbol_ptr,
       P_subscripts, P_n_subscripts, P_code);

  call set_globals_for_azm ();
  call common_c_setup ();		/* "0"b for probe, "1"b for azm */
  goto COMMON;



display_data_$for_probe:
  entry (P_probe_info_ptr, P_reference, P_code);

  call set_globals_for_probe ();
  call common_c_setup ();		/* "0"b for probe, "1"b for azm */

  if (global.language_type = PASCAL_lang_type) then do;
      call probe_print_pascal_$value (probe_info_ptr, addr (P_reference),
	 P_code, done_with_pascal);
      if done_with_pascal
        then return;		/* Otherwise, fall through and do our usual thing */
    end;

  goto COMMON;


COMMON:
  system_area_ptr = get_system_free_area_ ();

  global.line_length = get_line_length_$switch (global.output_switch, (0));

  global_output_info.header = output_info_template.header;
  global_output_info.buffer = copy (" ", 2);

  dont_print_me_this_time = "0"b;

  if global.probe_sw then do;				/* Only $for_probe entrypoint uses this code.	        */
    if (level_1_c_struct_ndims > 0) then do;
        begin;

	dcl inxs		      (level_1_c_struct_ndims) fixed bin;
	dcl (level_1_c_struct_inx0, level_1_c_struct_inx1,
	    level_1_c_struct_inx2)
			        fixed bin;
	dcl total_number_of_elements
			        fixed bin;

	inxs (*) = 0;
	total_number_of_elements = 0;
	do level_1_c_struct_inx0 = 1 to level_1_c_struct_ndims;
	  total_number_of_elements =
	       total_number_of_elements
	       + level_1_c_struct_dims_ptr
	       -> runtime_symbol.bounds (level_1_c_struct_inx0).upper + 1;
	end;

	P_reference.address_ptr =
	     addrel (P_reference.address_ptr, -1 *
	     divide (level_1_c_struct_dims_ptr
	     -> runtime_symbol.bounds (1).multiplier,
	     36, 17, 0));

	do level_1_c_struct_inx0 = 1 to total_number_of_elements;
	  call ioa_$ioa_switch_nnl (global.output_switch, "^/^a ",
	       P_reference.name);
	  do level_1_c_struct_inx1 = 1 to level_1_c_struct_ndims;
	    call ioa_$ioa_switch_nnl (global.output_switch, "[^d]",
	         inxs (level_1_c_struct_inx1));
	  end;
	  P_reference.address_ptr =
	       addrel (P_reference.address_ptr,
	       divide (level_1_c_struct_dims_ptr
	       -> runtime_symbol.bounds (1).multiplier,
	       36, 17, 0));

	  dont_print_me_this_time = "1"b;

	  call print_symbol (global.orig_symbolp,
	       global.n_orig_indices, TOP_LEVEL, addr (global_output_info),
	       (P_reference.address_ptr));

	  inxs (level_1_c_struct_ndims) = inxs (level_1_c_struct_ndims) + 1;
	  level_1_c_struct_inx2 = level_1_c_struct_ndims;
	  do while (level_1_c_struct_inx2 > 0);
	    if inxs (level_1_c_struct_inx2)
	         > level_1_c_struct_dims_ptr
	         -> runtime_symbol.bounds (level_1_c_struct_inx2).upper
	      then do;
	        inxs (level_1_c_struct_inx2) = 0;
	        if (level_1_c_struct_inx2 > 1)
		then
		     inxs (level_1_c_struct_inx2 - 1) =
			inxs (level_1_c_struct_inx2 - 1) + 1;
	      end;
	    level_1_c_struct_inx2 = level_1_c_struct_inx2 - 1;
	  end;
	end;
        end;
      end;
      else call print_symbol (global.orig_symbolp,
	      global.n_orig_indices, TOP_LEVEL, addr (global_output_info),
	      (P_reference.address_ptr));
    end;
    else call print_symbol (global.orig_symbolp,		/* only $for_azm entrypoint uses this code.	        */
	    global.n_orig_indices, TOP_LEVEL, addr (global_output_info),
	    P_data_ptr);

  P_code = 0;
  return;


FATAL_ERROR:
  P_code = error_code;
  return;
%page;
set_globals_for_azm:
  proc ();


  dcl idx			fixed bin;

  global.output_switch = P_iocb_ptr;
  if (global.output_switch = null ())
    then global.output_switch = iox_$user_output;

  global.amu_info_ptr = P_amu_info_ptr;
  global.probe_sw = "0"b;
  global.octal_sw = "0"b;		/* azm never uses silly probe octal hack */
  global.invert_sw = "0"b;		/* azm always uses PL/I subscripts */

  global.base_ptr = P_data_ptr;
  global.max_offset = binary (rel (P_data_ptr), 18) + P_data_size - 1;
  global.start_ptr = P_start_ptr;

  global.language_type = PL1_lang_type; /* azm must ALWAYS use PL1_lang_type.  Won't work for C_lang_type, or others. */
  global.stackp = null ();		/* Can't use these, 'cause stu_ can't hack with amu_ */
  global.linkp = null ();

  global.blockp = stu_$block_dcld_in (P_symbol_ptr);
  global.orig_symbolp = P_symbol_ptr;

  global.calculate_address = "1"b;	/* Since we're always doing structures */
  global.truncate_strings = "0"b;
  global.print_names = "1"b;		/* Actually, we mimic probe "short" mode */
  global.short_names = "1"b;

  global.no_handle_faults_sw = "0"b;

  global.n_bounds = P_n_subscripts;
  global.n_orig_indices = P_n_subscripts;

  do idx = 1 to global.n_bounds;
    global.bounds (*, idx) = P_subscripts (*, idx);
    global.indices (idx) = global.bounds (1, idx);
  end;

  call set_display_format (1, global.compress_output);

  global.use_match_names = "0"b;
  if (hbound (P_match_names, 1) > 0) & (P_match_name_count > 0)
    then
         if (P_match_names (1) ^= "") then do;
	   global.use_match_names = "1"b;
	   global.short_names = "0"b;
	 end;
  return;

  end set_globals_for_azm;
%page;
set_display_format:
  proc (P_bit_idx, P_bit);


  dcl P_bit_idx		fixed bin parameter;
  dcl P_bit		bit (1) aligned parameter;

  if (P_bit_idx <= length (P_display_format))
    then
         P_bit = substr (P_display_format, P_bit_idx, 1);
    else P_bit = "0"b;
  return;

  end set_display_format;
%page;
set_globals_for_probe:
  proc ();


  dcl idx			fixed bin;

  dcl 1 ref_subscripts	aligned based (P_reference.subscript_ptr)
			like reference_subscripts;


  probe_info_ptr = P_probe_info_ptr;

  global.output_switch = probe_info.output_switch;

  global.probe_sw = "1"b;
  global.octal_sw = P_reference.flags.octal;
  global.blockp = P_reference.source_info_ptr -> source_info.block_ptr;

  if global.blockp ^= null
    then
         global.invert_sw = global.blockp -> runtime_block.fortran;
    else global.invert_sw = "0"b;	/* we wont have arrays, anyway, but be safe */

  global.stackp = P_reference.source_info_ptr -> source_info.stack_ptr;
  global.linkp =
       P_reference.source_info_ptr -> source_info.seg_info_ptr
       -> seg_info.linkage_ptr;

  global.base_ptr = P_reference.base_addr;
  global.max_offset = 262143;		/* We don't get told where it ends */
  global.start_ptr = global.base_ptr;
  global.orig_symbolp = P_reference.symbol_ptr;
  global.language_type = probe_info.language_type;

  if (global.orig_symbolp = null ())
    then /* For probe builtins, etc. */
         global.calculate_address = "0"b;
  else if P_reference.cross_section & global.language_type ^= C_lang_type
    then
         global.calculate_address = "1"b;
  else if (P_reference.type = structure_dtype
       & global.language_type ^= C_lang_type)
    then
         global.calculate_address = "1"b;
  else if ((P_reference.type = structure_dtype |
       P_reference.type = c_union_dtype) /* union */ &
       global.language_type = C_lang_type)
    then
         global.calculate_address = "0"b;
  else if (runtime_symbol_info_$son (global.orig_symbolp) ^= null ()) &
       (global.language_type ^= PASCAL_lang_type) &
       (global.language_type ^= C_lang_type)
    then
         /* Don't chase the sons of pointers in C */
         global.calculate_address = "1"b;
				/* COBOL structure, probably */
  else global.calculate_address = "0"b;
  if P_reference.symbol_ptr = null ()
    then /* No symbol? Won't work, nohow */
         global.print_names = "0"b;
  else if P_reference.flags.constant
    then /* constants have no names */
         global.print_names = "0"b;
  else if (probe_modes.value_print = LONG_mode_type)
    then
         global.print_names = "1"b;	/* ALWAYS */
  else if (probe_modes.value_print = SHORT_mode_type)
    then
         global.print_names = global.calculate_address;
  else global.print_names = "0"b;	/* NEVER (brief mode) */

  global.truncate_strings = probe_modes.truncate_strings;
  if (probe_modes.qualification = BRIEF_mode_type)
    then
         global.short_names = "1"b;
  else if (probe_modes.qualification = SHORT_mode_type)
    then
         global.short_names = "1"b;
  else if (global.language_type = COBOL_lang_type)
    then
         global.short_names = "1"b;	/* Always short for COBOL, though I have no idea why */
  else global.short_names = "0"b;

  global.use_match_names = "0"b;

  global.no_handle_faults_sw =
       probe_info.static_info_ptr -> probe_static_info.no_handle_faults_sw;

  if global.language_type ^= PASCAL_lang_type
       & P_reference.subscript_ptr ^= null ()
    then
      do idx = 1 to ref_subscripts.number;
      if (P_reference.n_subscripts = 0)
	 & (ref_subscripts.value (2, idx) < ref_subscripts.value (1, idx))
        then
	   call ioa_$ioa_switch (global.output_switch,
	        "Warning: extent ^d is zero.", idx);
      global.indices (idx) = ref_subscripts.value (1, idx);
      global.bounds (1, idx) = ref_subscripts.value (1, idx);
      if ^P_reference.cross_section
        then /* Since only first subscript will be set in this case */
	   global.bounds (2, idx) = ref_subscripts.value (1, idx);
        else global.bounds (2, idx) = ref_subscripts.value (2, idx);
    end;

  if (P_reference.subscript_ptr ^= null ()) then do;
      global.n_bounds = ref_subscripts.number;
      global.n_orig_indices = ref_subscripts.number;
    end;
    else do;
      global.n_bounds = 0;
      global.n_orig_indices = 0;
    end;
  return;

  end set_globals_for_probe;
%page;
ref_node_not_struct_or_union:
  proc () returns (bit (1));
  dcl t_ptr		ptr;

  if (global.language_type ^= C_lang_type)
    then return ("0"b);

  t_ptr = P_reference.symbol_ptr;
  if t_ptr = null
    then return ("0"b);

  do while (fixed (t_ptr -> runtime_symbol.type) = pointer_dtype |
       fixed (t_ptr -> runtime_symbol.type) = c_typeref_dtype);
    t_ptr = addrel (t_ptr, fixed (t_ptr -> runtime_symbol.son));
  end;
  if (fixed (t_ptr -> runtime_symbol.type) = structure_dtype)
    then return ("0"b);
  else if (fixed (t_ptr -> runtime_symbol.type) = c_union_dtype)
    then return ("0"b);
  return ("1"b);

  end ref_node_not_struct_or_union;
%page;
print_symbol:
  proc (P_value_symbol_ptr, P_inherited_dims, P_top_level_sw,
       P_output_info_ptr, inherited_addr);


  /* This is the interface to the actual data display routine.  We may be 
   printing a structure, in which case the necessary recursive tree walking 
   is here-in implemented.  This involves printing full cross-sections of
   any arrays we run into. */

  dcl P_value_symbol_ptr	pointer parameter;
				/* to runtime_symbol node */
  dcl P_inherited_dims	fixed bin parameter;
  dcl P_top_level_sw	bit (1) aligned parameter;
  dcl P_output_info_ptr	pointer parameter;
  dcl inherited_addr	pointer parameter;
  dcl 1 parent_output_info	aligned like output_info_template
			based (P_output_info_ptr);

  /* This is all global information about the value we're going to print; mostly,
   it gets inherited by display_single_value. */

  dcl (value_symbol_ptr, previous_value_symbol_ptr, this_value_symbol_ptr)
			pointer;
  dcl (value_ptr, previous_value_ptr, this_value_ptr)
			pointer;
  dcl 1 (value_info, previous_value_info, this_value_info)
			like runtime_type_info;
				/* NOTE: This must be dcld without explicit alignment */
  dcl 1 (value_data_info, previous_value_data_info, this_value_data_info)
			aligned like data_type_info_$info;
  dcl (previous_value_indices, this_value_indices)
			(16) fixed bin (24);
				/* copies of global.indices */
  dcl value_name		char (256) varying;
  dcl (previous_value_name, this_value_name, starting_name)
			char (256);
  dcl (previous_real_value_ptr, real_value_ptr)
			pointer;	/* If we're working on a copy, this is the real address */

  dcl ndims		fixed bin;/* total number of dims we have */
  dcl my_dims		fixed bin;/* how many dims we have originated */
  dcl first_dim		fixed bin;
  dcl my_bounds		(2, 16) fixed bin (24);
  dcl (ele_num, levels_of_pointer_indir)
			fixed bin;
  dcl my_father_is_a_typeref	bit (1);
  dcl override		bit (1);
  dcl my_real_name_ptr	ptr;

  /* This is a general-purpose buffer for collecting output. It's dcld here
   only in order to avoid having multiple copies of it in loads of internal 
   procedures. It should always be filled and written immediately. */

  dcl value_str		char (500) varying;
  dcl old_value_symbol_ptr	ptr;
  dcl fixed		builtin;

  ele_num = 0;
  my_father_is_a_typeref = "0"b;
  my_real_name_ptr = null ();
  value_symbol_ptr = P_value_symbol_ptr;

  /* First, check for probe constants. A probe constant is a value constructed
   by probe as the result of an expression. It has no symbol node associated
   with it (which is how we tell what it is), never has dimensions, and only
   uses a restricted set of datatypes. Thus, we catch it the first time here
   and just return. This is done here because display_single_value is quick, 
   and internal to print_symbol. This check is only made when the entrypoint
   for probe is called; otherwise, it is an error. */

  if global.probe_sw & (value_symbol_ptr = null ()) then do;
				/* Probe constant */
      call display_probe_constant ();
      return;			/* All done */
    end;

  if ^global.no_handle_faults_sw
    then
         on size
	 begin;			/* if "size" occurs, skip to next element */
	 call ioa_$ioa_switch (global.output_switch,
	      "Size condition occurred evaluating ^a",
	      get_unsubscripted_name ());
	 go to PRINT_SYMBOL_RETURN;
         end;

  call setup_subscripts ();

  levels_of_pointer_indir = 0;
  my_father_is_a_typeref = "0"b;
  my_real_name_ptr = null ();
  old_value_symbol_ptr = value_symbol_ptr;
  override = "0"b;
  do while ((fixed (value_symbol_ptr -> runtime_symbol.type) = pointer_dtype |
       fixed (value_symbol_ptr -> runtime_symbol.type) = c_typeref_dtype) &
       global.language_type = C_lang_type);
    if (my_real_name_ptr = null ()) then do;
        my_real_name_ptr = value_symbol_ptr;
        my_father_is_a_typeref = "1"b;
      end;
    if (fixed (value_symbol_ptr -> runtime_symbol.type) = pointer_dtype)
      then
	 levels_of_pointer_indir = levels_of_pointer_indir + 1;
    value_symbol_ptr =
         addrel (value_symbol_ptr,
         fixed (value_symbol_ptr -> runtime_symbol.son));
    if (fixed (value_symbol_ptr -> runtime_symbol.type) = char_dtype
         & ^P_reference.flags.c_sub_c_ptr & ^double_override)
      then
	 override = "1"b;
  end;
  if (levels_of_pointer_indir > 0 & (^print_the_data | override)
       & global.language_type = C_lang_type) then do;
      value_symbol_ptr = old_value_symbol_ptr;
      levels_of_pointer_indir = 0;
    end;

  override = "0"b;
  call print_cross_section ();

  if P_top_level_sw
    then /* If this is the end, finish it */
         call finish_output (addr (parent_output_info), "1"b);

PRINT_SYMBOL_RETURN:
  return;
%page;
setup_subscripts:
  proc ();


  dcl idx			fixed bin;/* do loop index only */
  dcl symbol_ptr		ptr;	/* pointer to symbol node */
  dcl my_idx		fixed bin;
  dcl symbol_level		fixed bin;
  dcl first_level		fixed bin;



  ndims = runtime_symbol_info_$array_dims (value_symbol_ptr);

  if (global.language_type = C_lang_type & ndims = 0) then do;
      my_dims = 0;
      return;
    end;

  if (ndims > hbound (global.indices, 1)) then do;
				/* Too many dimensions to print successfully */
      error_code = probe_et_$dim_limit;
      goto FATAL_ERROR;
    end;

  if P_top_level_sw
    then /* Use any that we got from our caller */
         my_dims = ndims;		/* without disturbing those parts of global.bounds */
    else my_dims = ndims - P_inherited_dims;
				/* how many do we contribute */

  first_dim = ndims - my_dims + 1;	/* First one we manipulate */

  /* What follows here is a gross kludge, because runtime_array_info does not use refer extents properly,
   or even have its variable extent named reasonably. Instead, it is called n_dims, no doubt to the
   great confusion of all concerned. */

  n_dims = ndims;			/* Hope that scope-of-names works */

  begin;

    dcl 1 value_array_info	  like runtime_array_info;
				/* ADJUSTABLE AUTOMATIC */
				/* NOTE: This must be dcld without explicit alignment */

    value_array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;

    call runtime_symbol_info_$array (value_symbol_ptr,
         addr (value_array_info), error_code);
    if error_code ^= 0
      then call cannot_get_address ();

    do idx = (P_inherited_dims + 1) to ndims;
				/* Fill in our own bounds */
      global.bounds (1, idx) = decode (value_array_info.bounds (idx).lower,
	 value_array_info.bounds (idx).lower_is_encoded);
      global.bounds (2, idx) = decode (value_array_info.bounds (idx).upper,
	 value_array_info.bounds (idx).upper_is_encoded);
      global.indices (idx) = global.bounds (1, idx);
    end;

  end;				/* Kludge begin block */

  my_idx = 1;			/* Copy the appropriate part of the global bounds */
  do idx = first_dim to ndims;	/* and index info into our local copies */
    my_bounds (*, my_idx) = global.bounds (*, idx);

    if (my_bounds (2, my_idx) < my_bounds (1, my_idx))
      then
	 call ioa_$ioa_switch (global.output_switch,
	      "Warning: extent ^d of ^a is zero.",
	      idx, get_unsubscripted_name ());
    my_idx = my_idx + 1;
  end;

  if P_top_level_sw
    then first_level = 1;
    else first_level = runtime_symbol_info_$level (value_symbol_ptr);
  symbol_level = max (1, runtime_symbol_info_$level (value_symbol_ptr));

  symbol_ptr = value_symbol_ptr;

  do idx = symbol_level to first_level by -1;
    global.father (idx) = symbol_ptr;
    symbol_ptr = runtime_symbol_info_$father (symbol_ptr);
  end;
  return;

  end setup_subscripts;
%page;
decode:
  proc (encoded_val, is_encoded) returns (fixed bin (35));


  dcl encoded_val		fixed bin (35) parameter;
  dcl is_encoded		bit (1) unaligned parameter;

  dcl result		fixed bin (35);


  if ^is_encoded
    then
         return (encoded_val);

  result = stu_$decode_runtime_value_extended (encoded_val,
       global.blockp, global.stackp, global.linkp,
       pointer (global.blockp, 0), global.base_ptr, value_symbol_ptr,
       error_code);

  if (error_code ^= 0) & ^global.probe_sw then do;
      call ioa_$ioa_switch (global.output_switch,
	 "^5x^vxerror: Cannot decode size/bounds of ^a.",
	 indentation (), get_unsubscripted_name ());
      error_code = 0;		/* There's no sensible code here; let our caller */
      goto FATAL_ERROR;		/* think it worked, since there's nothing to do */
    end;

  else if (error_code ^= 0)
    then goto FATAL_ERROR;		/* Let probe figure it out */
  return (result);

  end decode;
%page;
display_probe_constant:
  proc ();


  /* This procedure sets the usual global variables, fakes up a symbol 
   node and calls display_single_value. Since probe constants are never
   arrays or structures, no attention is paid to subscripts or recursion
   for structure elements here */

  dcl 1 ep		like encoded_precision;

  value_ptr = P_reference.address_ptr;
  unspec (value_info) = ""b;

  value_info.type = P_reference.type;
  value_info.base_type = value_info.type;
  value_data_info = data_type_info_$info (value_info.type);

  value_info.packed = P_reference.flags.packed;
  unspec (ep) = unspec (P_reference.precision);
				/* Unpack arithmetic precision and scale, if need be */
  value_info.scale = ep.scale;
  if (value_info.scale ^= 0)
    then value_info.size = ep.prec;
    else value_info.size = P_reference.precision;


  value_info.type_addr = null ();	/* I don't know what these are, but they look like they */
  value_info.base_type_addr = null ();	/* will work better as null pointers than as zeros */

  value_symbol_ptr = null ();

  call display_single_value ();
  return;

  end display_probe_constant;
%page;
print_cross_section:
  proc ();


  /* This procedure prints the contents of the current array cross-section.
   It also implements the recursing for printing the immediate sons of a
   structure element.  For reasons I don't understand, it only increments
   subscripts PL/I-style, even if it's printing for Fortran. It used to 
   check in MR9.1, but this was removed in MR10.1.  */

  dcl done		bit (1) aligned;
  dcl first_time_sw		bit (1) aligned;
				/* First time for cross-section */
  dcl same_count		fixed bin;
  dcl dont_print		bit (1) aligned;

  dcl value_size		fixed bin (24);
  dcl this_value		bit (value_size) based (this_value_ptr);
  dcl previous_value	bit (value_size) based (previous_value_ptr);

  /* This array is used to increment a subset of the indices in the global
   subscript array. It uses based(addr) due to a PL/I bug preventing
   the use of the defined attribute in this context. */

  dcl my_indices		(my_dims) fixed bin (24)
			based (addr (global.indices (first_dim)));


  this_value_symbol_ptr = value_symbol_ptr;

  call get_value_info ();		/* get info for first time */

  if ignore_this_element (dont_print) then do;
				/* If anything in the cross-section is ignored, */
      return;			/* it's always ignored. */
    end;

  first_time_sw = "1"b;
  value_size = 0;
  done = "0"b;

  do while (^done);

    if first_time_sw then do;
        first_time_sw = "0"b;
        starting_name = this_value_name;
        same_count = 1;
      end;

      else do;
        if value_size = 0
	then /* set this once for the loop */
	     value_size =
		bitno (this_value_ptr) - bitno (previous_value_ptr);
        if this_value ^= previous_value then do;
				/* time to print something */

	  call use_previous_value ();

	  call do_symbol_and_sons (starting_name, previous_value_name,
	       same_count, dont_print);

	  starting_name = this_value_name;
	  same_count = 0;
	end;

	else same_count = same_count + 1;
      end;

    previous_value_name = this_value_name;
    previous_value_ptr = this_value_ptr;
    previous_value_symbol_ptr = this_value_symbol_ptr;
    previous_real_value_ptr = real_value_ptr;
    unspec (previous_value_info) = unspec (this_value_info);
    unspec (previous_value_data_info) = unspec (this_value_data_info);
    previous_value_indices = this_value_indices;

    if (my_dims = 0)
      then done = "1"b;		/* Not a cross-section */
      else call probe_increment_indices_ ("0"b,
				/* Always PL/I */
	      my_indices, my_bounds, my_dims, done, ("0"b));
    ele_num = ele_num + 1;

    if ^done
      then call get_value_info ();

  end;

  call use_previous_value ();

  call do_symbol_and_sons (starting_name, previous_value_name, same_count,
       dont_print);
  return;

  end print_cross_section;
%page;
get_value_info:
  proc ();

  dcl offset_bits		fixed bin (6) unsigned;
  dcl offset_words		fixed bin (18) unsigned;
  dcl fixed		builtin;
  dcl i			fixed bin;
  dcl based_ptr		ptr based;
  dcl temp_ptr		ptr;

  /* Get information about the value to be printed. The address calculation
   stuff here is purely an efficiency hack; we could always recalculate
   it, but if probe already gave us the address (which it can for scalars
   only), we may as well use that, instead. */

  this_value_info.version = RUNTIME_TYPE_INFO_VERSION_1;

  call runtime_symbol_info_$type (this_value_symbol_ptr,
       addr (this_value_info), error_code);
  if error_code ^= 0 then do;
      call use_this_value ();
      call cannot_get_address ();
    end;

  this_value_data_info = data_type_info_$info (this_value_info.type);

  if global.calculate_address
    then /* must recalculate address */
         this_value_ptr = stu_$get_runtime_address (global.blockp,
	    this_value_symbol_ptr, global.stackp, global.linkp,
	    global.blockp, global.base_ptr, addr (global.indices));

    else this_value_ptr = inherited_addr;
  if (my_father_is_a_typeref)
    then
         temp_ptr = my_real_name_ptr;
    else temp_ptr = this_value_symbol_ptr;

  if (^ref_node_not_struct_or_union () &
       global.language_type = C_lang_type) then do;
      if (temp_ptr ^= null ()) then do;
	if (^temp_ptr -> runtime_symbol.bits.simple) then do;
	    offset_bits = 0;
	    if (temp_ptr -> runtime_symbol.offset ^= 0
	         & my_real_name_ptr ^= P_reference.symbol_ptr)
	      then
		 offset_bits =
		      convert (offset_bits,
		      temp_ptr -> runtime_symbol.offset);
	    if (fixed (temp_ptr -> runtime_symbol.ndims) > 0) then do;
	        offset_bits =
		   offset_bits
		   + ele_num
		   *
		   get_size_in_bits_ (
		   fixed (temp_ptr -> runtime_symbol.type),
		   temp_ptr -> runtime_symbol.size,
		   (temp_ptr -> runtime_symbol.bits.packed));
	      end;
	    offset_words =
	         convert (offset_words, divide (offset_bits, 36, 17, 0));
	    offset_bits = convert (offset_bits, mod (offset_bits, 36));
	    addr (this_value_ptr) -> its_unsigned.offset =
	         addr (this_value_ptr) -> its_unsigned.offset
	         + offset_words;
	    addr (this_value_ptr) -> its_unsigned.bit_offset =
	         addr (this_value_ptr) -> its_unsigned.bit_offset
	         + offset_bits;


	  end;
        end;
    end;
  else if my_dims > 0 & global.language_type = C_lang_type then do;
      if (temp_ptr ^= null ()) then do;
	if (^temp_ptr -> runtime_symbol.bits.simple) then do;
	    offset_bits = 0;
	    if (fixed (temp_ptr -> runtime_symbol.ndims) > 0) then do;
	        offset_bits =
		   offset_bits
		   + ele_num
		   *
		   get_size_in_bits_ (
		   fixed (temp_ptr -> runtime_symbol.type),
		   temp_ptr -> runtime_symbol.size,
		   (temp_ptr -> runtime_symbol.bits.packed));
	      end;
	    offset_words =
	         convert (offset_words, divide (offset_bits, 36, 17, 0));
	    offset_bits = convert (offset_bits, mod (offset_bits, 36));
	    addr (this_value_ptr) -> its_unsigned.offset =
	         addr (this_value_ptr) -> its_unsigned.offset
	         + offset_words;
	    addr (this_value_ptr) -> its_unsigned.bit_offset =
	         addr (this_value_ptr) -> its_unsigned.bit_offset
	         + offset_bits;


	  end;
        end;
    end;

  if (global.language_type = C_lang_type)
    then
      do i = 1 to levels_of_pointer_indir;
      this_value_ptr = this_value_ptr -> based_ptr;
    end;

  real_value_ptr = addbitoffset (global.start_ptr,
       (bitno (this_value_ptr) - bitno (global.base_ptr)));

  this_value_indices = global.indices;

  call use_this_value ();

  this_value_name = get_symbol_name ();
  value_name = rtrim (this_value_name);

  if (this_value_ptr = null ()) & (this_value_info.type ^= structure_dtype)
    then
         call cannot_get_address ();	/* for instance, when a thunk cannot be evaluated */
  return;

  end get_value_info;
%page;
ignore_this_element:
  proc (P_dont_print) returns (bit (1) aligned);


  dcl P_dont_print		bit (1) aligned parameter;
				/* Set to suppress printing of extra structure levels */

  dcl 1 element_name	aligned
			based (
			runtime_symbol_info_$name (
			this_value_symbol_ptr)),
       2 len		fixed bin (9) unsigned unaligned,
       2 str		char (0 refer (element_name.len)) unaligned;
  dcl idx			fixed bin;
  dcl fixed		builtin;


  P_dont_print = "0"b;		/* This is only important when using match names */

  if global.probe_sw then do;
      if ^probe_modes.use_exclude_names
        then return ("0"b);
        else return (
	        probe_modes_mgr_$excludep (probe_info_ptr,
	        addr (element_name)));
    end;

  if global.use_match_names then do;
      do idx = 1 to P_match_name_count;
        if (index (this_value_name, P_match_names (idx)) ^= 0) then do;
	  return ("0"b);
	end;
      end;

      if (runtime_symbol_info_$son (this_value_symbol_ptr) ^= null ()
	 & (fixed (this_value_symbol_ptr -> runtime_symbol.type)
	 ^= pointer_dtype |
	 fixed (this_value_symbol_ptr -> runtime_symbol.type)
	 ^= c_typeref_dtype))
        then do;			/* Keep looking, but quietly */
	P_dont_print = "1"b;
	return ("0"b);
        end;
      return ("1"b);		/* No matches, so ignore it */
    end;

  /* Otherwise, azm uses a fixed heuristic */
  if (element_name.len < 3)
    then return ("0"b);
  if (substr (element_name.str, 1, 3) = "pad")
    then return ("1"b);
  if (substr (element_name.str, 1, 3) = "mbz")
    then return ("1"b);
  if (element_name.len < 6)
    then return ("0"b);
  if (substr (element_name.str, 1, 6) = "unused")
    then return ("1"b);
  if (element_name.len < 8)
    then return ("0"b);
  if (substr (element_name.str, 1, 8) = "unusable")
    then return ("1"b);
  return ("0"b);

  end ignore_this_element;
%page;
cannot_get_address:
  proc ();



  /* This is called when it turns out that the current symbol cannot be located
   for some reason; the usual one is that a thunk cannot be evaluated because
   the necessary pointers are not available (this is always the case for 
   display_data_, and sometimes the case for probe). In any case, when this 
   happens, we've done all we can, and we just punt. */

  if global.probe_sw then do;
      call probe_error_$record (probe_info_ptr,
	 probe_et_$no_address, get_symbol_name ());
      error_code = probe_et_$recorded_message;
    end;

    else do;

      call finish_output (addr (parent_output_info), "1"b);
				/* Finish anything waiting at this level */
      call ioa_$ioa_switch (global.output_switch,
	 "^5xerror: Cannot get address of ^a.", get_symbol_name ());
      error_code = 0;		/* There's no sensible code here; let our caller */
    end;				/* think it worked, since there's nothing to do */

  goto FATAL_ERROR;

  end cannot_get_address;
%page;
use_previous_value:
  proc ();


  value_symbol_ptr = previous_value_symbol_ptr;
  unspec (value_info) = unspec (previous_value_info);
  unspec (value_data_info) = unspec (previous_value_data_info);
  value_ptr = previous_value_ptr;
  real_value_ptr = previous_real_value_ptr;
  global.indices = previous_value_indices;
  ele_num = ele_num - 1;
  end use_previous_value;




use_this_value:
  proc ();


  value_symbol_ptr = this_value_symbol_ptr;
  unspec (value_info) = unspec (this_value_info);
  unspec (value_data_info) = unspec (this_value_data_info);
  value_ptr = this_value_ptr;
  global.indices = this_value_indices;
  end use_this_value;
%page;
do_symbol_and_sons:
  proc (P_first_name, P_last_name, P_count, P_dont_print);


  dcl (P_first_name, P_last_name)
			char (*);
  dcl P_count		fixed bin;
  dcl P_dont_print		bit (1) aligned parameter;

  dcl symbol_ptr		pointer;
  dcl fixed		builtin;


  dcl 1 my_output_info	aligned like output_info_template automatic;

dummy_node:
  proc (s_ptr) returns (bit (1));

  dcl s_ptr		parameter ptr;
  dcl name_ptr		ptr;

  name_ptr = addrel (s_ptr, fixed (s_ptr -> runtime_symbol.name));

  if (substr (name_ptr -> acc.string, 1, 1) = "!")
    then return ("1"b);
    else return ("0"b);

  end dummy_node;

  /* The P_dont_print flag is intended to suppress output for substructures which
   don't match the substring selections, but should be traversed anyway in 
   order to find interesting elements. */

  if P_count = 1
    then value_name = rtrim (P_first_name);
    else call ioa_$rsnnl ("^a ^[and^;through^] ^a", value_name,
	    length (value_name),
	    P_first_name, P_count = 2, P_last_name);

  if ^P_dont_print
    then call display_single_value ();

  /* We have a 'son' but the value my not be a structure. It may be a C
   indirect value. If the value is a pointer or typeref, ignore the son. */

  if (runtime_symbol_info_$son (value_symbol_ptr) = null () |
       fixed (value_symbol_ptr -> runtime_symbol.type) = pointer_dtype |
       fixed (value_symbol_ptr -> runtime_symbol.type) = c_typeref_dtype |
       fixed (value_symbol_ptr -> runtime_symbol.type) = c_enum_dtype)
    then do;
      return;			/* not a structure */
    end;

  /* This symbol may have 0 to N sons.  The first son is found by an 18 bit 
   offset (son), and the others are linked by 18 bit offsets from previous 
   son (brother).  Let symbol_offset take on, first the offset of my son, 
   then the offset of each brother of that son.  0 means end of chain */

  my_output_info.header = output_info_template.header;
  my_output_info.buffer = copy (" ", next_indentation ());


  do symbol_ptr = runtime_symbol_info_$son (value_symbol_ptr)
       repeat (runtime_symbol_info_$brother (symbol_ptr))
       while (symbol_ptr ^= null ());

    if (^dummy_node (symbol_ptr))
      then
	 call print_symbol (symbol_ptr, ndims, NOT_TOP_LEVEL,
	      addr (my_output_info), (value_ptr));
  end;

  call finish_output (addr (my_output_info), "1"b);
  return;

  end do_symbol_and_sons;
%page;
display_single_value:
  proc ();


  /* All knowledge about the internal representation of data is here, as is all
   knowledge of the formats that data are printed in. This procedure works
   entirely on values inherited from print_symbol */


  if (binary (rel (value_ptr), 18) > global.max_offset) then do;
      call finish_output (addr (parent_output_info), "1"b);
      call ioa_$ioa_switch (global.output_switch,
	 "^5xerror: ^a is outside the supplied data.",
	 get_symbol_name ());

      error_code = 0;		/* There's no sensible code here; let our caller */
      goto FATAL_ERROR;		/* think it worked, since there's nothing to do */
    end;

  if value_data_info.arithmetic
    then call display_arithmetic ();
  else if value_data_info.char_string
    then call display_char_string ();
  else if value_data_info.bit_string
    then call display_bit_string ();
  else if (value_info.type = picture_runtime_dtype)
    then call display_picture ();
  else if (value_info.type = pointer_dtype)
    then call display_pointer ();
  else if (value_info.type = offset_dtype)
    then call display_offset ();
  else if (value_info.type = label_constant_runtime_dtype)
    then call display_label_constant ();
  else if (value_info.type = label_dtype) | (value_info.type = entry_dtype)
    then
         call display_label_or_entry ();
  else if (value_info.type = file_dtype)
    then call display_file ();
  else if (value_info.type = int_entry_runtime_dtype)
       | (value_info.type = ext_procedure_runtime_dtype)
       | (value_info.type = ext_entry_runtime_dtype)
    then
         call display_entry_constant ();
  else if (value_info.type = structure_dtype)
    then call display_structure ();
  else if (value_info.type = c_union_dtype)
    then call display_structure ();
  else if (value_info.type = c_enum_dtype)
    then
         call display_c_enum ();
  else if (value_info.type = c_enum_const_dtype)
    then
         call display_arithmetic ();
  else call display_undisplayable ();

NONFATAL_ERROR:
  return;
%page;
display_arithmetic:
  proc ();


  dcl TEN_YEARS		fixed bin (71) int static
			options (constant) init (315360000000000);
  dcl 1 (source, target)	aligned like computational_data;
  dcl precision		fixed bin;
  dcl invalid_decimal_data	bit (9 * precision) based (value_ptr);
  dcl long_message		char (100) aligned;
  dcl short_message		char (8) aligned;
  dcl (fb71, hexfp_space)	fixed bin (71);
  dcl code		fixed bin (35);


  precision = decode (value_info.size, value_info.size_is_encoded);

  if value_data_info.decimal
    then
         if ^valid_decimal_ ((value_info.type), value_ptr, (precision))
	 then do;
	   call ioa_$rsnnl ("[invalid decimal data @ ^p] ""^.3b""b3",
	        value_str, (0), real_value_ptr, invalid_decimal_data);

	   call write_value_str ();
	   return;
	 end;

  unspec (source) = "0"b;
  source.address = value_ptr;
  source.data_type = value_info.type;
  source.packed = value_info.packed;
  source.prec_or_length = precision;
  source.scale = value_info.scale;
  source.picture_image_ptr = null;

  if source.data_type = real_flt_dec_generic_dtype
       | source.data_type = cplx_flt_dec_generic_dtype then do;
				/* don't print generic's tremendous precision */
      unspec (target) = "0"b;
      target.address = addr (hexfp_space);
      if source.data_type = real_flt_dec_generic_dtype
        then target.data_type = real_flt_hex_1_dtype;
        else target.data_type = cplx_flt_hex_1_dtype;
      target.prec_or_length = 27;	/* use a constant? */
      target.picture_image_ptr = null;

      call assign_$computational_ (addr (target), addr (source), code);
      if code = 0
        then source = target;		/* print hex instead if conversion worked */
    end;

  unspec (target) = "0"b;
  target.address = addr (value_str);
  target.data_type = varying_char_dtype;
  target.prec_or_length = maxlength (value_str);
  target.picture_image_ptr = null;

  on conversion go to CONVERSION_ERROR;
  on overflow go to CONVERSION_ERROR;
  on size go to CONVERSION_ERROR;

  call assign_$computational_ (addr (target), addr (source), code);
  if code ^= 0 then do;
CONVERSION_ERROR:
      call write_value_name ();

      call convert_status_code_ (code, short_message, long_message);
      call ioa_$ioa_switch (global.output_switch, "^a", long_message);
    end;
    else do;
      value_str = ltrim (value_str);

      if ^global.probe_sw & value_data_info.fixed & ^value_data_info.complex &
	 value_info.scale = 0 & precision >= 52 then do;

	unspec (target) = "0"b;
	target.address = addr (fb71);
	target.data_type = real_fix_bin_2_dtype;
	target.prec_or_length = 71;
	target.picture_image_ptr = null;

	call assign_$computational_ (addr (target), addr (source), 0);

	if fb71 > (clock () - TEN_YEARS) & fb71 < (clock () + TEN_YEARS)
	  then do;
				/* might be a date-time; is within 10 yr of now */
	    on sub_error_ go to SKIP_DTM;
	    value_str =
	         value_str || "   "
	         || date_time_$format ("iso_long_date_time", fb71, "", "");
	  end;
        end;
SKIP_DTM:
      call write_value_str ();
    end;
  return;

  end display_arithmetic;
%page;
display_c_enum:
  proc ();

  dcl (sym_addr, t_ptr, name_ptr)
			ptr;
  dcl not_found		bit (1);
  dcl based_int		fixed bin (35) based;

  t_ptr = value_symbol_ptr;
  not_found = "1"b;
  do while (not_found & t_ptr ^= null ());
    if (fixed (t_ptr -> runtime_symbol.type) = c_enum_const_dtype) then do;
        sym_addr = stu_$get_runtime_address (global.blockp,
	   t_ptr, global.stackp, global.linkp,
	   global.blockp, global.base_ptr, addr (global.indices));
        if sym_addr -> based_int = P_reference.address_ptr -> based_int
	then do;
	  name_ptr = addrel (t_ptr, fixed (t_ptr -> runtime_symbol.name));
	  call ioa_$ioa_switch (global.output_switch, "^a",
	       substr (name_ptr -> acc.string, 1, name_ptr -> acc.num_chars)
	       );
	  not_found = "0"b;
	end;
	else do;
	  if (fixed (t_ptr -> runtime_symbol.brother) = 0)
	    then t_ptr = null ();
	    else t_ptr =
		    addrel (t_ptr,
		    fixed (t_ptr -> runtime_symbol.brother));
	end;
      end;
      else do;
        if (fixed (t_ptr -> runtime_symbol.son) = 0)
	then t_ptr = null ();
	else t_ptr = addrel (t_ptr, fixed (t_ptr -> runtime_symbol.son));
      end;
  end;
  if not_found then do;
      call ioa_$ioa_switch (global.output_switch,
	 "Warning: The value for this enumerated value is out of range.");
      value_info.type = real_fix_bin_1_dtype;
      value_info.size = 35;
      value_info.scale = 0;
      call display_arithmetic ();
    end;
  end display_c_enum;
%page;
display_picture:
  proc ();


  dcl picture_ptr		pointer;
  dcl picture_len		fixed bin (35);
  dcl picture_string	char (picture_len) based (picture_ptr);


  call get_string_info (9, picture_ptr, picture_len);

  value_str = """" || picture_string || """";
  call write_value_str ();
  return;

  end display_picture;
%page;
display_char_string:
  proc ();


  dcl (amount_trimmed, str_len, trimmed_len)
			fixed bin (35);
  dcl str_ptr		pointer;
  dcl based_string		char (str_len) based (str_ptr);
  dcl trim_str		char (32) varying;
  dcl truncated_sw		bit (1);
  dcl quote_char		char (1);

  if language (COBOL_lang_type)
    then
         if (value_symbol_ptr ^= null ())
	 then /* In case it's a constant */
	      if (runtime_symbol_info_$son (value_symbol_ptr) ^= null ())
	        then do;
		call display_structure ();
				/* COBOL structures are strings;ase */
		return;
	        end;

  call get_string_info (9, str_ptr, str_len);

  if str_len > MINIMUM_TRIM then do;	/* "foo" || (165)" ", etc. */
      if substr (based_string, str_len, 1) = " "
        then
	   trimmed_len = length (rtrim (based_string, " "));
      else if substr (based_string, str_len, 1) = low (1)
        then
	   trimmed_len = length (rtrim (based_string, low (1)));
      else if substr (based_string, str_len, 1) = high (1)
        then
	   trimmed_len = length (rtrim (based_string, high (1)));
      else trimmed_len = str_len;

      if str_len - trimmed_len < MINIMUM_TRIM
        then trimmed_len = str_len;
    end;
    else trimmed_len = str_len;

  amount_trimmed = str_len - trimmed_len;

  if trimmed_len > STRING_LIMIT & global.truncate_strings then do;
				/* "mode truncate_strings" */
      truncated_sw = "1"b;
      trimmed_len = STRING_LIMIT;
    end;
    else truncated_sw = "0"b;

  quote_char = """";
  if language (FORTRAN_lang_type) | language (PASCAL_lang_type)
    then
         if index (substr (based_string, 1, trimmed_len), "'") = 0
	 then quote_char = "'";

  if amount_trimmed > 0 then do;
      if trimmed_len > 0
        then trim_str = " || ";
        else trim_str = "";
      trim_str = trim_str || "(";
      trim_str = trim_str || ltrim (character (amount_trimmed));
      trim_str = trim_str || ")";
      trim_str = trim_str || quote_char;
      trim_str = trim_str || substr (based_string, str_len, 1);
      trim_str = trim_str || quote_char;
    end;
    else trim_str = "";

  call write_value_name ();

  if trimmed_len = 0
    then
         call ioa_$ioa_switch (global.output_switch, "^[^a^;""""^]",
	    trim_str ^= "", trim_str);

  else if quote_char = """"
    then
         call ioa_$ioa_switch (global.output_switch, "^a^[ <MORE>^]^a",
	    requote_string_ (substr (based_string, 1, trimmed_len)),
	    truncated_sw, trim_str);

  else call ioa_$ioa_switch (global.output_switch, "'^a'^[ <MORE>^]^a",
	  substr (based_string, 1, trimmed_len), truncated_sw, trim_str);
  return;

  end display_char_string;
%page;
display_bit_string:
  proc ();


  dcl str_len		fixed bin (35);
  dcl str_ptr		pointer;
  dcl bit_string		bit (str_len) based (str_ptr);

  dcl FORTRAN_LOGICAL	(0:1) char (8) internal static
			options (constant) init
			(".FALSE.", ".TRUE.");
  dcl BIT_IOA_STRING	(4) char (12) varying internal static
			options (constant) init
			("""^.b""b", "^.3b", """^.3b""b3", """^.4b""b4")
			;

  dcl bit_radix		fixed bin;
  dcl truncated_sw		bit (1);


  call get_string_info (1, str_ptr, str_len);

  if language (FORTRAN_lang_type) & (str_len = 1) then do;
      value_str = FORTRAN_LOGICAL (binary (bit_string, 1));
      call write_value_str ();
      return;
    end;

  if str_len > STRING_LIMIT & global.truncate_strings then do;
      truncated_sw = "1"b;
      str_len = STRING_LIMIT;
    end;
    else truncated_sw = "0"b;

  /* In compressed output format, if we're given a single bit, we save it up for 
   later and print out all the flags in two groups ("ON" and "OFF"). */

  if global.compress_output & (str_len = 1) & (value_info.type = bit_dtype)
    then do;
      call add_bit (bit_string, value_name);
      return;
    end;

  /* For PL/I, we try to be clever, and display bitstrings in a useful format:
   octal, if appropriate, try hexadecimal next, and, all else failing, as bits.
   NOTE: This is sort of a crock, in that it uses 2 to mean "raw octal", 
   instead of "b2". This is done so that the "does-it-fit-in-the-buffer"
   test will work without further hacking. */

  if global.octal_sw
    then bit_radix = 2;
  else if (mod (str_len, 3) = 0)
    then bit_radix = 3;
  else if (mod (str_len, 4) = 0) & (str_len <= 64) & (str_len > 4)
    then bit_radix = 4;
  else bit_radix = 1;

  if divide (str_len, bit_radix, 24, 0) < maxlength (value_str) - 20 then do;
      call ioa_$rsnnl (BIT_IOA_STRING (bit_radix) || "^[ <MORE>^]", value_str,
	 (0),
	 bit_string, truncated_sw);
      call write_value_str ();
    end;
    else do;
      call write_value_name ();
      call ioa_$ioa_switch (global.output_switch,
	 BIT_IOA_STRING (bit_radix) || "^[ <MORE>^]",
	 bit_string, truncated_sw);
    end;
  return;
%page;
add_bit:
  proc (P_bits, P_name);


  dcl P_bits		bit (*) unaligned;
  dcl P_name		char (*) varying;

  dcl bitbufp		pointer;
  dcl 1 bitbuf		aligned like bit_buffer based (bitbufp);
  dcl this_bit		bit (1) aligned;
  dcl max_len		fixed bin;
  dcl new_len		fixed bin;


  this_bit = substr (P_bits, 1, 1);

  bitbufp = get_bitbuf (this_bit, "0"b);

  if (length (bitbuf.str) > 0) then do;
      max_len = global.line_length - (indentation () + 5);
      new_len = length (bitbuf.str) + length (value_name) + 2;
      if (new_len > max_len) then do;
	bitbuf.str = bitbuf.str || ",";
				/* End the last one with a comma */
	bitbufp = get_bitbuf (this_bit, "1"b);
				/* See if it can fit, get a new buffer if not */
        end;
    end;

  if (length (bitbuf.str) > 0)
    then
         bitbuf.str = bitbuf.str || ", ";
  bitbuf.str = bitbuf.str || value_name;
  return;
%page;
get_bitbuf:
  proc (P_bit, P_create_sw) returns (pointer);



  dcl a_temp_pointer	pointer;
  dcl P_bit		bit (1) aligned parameter;
  dcl P_create_sw		bit (1) aligned parameter;

  /* This is just an interface to find_or_create_bitbuf, passing the appropriate
   pointers from parent_output_info. */

  if (P_bit = "1"b)
    then
         a_temp_pointer = find_or_create_bitbuf (P_create_sw,
	    parent_output_info.on_bits.first,
	    parent_output_info.on_bits.last);

    else a_temp_pointer = find_or_create_bitbuf (P_create_sw,
	    parent_output_info.off_bits.first,
	    parent_output_info.off_bits.last);

  return (a_temp_pointer);


find_or_create_bitbuf:
  proc (P_create_sw, P_first, P_last) returns (pointer);

  dcl P_create_sw		bit (1) aligned parameter;
  dcl P_first		pointer parameter;
  dcl P_last		pointer parameter;

  dcl bufp		pointer;

  /* This procedure either finds the last bit buffer, or creates one and threads
   it into the list. One is always created if the list is empty; otherwise, 
   one is created if P_create_sw specifies it. */


  if P_create_sw | (P_first = null ()) then do;
      allocate bit_buffer in (system_area) set (bufp);
      bufp -> bit_buffer.str = "";
      bufp -> bit_buffer.next = null ();
      if (P_first = null ())
        then P_first = bufp;
        else P_last -> bit_buffer.next = bufp;
      P_last = bufp;
    end;

    else bufp = P_last;
  return (bufp);
  end find_or_create_bitbuf;


  end get_bitbuf;


  end add_bit;


  end display_bit_string;
%page;
get_string_info:
  proc (bits_per_char, str_ptr, str_len);


  dcl bits_per_char		float bin parameter;
  dcl str_ptr		pointer parameter;
  dcl str_len		fixed bin (35) parameter;

  dcl max_len		fixed bin (35);
  dcl chars_per_word	float bin;
  dcl based_varying_len	fixed bin (35) based (value_ptr);

  if value_data_info.varying
    then str_ptr = addrel (value_ptr, 1);
    else str_ptr = value_ptr;

  chars_per_word = 36 / bits_per_char;
  value_str = "";			/* If there is a problem, we will put an error message here */

  if (value_info.type = picture_runtime_dtype)
    then
         str_len =
	    pointer (value_symbol_ptr,
	    decode (value_info.size, value_info.size_is_encoded))
	    -> picture_image.varlength;

  else if value_data_info.varying then do;
      max_len = decode (value_info.size, value_info.size_is_encoded);
      str_len = based_varying_len;	/* get length word */
      if (str_len > max_len)
        then
	   call ioa_$rsnnl ("[varying length ^d is > dcld maximum ^d.]",
	        value_str, (0), str_len, max_len);
    end;

  else str_len = decode (value_info.size, value_info.size_is_encoded);

  if (language (C_lang_type) & P_reference.type = pointer_dtype
       & P_reference.precision > 0) then do;
      str_len = P_reference.precision;
    end;
  else if language (C_lang_type)
       & (value_info.size > 1 | my_real_name_ptr ^= null ()) then do;
      begin;
        dcl end_not_found	      bit (1) init ("1"b);
        dcl based_ints	      (0:255) fixed bin (9) unsigned
			      unaligned based (str_ptr);
        dcl max_len		      fixed bin (24);

        if (my_real_name_ptr ^= null ())
	then max_len = 256;
	else max_len = value_info.size - 1;
        do str_len = 0 to max_len while (end_not_found);
	if based_ints (str_len) = 0 then do;
	    end_not_found = "0"b;
	    str_len = str_len - 1;
	  end;
        end;
      end;
    end;
  if (str_len < 0)
    then
         call ioa_$rsnnl ("[length ^d is less than zero.]",
	    value_str, (0), str_len);

  else if ((binary (rel (str_ptr), 18) + (str_len / chars_per_word))
       > sys_info$max_seg_size)
    then
         call ioa_$rsnnl ("[length ^d is past end of the segment.]",
	    value_str, (0), str_len);

  else if ((binary (rel (str_ptr), 18) + (str_len / chars_per_word))
       > global.max_offset)
    then
         call ioa_$rsnnl ("[length ^d is past end of available data.]",
	    value_str, (0), str_len);

  if (value_str ^= "") then do;
      call write_value_str ();
      goto NONFATAL_ERROR;
    end;
  return;

  end get_string_info;
%page;
display_pointer:
  proc ();


  dcl based_ptr		pointer based (value_ptr);
  dcl based_packed_ptr	pointer unaligned based (value_ptr);


  if value_info.packed
    then
         value_str = format_pointer_$packed
	    (based_packed_ptr, "1"b, global.amu_info_ptr);

    else value_str =
	    format_pointer_$its (based_ptr, "1"b, global.amu_info_ptr);

  call write_value_str ();
  return;

  end display_pointer;

display_offset:
  proc ();


  dcl offset_ptr		pointer;
  dcl based_offset		offset based (value_ptr);
  dcl 1 offset_overlay,
       2 word		fixed bin (18) unsigned unaligned,
       2 bit		fixed bin (18) unsigned unaligned;


  offset_ptr = stu_$offset_to_pointer (global.blockp, value_symbol_ptr,
       value_ptr, global.stackp, global.linkp, global.blockp);

  if (offset_ptr ^= null ())
    then
         value_str =
	    format_pointer_$its (offset_ptr, "1"b, global.amu_info_ptr);

  else if (based_offset = nullo ())
    then
         value_str = "null offset";

  else do;
    unspec (offset_overlay) = unspec (based_offset);
    call ioa_$rsnnl ("word offset: ^o bit offset: ^d",
         value_str, (0), offset_overlay.word, offset_overlay.bit);
  end;

  call write_value_str ();
  return;

  end display_offset;
%page;
display_label_constant:
  proc ();


  call ioa_$rsnnl ("^a|^o", value_str, (0),
       format_pointer_$its (value_ptr, "1"b, global.amu_info_ptr),
       binary (rel (value_ptr), 18));
  call write_value_str ();
  return;

  end display_label_constant;



display_entry_constant:
  proc ();


  value_str = format_pointer_$its (value_ptr, "1"b, global.amu_info_ptr);
  call write_value_str ();
  return;

  end display_entry_constant;
%page;
display_label_or_entry:
  proc ();


  dcl based_label		label variable based (value_ptr);
  dcl 1 label		aligned,
       2 place		pointer,
       2 frame		pointer;


  unspec (label) = unspec (based_label);
  call ioa_$rsnnl ("^a :: ^p", value_str, (0),
       format_pointer_$its (label.place, "1"b, global.amu_info_ptr),
       label.frame);
  call write_value_str ();
  return;

  end display_label_or_entry;


display_file:
  proc ();


  dcl based_file		file variable based (value_ptr);


  call display_file_value_ (global.output_switch, based_file, (0));
  return;

  end display_file;
%page;
display_structure:
  proc ();


  /* To display a structure, we always give the structure name a line of its
   own before the recursing starts to print out the next level.  This is 
   only really important for compressed output mode, since otherwise, every
   value gets a line of its own anyway.  This does its own printing because
   it's far easier to do that than to make write_value_str any hairier. */

  /* It is a side-effect of this next call that the last line of output (say, 
   for level 3) before a substructure (say, level 4) is printed will not end
   in a comma, even if there are more scalar elements yet to be printed (at
   level 3).  I happen to think this is reasonably aesthetic, and better than
   including that lonesome comma, but it would be easy to change by adding
   another parameter to the finish_output call. */


  call finish_output (addr (parent_output_info), "0"b);

  call ioa_$ioa_switch (global.output_switch,
       "^vx^a^[^31t@ ^p", indentation (),
       value_name, ^global.probe_sw, real_value_ptr);
  return;

  end display_structure;
%page;
display_undisplayable:
  proc ();


  dcl message		char (40);


  if (value_info.type = area_dtype)
    then message = "an area";
  else if (value_info.type = algol68_straight_dtype)
    then message = "an algol68 straight";
  else if (value_info.type = algol68_format_dtype)
    then message = "an algol68 format";
  else if (value_info.type = algol68_array_descriptor_dtype)
    then
         message = "an algol68 array descriptor";
  else if (value_info.type = algol68_union_dtype)
    then message = "an algol68 union";
  else message = "data type " || ltrim (character (value_info.type));

  call ioa_$rsnnl ("[can't display value of ^a @ ^p]",
       value_str, (0), message, real_value_ptr);
  call write_value_str ();

  end display_undisplayable;

  end display_single_value;
%page;
language:
  proc (lang_type) returns (bit (1) aligned);


  dcl lang_type		fixed bin parameter;

  /* This procedure appears in two places in order for it to be quick in both of
   them. Clearly, it's not very complicated. */
  return (global.language_type = lang_type);

  end language;
%page;
get_symbol_name:
  proc () returns (char (256) varying);


  dcl name_string		char (256) varying;
  dcl father_idx		fixed bin;
  dcl start_level		fixed bin;
  dcl sym_dim		fixed bin;/* number of dims a symbol owns */
  dcl running_dims		fixed bin;/* total dims of all fathers */
  dcl my_level		fixed bin;
  dcl total_dims		fixed bin;/* total number of subscripts on this identifier */

  dcl father_dims		fixed bin;
  dcl element_symbol_ptr	pointer;
  dcl 1 element_name	aligned
			based (
			runtime_symbol_info_$name (element_symbol_ptr)),
       2 len		fixed bin (9) unsigned unaligned,
       2 str		char (0 refer (element_name.len)) unaligned;


  sym_dim = runtime_symbol_info_$array_dims (value_symbol_ptr);
  name_string = "";

  if (language (C_lang_type) & dont_print_me_this_time) then do;
      dont_print_me_this_time = "0"b;
      return (name_string);
    end;

  if language (FORTRAN_lang_type) then do;
      element_symbol_ptr = value_symbol_ptr;
      name_string = element_name.str;
      call add_dims (sym_dim, 1, -1);	/* FORTRAN is backwards */
    end;				/*  FORTRAN name */

  else if global.short_names then do;
      element_symbol_ptr = value_symbol_ptr;

      if my_real_name_ptr ^= null ()
        then
	   element_symbol_ptr = my_real_name_ptr;

      /* Without this test for null, big headaches. */

      if (runtime_symbol_info_$name (element_symbol_ptr) ^= null ())
        then do;
	if (P_reference.type ^= structure_dtype &
	     P_reference.type ^= c_union_dtype &
	     my_real_name_ptr = null ()
	     & global.language_type = C_lang_type)
	  then
	       name_string = name_string || P_reference.name;
	  else
	       name_string = name_string || element_name.str;
        end;
        else name_string = P_reference.name;

      if language (COBOL_lang_type)
        then name_string = translate (name_string, "-", "_");

      my_level = runtime_symbol_info_$level (element_symbol_ptr);
      total_dims = runtime_symbol_info_$array_dims (element_symbol_ptr);
      if P_top_level_sw
        then father_dims = 0;

      /* This global.father array is a mess. C seems to reference values
         in this array that have not been initialized.   */

      else if (my_level > 1 & global.language_type ^= C_lang_type)
        then do;			/* we are in structure, there is a global.father */
	if global.father (my_level - 1) ^= null ()
	  then
	       father_dims =
		  runtime_symbol_info_$array_dims (global
		  .father (my_level - 1));
        end;
      else father_dims = 0;
      call add_dims ((father_dims + 1), total_dims, 1);
    end;				/* COBOL or BRIEF or SHORT */

  else do;
    start_level = max (1, runtime_symbol_info_$level (value_symbol_ptr));
				/* for level 0 symbol, name stored in first */
    running_dims = 0;
    do father_idx = 1 to start_level;
      element_symbol_ptr = global.father (father_idx);

      name_string = name_string || element_name.str;
      sym_dim =
	 runtime_symbol_info_$array_dims (element_symbol_ptr)
	 - running_dims;
      call add_dims ((running_dims + 1),
	 (running_dims + sym_dim), 1);
      running_dims = running_dims + sym_dim;
      if (father_idx < start_level)
        then /* there are more names ahead */
	   name_string = name_string || ".";
    end;
  end;				/* end long naming */

  if (global.language_type = C_lang_type
       & substr (name_string, 1, 1) = "!")
    then
         name_string = "";


  return (name_string);
%page;
  /* This entry just returns a name which can be used in messages */

get_unsubscripted_name:
  entry () returns (char (256) varying);

  name_string = "";

  start_level = max (1, runtime_symbol_info_$level (value_symbol_ptr));
				/* for level 0 symbol, name stored in first */

  do father_idx = 1 to start_level;
    element_symbol_ptr = global.father (father_idx);
    name_string = name_string || element_name.str;
    name_string = name_string || ".";
  end;

  element_symbol_ptr = value_symbol_ptr;
  name_string = name_string || element_name.str;
  return (name_string);



add_dims:
  proc (first, last, increment);


  dcl first		fixed bin parameter;
  dcl last		fixed bin parameter;
  dcl increment		fixed bin parameter;

  dcl dim_idx		fixed bin;

  /* Add dimension string to name_string if need be. The test sees whether there
   are any dimensions in the range to be added */


  if ((increment * (last - first)) < 0) then do;
      return;
    end;

  if (global.language_type ^= C_lang_type) then do;
      name_string = name_string || " (";
      do dim_idx = first to last by increment;
        name_string = name_string ||
	   ltrim (rtrim (character (global.indices (dim_idx))));
        if (dim_idx ^= last)
	then name_string = name_string || ",";
      end;

      name_string = name_string || ")";
    end;
    else do;
      name_string = name_string || "[";
      do dim_idx = first to last by increment;
        name_string = name_string ||
	   ltrim (rtrim (character (global.indices (dim_idx))));
        if (dim_idx ^= last)
	then name_string = name_string || "][";
      end;

      name_string = name_string || "]";
    end;
  return;

  end add_dims;

  end get_symbol_name;
%page;
write_value_str:
  proc ();


  dcl delimiter		char (32) varying;
  dcl value_len		fixed bin;
  dcl max_len		fixed bin;
  dcl buf_len		fixed bin;
  dcl ind_len		fixed bin;
  dcl include_value		bit (1) aligned;


  include_value = "1"b;

  if ^global.print_names then do;	/* Get scalars out of the way quickly */
      call ioa_$ioa_switch (global.output_switch, "^a", value_str);
      return;
    end;

  goto COMMON;


write_value_name:
  entry ();


  include_value = "0"b;

  if ^global.print_names then do;
      return;
    end;

  goto COMMON;


COMMON:
  if global.probe_sw
    then delimiter = probe_modes.value_separator;
    else delimiter = " = ";

  value_len = length (value_name) + length (delimiter);
  if include_value
    then value_len = value_len + length (value_str);

  ind_len = indentation ();		/* For efficiency only */

  if ^global.compress_output then do;
      call ioa_$ioa_switch_nnl (global.output_switch,
	 "^vx^va^va^[^/^5x^vx^;^s^]^[^a^/^]", ind_len,
	 length (value_name), value_name,
	 length (delimiter), delimiter,
	 ((value_len > 72) & include_value), ind_len,
	 include_value, value_str);
      return;
    end;

  buf_len = length (parent_output_info.buffer);
  max_len = global.line_length;

  if ^include_value then do;

      /* In this case, we've been asked not to include the value, on the presumption
   that it is a rather long string. So, we just print out the current buffer
   contents, possibly inserting a newline if the value name itself is too
   long for the current line. */

      call ioa_$ioa_switch_nnl (global.output_switch,
	 "^va^[, ^]^[^/^vx^;^s^]^va^va",
	 buf_len, parent_output_info.buffer, (buf_len > 0),
	 ((buf_len + value_len + 2) > max_len), ind_len,
	 length (value_name), value_name,
	 length (delimiter), delimiter);

      parent_output_info.buffer = copy (" ", indentation ());
      return;			/* Empty the buffer */
    end;

  if ((buf_len + value_len + 2) < max_len) then do;

      /* In this case, the whole thing is small enough to fit in the current buffer,
   so we just append it and return, knowing that it will get printed later */

      if (parent_output_info.buffer ^= "")
        then /* Something there already */
	   parent_output_info.buffer = parent_output_info.buffer || ", ";
      parent_output_info.buffer = parent_output_info.buffer || value_name;
      parent_output_info.buffer = parent_output_info.buffer || delimiter;
      parent_output_info.buffer = parent_output_info.buffer || value_str;
      return;
    end;

  /* If it didn't fit, then we'll just go to the next line and print the stuff */

  if (buf_len > 0)
    then /* Print the current buffer if it has any contents */
         call ioa_$ioa_switch (global.output_switch, "^va,",
	    buf_len, parent_output_info.buffer);

  parent_output_info.buffer = copy (" ", ind_len);
				/* Empty the buffer */

  if ((value_len + 2) < max_len) then do;
				/* If it will fit, put it in */
      parent_output_info.buffer = parent_output_info.buffer || value_name;
      parent_output_info.buffer = parent_output_info.buffer || delimiter;
      parent_output_info.buffer = parent_output_info.buffer || value_str;
      return;
    end;

  /* Otherwise, write it out now, and leave the buffer empty */

  call ioa_$ioa_switch (global.output_switch,
       "^vx^va^va^[^/^5x^vx^;^s^]^a",
       ind_len, length (value_name), value_name,
       length (delimiter), delimiter,
       ((value_len + 2) > max_len), ind_len,
       value_str);
  return;

  end write_value_str;
%page;
indentation:
  proc () returns (fixed bin);

  dcl a_temp_value		fixed bin;
  a_temp_value =
       get_indentation (runtime_symbol_info_$level (value_symbol_ptr));
  return (a_temp_value);
  end indentation;


next_indentation:
  proc () returns (fixed bin);

  dcl a_temp_value		fixed bin;
  a_temp_value =
       get_indentation (1 + runtime_symbol_info_$level (value_symbol_ptr));
  return (a_temp_value);
  end next_indentation;


get_indentation:
  proc (P_level) returns (fixed bin);


  dcl P_level		fixed bin (6) parameter;

  dcl amount		fixed bin;
  dcl MAX_INDENT		fixed bin internal static
			options (constant) init (12);


  if ^global.short_names | language (C_lang_type) then do;
      return (0);
    end;

  amount = binary (P_level, 6) - 1;
  amount = max (amount, 0) * 2;
  amount = min (amount, MAX_INDENT);
  return (amount);

  end get_indentation;
%page;
finish_output:
  proc (P_output_info_ptr, P_finish_bits);


  dcl P_output_info_ptr	pointer parameter;
  dcl 1 finish_output_info	aligned like output_info_template
			based (P_output_info_ptr);
  dcl P_finish_bits		bit (1) aligned parameter;


  if ^global.compress_output then do;
      return;			/* nothing to do */
    end;

  if (finish_output_info.buffer ^= "")
    then
         call ioa_$ioa_switch (global.output_switch,
	    "^a", finish_output_info.buffer);

  if P_finish_bits
    then call finish_bits ();

  finish_output_info.buffer = copy (" ", indentation ());
				/* for safety's sake */
  return;
%page;
finish_bits:
  proc ();


  /* This procedure writes out the contents of any of the bit flag buffers we
   may have allocated, and frees them as it does so. */


  call write_bitbufs ("ON:",
       finish_output_info.on_bits.first,
       finish_output_info.on_bits.last);

  call write_bitbufs ("OFF:",
       finish_output_info.off_bits.first,
       finish_output_info.off_bits.last);
  return;



write_bitbufs:
  proc (P_name, P_first, P_last);


  dcl P_name		char (4) parameter;
  dcl P_first		pointer parameter;
  dcl P_last		pointer parameter;

  dcl bitbufp		pointer;
  dcl 1 bitbuf		aligned like bit_buffer based (bitbufp);
  dcl lastp		pointer;


  lastp = null ();
  do bitbufp = P_first repeat (bitbuf.next) while (bitbufp ^= null ());
    if (lastp ^= null ())
      then free lastp -> bitbuf;
    call ioa_$ioa_switch (global.output_switch,
         "^vx^[^5a^;^5x^s^]^a", next_indentation (),
         (bitbufp = P_first), P_name, bitbuf.str);
    lastp = bitbufp;
  end;

  if (lastp ^= null ())
    then free lastp -> bitbuf;
  P_first = null ();
  P_last = null ();
  return;

  end write_bitbufs;

  end finish_bits;

  end finish_output;

  end print_symbol;
%page;
bitno:
  proc (p) returns (fixed bin (24));


  dcl p			pointer parameter;
  dcl o			fixed bin (24) parameter;
  dcl 1 itsp		aligned like its_unsigned;
  dcl bito		fixed bin (24);
  dcl bitp		pointer;
  dcl mod			builtin;
%include its;

  /* This procedure can be flushed when this gets back to MIT */

  unspec (itsp) = unspec (p);
  return (36 * itsp.offset + itsp.bit_offset);


addbitoffset:
  entry (p, o) returns (pointer);


  unspec (itsp) = unspec (p);
  bito = 36 * itsp.offset + itsp.bit_offset;
  bito = bito + o;
  itsp.offset = divide (bito, 36, 18, 0);
  itsp.bit_offset = mod (bito, 36);
  unspec (bitp) = unspec (itsp);
  return (bitp);

  end bitno;

%page;
%include probe_info;
%page;
%include probe_static_info;
%page;
%include probe_references;
%page;
%include probe_source_info;
%page;
%include probe_seg_info;
%page;
%include probe_data_type_names;
%page;
%include probe_modes;
%page;
%include probe_lang_types;
%page;
%include acc;
%page;
%include computational_data;
%page;
%include data_type_info_;
%page;
%include encoded_precision;
%page;
%include picture_image;
%page;
%include runtime_symbol;
%page;
%include runtime_symbol_info_;
%page;
%include std_descriptor_types;
%page;
%include its;
  end display_data_;
