/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-06-14 by Thanh
     Nguyen. (see mrds #137, #139 (phx19906)
  2) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-06,Dupuis), install(88-08-01,MR12.2-1073):
     For the new parser, modified the way that the range and select list
     pointers are set.
                                                   END HISTORY COMMENTS */


mrds_dsl_optimize: proc (dbcb_ptr, pred_ptr, so_ptr, code);

/*
   .                        BEGIN_DESCRIPTION
   This  procedure performs final processing and optimization of the predicate
   tree  resulting  from  the -where clause.  All "not" nodes are removed, and
   all  "or" node are moved so that none appears subordinate to an "and" node.
   At  this point, the usefulness of the tree structure disappears, and so the
   tree  is  converted  into a list of "and groups".  After the predicate tree
   optimization, a "program" for mrds_dsl_search is generated.



   INPUT CONDITIONS:

   dbcb_ptr  points  to  a valid DBCB and pred_ptr points to a valid
   predicate tree.



   OUTPUT DEFINITIONS:

   dbcb.pred_ptr will point to an array of "and groups".

   code = 0;  if no errors are detected.

   code  = mrds_error_$node_stack_ovfl; if one of the internal stacks used for
   traversing the tree overflows.

   code = mrds_error_$max_and_groups;  if there are too many and groups.

   code  =  mrds_error_$max_and_terms; if there are too many terms to fit into
   an and group;

   code  = mrds_error_$var_stack_ovfl; if the variable stack used for ordering
   terms within an and group overflows.

   code  = mrds_error_$no_tuple_effect; if there are tuple variables that have
   no effect on the select set.

  HIGH LEVEL VIEW:
       a. If no predicate tree (no where clause)
	do  cross	 product	over  all	 tuple  variables,	if  a
	relation	has  no tuples  the search  program generated
	will  cause the  tuple not  found error	 to be returned
	with out causing any i/o to the database
       b. else
	  1. convert predicate  tree to disjuctive  normal form
	     and go from a tree to a list.
	  2. loop
	       a. determine	 optimium	 search	path  for	 each
		and-group (mrds_dsl_permute)
	       b. generate	search  program for	 each and-group
		(mrds_dsl_gen_srch_prog)
	  3. build  global	search program  over  all and-group
	     search programs.   Done by sorting	 each and-group
	     search  program  and building  the global  list by
	     putting  the  ones with	the smallest  cost first,
	     and-groups with zero cost are removed.

  NOTES:
       1. if  no-optimize is	set than	and-group search programs
	are not sorted  by cost or if cross  product not sorted
	by relation size.
       2. output from print_search_order is done from optimize.
   .                        END_DESCRIPTION

   MRDS_DEBUG_TOOL SWITCH DEFINITIONS:

   bit 1 = perdicate tree display switch

   bit 2 = search paths display switch

   bit 3 = use calc_cost in addition to permute to determine search paths

   bits 4 thru 9 = not used



   HISTORY:

   76-03-01 J. A. Weeldreyer: Initially written.

   76-08-01 J. A. Weeldreyer: Modified to create  pseudo  terms  for
   undetermined free terms.

   76-09-01 J.  A.  Weeldreyer:  Modified  to  fix  and_group  shift
   problem.

   77-04-01 J. A. Weeldreyer: Modified  to  fix  a  term  reordering
   problem.

   77-09-01 J. A. Weeldreyer:  Modified  to  fix  yet  another  term
   reordering problem.

   77-04-01 J. A. Weeldreyer: Modified to incorporate MR6.0 changes.

   77-09-01 J. A. Weeldreyer: Modified to eliminate concept of bound
   variables.

   78-03-01 J. A. Weeldreyer: Modified to  fix  more  bugs  in  term
   reordering and copying.

   78-11-01 J. A. Weeldreyer: Modified for MR7.0.

   79-04-24  Al  Kepner:  Modified  to  (1)   initialize   cost   in
   path_array, (2) to rewrite combining of all search op tables into
   one in create_search_lists.

   79-06-01 Al Kepner: Modified by to use select_area.

   79-07-16 NSDavids: Modified to build  a  search  path  using  all
   tuple  variables  in  range  clause.  also  to  check for a tuple
   variable that has no effect on  the  select  set  and  return  an
   error.

   79-10-22 Rickie E. Brinegar: Modified to call mrds_dsl_permute to
   get  the  absolute  minmum  cost  path,  and  to  make use of the
   mrds_debug_tool with mrds_debug_names.

   80-01-21 Rickie E. Brinegar: Modified  to  properly  account  for
   range variables not used in a particular and group.

   80-01-23 Davids: modified determine_min_cost_segment so  that  if
   all  paths  have  already  been  looked  at it returns a null pvp
   pointer   rather   than   just   returning   what   was    given.
   create_search_lists  has  been modifed to work with the case of a
   returned null pointer.

   80-01-24  Davids:  path_var_flags  is  reset  to  "0"  for   each
   and-group rather than retaining flag values from last and group.

   80-04-11 Rickie E. Brinegar: Modified  to  make  mdb_calc_cost  a
   debug tool using debug switch number 3.

   80-09-23 Jim Gray: Modified to capture max_and_groups overflow in
   the routine cannonize_pred in one case that was overlooked.

   81-03-27 Jim Gray : added dbcb_ptr parameter  to  mu_get_rel_size
   as part of getting rid of mus_ptr_man module.

   81-03-30 Jim Gray : for TR 9457, moved a check for  only  a  left
   branch  "or",  in the canonize_pred routine, to handle both right
   and left branches. Problem  symptom  was  that  (a|b)&(c|d)&(e|f)
   type queries would not return all matching tuples.

   01-06-01 Jim Gray : changed to use new resultant structure.  Also
   renamed rmds_dsl_calc_cost to mdb_calc_cost.

   81-06-17  Jim  Gray  :  added  call  to  mu_open_iocb_manager  to
   implement attach/open of iocbs on an as needed basis.

   81-06-23 Jim  Gray  :  changed  sort  order  for  the  cross_prod
   routine,  so  that  search program generated is to do the smaller
   relations first.


   81-06-24 Jim Gray : added capture of case when cross product will
   be  empty, so that no retrieves have to be done to find this out.
   This  can  only  be  done  for  non   set   operation   selection
   expressions.

   81-06-26 Roger Lackey : added  code  to  handle  no_optimize  and
   print_search_order

   81-07-01 Jim Gray : modified  print_search_order  for  the  cross
   product case to use the real search order, not the tuple variable
   order.

   81-07-02 Jim Gray : changed method  of  getting  tuple  count  in
   cross_prod,  to  get  it from rm_rel_info statistics, rather than
   calling mu_get_rel_size. Also changed -no_optimize, to only avoid
   sorting, noptimize the getting of rel sizes.

   81-07-09 Jim Gray  :  removed  code  dealing  with  mdb_calc_cost
   logic,  as  this  routine  does  not  support  the  new  path_var
   structure and constants.

   81-07-14 Jim Gray : changed -print_search_order display to output
   additional  info  now  available  in  path_var  structure, and to
   separate and group info.  Also  added  logic  to  display  access
   method  as  indexed  attr  if  the  user  is  a peon on a secured
   database and actually has  a  key  access  method.  Added  proper
   handling  of  temp rel names, and changed internal form of access
   method names to better user visible ones. Revamped output format.

   81-07-15 Jim Gray : changed method of determining whether a tuple
   variable  has an effect on the select set for the case of a where
   clause.  The  previous  method  relied  on   mdb_calc_cost.   Now
   existance of conditions in the where clause is determined as well
   as use in the select clause. One or the other must exist. If only
   present in the select clause we have a cross product effect. Also
   removed all  use  of  the  path_array  which  was  only  used  by
   mdb_cal_cost.

   81-07-16 Jim Gray : changed cross product print search order  ioa
   parameters  so that the order in the array was used for the ORDER
   output, and also so that the size  was  gotten  from  the  proper
   place  in  the  array. Also changed tuple_no_effect logic for the
   where clause case, so that tuple variables appearing last in  the
   list with no conditions, but really used are properly handled.

   81-07-17 Jim Gray : modified method by  which  several  and_group
   search  programs  were  made into a single search_op program. The
   individual and_group search_op programs are now sorted  based  on
   their cost. This will help improve the performance of getting the
   first tuple from a multiple and group select expr.

   81-07-18 Jim Gray : added logic to make a phony search program of
   just  return_null  for  the  case where all and groups contain an
   unpopulated  relation,  and  thus  can  not  be  satistied.  Also
   extended  the  fix to the cross product case, to make it work for
   set S.E.'s, and allow display of the -pso  output  regardless  of
   the situation.

   81-07-19 Jim Gray : extended  the  fix  for  the  no_tuple_effect
   detection  so it could handle the case -select A -where (A & B) |
   (A & C) or the case -select A -where A | B.

   81-07-21 Jim Gray : modified -pso output, where clause  case,  to
   show both conditions when permute used a range against a key head
   or indexed attr.

   81-07-23  Roger  Lackey  :   set   dbcb.pred_ptr   for   use   by
   mrds_dsl_retrieve auto dup

   81-07-24 Jim Gray : changed setting of  dbcb.pred_ptr  to  handle
   case  of  where  clause. The input pred_ptr is to the root of the
   predicate tree. This value is changed in cannonize_pred to  point
   to the pred_array.

   81-09-10  Rickie E.  Brinegar: Removed (no-subrg) prefix that was
   buried in the code as (subrg) is not on except in the development.

   81-09-11 Davids: enclosed both target and source of two assigment
   statements  with  unspec.  This  was done to get around a pl1 bug
   which causes the subscriptrange condition to be signaled when the
   module  is  compiled  with the subscriptrange prefix. The pl1 bug
   was reported as tr11508.

   81-09-19  Davids:  changed  the  lowest  index   reference   into
   path_var_pointer_array  to 1 from 0. The reference to index 0 was
   causing a subscriptrange condition to occur.

   81-09-29 Davids: modified section of code dealing with zero  cost
   and-groups. moved the setting of the err_xfer within the scope of
   the if cost ^= 0 statement, it was just outside the scope,  which
   resulted  in  subscriptrange  conditions when begin_and_group was
   not set.

   82-06-14 Davids: added high level view and notes.

   82-09-01 Mike Kubicar : converted from using the tuple structure to
   using the vector structure.  In this module, this means using an index
   into the tuple structure (select_info.tuple_info_index) instead of
   a pointer to where a tuple will be place (select_info.t_ptr).

   82-09-23 Davids: removed references to the file_io_array and the 
   rm_rel_info.iocb_ptr array and mu_open_iocb_manager and replaced
   them with a call to mu_cursor_manager_$get.

   82-10-26 Davids: Modified so the cursor set up in the cross_prod
   internal proc always uses the record collection (rel_id). It was
   using the record collection if the ready_mode was retrieval and the
   primary key collection if the ready mode was update.

   82-11-12 Mike Kubicar : Due to problems with vrm_relmgr_, the previous
   change had to be backed out.

   82-11-29 Davids: Modified so name of a temp rel dispalyed by the -pso
   option is the temp rel index. This was inadvertently changed when the
   use of the rm_rel_info.rel_id element changed to be a relation manager
   identifier.

   83-04-04 Mike Kubicar : Removed distinction between unordered and ordered
   sequential searches.  -pso should only print out sequential search.
   Also, for cross products, only generate a record collection cursor ptr.

   83-04-22 Mike Kubicar : If there is no where clause, cross_product must
   generate a search specification that will select the entire relation.
   Also, removed all references to the obsolete structure init_info.

   83-05-03 Mike Kubicar : Added initialization of rtrv_info (or its alias)
   .maxtids.

   83-05-25 Ron Harvey : Added the build_vectors routine to support the 
   shortened simple_typed_vector changes.

   83-05-31 Mike Kubicar : Updated to use the new (version 4) search
   specification.

   83-08-04 Mike Kubicar : Added code to set up all the element id lists
   needed by the search program.  The element_id_list_segment is evenly
   divided among all the tuple variables.

   83-08-05 Ron Harvey : Modified the build_vectors routine to back out the
   shortened simple_typed_vector changes.

   83-10-24 Mike Kubicar - Changed to only request
   mrds_data_$max_tids_returned_per_call tuple ids be returned in the element
   id list instead of as many as possible.  This is due to a customer request
   that mrds be more interactive (i.e. they liked it the old way).

   85-04-08 Thanh Nguyen - Added code to set the max_tids to be either 
   max_tids_returned_per_call or max_safe_tids_returned_per_call depending on 
   the scope of the relation is shared or not.

   85-06-14 Thanh Nguyen - Added code to check if the relation is temporary
   (rm_rel_info.file_type = 3) then set max_tids to be 
   max_tids_returned_per_call and not validate the scopes.  Also rewrote
   the calculation method for the size of element_id_list structure.
*/
%page;

	display_predicate_tree = substr (db_mrds_dsl_optimize, 1, 1);
	display_search_paths = substr (db_mrds_dsl_optimize, 2, 1);
	num_ptrs = 0;
	rdbi_ptr = dbcb.rdbi_ptr;
          range_ptr = dbcb.range_ptr;
	select_list_ptr = dbcb.select_ptr;
	ti_ptr = dbcb.ti_ptr;

	select_area_ptr = dbcb.select_area_ptr;
	sa_alloc = "0"b;
	sap = null ();
	or_top = 0;
	if pred_ptr = null then do;			/* if no pred. */
		dbcb.pred_ptr = null ();		/* no and groups */
		call cross_prod;			/* either rel dump, or cross prod. */
	     end;

	else do;					/* if pred. specified */
		call canonize_pred;			/* put in disjunctive normal form */

		dbcb.pred_ptr = pred_ptr;		/* to pred_array */

		call create_search_lists;		/* generate the program for search */

	     end;

	code = 0;					/* tell caller the good news */

exit:	return;
%page;
cross_prod: proc;

/* Procedure to build search info for select block with no where clause.  THis
   implies either a relation dump or a cross product. */

	dcl     (i,
	        j,
	        ii,
	        si,
	        vi,
	        rvi,
	        rni)		 fixed bin;
	dcl     sz		 fixed bin (35);
	dcl     next_element_id_list_ptr ptr;

	dcl     sub_err_		 entry options (variable);
	dcl     retval		 fixed bin (35);	/* to make sub_err_ happy */

	sa_nvars = range.num_vars;			/* init */
	if sa_nvars < 4				/* try to use stack space */
	then sa_ptr = addr (wkspc1);
	else do;					/* if must allocate */
		allocate size_array in (select_area);	/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
		sa_alloc = "1"b;
	     end;

	code = 0;
	do i = 1 to sa_nvars;			/*  get size of each relation */

	     size_array.var_index (i) = i;
	     size_array.size (i) = range.tup_var (i).ri_ptr -> rm_rel_info.current_tuple_population;
	     if size_array.size (i) = 0 then
		icode = mrds_error_$tuple_not_found;
	end;

	if ^dbcb.no_optimize then do;			/* don't sort if -no_optimize specified */

		nxchng = sa_nvars;
		do i = sa_nvars by -1 to 2 while (nxchng > 0); /* sort by size */
		     nxchng = 0;
		     do j = 2 to i;


/* do the smaller relations first in the cross product */

			if size_array.size (j) < size_array.size (j - 1) then do; /* must exchange */
				sz = size_array.size (j);
				vi = size_array.var_index (j);
				size_array.size (j) = size_array.size (j - 1);
				size_array.var_index (j) = size_array.var_index (j - 1);
				size_array.var_index (j - 1) = vi;
				size_array.size (j - 1) = sz;
				nxchng = nxchng + 1;
			     end;			/* exchanging */
		     end;				/* j loop */
		end;				/* i loop */
	     end;					/* END of else do   to optimize */


/* if a 0 size relation was detected, we can not ever return
   any tuples from a cross product involving it. Thus we can improve
   performance by generating a search program that does not do I/O,
   but simply does the return_null operation instead. */

	if icode = mrds_error_$tuple_not_found then do;

/* null cross product becuase of 0 size relation,
   force a dummy search program that will work with set S.E.'s
   and not do any I/O, just return the tuple_not_found error */

		so_nops_init = 1;
		allocate search_ops in (select_area);

		search_ops.ic = 1;
		search_ops.nops = 1;
		search_ops.op.code (1) = RETNUL;
		icode,				/* reset to not really error at this point */
		     search_ops.op.var_ind (1),
		     search_ops.op.good_xfer (1),
		     search_ops.op.err_xfer (1) = 0;
		search_ops.op.info_ptr (1) = null ();

	     end;
	else do;
	          /* We start on a new select expression, so turn scopes_changed flag and shared mode flag off. */
	          dbcb.non_shared_to_shared = "0"b;
	          dbcb.scopes_changed = "0"b;
		sv_nvars_init = sa_nvars;		/* init. search tables */
		so_nops_init = 2 * sa_nvars + 3;
		allocate search_vars in (select_area);	/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
		string (search_vars.new_val) = "0"b;
		allocate search_ops in (select_area);	/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */



		search_ops.ic = 1;
		search_ops.op.code (1) = PICKUP_SVP;	/* init to pick up sv ptr */
		search_ops.op.info_ptr (1) = sv_ptr;
		search_ops.op.var_ind (1) = 0;
		search_ops.op.good_xfer (1) = 1;
		search_ops.op.err_xfer = 0;
		next_element_id_list_ptr = dbcb.element_id_list_segment_ptr;

		do i = 1 to sa_nvars;		/* fill in search tables for each var. */

		     if ^range.tup_var (i).used	/* if ^a tuple variable has been defined */
		     then do;			/* but is not used in the select set */
			     call sub_err_ (mrds_error_$no_tuple_effect, "mrds_dsl_optimize", "c", null (), retval,
				"A Useless tuple variable is ^a", range.tup_var (i).name);

			     call error (mrds_error_$no_tuple_effect);
			end;
		     rmri_ptr,
			search_vars.info.ri_ptr (i) = range.tup_var.ri_ptr (i); /* fill search vars info */

		     call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, (i), rm_rel_info.rel_id,
			dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open, dbcb.cursor_ptrs_storage_ptr,
			dbcb.cursor_storage_area_ptr, search_vars.info.relation_cursor_ptr (i), icode);
		     if icode ^= 0
		     then call error (icode);
		     search_vars.info.ntids (i),
			search_vars.info.ctid (i) = 0;
		     current_max_tids_per_call = mrds_data_$max_tids_returned_per_call;
		     if rm_rel_info.file_type ^= 3 then do;
			/* we have a real relation here. */
			current_scope_ptr = rm_rel_info.scope_flags_ptr;
			if current_scope_flags.permits.read_attr |
			   current_scope_flags.permits.delete_tuple |
			   current_scope_flags.permits.modify_attr then
			   if ^current_scope_flags.prevents.modify_attr |
			     (^current_scope_flags.prevents.append_tuple &
			     ^current_scope_flags.prevents.delete_tuple) then
			     current_max_tids_per_call = mrds_data_$max_safe_tids_returned_per_call;
		     end;
		     search_vars.info.maxtids (i) = current_max_tids_per_call;
		     search_vars.info.ta_ptr (i) = next_element_id_list_ptr;
		     next_element_id_list_ptr = addrel (search_vars.info.ta_ptr (i),
			current_max_tids_per_call + 2);
		     /* There are two words of header in an element id list */
		     element_id_list_ptr = search_vars.info.ta_ptr (i);
		     element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
		     element_id_list.number_of_elements = 0;
		     ii = 2 * i;
		     si = 2 * i + 1;
						/* fill in search op items */

		     search_ops.op.info_ptr (ii) = null ();
		     allocate select_info in (select_area); /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
		     search_ops.op.info_ptr (si) = seli_ptr;
		     select_info.cvla_ptr = null;
		     do j = 1 to tuple_info.num_tuples while (tuple_info.tuple.var_index (j) ^= size_array.var_index (i));
		     end;
		     select_info.tuple_info_index = j;
		     select_info.tid_ptr = addr (tuple_info.tuple.tuple_id (j));
		     rss_number_of_and_groups = 0;
		     rss_maximum_number_of_constraints = 0;
		     allocate relation_search_specification in (select_area);
		     relation_search_specification.head.version = SPECIFICATION_VERSION_4;
		     relation_search_specification.head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE;
		     relation_search_specification.head.pad = "0"b;
		     relation_search_specification.head.subset_specification_ptr = null ();
		     relation_search_specification.maximum_number_of_constraints =
			rss_maximum_number_of_constraints;
		     relation_search_specification.number_of_and_groups =
			rss_number_of_and_groups;
		     relation_search_specification.range.type = LOW_RANGE_TYPE;
		     relation_search_specification.range.size = current_max_tids_per_call;
		     relation_search_specification.flags.return_unique_tuples = "0"b;
		     relation_search_specification.flags.mbz = "0"b;
		     select_info.relation_search_specification_ptr = relation_search_specification_ptr;
		     search_ops.op.code (ii) = INIT;
		     search_ops.op.code (si) = SEL;
		     search_ops.op.var_ind (ii),
			search_ops.op.var_ind (si) = size_array.var_index (i);
		     search_ops.op.good_xfer (ii) = 1;
		     search_ops.op.good_xfer (si) = 1;
		     if i = 1 then do;		/* if first set of ops */
			     search_ops.op.err_xfer (ii) = 2 * sa_nvars + 1;
			     search_ops.op.err_xfer (si) = 2 * sa_nvars;
			end;
		     else do;
			     search_ops.op.err_xfer (ii) = -1;
			     search_ops.op.err_xfer (si) = -2;
			end;

		end;				/* fill ing in var and op info */
		rvi = 2 * sa_nvars + 2;
		rni = 2 * sa_nvars + 3;
		search_ops.op.code (rvi) = RETVAL;	/* fill in return search ops */
		search_ops.op.code (rni) = RETNUL;
		search_ops.op.var_ind (rvi),
		     search_ops.op.var_ind (rni),
		     search_ops.op.good_xfer (rni),
		     search_ops.op.err_xfer (rni),
		     search_ops.op.err_xfer (rvi) = 0;
		search_ops.op.good_xfer (rvi) = -1;
		search_ops.op.info_ptr (rvi),
		     search_ops.op.info_ptr (rni) = null;

	     end;

/* Set up the simple typed vector  and id list ptrs */

	call build_vectors;

	if dbcb.print_search_order then do;		/* Print the order tuple variable are used  */

		call ioa_ ("^/Tuple variables listed in search order - - all accessed sequentially.");
		do z = 1 to sa_nvars;

		     i = size_array.var_index (z);

		     if range.tup_var.temp_rel (i) then
			rel_name = ltrim (before (after (range.tup_var.ri_ptr (i) -> rm_rel_info.model_name, "."), "."), "0")
			     || " (temp rel index)";
		     else rel_name = range.tup_var.ri_ptr (i) -> rm_rel_info.name;

		     call ioa_ ("^/Order: ^d  Tuple variable: ""^a""^5xRelation name: ""^a""^/^11xRelation size: ^d",
			z, range.tup_var.name (i), rel_name, size_array.size (z));
		end;
		call ioa_ ("");			/* give um a line feed */

	     end;					/* END if print_search_order */
     end cross_prod;
%page;
canonize_pred: proc;

/* Procedure to convert predicate tree to disjunctive normal form. */

/* This first section eliminates not nodes from the tree by negating the operator of the descendent node */

	top = 1;					/* init. the node stack */
	node_stack (top) = pred_ptr;

	do while (top > 0);				/* while we have not exhausted the stack */

	     pn_ptr = node_stack (top);		/* look at top node in stack */
	     top = top - 1;

	     if pred_node.id.op_code = AND_OP /* if and node or or node */
		| pred_node.id.op_code = OR_OP then do;

		     if top + 2 > mrds_data_$max_pred_depth then
			call error (mrds_error_$node_stack_ovfl); /* if we would overflow the stack */
		     node_stack (top + 1) = pred_node.rbr; /* add branches to stack */
		     node_stack (top + 2) = pred_node.lbr;
		     top = top + 2;

		end;				/* and or or node */

	     else if pred_node.id.op_code = NOT_OP then do; /* if a not node */

		     c_ptr = pred_node.lbr;		/* point to child */
		     if c_ptr -> pred_node.term then /* if child is term */
			c_ptr -> pred_node.id.op_code = neg_op (fixed (c_ptr -> pred_node.id.op_code));
						/* negate the opcode of child */
		     else if c_ptr -> pred_node.id.op_code = AND_OP /* if child is and or or */
			| c_ptr -> pred_node.id.op_code = OR_OP then do;

/* ^(a & b) => ^a | ^b, ^(a | b) => ^a & ^b */

			     if c_ptr -> pred_node.id.op_code = AND_OP then /* reverse the op code */
				c_ptr -> pred_node.id.op_code = OR_OP;
			     else c_ptr -> pred_node.id.op_code = AND_OP;

			     allocate pred_node in (select_area) set (notr_ptr);
						/* alloc. temp not nodes */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
			     allocate pred_node in (select_area) set (notl_ptr);
						/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */

/* it is not necessary to completely fill in these nodes, since they will exist only through the next iteration */

			     notl_ptr -> pred_node.type,
				notr_ptr -> pred_node.type = NODE;
			     notl_ptr -> pred_node.id.op_code,
				notr_ptr -> pred_node.id.op_code = NOT_OP;
			     string (notl_ptr -> pred_node.id.lleaf_id),
				string (notl_ptr -> pred_node.id.rleaf_id),
				string (notr_ptr -> pred_node.id.lleaf_id),
				string (notr_ptr -> pred_node.id.rleaf_id),
				notl_ptr -> pred_node.root,
				notr_ptr -> pred_node.root,
				notl_ptr -> pred_node.term,
				notr_ptr -> pred_node.term = "0"b;
			     notl_ptr -> pred_node.lbr = c_ptr -> pred_node.lbr; /* splice new not nodes between
						   child & his branches */
			     notr_ptr -> pred_node.lbr = c_ptr -> pred_node.rbr;
			     notl_ptr -> pred_node.parent,
				notr_ptr -> pred_node.parent = c_ptr;
			     c_ptr -> pred_node.lbr = notl_ptr;
			     c_ptr -> pred_node.rbr = notr_ptr;

			     if top + 2 > mrds_data_$max_pred_depth then /* if we would overflow stack */
				call error (mrds_error_$node_stack_ovfl);

			     node_stack (top + 1) = notr_ptr; /* add new nodes to stack */
			     node_stack (top + 2) = notl_ptr;
			     top = top + 2;

			end;			/* if & or | node */

		     else if c_ptr -> pred_node.id.op_code = NOT_OP then do; /* if child is not */

/* ^^a => a */

			     pred_node.lbr = c_ptr -> pred_node.lbr; /* remove lower ^ node */
			     if top + 1 > mrds_data_$max_pred_depth then /* if we would overflow stack */
				call error (mrds_error_$node_stack_ovfl);

			     node_stack (top + 1) = pred_node.lbr;
			     top = top + 1;

			end;			/* if ^ node */

		     if pred_node.root then do;	/* if current is root, have no parent */
			     pred_ptr = c_ptr;	/* child now becomes root */
			     c_ptr -> pred_node.root = "1"b;
			end;
		     else /* if not root then have parent */
			if pred_node.parent -> pred_node.lbr = pn_ptr then /* if current is left br. */
			pred_node.parent -> pred_node.lbr = c_ptr; /* remove current node */
		     else /* current is right br. */
			pred_node.parent -> pred_node.rbr = c_ptr;

		end;				/* if current was ^ node */

	end;					/* loop to remove not nodes */

/* Have now eliminated all not nodes from the tree.  Now we rearrange the
   remainder of the tree so that no | nodes are subordinate to any & nodes (disjunctive normal form). */

	top = 1;					/* init node stack */
	node_stack (top) = pred_ptr;

	do while (top > 0);				/* while stack is not exhausted */

	     pn_ptr = node_stack (top);		/* pick up top node from stack */
	     top = top - 1;

	     if ^pred_node.term then do;		/* if and or or */
		     if top + 2 > mrds_data_$max_pred_depth then /* if we would overflow the stack */
			call error (mrds_error_$node_stack_ovfl);
		     node_stack (top + 1) = pred_node.rbr; /* add branches to stack */
		     node_stack (top + 2) = pred_node.lbr;
		     top = top + 2;
		end;				/* if & or | */

	     if pred_node.id.op_code = OR_OP & ^pred_node.root then /* if or which may need moving */
		if pred_node.parent -> pred_node.id.op_code = AND_OP then do;

			p_ptr = pred_node.parent;	/* pick up parent pointer */
			c_ptr = pn_ptr;		/* current node becomes child */
			done = "0"b;		/* init compl. flag */

			do while (^done);		/* while the or needs to  be moved upward in the tree */

			     allocate pred_node in (select_area) set (and_ptr);
						/* alloc. new and node */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
			     and_ptr -> pred_node.type = NODE; /* and fill it in */
			     and_ptr -> pred_node.id.op_code = AND_OP;
			     and_ptr -> pred_node.root = "0"b;
			     and_ptr -> pred_node.term = "0"b;
			     string (and_ptr -> pred_node.id.lleaf_id) = "0"b;
			     string (and_ptr -> pred_node.id.rleaf_id) = "0"b;
			     and_ptr -> pred_node.parent = p_ptr;

			     if c_ptr = p_ptr -> pred_node.lbr then do; /* if the | is a left branch */

				     call copy_subtree (p_ptr -> pred_node.rbr, copy_ptr, and_ptr);
						/* make a copy of right branch */
				     call move_subtree (c_ptr -> pred_node.rbr, and_ptr -> pred_node.lbr, and_ptr);
				     and_ptr -> pred_node.rbr = copy_ptr;
				     call move_subtree (p_ptr -> pred_node.rbr, c_ptr -> pred_node.rbr, c_ptr);
				     p_ptr -> pred_node.rbr = and_ptr;

				end;		/* if the | was a left branch */

			     else do;		/* if the | is a right branch */

				     call copy_subtree (p_ptr -> pred_node.lbr, copy_ptr, and_ptr);
						/* copy the left branch */
				     call move_subtree (c_ptr -> pred_node.lbr, and_ptr -> pred_node.rbr, and_ptr);
				     and_ptr -> pred_node.lbr = copy_ptr;
				     call move_subtree (p_ptr -> pred_node.lbr, c_ptr -> pred_node.lbr, c_ptr);
				     p_ptr -> pred_node.lbr = and_ptr;


				end;		/*  if | is right branch */


/* for either a right or left branch */

			     if top + 1 > mrds_data_$max_pred_depth then /* if stack is overflowing */
				call error (mrds_error_$node_stack_ovfl);

/* In this case, we can guarantee that all nodes will be looked at by placing copy_ptr in stack */

			     top = top + 1;
			     node_stack (top) = copy_ptr;
			     p_ptr -> pred_node.id.op_code = OR_OP; /* parent is now an | node */
			     c_ptr -> pred_node.id.op_code = AND_OP; /* and the current is now an & node */

			     c_ptr = p_ptr;		/* go up one level */
			     p_ptr = p_ptr -> pred_node.parent;

			     if c_ptr -> pred_node.root then done = "1"b; /* if no farther to go */
			     else if p_ptr -> pred_node.id.op_code ^= AND_OP then done = "1"b; /* or we have hit ors */

			end;			/* bubbling this or */

		     end;				/* if or node */

	end;					/* search for ors */

/* Have now eliminated all not nodes from the tree, and have rearranged the tree so that no and nodes have
   subordinate or nodes.  Hence, the tree has now degenerated into a set of "and groups", i.e. a set
   of requirements lists which must be met for tuple to be selected.  Thus, in order to facilitate further
   manipulation, we first discard the tree structure in favor of a list of and groups.  For each and group, we
   then group all terms in like variables together */

	if display_predicate_tree then
	     call mdb_display_pred_tree$display_pred_tree_ (pred_ptr, /* ptr to root of tree */
		"0"b,				/* ^brief mode */
		"1"b,				/* long mode */
		10,				/* maximum depth */
		1,				/* => inorder */
		dbcb_ptr);
	or_top = 1;				/* init. or stack */
	or_stack (or_top) = pred_ptr;

	num_ands_init = mrds_data_$max_and_groups;
	allocate pred_array in (select_area);
						/* alloc. array for and groups */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
	pred_array.type = ARRAY;			/* init. it */
	pred_array.num_ands = 0;

	do while (or_top > 0);			/* for every and group */

	     pn_ptr = or_stack (or_top);		/* pick up top node from or_stack */
	     or_top = or_top - 1;

	     if pred_node.term then do;		/* and_group consists of single term */
		     if pred_array.num_ands + 1 > num_ands_init then /* if we will exceed list size */
			call error (mrds_error_$max_and_groups);
		     pred_array.num_ands = pred_array.num_ands + 1;
		     num_terms_init = 1;
		     allocate and_group in (select_area);
						/* alloc. and group of single or double term */
						/* Allocations in select_area are never freed.  It
						   is reinitialized at the beginning
						   of each new selection expression. */
		     and_group.num_terms = num_terms_init;
		     and_group.term_ptr (1) = pn_ptr;	/* fill it in */
		     pred_array.and_ptr (pred_array.num_ands) = ag_ptr; /* add it to  and group array */
		end;				/* if node was a term */

	     else if pred_node.id.op_code = OR_OP then do;/* if this is an or node */
		     if or_top + 2 > mrds_data_$max_pred_depth then /* if we would overflow the stack */
			call error (mrds_error_$node_stack_ovfl);
		     or_stack (or_top + 1) = pred_node.rbr; /* just add the two branches to the stack */
		     or_stack (or_top + 2) = pred_node.lbr;
		     or_top = or_top + 2;
		end;				/* if was or node */

	     else do;				/* if node is an and node, => top of and group */

		     num_terms_init = mrds_data_$max_and_terms;
		     allocate and_group in (select_area);
						/* alloc. max sized and group */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
		     and_group.num_terms = 0;		/* init it */

		     pred_array.num_ands = pred_array.num_ands + 1; /* and add it to group array */
		     if pred_array.num_ands > num_ands_init then
			call error (mrds_error_$max_and_groups);
		     pred_array.and_ptr (pred_array.num_ands) = ag_ptr;

		     and_top = 2;
		     and_stack (1) = pred_node.rbr;	/* init. and stack */
		     and_stack (2) = pred_node.lbr;

		     do while (and_top > 0);		/* look through every node in the and group */

			pn_ptr = and_stack (and_top); /* pick off top stack element */
			and_top = and_top - 1;

			if pred_node.term then do;	/* if this is a term */
				if and_group.num_terms + 1 > num_terms_init then /* if we will overflow list */
				     call error (mrds_error_$max_and_terms);
				and_group.num_terms = and_group.num_terms + 1; /* increment number of terms */
				and_group.term_ptr (and_group.num_terms) = pn_ptr; /* add this term to and group */
			     end;			/* if this is term */

			else do;			/* is another and node */

				if and_top + 2 > mrds_data_$max_pred_depth then /* if we will overflow the and stack */
				     call error (mrds_error_$node_stack_ovfl);
				and_top = and_top + 2;
				and_stack (and_top - 1) = pred_node.rbr; /* add branches to and stack */
				and_stack (and_top) = pred_node.lbr;
			     end;			/* if internsl and node */
		     end;				/*  converting and group to list form */
		end;				/* loop for and group */
	end;					/* loop for tree */
     end canonize_pred;
%page;
create_search_lists: proc;

/* Procedure to create the "program" for mrds_dsl_search */

	dcl     (i, j, k)		 fixed bin;

	allocate path_var_flags in (select_area);

	search_array.num_and_groups = pred_array.num_ands;

	do i = 1 to pred_array.num_ands;		/* process each and group */

	     var_count = 0;				/* so far there are no tuple variables in the search path */
	     ag_ptr = pred_array.and_ptr (i);
	     done = "0"b;

/*           Call the permutatuions program. */


	     call mrds_dsl_permute (dbcb_ptr, ag_ptr, search_array (i).path_ptr, search_array (i).cost, icode);
	     if icode ^= 0 then call error (icode);

	     pvp = search_array (i).path_ptr;
	     unspec (path_var_flags) = "0"b;

	     call count_path_len_and_set_flags (pvp, var_count, last_el_ptr, path_var_flags);

	     min_path_first_el_ptr = pvp;
						/* save pointer to fist element in mim cost partial path */
	     min_path_last_el_ptr = last_el_ptr;	/* last element in path also */


	     if display_search_paths then do;
		     call ioa_ ("^/^/The minimum cost search path^/^/");
		     call mdb_display_path_$path (min_path_first_el_ptr, dbcb_ptr);
		     call ioa_ ("^/^/End minimum costr search path^/^/");
		end;
	     if dbcb.print_search_order then do;

/* -print_search_order specified in selection expression,
   output info for each and_group search path */

		     if i = 1 then /* first and_group */
			call ioa_ ("^/Tuple variables listed in search order");
		     else call ioa_ ("^/***** New and group.");

/* put the path variable pointers into an array, so they can be
   printed out in reverse of the list linking for search order */

		     x = 1;			/* CHANGE 81-09-19 */
		     do temp_pvp = pvp repeat temp_pvp -> path_var.fwd_thd
			while (temp_pvp ^= null ());

			path_var_pointer_array (x) = temp_pvp;
			x = x + 1;

		     end;

/* now print out the array using the reverse order
   that is actually the search path order */

		     x = x - 1;			/* last increment not needed */
		     do z = x by -1 to 1;		/* CHANGE 81-09-19 */

			temp_pvp = path_var_pointer_array (z);

			if temp_pvp -> path_var.in_and_group | temp_pvp -> path_var.in_select_clause then do;

/* only do tuple variables that hve an effect on the select set */

				y = temp_pvp -> path_var.var_index;
				temp_rmri_ptr = range.tup_var.ri_ptr (y);

				if range.tup_var.temp_rel (y) then
				     rel_name = ltrim (before (after (range.tup_var.ri_ptr (i) -> rm_rel_info.model_name, "."), "."), "0")
					|| " (temp rel index)";
				else rel_name = temp_rmri_ptr -> rm_rel_info.name;

/* on a secure database, a non-DBA will only see indexed attr,
   never any type of key access method */

				saved_access_method = 0;
				if rm_db_info.mdbm_secured & ^rm_db_info.administrator then do;
					if temp_pvp -> path_var.access_method < INDEXED_ATTR then do;
						saved_access_method =
						     temp_pvp -> path_var.access_method; /* remember real access method */
						temp_pvp -> path_var.access_method =
						     INDEXED_ATTR; /* make the peon see index, rather than key */
					     end;
				     end;

				call ioa_ ("^/Order: ^d  Tuple variable: ""^a""     Relation: ""^a""",
				     x - z + 1, range.tup_var.name (y), rel_name);

				call ioa_ ("^11xAccess method: ""^a""",
				     access_method_name (temp_pvp -> path_var.access_method));

/* addition detail depends on access method used,
   they can't be show to a peon on a secure db,
   because he can infer key info from them. */

				if rm_db_info.administrator | ^rm_db_info.mdbm_secured then do;

					call ioa_ ("^11xEstimate of tuples selected: ^d",
					     temp_pvp -> path_var.number_tuples_selected);

					if temp_pvp -> path_var.access_method = LONG_KEY_HEAD |
					     temp_pvp -> path_var.access_method = TOTAL_PRIMARY_KEY then

					     call ioa_ ("^11xNumber of key attributes involved: ^d",
						temp_pvp -> path_var.attr_index);

					else if temp_pvp -> path_var.access_method = SHORT_KEY_HEAD |
					     temp_pvp -> path_var.access_method = INDEXED_ATTR then do;

						attr_name = temp_rmri_ptr ->
						     rm_rel_info.attr_ptrs (temp_pvp -> path_var.attr_index) ->
						     rm_attr_info.name;

						if temp_pvp -> path_var.second_cond_ptr = null () then
						     call ioa_ ("^15xCondition: ""^a""     Attribute: ""^a""",
							condition_name (temp_pvp -> path_var.cond_ptr -> cond.op_code), attr_name);
						else call ioa_ ("^14xConditions:  ""^a"" & ""^a""    Attribute:  ""^a""",
							condition_name (temp_pvp -> path_var.cond_ptr -> cond.op_code),
							condition_name (temp_pvp -> path_var.second_cond_ptr -> cond.op_code),
							attr_name);
					     end;
				     end;

				if saved_access_method ^= 0 then
				     temp_pvp -> path_var.access_method =
					saved_access_method; /* put back real access method for peon */
			     end;
		     end;
		end;
	     call mrds_dsl_gen_srch_prog (dbcb_ptr, min_path_first_el_ptr, search_array.sv_ptr (i),
		search_array.so_ptr (i), icode);
	     if icode ^= 0 then call error (icode);

	end;					/* creating search lists for each and group */

	if dbcb.print_search_order then
	     call ioa_ ("^/");			/* addition line feed for formating */
	call check_no_tuple_effect ();
	if ^dbcb.no_optimize then do;

/* sort the and groups to get lowest cost and group first,
   so that the first tuple in a series of "or"'s is found faster. */

		sorted = "0"b;
		i = search_array.num_and_groups;
		spare_element = mrds_data_$max_and_groups + 1;
		do while (^sorted);			/* bubble sort */

		     exchanged = "0"b;

		     do j = 2 to i;			/* bubble highest cost element to position "i" */

			if search_array.cost (j) < search_array.cost (j - 1) then do;

				search_array.and_group (spare_element) = search_array.and_group (j);
				search_array.and_group (j) = search_array.and_group (j - 1);
				search_array.and_group (j - 1) = search_array.and_group (spare_element);

				exchanged = "1"b;
			     end;
		     end;

		     if ^exchanged then
			sorted = "1"b;
		     else if i > 2 then
			i = i - 1;
		     else sorted = "1"b;
		end;
	     end;


/* skip over and groups that have 0 cost, and thus can not
   possiblly return any tuples. (they got 0 cost from permute
   by one of the involved relations being empty)
   This will reduce the search program to just those non-null and groups.
   In the extreme, will no non-null and groups, the search program
   degenerates to just a simple reutnr_null action */

	non_null_and_groups = 0;
	so_nops_init = 0;				/* combine all search op tables into onetable */
	do i = 1 to pred_array.num_ands;
	     if search_array.cost (i) ^= 0.0 then do;
		     so_nops_init = so_nops_init + search_array.so_ptr (i) -> search_ops.nops - 1;
		     non_null_and_groups = non_null_and_groups + 1;
		end;
	end;
	so_nops_init = so_nops_init + 1;		/* for RETNUL */
	allocate search_ops in (select_area);		/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
	search_ops.ic = 1;
	k = 0;
	do i = 1 to pred_array.num_ands;
	     if search_array.cost (i) ^= 0.0 then do;
		     begin_and_group = k;
		     do j = 1 to search_array.so_ptr (i) -> search_ops.nops - 1;
			k = k + 1;
			unspec (search_ops.op (k)) =
			     unspec (search_array.so_ptr (i) -> search_ops.op (j));
		     end;
		     search_ops.op.err_xfer (begin_and_group + 3) = k - begin_and_group - 2;
						/* special case first init and select in each and_group */
		     search_ops.op.err_xfer (begin_and_group + 4) = k - begin_and_group - 3;
		end;
	end;
	k = k + 1;
	unspec (search_ops.op (k)) = unspec (search_array.so_ptr (pred_array.num_ands) ->
	     search_ops.op (search_array.so_ptr (pred_array.num_ands) ->
	     search_ops.nops));			/* Pick up last RETNUL */

	return;
%page;
count_path_len_and_set_flags: proc (top_of_path, var_count, last_el_ptr, path_var_flags);

/* This routine counts the number  of  tuple  variables  used  in  a
   section  of  the  minimum  cost path and sets a bit flag for each
   variable used. It also returns a pointer to the last  element  in
   the path.
*/

/* PARAMETERS */

	dcl     top_of_path		 ptr;		/* (input) first element in path */
	dcl     last_el_ptr		 ptr;		/* (output) pointer to last element in path */
	dcl     var_count		 fixed bin;
						/* (input/output) total number of tuple variables
						   used in all path segments */
	dcl     path_var_flags	 (*) bit (1) unaligned;
						/* (input/output) true is tuple variable used in minimum path */

/* AUTOMATIC */

	dcl     path_var_ptr	 ptr;		/* pointer to an element in path_var list */

	path_var_ptr = top_of_path;

	do while (path_var_ptr ^= null ());		/* loop through path list */
	     var_count = var_count + 1;
	     path_var_flags (path_var_ptr -> path_var.var_index) = "1"b;

	     last_el_ptr = path_var_ptr;		/* save incase this is the last element */
	     path_var_ptr = path_var_ptr -> path_var.fwd_thd;
	end;


	return;

     end /* count_path_len_and_set_flags */;





     end create_search_lists;
%page;
check_no_tuple_effect: procedure ();

/* this routine decides if the tuple variables given
   in the range clause are usefull in this selection expression.
   If a tuple variable appears in the select clause it is OK,
   because it either also appears in the where clause,
   or it will be used to form a cross product with the results
   of the where clause. If a tuple variable does not appear in the select clause
   it must appear in some and group in the where clause. */

	message = "";
	do i = 1 to range.num_vars;

	     if ^range.tup_var (i).used then do;

/* this tuple variable does not appear in the select clause,
   see if it is some and group in the where clause */

		     good_use_found = "0"b;
		     do j = 1 to search_array.num_and_groups while (^good_use_found);

			do pvp = search_array.and_group (j).path_ptr
			     repeat path_var.fwd_thd
			     while (pvp ^= null () & ^good_use_found);

			     if i = path_var.var_index & path_var.in_and_group then

/* we found an instance of the use of this tuple variable in an and group */

				good_use_found = "1"b;

			end;

		     end;

/* see if the tuple variable was used properly
   add it to the error list if not */

		     if ^good_use_found then do;

			     if message = "" then
				message = "Useless tuple variables are: ";

			     message = message || rtrim (range.tup_var (i).name) || " ";

			end;

		end;

	end;

/* see if any bad T.V.'s were found */

	if message ^= "" then do;

		call sub_err_ (mrds_error_$no_tuple_effect, "mrds_dsl_optimize", "c", null (), return_value, message);
		call error (mrds_error_$no_tuple_effect);

	     end;




	dcl     (i, j)		 fixed bin;	/* loop indexes */
	dcl     good_use_found	 bit (1);		/* on => this T.V. OK */
	dcl     message		 char (100) varying;/* error message being built */
	dcl     sub_err_		 entry options (variable);
	dcl     return_value	 fixed bin (35) init (0); /* dummy arg */

     end;
%page;
move_subtree: proc (s_ptr, t_ptr, p_ptr);

/* procedure to relocate a subtree */

	dcl     (s_ptr,				/* pointer to source location */
	        t_ptr,				/* pointer to target location */
	        p_ptr)		 ptr;		/* new parent pointer */

	t_ptr = s_ptr;
	if s_ptr -> pred_node.type = NODE then
	     s_ptr -> pred_node.parent = p_ptr;
	else s_ptr -> pred_leaf.parent = p_ptr;

     end move_subtree;
%page;
copy_subtree: proc (s_ptr, c_ptr, p_ptr);

/* Internal procedure to copy a portion of the pred tree */

	dcl     (s_ptr,				/* ptr to source subtree */
	        c_ptr,				/* ptr to copy subtree */
	        sr_ptr,				/* ptr to current source node */
	        cp_ptr,				/* ptr to current copy node */
	        p_ptr,				/* ptr to parent of copy */
	        p_hold)		 ptr;		/* temp parent pointer holder */

	dcl     1 node_stack	 (mrds_data_$max_pred_depth), /* copy node stack */
		2 s_ptr		 ptr,		/* source node */
		2 c_ptr		 ptr;		/* copy node */

	dcl     top		 fixed bin;	/* index to node stack */

	top = 1;					/* initialize */
	allocate pred_node in (select_area) set (c_ptr);	/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
	c_ptr -> pred_node.parent = p_ptr;		/* preset parent */
	node_stack.s_ptr (top) = s_ptr;
	node_stack.c_ptr (top) = c_ptr;

	do while (top > 0);				/* while there are nodes to copy */

	     sr_ptr = node_stack.s_ptr (top);		/* pick off node to be copied */
	     cp_ptr = node_stack.c_ptr (top);
	     top = top - 1;

	     if sr_ptr -> pred_node.type = NODE then do;	/* if copying a node */
		     p_hold = cp_ptr -> pred_node.parent; /* save parent ptr which has been set */
		     cp_ptr -> pred_node = sr_ptr -> pred_node; /* copy the node */
		     cp_ptr -> pred_node.parent = p_hold; /* reinsert parent pointer */

		     if cp_ptr -> pred_node.term then do; /* if this is a term */
			     allocate pred_leaf in (select_area) set (cp_ptr -> pred_node.lbr);
						/* alloc. left leaf */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
			     cp_ptr -> pred_node.lbr -> pred_leaf.parent = cp_ptr; /* set parent */
			     allocate pred_leaf in (select_area) set (cp_ptr -> pred_node.rbr);
						/* same for right lf */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
			     cp_ptr -> pred_node.rbr -> pred_leaf.parent = cp_ptr;
			end;			/* if was term */

		     else do;			/* if children are nodes */

			     allocate pred_node in (select_area) set (cp_ptr -> pred_node.lbr);
						/* alloc. left node */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
			     cp_ptr -> pred_node.lbr -> pred_node.parent = cp_ptr; /* set parent */
			     allocate pred_node in (select_area) set (cp_ptr -> pred_node.rbr);
						/* same for right */ /* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
			     cp_ptr -> pred_node.rbr -> pred_node.parent = cp_ptr;

			end;			/* if children are nodes */

		     top = top + 2;
		     if top > mrds_data_$max_pred_depth then /* if we will overflow the stack */
			call error (mrds_error_$node_stack_ovfl);
		     node_stack.s_ptr (top - 1) = sr_ptr -> pred_node.rbr; /* add branches to stack */
		     node_stack.c_ptr (top - 1) = cp_ptr -> pred_node.rbr;
		     node_stack.s_ptr (top) = sr_ptr -> pred_node.lbr;
		     node_stack.c_ptr (top) = cp_ptr -> pred_node.lbr;

		end;				/* if we had a node */

	     else do;				/* we have a leaf */

		     p_hold = cp_ptr -> pred_leaf.parent; /* save parent pointer */
		     cp_ptr -> pred_leaf = sr_ptr -> pred_leaf; /* copy the leaf */
		     if cp_ptr -> pred_leaf.expr_ptr ^= null then /* if expr leaf */
			call copy_expr (cp_ptr -> pred_leaf.expr_ptr); /* then must copy expr tables */
		     cp_ptr -> pred_leaf.parent = p_hold; /* sestore parent pointer */

		end;				/* if leaf */

	end;					/* copy loop */

     end copy_subtree;

copy_expr: proc (e_ptr);

/* Procedure to copy and expr and modify e_ptr to point to the new tables */

	dcl     e_ptr		 ptr;
	dcl     i			 fixed bin;

	nexp_items_init = e_ptr -> expr.nitems;		/* copy expr struct. */
	allocate expr in (select_area);		/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
	expr = e_ptr -> expr;
	e_ptr = expr_ptr;

	do i = 1 to e_ptr -> expr.nitems;		/* copy all contained functions */
	     if e_ptr -> expr.item.type (i) = SCAL_FUN then
		call copy_fun (e_ptr -> expr.item.fn_ptr (i));
	end;

     end copy_expr;

copy_fun: proc (f_ptr);

/* Procedure to copy a function */

	dcl     f_ptr		 ptr;
	dcl     i			 fixed bin;

	nsf_args_init = f_ptr -> scalfn.nargs;		/* copy scafn struct. */
	allocate scalfn in (select_area);		/* Allocations in select_area are never freed.  This area
						   is reinitialized at the beginning
						   of each new selection expression. */
	scalfn = f_ptr -> scalfn;
	f_ptr = sfn_ptr;

	do i = 1 to f_ptr -> scalfn.nargs;
	     if f_ptr -> scalfn.arg.type (i) = EXPR then
		call copy_expr (f_ptr -> scalfn.arg.ef_ptr (i));
	     else if f_ptr -> scalfn.arg.type (i) = SCAL_FUN then
		call copy_fun (f_ptr -> scalfn.arg.ef_ptr (i));
	end;

     end copy_fun;
%page; build_vectors: proc;

/* Here is where we build the 'shortened' simple_typed_vector for each tuple variable.
   If the whole tuple has been selected, the 'whole' one in the resultant is used. */

	do i = 1 to range.num_vars;
	     bv_stv_ptr = tuple_info.tuple (i).tuple_ptr; /* simple_typed_veector for whole 'view' */
	     bv_ri_ptr = range.tup_var (i).ri_ptr;	/* rm_rel_info ptr */
	     bv_idl_ptr = bv_ri_ptr -> rm_rel_info.id_list_ptr; /* id_list for whole 'view' */
	     if range.tup_var (i).whole_tuple_selected
	     then do;				/* just grab what's already available */
		     range.tup_var (i).stv_ptr = bv_stv_ptr;
		     range.tup_var (i).idl_ptr = bv_idl_ptr;
		end;
	     else do;				/* Build a simple_typed_vector and an id_list */
		     il_number_of_ids = bv_ri_ptr -> rm_rel_info.num_attr; /* Build it oversize */
		     allocate id_list in (select_area) set (id_list_ptr);
		     id_list.version = ID_LIST_VERSION_1;
		     range.tup_var (i).idl_ptr = id_list_ptr;

		     id_list.number_of_ids = 0;
		     do k = 1 to il_number_of_ids;
			if range.tup_var (i).needed_bits.attr (k)
			then do;			/* get the proper id for relation */
				id_list.number_of_ids = id_list.number_of_ids + 1;
				id_list.id (id_list.number_of_ids) = bv_idl_ptr -> id_list.id (k);
			     end;
		     end;
		     if id_list.number_of_ids ^= 0
		     then do;
			     stv_number_of_dimensions = id_list.number_of_ids;
			     allocate simple_typed_vector in (select_area) set (simple_typed_vector_ptr);
			     simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
			     range.tup_var (i).stv_ptr = simple_typed_vector_ptr;

			     stv_number_of_dimensions = 0; /* use for walking through the vector */
			     do k = 1 to il_number_of_ids; /* walk the WHOLE relation */
				if range.tup_var (i).needed_bits.attr (k)
				then do;
					stv_number_of_dimensions = stv_number_of_dimensions + 1;
					simple_typed_vector.dimension (stv_number_of_dimensions).value_ptr =
					     bv_stv_ptr -> simple_typed_vector.dimension (k).value_ptr;
				     end;
			     end;
			end;			/* ids to move */
		     else do;			/* no ids to move */
			     range.tup_var (i).stv_ptr = null ();
			end;
		end;				/* build simple_typec_vector */
	end;					/* walk through tuple vars */


	dcl     bv_idl_ptr		 ptr;
	dcl     bv_stv_ptr		 ptr;
	dcl     bv_ri_ptr		 ptr;
	dcl     i			 fixed bin;
	dcl     k			 fixed bin;

     end build_vectors;
%page;
error: proc (cd);

/* Internal error procedure */

	dcl     cd		 fixed bin (35);	/* statuc code */

	code = cd;
	go to exit;

     end error;
%page;
	dcl     code		 fixed bin (35);	/* Output -- return code */
	dcl     icode		 fixed bin (35);	/* internal status code */

	dcl     (top,				/* index to top of node stack */
	        or_top,				/* index to top of or node stack */
	        and_top,				/* index to top of and node stack */
	        sa_nvars,				/* no. of vars for size_array. */
	        nxchng,				/* no. of exchanges for bubble sort */
	        begin_and_group)	 fixed bin;	/* index just before the beginning of the
						   current and_group in the combined search ops list. */


	dcl     (c_ptr,				/* pointer to child node */
	        notl_ptr,				/* ptr to temp not node */
	        notr_ptr,				/* ptr to temp not node */
	        p_ptr,				/* pointer to parent node */
	        and_ptr,				/* ptr to new and node */
	        copy_ptr,				/* ptr to top of copied subtree */
	        sa_ptr,				/* to size_array */
	        sap)		 ptr;

	dcl     (done,				/* internal flag */
	        display_predicate_tree,
	        display_search_paths,
	        sa_alloc)		 bit (1) unal;	/* internal flag */

	dcl     node_stack		 (mrds_data_$max_pred_depth) ptr; /* stack of tree nodes */
	dcl     or_stack		 (mrds_data_$max_pred_depth) ptr; /* stack of or nodes */
	dcl     and_stack		 (mrds_data_$max_pred_depth) ptr; /* stack of and nodes */
	dcl     1 size_array	 (sa_nvars) based (sa_ptr),
		2 var_index	 fixed bin,
		2 size		 fixed bin (35);
	dcl     wkspc1		 (4) fixed bin (71);
	dcl     1 search_array	 aligned,		/* to hold search info from each and group */
		2 num_and_groups	 fixed bin,	/* number of and groups used */
		2 and_group	 (mrds_data_$max_and_groups + 1),
		  3 cost		 float bin (63),	/* cost of this and group */
		  3 path_ptr	 ptr,		/* to low cost path for this and group */
		  3 sv_ptr	 ptr,		/* to search_vars for and group */
		  3 so_ptr	 ptr;		/* to search_ops for and group */

	dcl     sorted		 bit (1);		/* on => search array has been sorted by cost */
	dcl     exchanged		 bit (1);		/* on => no more bubbling needed, since none done last pass */
	dcl     spare_element	 fixed bin;	/* address of last unused element in array */
	dcl     neg_op		 (10) bit (6) int static options (constant) init (/* table of negating operators */
				 "0"b, "0"b, "0"b, "0"b, /* first four are not applic. */
				 "000110"b,	/* EQ -> NE */
				 "000101"b,	/* NE -> EQ */
				 "001010"b,	/* LT -> GE */
				 "001001"b,	/* GT -> LE */
				 "001000"b,	/* LE -> GT */
				 "000111"b);	/* GE -> LT */

	dcl     (mrds_error_$node_stack_ovfl,
	        mrds_error_$no_tuple_effect,
	        mrds_error_$max_and_groups,
	        mrds_error_$max_and_terms,
	        mrds_data_$max_attributes,
	        mrds_data_$max_id_len,
	        mrds_data_$max_pred_depth,
	        mrds_data_$max_and_groups,
	        mrds_data_$max_and_terms,
	        mrds_data_$max_safe_tids_returned_per_call,
	        mrds_data_$max_tids_returned_per_call,
	        mrds_data_$max_tup_var) fixed bin (35) ext;

	dcl     var_count		 fixed bin;	/* number of tuple variables used in search path */
	dcl     min_path_first_el_ptr	 ptr;		/* pointrer to first element in minimum cost search path */
	dcl     min_path_last_el_ptr	 ptr;		/* ditto last element */
	dcl     last_el_ptr		 ptr;		/* pointer to last element in minimum cost parstial path */
	dcl     path_var_flags	 (range.num_vars) bit (1) based (pvf_ptr); /* if tuple variable has been used in search path */
	dcl     pvf_ptr		 ptr;		/* pointer to the path_var_flags */
						/* corresponding bit is true */
	dcl     ioa_		 entry options (variable);

	dcl     (addr,
                  addrel,
	        after,
	        before,
	        fixed,
	        ltrim,
	        null,
	        rel,
	        rtrim,
	        string,
	        substr,
	        unspec)		 builtin;

	dcl     mdb_display_path_$path entry (ptr, ptr);
	dcl     mdb_display_pred_tree$display_pred_tree_ entry (ptr, bit (1), bit (1), fixed bin, fixed bin, ptr);
	dcl     mrds_dsl_gen_srch_prog entry (ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     mrds_dsl_permute	 entry (ptr, ptr, ptr, float bin (63), fixed bin (35));
	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr,
				 ptr, ptr, fixed bin (35));
	dcl     info_ptr		 ptr init (null ());/* dummy arg */
	dcl     return_value	 fixed bin (35) init (0); /* dummy arg */
	dcl     mrds_error_$tuple_not_found fixed bin (35) ext; /* no data to be found */
	dcl     temp_pvp		 ptr;		/* temp for displaying path_var structure info */
	dcl     temp_rmri_ptr	 ptr;		/* temp for rm_rel_info pointer for pso display */
	dcl     (x, y, z)		 fixed bin;	/* array/loop indexes */
	dcl     path_var_pointer_array (mrds_data_$max_tup_var) ptr; /* array of pointers to path_var structures for pso display */
	dcl     condition_name	 (1:6) char (2) init ("=", "^=", "<", "<=", ">", ">=")
				 int static options (constant); /* char versions of comparison ops */
	dcl     access_method_name	 (1:6) char (32) int static options (constant) init
				 ("Primary key equality",
				 "Key head equality",
				 "Key or key head range",
				 "Indexed attribute",
				 "Sequential",
				 "Sequential");
	dcl     (rel_name, attr_name)	 char (32);	/* temps for display for -pso */
	dcl     saved_access_method	 fixed bin;	/* for changing peons displayed access method */
	dcl     non_null_and_groups	 fixed bin;	/* and groups without a 0 size rel */
	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
	dcl     current_max_tids_per_call fixed bin (35);
	dcl     1 current_scope_flags	aligned based (current_scope_ptr) like scope_flags;
          dcl     current_scope_ptr      ptr;
%page;
%include mdbm_scope_info;
%page;
%include dm_element_id_list;
%page;
%include dm_range_constants;
%page;
%include dm_relation_spec;
%page;
%include dm_specification_head;
%page;
%include mrds_dbcb;
%page;
%include mdbm_rm_db_info;
%page;
%include mrds_predicate_tree;
%page;
%include mrds_expressions;
%page;
%include mrds_range;
%page;
%include mrds_select_list;
%page;
%include mrds_tuple_info;
%page;
%include mrds_search_vars;
%page;
%include mdbm_rtrv_info;
%page;
%include mrds_search_ops;
%page;
%include mrds_optimize_tables;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_arg_list;
%page;
%include mdbm_seg_area;
%page;
%include mrds_select_area;
%page;
%include vu_typed_vector;
%page;
%include dm_id_list;
%page;
%include mrds_debug_names;
%page;
%include mdbm_rm_attr_info;


     end mrds_dsl_optimize;
