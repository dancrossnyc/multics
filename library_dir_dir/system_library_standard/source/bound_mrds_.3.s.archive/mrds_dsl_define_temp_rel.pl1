/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-04-19,
     85-06-14, and 85-07-09 by Thanh Nguyen. (see mrds #136 and
     #139 (phx19906))
  2) change(86-11-18,Blair), approve(86-11-18,PBF7311), audit(86-11-26,Dupuis),
     install(86-12-09,MR12.0-1237):
     Change to use mrds_data_$relation_blocking_factor to create temp
     relations.
  3) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-05-19,Dupuis), install(88-08-01,MR12.2-1073):
     For new parser, changed references of sel_ptr to select_list_ptr.
                                                   END HISTORY COMMENTS */

mrds_dsl_define_temp_rel:
define_temp_rel:
     proc;

/* (database_index, selection_expression, sel_value, rel_index, code)

   DESCRIPTION:

		      BEGIN_DESCRIPTION
   The  purpose  of  this  procedure  is to implement the dsl_$define_temp_rel
   function.  This procedure creates an argument list, for and calls translate
   then calls search or retrieve_set_tuple.

   If  the rel_index is zero on input, a new temporary relation is defined and
   its index is returned in rel_index as an output parameter.  If rel_index is
   >zero  on  input,  and  a  temorary  relation possessing this index already
   exists, that temporary relation is redefined.  If rel index is <zero, and a
   temporary relation possessing that index already exists, it is deleted, and
   it's index made available for future use in another definition (rel_index =
   0).
		       END_DESCRIPTION






   INPUT CONDITIONS:

   database_index   is  the  index  of  the  database  the  caller  wishes  to
   define_temp_rel.

   selection_expression  is  the expression supplied by the user to select the
   tuplies to be include in the temp rel.  the selection_expression is ignored
   in the case of a negative rel_index.

   se_value selection expression values (optional);

   rel_index index designating the temp_rel being defined, It is zero on input
   if  a  new temp_rel is to be defined and the index is returned as an output
   paramater.  an input value for the rel_index of >0 means redefine that temp
   rel, and an input value of <0 means delete that temp rel definition.



   OUTPUT CONDITIONS:

   If no errors are encountered the temp_rel definition was performed.

   code = 0; If no errors are detected.

   code  =  mrds_error_$invalid_db_index;  If  no  dbcb_ptr  was found for the
   database index.

   code  =  mrds_error_$undefined_temp_rel_index; If the value of rel_index on
   input  is non-zero or does not refer to an existing temporary relation when
   non-zero.

   code  =  mrds_error_$max_temp_rels  If  the  number  of definitions exceeds
   mrds_data_$max_temp_rels

   code = something else; If some other error was detected;

   rel_index  = numeric value of the temporary relation created.  or it is set
   to 0, if an index was being deleted(i.e.  <0 on input)


   If  less  then  4  arguments  were  passed  to this procedure the condition
   arg_error will be signaled.





   HISTORY:

   76-01-01 R. D. Lackey: Initially written.

   78-10-01 J. A. Weeldreyer: Modified for MR7.0.

   79-03-26 Al Kepner: Modified to add caller parameter to mrds_dsl_translate.

   79-07-13  Al  Kepner:  Modified to handle char varying attributes stored in
   the data base by Pl/I standards.

   79-10-01 Jim Gray : Modified to correct key order counting.

   79-10-02  Jim  Gray  :  Modified  to  ignore duplicate key value tuples per
   documentation.

   79-10-03   Jim   Gray   :   Modified   to   change   iox_$attach_ioname  to
   iox_$attach_name, so that temp_rels can be properly deleted.

   79-10-04  Jim Gray : Modified to put temp rel info structures in rm_db_info
   area,  rather  than dbcb area, so that structures are handled consistantly,
   and so rdbi_ptr can be gotten simply after calls to mus_ptr_man$get_rip.

   79-12-01  Jim  Gray  :  Modified  to change the real_bit_length calculation
   routine,  to  use  whether  the  data  type  is varying character, not just
   varying,  to  determine  the bit length from the count field of the varying
   data item.

   80-01-01  Jim  Gray : Modified to handle undefined temp rel indexes, and to
   make negative temp rel indexes mean delete that temp rel definition, and to
   correct some undefined mrds_error_ table entries.

   80-01-02  Jim  Gray  : Modified to correct order of inititalization problem
   with  rm_rel_info/rm_rel_info in create_temp_rel_file that caused the value
   of the rmri_ptr to become unknown.

   80-01-03 Jim Gray : Modified to fix tidy_up problem on >max_temp_rel error,
   and to prevent recursive calls to tidy_up, when an error occurs.

   80-01-04  Jim Gray : Modified to fixed multiple redefinition problem (added
   destroy_iocb)

   80-02-01  Jim  Gray  : Modified to detect non-unique attr names in relation
   definition.

   80-02-02 Jim Gray : Modified to put allocations in a non-freeing extensible
   area managed by this routine.

   80-05-07 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
   submodels were the submodel view did not contain a varying string attribute
   and the model did.

   80-05-12     Rickie     E.      Brinegar:     Modified     to    initialize
   rm_rel_info.model_nvar_atts      and      rm_rel_info.model_num_attr     in
   create_temp_rel_file  to  the  same initial values as rm_rel_info.nvar_atts
   and   rm_rel_info.num_attr   respectively.    This  was  necessary  because
   define_temp_rel builds its own tuple structure.

   80-06-01  Jim Gray : Modified to add first_time_flag to store direct entry,
   so that allocated space could be reused, especially for large temp rels.

   80-09-16  Jim  Gray  :  Modified to put the temp rel (vfile) storage in the
   same  place  as  the  resultant  model,  which  may  have  been  changed by
   set_mrds_temp_dir

   80-10-01  Jim  Gray  : Modified to make the $del_trels entry know about the
   proper  place  to get the resultant model temp dir, instead of always using
   the pdir.

   80-10-03  Jim Gray : Modified to make temp rel redefinition delete the temp
   rel, if the new temp rel definition did not find any tuples.  This makes it
   work  the  way  it used to before the recursive tidy up problem fix entered
   this rebug.

   80-10-17  Jim  Gray  :  Modified to allow empty temp rels to be created, or
   defined by redefinition, according to customer wishes.

   80-11-05  Jim  Gray : Modified to set mdbm_secured bit and ??_perm bits the
   same  way  as  a  normal  relation  would  be set, for proper handling when
   secure_mrds_db was invoked.

   80-11-10  Jim Gray : Modified to change dele_$path to hcs_$del_dir_tree and
   hcs_$delentry_file calls in order to improve performance.

   81-1-13   Jim  Gray  :  added  routine  (from  mrds_rst_format_file  logic)
   force_msf_temp_rel,  to  always  start  temporary  relations  out  as  full
   multi-segment  files,  just  like  permanent  relations  are.   This avoids
   problems  with  vfile_ and msf_manager_ when the ssf grows to msf and there
   are  multiple  openings.   This  is  a  fix  for critical TR 8871.  It also
   results  in  a  permformance  improvement for cases where as msf would have
   been created on temp_rel creation (i.e.  most non-empty temp rels)

   81-01-29 Jim Gray : removed references to mdbm_data_$current_version, using
   a constant instead, to allow future db version expansion.

   81-01-29  Jim  Gray  :  added  proper  alignment of different data type and
   alignment   type   attributes   within   the  tuple,  as  already  done  in
   mrds_rst_file_handler  for  permanent  relations,  so that the logic in the
   rest  of  mrds  can  find the attributes in the tuple.  TR 9021 pointed out
   that  where  clause  comparisons  were failing due to improper alignment of
   temp  rel  tuple  attrs.   Also  found  that tuples were 9 times as long as
   necessary,  because  improper use of bit versus character lengths was being
   done, compare rel_info versus rm_rel_info as init in mu_sec_make_res.

   81-01-30  Jim  Gray  : added interface get_temp_rel_population according to
   suggestion  TR  8991,  this  required  a change to rm_rel_info that will be
   usefull in improving finding approx tuple count in perm relations.

   81-01-30  Jim Gray : added padding logic to align varying strings to a word
   boundary  in the get_tuple routine.  this was done because the previous fix
   only  set  the  max_data_len for the tuple, and var_offset (i.e.  the start
   and  end  of  the varying attr section of the tuple) but not the offsets of
   the  varying  attrs, because they are stored in current length fashion, and
   must be set at data definition time.

   81-02-03  Jim  Gray  : changed declaration of fb35 to unaligned and renamed
   fb35u,  in  answer  to  TR  9041.   Note this was done as a quick and dirty
   because  the  tuple  defined by a set operation is not properly aligned and
   padded.   Thus  it is different in structure from perm and temp rel tuples.
   However,  since  it can only be used in retrieves, and temp rel definition,
   this fix is adequate for now, until we build a common tuple manager.

   81-03-17  Davids:  added  code  to  set  the rm_rel_info.model_nkey_attr to
   nkey_attr_init  in  the internal procedure create_temp_rel_file, this fixed
   tr9211.   also removed some unused declarations and explicity declared some
   builtins.   added  the  page  macro  between  include file declarations and
   removed  the form feeds that were there, also removed extra form feeds that
   were  causing  blank pages.  reformated the header section so that the text
   is justified.

   81-03-24  Jim  Gray  :  added  capability  for  selection  expression to be
   declared by caller to be char varying as well as just char.

   81-03-27    Jim   Gray   :   changed   dbi   to   dbcb_ptr   parameter   to
   mu_store$store_direct as part of getting rid of the mus_ptr_man module.

   81-06-02 Jim Gray : changed to use new resultant structure.

   81-06-17 Jim Gray : changed iocb pointer init to call mu_open_iocb_manager.

   81-10-05  Rickie  E.   Brinegar: collapsed all of the processing to be done
   when  the  arg_list.code  =  4  and  when  it  is not into one if-then-else
   statement as opposed to the three that used to exist.

   81-10-14 Davids: corrected value of the adpl_ptr so it pointed to
   the descriptor of the argument following the selection expression
   instead of the selection expression  descriptor.  This  corrected
   .V. problems.

   81-10-23 Davids: Have converted references of the form:
   .          ptr = addr (bit_array (large_offset))
   .	              to
   .          ptr = add_bit_offset (bit_array_ptr, large_offset - 1)
   This gets around a pl1 bug (tr11784) that causes the first method
   to  produce  the  wrong  value  when  the code is compiled with a
   subscriptrange condition. The "-1" is needed because  bit_array's
   first element is 1 not 0.

   81-12-04 Davids: changed the value of rm_rel_info.file_id_len  to
   be  equal to the constant 9 rather than computing it based on the
   max  number  of  temp  rels.  This  value  should   be   set   to
   db_model.unblk_file_id_len  but  it  was  easier  just to use the
   constant  value.  Also  set  rm_rel_info.file_id  to   "0"b   and
   rm_rel_info.file_type to UNBLK (= 1). All this is so that the tid
   created for a temp rel tuple will look the same (except  for  the
   component  and  offset)  as tids created for permanent relations.
   This is done so that the moving the data into the database dir to
   create a permanent relation will not cause any problems.

   81-12-16 Davids: modified to handle self-defined temp  rels,  i.e
   the  temp  rel refers to itself in the defining SE. This required
   changing the rm_rel_array refering to temp rels to have  1  extra
   slot, i.e. have a dimension of mrds_data_$max_temp_rels + 1, this
   was done in mu_sec_init_res. In this routine  all  references  to
   rm_rel_array.num_rels   have   been   changed  to  references  to
   mrds_data_$max_temp_rels becuase num_rels is now too big. The new
   relation  is  defined using the extra index and then the old temp
   rel is deleted and the rm_rel_array fields copied. for TR11630

   81-12-18         Davids:         modified         so         that
   rm_rel_array.last_statistics_update_s_e_ref_num   is  set  to  0,
   rm_rel_array.ready_mode is set to SCOPE_UPDATE instead  of  LOAD,
   the  view permissions modify and delete in rm_rel_info are set to
   "1"b (retrieve and store were already set), the scope permissions
   rm_attr_info.modify_perm  was  set  to  "1"b (others were already
   set) and reformated the assignments so they were easier to  read.
   All this so that temp rels can be updated.

   82-04-21  R. Lackey : Add rm_rel_info.number_selected = 0;
   To help keep track of how much space is used and delete old subsets.
   TR12205 (Suggestion).

   82-04-26 R. Lackey : removed get_tuple internal procedure and made it
   external with the name mu_get_tuple providing common code for
   rmdb_create_relation with a selection exp.

   82-05-24 R. Lackey : Modified the initialization of rm_rel_info.file_id_len
   from 9 to 7 cause the tuple_id_unbl.file_id length is only 7 bits.
   This corrected a stringsize condition.

   82-06-09 Mike Kubicar : added the fix for TR phx12347.  If a temp relation
   had varying strings in it but the last attribute in it is not a varying
   string, the temp relation would be missing data.

   82-08-20 D. Woodka : deleted references to rm_rel_info.max_data_len
   and to rm_attr_info.bit_offset for DMS conversion

   82-08-25 Mike Kubicar : Converted the use of the tuple structure to
   the simple vector structure.

   82-09-12 Mike Kubicar : Converted to use relation manager.

   82-12-10 Davids: Modified the call to dbcb.relmgr_entries.create_relation
   and destroy_relation_by_path by enclosing the relation name in ()s.
   This was needed because the declaration of the relation manager entries
   in the dbcb was changed from options variable to reality. The relation name
   is declared as character aligned in the include file while the entry expects
   character unaligned.

   83-01-31 Mike Kubicar : Added included files to call transaction manager
   when using a dm file database.

   83-02-17 Ron Harvey : Modified to call $create_relation with the attribute
   names.

   83-02-25 Davids: Modified to set the protected, no_concurrency and
   no_rollback elements of the file_create_info structure from the 
   transactions_needed, concurrency_on, rollback_on elements of the
   dbcb structure. This allows temp rels to be created with the same
   file attributes as the permanent relations.

   83-05-04 Davids: Modified so that mu_define_area is called with a name
   of MRDS || dbi_pic. This will allow closes to be faster since all
   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
   the variable dbi_pic was created as an easy way to convert from fixed bin
   to character.

   83-06-20 Davids: Removed check for old version database and the call
   to v1 code if it was an old version db (old version dbs can no longer
   be opened)

   84-08-22 Pierret: Changed usage of file_create_info structure for version
   FILE_CREATE_INFO_VERSION_2.  This add the ring_brackets component, which
   is set to 0 to get the default action.

   85-01-15 Thanh Nguyen:  Added code to create a special work area using 
   mu_define_area$define_spec_temp_dir_area.  For now, this work area is used
   by mu_retrieve and mu_get_data to "allocate" value_for_db and value_for_user
   thru function mrds_space_allocate and reinitialize the area thru subroutine
   mrds_area_initialize.

   85-06-14 Thanh Nguyen:  Initialized the rm_rel_info.scope_flags_ptr to null
   so later noone would have some gabages overwrite on their good areas when
   accidentally referencing scope_flags_ptr.

   85-07-09 Thanh Nguyen:  Modified the code to set rm_rel_info.file_type as
   TEMPORARY (3) from UNBLCK (1).
*/
%page;
	area_ptr, dbcb_ptr, simple_typed_vector_ptr = null;
	tri = 0;					/* initialize */
	no_recurse = "0"b;
	created_resultant = "0"b;
	mstxn_txn_id = "0"b;
	entry_point_name = "mrds_dsl_define_temp_rel";

	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
	if al_ptr = null then
	     signal arg_error;			/* This returns you to command level */
	nargs = arg_list.arg_count / 2;		/* Get the number of arguments to this proc */
	if nargs < 4 then
	     signal arg_error;			/* This returns to command level */

	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get  pointer to callers return code */
	if icode ^= 0 then
	     signal arg_error;			/* This returns to command level */

	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
	if icode ^= 0 then
	     call error (icode);

	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
	if icode ^= 0 then
	     call error (icode);

	if arg_list.code = 4 then do;
		num_ptrs = arg_list.arg_count;	/* Determine number of pointers in arg list */
		adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 3)); /* Get pointer to descriptor ptr list for
						   args after SE for translate */
		desc_ptr = arg_list.arg_des_ptr (nargs + 2); /* Get pointer to descriptor of the selection expression */
	     end;
	else do;
		num_ptrs = arg_list.arg_count + 1;
		adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));
		desc_ptr = arg_list.arg_des_ptr (nargs + 3);
	     end;

	if descriptor.type = 22 then do;
		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
		se_len = se_len_ptr -> se_len_ovrly;
	     end;

	call cu_$arg_ptr (nargs - 1, rel_index_ptr, arg_len, icode);
						/* Get the rel_index */
	if icode ^= 0 then
	     call error (icode);

	appl_ptr = addr (arg_list.arg_des_ptr (3));	/* Get ptr to the start  of the arg_ptr_list for translate */

	num_args = nargs - 4;			/* Number of args passed to translate */

	call
	     mu_database_index$get_resultant_model_pointer (database_index,
	     dbcb_ptr);				/* Get the dbcb pointer */
	if dbcb_ptr = null then
	     call error (mrds_error_$invalid_db_index);

	rdbi_ptr = dbcb.rdbi_ptr;

	tr_dir = get_resultant_dir (database_index);	/* put temp rels in same dir as resultant model */

	dbi_pic = dbcb.dbi;
	call
	     mu_define_area$define_temp_dir_area (dbcb.def_temp_rel_area_ptr,
	     database_index, (sys_info$max_seg_size),
	     "MRDS" || dbi_pic, "0"b /* not extensible */, "1"b /* no freeing */, "0"b,
	     "0"b /* no zeroing */, icode);
	area_ptr = dbcb.def_temp_rel_area_ptr;
	if icode ^= 0 then
	     call error (icode);
	rmra_ptr = rm_db_info.tra_ptr;		/* get rel and file aray ptrs */
						/* Create a work area for mu_retrieve to allocate the value_for_users. */
	call mu_define_area$define_spec_temp_dir_area (dbcb.work_area_ptr, database_index, "MRDS" || dbi_pic, icode);
	if icode ^= 0 then call error (icode);
%page;

	if rel_index = 0 then do;			/* if new temp rel */
		tri = 0;
		do i = 1 to mrds_data_$max_temp_rels;
		     if rm_rel_array.rel_data.ri_ptr (i) = null () & tri = 0 then
			tri = i;
		end;
		if tri = 0 then
		     call error (mrds_error_$max_temp_rels);
	     end;					/* if new temp rel */
	else do;					/* if redefinition */
		if abs (rel_index) > mrds_data_$max_temp_rels then
		     call error (mrds_error_$undefined_temp_rel_index);
		tri = abs (rel_index);
		if rm_rel_array.rel_data.ri_ptr (tri) = null () then
		     call error (mrds_error_$undefined_temp_rel_index);
	     end;					/* if redefin. */
	mstxn_transactions_needed = dbcb.transactions_needed;
	save_appl_ptr = appl_ptr;
	save_adpl_ptr = adpl_ptr;
	save_num_args = num_args;
	on cleanup
	     begin;
		call mstxn_cleanup;
		call tidy_up;
	     end;
	on any_other call mstxn_any_other;
%include mrds_start_transaction;
	if mstxn_code ^= 0
	then call error (mstxn_code);

	dbcb.user_started_transaction = user_started_transaction;
	if rel_index < 0 then
	     ;					/* ignore selection expr, when only deleting temp rel */
	else do;
		call
		     mrds_dsl_translate (dbcb_ptr, area_ptr,
		     mrds_data_$caller_define_temp_rel, se_ptr, se_len, appl_ptr,
		     adpl_ptr, num_args, icode);
		if icode ^= 0 then
		     call error (icode);
		if ^dbcb.val_dtr then
		     call error (mrds_error_$inval_dtr_expr);

		if dbcb.ss_ptr ^= null then do;	/* set ptrs needed later */
			ss_ptr = dbcb.ss_ptr;
			select_list_ptr = select_sets.items.select_ptr (1);
			range_ptr = select_sets.items.range_ptr (1);
			ti_ptr = select_sets.items.ti_ptr (1);
			self_defined = "0"b;
			do i = 1 to select_sets.nitems while (^self_defined & rel_index > 0);
			     self_defined = check_self_definition (select_sets.items (i).range_ptr, rel_index);
			end;
		     end;
		else do;
			range_ptr = dbcb.range_ptr;	/* initialize */
			select_list_ptr = dbcb.select_ptr;
			ti_ptr = dbcb.ti_ptr;
			self_defined = "0"b;
			if rel_index > 0
			then self_defined = check_self_definition (range_ptr, rel_index);
		     end;
		stv_number_of_dimensions = mrds_data_$max_attributes;
		allocate simple_typed_vector set (simple_typed_vector_ptr)
		     in (work_area);
		simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
	     end;

	if self_defined				/* this saves the actual user requested temp */
	then do;					/* rel index and sets up to use a temporary */
		actual_rel_index = rel_index;		/* temp rel index */
		rel_index = mrds_data_$max_temp_rels + 1;
		tri = rel_index;
	     end;
	else actual_rel_index = tri;

	if rel_index ^= 0 then /* if redefining an old temp rel */
	     call delete_temp_rel_file;		/* Delete the existing file for this temp_rel */
	if rel_index < 0 then
	     rel_index = 0;				/* only deleting previously defined temp rel */
	else do;					/* redefine or initial define */
		call create_temp_rel_file;		/* Create a new temp_rel file for this temp_rel */
		ntuples_retrieved = 0;
		dbcb.last_store_rel_name = "!!!!!!!... ...!!!!!"; /*  Temparory store bad rel name incase this store fails */
		call mu_get_tuple (dbcb_ptr, area_ptr, rmri_ptr, simple_typed_vector_ptr, icode); /* get a tuple */
		do while (icode = 0);		/* so long as there are tuples to be retrieved */
		     call
			mu_store$store_direct (dbcb_ptr, rmri_ptr, simple_typed_vector_ptr,
			icode);			/* add tuple */
		     if icode = 0 | icode = dm_error_$key_duplication then do;
						/* ignore duplicates */
			     if icode = 0 then
				ntuples_retrieved = ntuples_retrieved + 1;
			     dbcb.another_flag = "1"b;
			     call mu_get_tuple (dbcb_ptr, area_ptr, rmri_ptr, simple_typed_vector_ptr, icode);
			end;
		end;
		if icode = mrds_error_$tuple_not_found then do; /* allow empty temp rels */
			rm_rel_info.current_tuple_population
			     = ntuples_retrieved;
			rm_rel_info.last_statistics_update_time,
			     rm_rel_info.last_statistics_update_s_e_ref_num = 0;
		     end;
		else call error (icode);
		if rel_index = 0 then /* A new temp_rel file was created */
		     rel_index = tri;		/* let caller know the index */

		if self_defined
		then call complete_definition;

	     end;
	code = 0;
exit:

	mftxn_code = code;
%include mrds_finish_transaction;
	if mftxn_code ^= 0
	then code = mftxn_code;

	if dbcb_ptr = null () then
	     ;
	else if dbcb.def_temp_rel_area_ptr ^= null then
	     call mu_release_area (dbcb.def_temp_rel_area_ptr);
	return;					/* Return to the caller with a code */
%page;
get_temp_rel_population:
     entry (a_db_index, temporary_relation_index, tuple_count, a_error_code);

/* entry to get the number of tuples in a given temp
   rel definition, given it's temp rel index.  Note that no transactions
   need be started by this entry point.  It is used exclusively as an
   internal entry point by dsl_$get_population.  This module will have
   already started a transaction */

	a_error_code, tuple_count = 0;		/* init */
	no_recurse = "0"b;
	entry_point_name = "get_temp_rel_population";

	call mu_database_index$get_resultant_model_pointer (a_db_index, dbcb_ptr);
	if dbcb_ptr = null () then
	     a_error_code = mrds_error_$invalid_db_index;
	else do;
		rdbi_ptr = dbcb.rdbi_ptr;

		rmra_ptr = rm_db_info.tra_ptr;

		if temporary_relation_index <= 0
		     | temporary_relation_index > mrds_data_$max_temp_rels then
		     a_error_code = mrds_error_$undefined_temp_rel_index;
		else do;
			rmri_ptr =
			     rm_rel_array.rel_data.ri_ptr (temporary_relation_index);

			if rm_rel_array.rel_data.ri_ptr (temporary_relation_index)
			     = null () then
			     a_error_code = mrds_error_$undefined_temp_rel_index;
			else do;

				tuple_count = rm_rel_info.current_tuple_population;

			     end;
		     end;
	     end;

	return;
%page;
del_trels:
     entry (a_dbcb_ptr);

/* Entry to delete temp files.  This entry point is used only internally by
   mrds in dsl_$close.  Thus, it need not start its own transaction. */

	dcl     a_dbcb_ptr		 ptr;
	dcl     num_defined		 fixed bin;

	dbcb_ptr = a_dbcb_ptr;
	rdbi_ptr = dbcb.rdbi_ptr;
	rmra_ptr = rm_db_info.tra_ptr;
	area_ptr = null ();
	no_recurse = "0"b;
	entry_point_name = "del_trels";

	if rmra_ptr ^= null then do;
		tr_dir = get_resultant_dir (dbcb.dbi);
		num_defined = mrds_data_$max_temp_rels;
		do tri = 1 to mrds_data_$max_temp_rels; /* delete all temp files and rels */
		     call delete_temp_rel_file;
		end;
	     end;

	return;
%page;
get_resultant_dir:
     procedure (db_index) returns (char (168));

/* routine to get the resultant models storage directory */

	dcl     pathname		 char (168);	/* directory under which resultant model is stored */
	dcl     db_index		 fixed bin (35);	/* local version of databsae opening index */
	dcl     mrds_dsl_resultant_storage$get_opening_temp_dir
				 entry (fixed bin (35), fixed bin (35)) returns (char (168));
						/* gets temp dir for a particular opening */

/* good index, get a pathname from the dbcb segment pointer */

	pathname =
	     mrds_dsl_resultant_storage$get_opening_temp_dir (db_index, icode);
	if icode ^= 0 then
	     call error (icode);			/* does not return */

/* 				The dbcb segment pointer could not be expanded into a pathname. */

	else return (pathname);			/* good path of model dir found */

     end;
%page;
delete_temp_rel_file:
     proc;

/* Procedure to delete a temporary relation. */

	dcl     j			 fixed bin;

	if rm_rel_array.rel_data.ri_ptr (tri) ^= null then do; /* if there */
		rmri_ptr = rm_rel_array.rel_data.ri_ptr (tri); /* clean up file stuff */

		no_recurse = "1"b;			/* prevent recursive tidy_up calls */

		if rm_rel_info.opening_id ^= "0"b then do; /* Don't close if not open */
			call mu_cursor_manager_$destroy_and_free_on_opening_id (
			     rm_rel_info.opening_id, dbcb.cursor_storage_area_ptr,
			     dbcb.cursor_ptrs_storage_ptr, dbcb.relmgr_entries.destroy_cursor,
			     dbcb.relmgr_entries.close, icode);
			if icode ^= 0
			then call error (icode);
			call dbcb.destroy_relation_by_path (
			     tr_dir, (rm_rel_info.name), icode);
			if icode ^= 0 then
			     call error (icode);
		     end;
		rm_rel_array.name.submodel (tri),
		     rm_rel_array.rel_data.model_name (tri) = "";
		rm_rel_array.rel_data.ri_ptr (tri) = null;

		if rmri_ptr ^= null then do;
			do j = 1 to rm_rel_info.num_attr; /* free attr infos */
			     rai_ptr = rm_rel_info.attr_ptrs (j);
			     if rai_ptr ^= null then do;
				     free rm_attr_info in (dbcb.static_area);
				     rai_ptr = null ();
				     rm_rel_info.attr_ptrs (j) = null ();
				end;
			end;
		     end;				/* freeing rel info */
		free rm_rel_info.id_list_ptr -> id_list in (dbcb.static_area);
		free rm_rel_info in (rm_db_info.static_area);
		no_recurse = "0"b;			/* turn off, so temp rel redefinition deletes
						   when no tuple found */
	     end;

     end delete_temp_rel_file;
%page;
create_temp_rel_file:
     proc;

/* Procedure to create a temporary relation. */

	dcl     actual_rel_pic	 pic "99";
	dcl     cibi_ptr		 ptr;		/* ptr to ci_build_index structure */
	dcl     1 ci_build_index	 based (cibi_ptr),	/* To record which attributes are indexed */
		2 num_indices	 fixed bin,	/* How many? */
		2 index_position	 (max_build_indices refer
				 (ci_build_index.num_indices)) fixed bin; /* Position in attribute */
	dcl     create_index_flags	 bit (36) aligned;	/* Flag bits for create_index call */
	dcl     i			 fixed bin;
	dcl     j			 fixed bin;
	dcl     max_build_indices	 fixed bin;	/* Maximum number of indices */
	dcl     retrieve_id_list_ptr	 ptr;		/* Pointer to id list to be used for gets */
	dcl     SORTING_STYLE	 fixed bin init (1) int static
				 options (constant);/* Create index index style */
	dcl     var_att_index	 fixed bin;

	rmri_ptr = null ();
	created_resultant = "1"b;
	actual_rel_pic = actual_rel_index;		/* for easier manipulation */
	natts_init = select_list.num_items;
	nvar_atts_init = 0;
	do i = 1 to select_list.num_items;
	     raip = select_list.item.ai_ptr (i);
	end;					/* counting varying attrs */
	nkey_attr_init = 0;
	do i = 1 to select_list.num_items;		/* count keys */
	     if select_list.item.key (i) then
		nkey_attr_init = nkey_attr_init + 1;
	end;
	if nkey_attr_init < 1 then
	     call error (mrds_error_$no_tr_keys);	/* must have key */

	allocate rm_rel_info in (rm_db_info.static_area);

	rm_rel_array.rel_data.ri_ptr (tri) = rmri_ptr;
	rm_rel_info.model_name, rm_rel_info.name,
	     rm_rel_array.name.submodel (tri),
	     rm_rel_array.rel_data.model_name (tri) =
	     unique_chars_ ("0"b) || "." || actual_rel_pic || ".temp_rel";
	rm_rel_info.ready_mode = SCOPE_UPDATE;
	rm_rel_info.file_type = TEMPORARY;
	rm_rel_info.tuple_id_len = 36;
	rm_rel_info.retrieve,
	     rm_rel_info.store,
	     rm_rel_info.delete,
	     rm_rel_info.modify = "1"b;

	rm_rel_info.status_perm,
	     rm_rel_info.delete_tuple_perm,
	     rm_rel_info.append_tuple_perm,
	     rm_rel_info.unused_perm = "1"b;

	rm_rel_info.total_key = "1"b;

	rm_rel_info.mdbm_secured = rm_db_info.mdbm_secured; /* temp secured if db is */

	rm_rel_info.last_model_attr_char_var,
	     rm_rel_info.indexed,
	     rm_rel_info.reserved = "0"b;

	rm_rel_info.nsec_inds,
	     rm_rel_info.max_key_len = 0;

	rm_rel_info.num_attr = natts_init;
	rm_rel_info.model_num_attr = natts_init;
	rm_rel_info.nkey_attr = nkey_attr_init;
	rm_rel_info.model_nkey_attr = nkey_attr_init;	/* added on 81-03-17 */
	rm_rel_info.scope_flags_ptr = null;/* temp. relation so no need scope. */
	var_att_index, key_order = 0;

	il_number_of_ids = select_list.num_items;
	allocate id_list in (rm_db_info.static_area) set (retrieve_id_list_ptr);
	retrieve_id_list_ptr -> id_list.version = ID_LIST_VERSION_1;
	retrieve_id_list_ptr -> id_list.number_of_ids = select_list.num_items;

/* Set up the structures needed to keep track of indices */

	allocate id_list in (work_area);
	id_list.version = ID_LIST_VERSION_1;
	id_list.number_of_ids = 0;

	max_build_indices = select_list.num_items;
	allocate ci_build_index in (work_area);
	ci_build_index.num_indices = 0;

	tva_number_of_vector_slots = 0;
	tva_number_of_dimensions = select_list.num_items;
	tva_maximum_dimension_name_length = 32;
	allocate typed_vector_array in (work_area);
	typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;

	do i = 1 to select_list.num_items;		/* do the attr infos */

	     raip = select_list.item.ai_ptr (i);	/* pick up one for source attr */
	     allocate rm_attr_info in (rm_db_info.static_area);
	     rm_attr_info.model_name, rm_attr_info.name = raip -> rm_attr_info.name;

	     do x = 1 by 1 to i - 1;			/* check for duplicate attr selection */
		temp_rai_ptr = select_list.item.ai_ptr (x);
		if rm_attr_info.name = temp_rai_ptr -> rm_attr_info.name then
		     icode = mrds_error_$dup_temp_rel_attr;
	     end;

	     rm_attr_info.key_attr = select_list.item.key (i);
	     rm_attr_info.index_attr, rm_attr_info.reserved, rm_attr_info.index_id =
		"0"b;

	     rm_attr_info.read_perm,
		rm_attr_info.modify_perm = "1"b;

	     rm_attr_info.index_id = "0"b;
	     rm_attr_info.mdbm_secured = rm_rel_info.mdbm_secured;
	     rm_attr_info.defn_order = i;
	     rm_attr_info.model_defn_order = i;
	     rm_attr_info.bit_length = raip -> rm_attr_info.bit_length;
	     retrieve_id_list_ptr -> id_list.id (i) = i;

/*  Save some of the attribute's information so that we can later create
    the relations and indices */

	     if select_list.item.index (i) then do;	/* is the attribute indexed? */
		     ci_build_index.num_indices =
			ci_build_index.num_indices + 1;
		     ci_build_index.index_position = i;
		end;

	     typed_vector_array.dimension_table (i).name =
		raip -> rm_attr_info.name;
	     typed_vector_array.dimension_table (i).descriptor_ptr =
		addr (raip -> rm_attr_info.domain_ptr ->
		rm_domain_info.db_desc);


/* ********************************************************************* */
/* 	compute the bit offset within the tuple			*/

	     rm_attr_info.domain_ptr, rdi_ptr = raip -> rm_attr_info.domain_ptr;

	     rm_rel_info.attr_ptrs (i) = rai_ptr;

	     if select_list.item.key (i) then do;
		     rm_attr_info.key_order, key_order = key_order + 1;
		     rm_rel_info.key_attr_ptrs (key_order) = rai_ptr;
		     rm_rel_info.max_key_len =
			rm_rel_info.max_key_len + rm_attr_info.bit_length;
		     id_list.number_of_ids = key_order;
		     id_list.id (key_order) = i;
		end;
	end;					/* initial attr loop */
	rm_rel_info.max_key_len = ceil (rm_rel_info.max_key_len / 9);

/* ******************************************************************* */

	rm_rel_info.id_list_ptr = retrieve_id_list_ptr;


/*  Now create the relation and the indices */

	allocate rel_creation_info in (work_area);
	allocate file_create_info in (work_area);
	file_create_info.version = FILE_CREATE_INFO_VERSION_2;
	file_create_info.ci_size_in_bytes = 4096;
	file_create_info.blocking_factor = mrds_data_$relation_blocking_factor;
	file_create_info.flags.protected = "0"b;
	file_create_info.flags.no_concurrency = "1"b;
	file_create_info.flags.no_rollback = "1"b;
	file_create_info.flags.mbz_1 = "0"b;
	file_create_info.ring_brackets (*) = 0;
	file_create_info.mbz_2 = 0;
	file_create_info.mbz_3 = "0"b;
	rel_creation_info.version = REL_CREATION_INFO_VERSION_2;
	rel_creation_info.file_create_info_ptr = file_create_info_ptr;
	rel_creation_info.esm_info_ptr, rel_creation_info.cism_info_ptr
	     = null ();

	rm_rel_info.opening_id = "0"b;		/* If open fails, we will
					  assume there has been no
					  new relation created */
	call dbcb.relmgr_entries.create_relation (tr_dir,
	     (rm_rel_info.name), rel_creation_info_ptr,
	     typed_vector_array_ptr, rm_rel_info.opening_id,
	     rm_rel_info.rel_id, icode);

	if icode ^= 0
	then call error (icode);

/* We're done with the relation, now create the indices (and primary key) */

	create_index_flags = "0"b;
	relation_index_flags_ptr = addr (create_index_flags);
	relation_index_flags.relation_must_be_empty = "1"b;
	relation_index_flags.index_is_unique = "1"b;	/* For primary key */
	call dbcb.relmgr_entries.create_index (rm_rel_info.opening_id,
	     id_list_ptr, create_index_flags, SORTING_STYLE,
	     rm_rel_info.primary_key_index_id, icode);
	if icode ^= 0
	then call error (icode);

/*  Create the secondary indices */

	id_list.number_of_ids = 1;
	relation_index_flags.index_is_unique = "0"b;

	do j = 1 to ci_build_index.num_indices;
	     id_list.id (1) = ci_build_index.index_position (j);
	     call dbcb.relmgr_entries.create_index (rm_rel_info.opening_id,
		id_list_ptr, create_index_flags, SORTING_STYLE,
		rm_rel_info.attr_ptrs (ci_build_index.index_position (j))
		-> rm_attr_info.index_id, icode);
	     if icode ^= 0
	     then call error (icode);
	end;

     end create_temp_rel_file;
%page;
check_self_definition: proc (range_ptr, rel_index) returns (bit (1));

/*
   This procedure will return true if any of the  relations  in  the
   defining  SE  are  temporary relations and have an index equal to
   rel_index, i.e. it will return true if the requested temp rel  is
   to be defined in terms of itself.
*/

/* PARAMETERS */

	dcl     range_ptr		 ptr;		/* (input) pointer to the range structure */
	dcl     rel_index		 fixed bin (35);	/* (input) index of the temp rel to be defined */

/* AUTOMATIC */

	dcl     i			 fixed bin;	/* loop index */
	dcl     self_defined_flag	 bit (1) init ("0"b); /* true if the temp rel index appears in the */
						/* range of the defining SE */


	do i = 1 to range.num_vars while (^self_defined_flag);
	     if range.tup_var (i).temp_rel
	     then do;
		     if bin (substr (range.tup_var (i).ri_ptr -> rm_rel_info.name, 17, 2)) = rel_index
		     then self_defined_flag = "1"b;
		end;
	end;

	return (self_defined_flag);

     end;
%page;
complete_definition: proc;

/*
   This procedure completes the definition of a temp  rel  that  was
   defined  in  terms  of itself.
*/

/* AUTOMATIC */

	dcl     temporary_index	 fixed bin (35);	/* This will always be max_temp_rels + 1 */


	temporary_index = rel_index;
	rel_index = actual_rel_index;
	tri = rel_index;
	call delete_temp_rel_file;

	rm_rel_array.name (tri).submodel = rm_rel_array.name (temporary_index).submodel;
	rm_rel_array.rel_data (tri).model_name = rm_rel_array.rel_data (temporary_index).model_name;
	rm_rel_array.rel_data (tri).ri_ptr = rm_rel_array.rel_data (temporary_index).ri_ptr;
	rm_rel_array.rel_data (temporary_index).ri_ptr = null ();

	return;

     end;
%page;
error:
     proc (cd);					/* Internal error  procedure */

/* Error procedure */

	dcl     cd		 fixed bin (35);

	if entry_point_name = "del_trels"
	then goto exit;				/* Errors are ignored for that entry point */
	code = cd;				/* Return the error code to caller */
	if no_recurse then
	     cd = original_cd;
	else do;
		original_cd = cd;
		call tidy_up;
	     end;
	go to exit;

     end error;

	dcl     original_cd		 fixed bin (35);	/* The original error code, in case of recursive calls */
%page;
tidy_up:
     proc;

/* Cleanup procedure */





	if tri > 0 & tri <= mrds_data_$max_temp_rels + 1 then do;
		call delete_temp_rel_file;
		tri = 0;
	     end;
	if dbcb_ptr ^= null then
	     call mrds_dsl_delete_se (dbcb_ptr, (mrds_data_$caller_define_temp_rel), icode);

     end tidy_up;
%page;
/***********
*
*   These routines are used by the transaction processing include files.
*   Restore_significant_data is called to reinitialize variables in case
*   of a rollback.  Should_rollback determines whether a transaction should
*   be rolled back or aborted on error.  Currently, it is always aborted.
*
**********/


restore_significant_data:
     proc;

	dcl     ignore_icode	 fixed bin (35);	/* Ignore errors from mu_cursor_manager_ */

/* Uncreate the resultant if necessary */

	if created_resultant & rmri_ptr ^= null () then do;
		do i = 1 to rm_rel_info.model_num_attr;
		     free rm_rel_info.attr_ptrs (i) -> rm_attr_info;
		end;


/* Destroy any cursors if the relation is open.  Ignore any errors. */

		if rm_rel_info.opening_id ^= "0"b
		then call mu_cursor_manager_$destroy_and_free_on_opening_id
			(rm_rel_info.opening_id, dbcb.cursor_storage_area_ptr,
			dbcb.cursor_ptrs_storage_ptr, dbcb.relmgr_entries.destroy_cursor,
			dbcb.relmgr_entries.close, ignore_icode);


/* Restore the rest of the data */

		free rm_rel_info;
		rmri_ptr, rm_rel_array.rel_data.ri_ptr (tri) = null ();
	     end;
	if self_defined
	then rel_index = actual_rel_index;
	appl_ptr = save_appl_ptr;
	adpl_ptr = save_adpl_ptr;
	num_args = save_num_args;

     end restore_significant_data;



should_rollback:
     proc returns (bit (1));
	return ("0"b);
						/* MRDS currently does not do rollbacks (or windows) */
     end should_rollback;

%page;
%include dm_rel_creation_info;
%page;
%include dm_file_create_info;
%page;
%include vu_typed_vector_array;
%page;
%include dm_id_list;
%page;
%include dm_relation_index_flags;
%page;
%include mrds_dbcb;
%page;
%include mdbm_rm_db_info;
%page;
%include mrds_range;
%page;
%include mrds_select_sets;
%page;
%include mrds_select_list;
%page;
%include mrds_tuple_info;
%page;
%include mdbm_rm_rel_array;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mdbm_rm_domain_info;
%page;
%include mdbm_arg_list;
%page;
%include mdbm_rs_info;
%page;
%include mdbm_descriptor;
%page;
%include vu_typed_vector;
%page;
/* Multics subroutines */

	dcl     cu_$arg_list_ptr	 entry (ptr);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
	dcl     sys_info$max_seg_size	 ext fixed bin;


/*  DBM Routines */

	dcl     mrds_dsl_delete_se	 entry (ptr, fixed bin (35), fixed bin (35));
	dcl     mrds_dsl_translate
				 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr, ptr, fixed bin,
				 fixed bin (35));
	dcl     mu_cursor_manager_$destroy_and_free_on_opening_id entry (bit (36) aligned, ptr, ptr, entry, entry,
				 fixed bin (35));
	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
	dcl     mu_store$store_direct	 entry (ptr, ptr, ptr, fixed bin (35));

	dcl     (
	        mrds_data_$max_temp_rels,
	        mrds_data_$max_select_items,
	        mrds_data_$max_id_len
	        )			 fixed bin (35) ext;

	dcl     mrds_data_$caller_define_temp_rel fixed bin (17) ext;
	dcl     mrds_data_$max_attributes fixed bin (35) ext static;
          dcl     mrds_data_$relation_blocking_factor fixed bin (17) ext static;


	dcl     (
	        dm_error_$key_duplication,
	        mrds_error_$inval_dtr_expr,
	        mrds_error_$tuple_not_found,
	        mrds_error_$max_temp_rels,
	        mrds_error_$no_tr_keys,
	        mrds_error_$invalid_db_index
	        )			 ext fixed bin (35);

/* Based variable */

	dcl     code		 fixed bin (35) based (cd_ptr);
	dcl     database_index	 fixed bin (35) based (dbi_ptr);
	dcl     rel_index		 fixed bin (35) based (rel_index_ptr); /* Temp_rel index */
	dcl     work_area		 area based (area_ptr);

/* Pointers */

	dcl     (
	        se_ptr,				/* Points to the selection expression */
	        raip,				/* temp attr info ptr */
	        appl_ptr,				/* Points to the list of arg pointers for translate */
	        adpl_ptr,				/* Points to the list of arg descriptors for translate */
	        save_appl_ptr,			/* Copy of appl_ptr, in case of rollback */
	        save_adpl_ptr,			/* Copy of adpl_ptr, in case of rollback */
	        cd_ptr,				/* Points to callers return code */
	        rel_index_ptr,			/* Points to temp_relindex */
	        dbi_ptr
	        )			 ptr;		/* Points to the database index */


/* Others */

	dcl     (
	        nargs,				/* Number of arguments passed to this proc */
	        arg_len,
	        se_len,				/* Selection expression length */
	        tri,				/* temp rel index */
	        key_order,				/* current key attr index */
	        num_args,
	        save_num_args			/* Copy of num_args, in case of rollback */
	        )			 fixed bin;	/* Number of args passed to translate */

	dcl     icode		 fixed bin (35);	/* Internal error code */
	dcl     entry_point_name	 char (32);	/* What were we called as */
	dcl     tr_dir		 char (168);
	dcl     ntuples_retrieved	 fixed bin (35);	/* count of retrieved tuples */

	dcl     SCOPE_UPDATE	 fixed bin int static options (constant) init (6);
	dcl     TEMPORARY		 fixed bin int static options (constant) init (3);

	dcl     (any_other, cleanup, arg_error) condition;

	dcl     mrds_error_$undefined_temp_rel_index fixed bin (35) ext;
						/* index not previously defined */
	dcl     mrds_error_$dup_temp_rel_attr fixed bin (35) ext; /* non-unique attr names in relation */
	dcl     x			 fixed bin;	/* loop index for dup attr name check */
	dcl     temp_rai_ptr	 ptr;		/* temporary pointer for rm_attr_info, during dup name check */
	dcl     i			 fixed bin;	/* index for finding temporary relation index slot */
	dcl     no_recurse		 bit (1) init ("0"b); /* prevent recursive error calls to tidy up if on */
	dcl     area_ptr		 ptr;
	dcl     mu_release_area	 entry (ptr);
	dcl     mu_define_area$define_temp_dir_area entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
	dcl     mu_define_area$define_spec_temp_dir_area entry (ptr, fixed bin (35), char (11), fixed bin (35));
	dcl     a_db_index		 fixed bin (35);	/* opening index for get pop entry  */
	dcl     a_error_code	 fixed bin (35);	/* error code for get pop entry */
	dcl     temporary_relation_index fixed bin (35);	/* temp rel index desired */
	dcl     tuple_count		 fixed bin (35);	/* number of tuples in temp rel */
	declare se_len_ptr		 ptr;		/* temp for getting varying se len */
	declare se_len_ovrly	 fixed bin (35) based;
	dcl     mu_get_tuple	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     (fixed, null, ceil, addrel, bin, abs, addr, rel, substr) builtin;

	dcl     self_defined	 bit (1) init ("0"b); /* true if the temp_rel is defined in terms of itself */
	dcl     actual_rel_index	 fixed bin (35);	/* the index that the user actually supplied */
						/* This will not correspond to rel_index if the temp rel is defined in terms of itself */
	dcl     created_resultant	 bit (1);		/* During rollback, we must release a created resultant. This tells if one was made */
	dcl     dbi_pic		 picture "999";

     end mrds_dsl_define_temp_rel;
