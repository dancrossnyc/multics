/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-06-14 by Thanh
     Nguyen. (see mrds #136 and #139, phx19906)
  2) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-10-13 by John
     Hergert. (see mrds #138, phx19901)
  3) change(86-06-13,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
     install(86-08-15,MR12.0-1127):
     Added the word "aligned" to the declaration of current_scope_flags
     (mrds #155).
  4) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-05-23,Dupuis), install(88-08-01,MR12.2-1073):
     For new parser, modified the way the values of range_ptr and ti_ptr are
     set.  These values are now passed in and need not be calculated from
     ss_ptr.
                                                   END HISTORY COMMENTS */


mrds_dsl_gen_srch_prog: proc (dbcb_ptr, path_var_ptr, sv_ptr, so_ptr, code);

/* 
   BEGIN_DESCRIPTION
   This  procedure  generates the search operator tables necessary to evaluate
   an and group.  Input is the path structure produced by calc_cost and output
   is  the  search_vars and search_ops structures, which are the "program" for
   mrds_dsl_search.


   DEBUG SWITCHES:

   bit 1 - - for possible additional key searches after the  initial
   tuple  access via long key head, short key head, or indexed attr,
   use comparisons, rather than more key searches  if  this  bit  is
   one.

   bit 2 - - the opposite of bit 1, it forces  key  searches  rather
   than compares, regardless of the strategy for deciding when to do
   key searches versus compares.

   bit 3 - 9 - - - unused.
   END_DESCRIPTION

   HISTORY:

   79-02-01 J. A. Weeldreyer: Initially written.

   79-04-24 Al Kepner: Modified to initialize ti_ntuples_init.

   79-04-25  Al  Kepner: Modified to make pvp a local ptr so the corresponding
   input parameter won't get changed.

   79-05-24  Al  Kepner:  Modified  to  initialize index.mbz to "0"b and to do
   primary  initialization of move_info by setting the whole structure to zero
   in alloc_move_info.

   79-06-08 Al Kepner: Modified to use select_area.

   79-06-29  Al  Kepner:  Modified  to  provide  for comparing values within a
   single tuple.

   79-07-03  Al  Kepner:  Modified to use provide descriptors in move_info for
   use by mu_convert.

   79-09-07  Davids:  Modified  so  that move_info.t_ptr will now point to the
   structure  ind_sel_info  when move_info.encd_index = "1"b.  For the case of
   unique  index  a  ind_sel_info  structure  will  also  be allocated and the
   init_info.val_ptr   will   point   at   the  ind_sel_info.key  rather  then
   ind_sel_info.

   79-10-26   Davids:  init_info.val_ptr  will  now  point  to  the  structure
   ind_sel_info  rather than ind_sel_info.key.  Why it was not done originally
   is a good question.

   80-01-19  Davids:  key  search lists are now built only for cases were they
   can  be  used  i.e.  r,key < r.index cannot be used since there is no value
   for either key or index.

   80-02-13  Davids: internal procedure extract_attr now sets move_info.s_desc
   for  varying  attributes.   non-varying  attributes seem to work without it
   being  set so i haven't done anything about them (don't mess with a working
   system).

   80-05-07 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
   submodels were the submodel view did not contain a varying string attribute
   and the model did.

   81-05-06  Rickie  E.   Brinegar:  Modified to use the change rm_domain_info
   structure.

   81-05-22 Jim Gray : filled in descriptor information to move_info
   for  case  of  nonvarying attribute, in the extract_attr routine.
   This is needed in the case of a r1.key =  r2.key,  but  the  data
   types  differ.  Also  changed  build_ksl  to  know the difference
   between the key, and moving attr  descriptors,  and  to  force  a
   conversion type move_info, when the data types disagree.

   81-05-23 Jim Gray : commented out code referencing unsed parts of
   tuple  structure,  in  process  of  removing  them from the tuple
   structure.

   81-06-01 Jim Gray : changed to use new resultant structure,  thus
   blocked file code was deleted.

   81-06-12 Jim Gray : moved setting  of  rai_ptr  and  rdi_ptr  (to
   rm_attr_info  and rm_domain_info) inside of condition loop in the
   attr loop in the build_select_op routine. This was  done  because
   the  call  to complete_comparison_item was resetting these values
   from  the  attribute  being  comapred  against  to  one  of   the
   attributes   targeted   for  comparison.  This  caused  selection
   expressions such as -where ((r1.key = "x") & (((r1.key = r2.data)
   &  (r1.key  =  r3.data))  & (r2.data = r3.data))) to fail because
   after the keyed tuple is found, and r2's matching tuple is found,
   then two compares must be done against the one r3.data attribute,
   one for the r1.key value, and the other for the r2.data attribute
   value.  Of course if MRDS was smart, it would know it only had to
   make one of these comparisons because of  the  r1.key  =  r2.data
   clause.

   81-06-17 Jim Gray : added call to  mu_open_iocb_manager  so  that
   iocbs are obtained on an as needed basis.

   81-06-30 Jim Gray  :  changed  build_vfile_select_init_info  to  make  only  one
   init_info  for  the  case  10  <  x  < 20, so that a range on one
   attriubte could be done in one call to vfile select,  instead  of
   two.

   81-07-01 Jim Gray : modified  process_ind_hd  to  recognize  case
   when  the  first  N of M key attrs have only the "=" condition on
   them, and can thus be used as a pure key head.

   81-07-07 Jim Gray : changed  to  use  new  path_var.access_method
   encodings

   81-07-09 Jim Gray : changed logic, so  that  gen_srch_prog  could
   not  build  search  program  using  key_head  (if available) when
   permute said to use index attr instead.

   81-07-18 Jim Gray  :  changed  build_ksl  to  use  the  condition
   selected  by permute, rather than doing it's own thing. Also made
   it the only logic to do the removal of  a  key  search  condition
   from  further consideration. ALso removed routine proc_ind_hd, as
   it's job is done in permute. Renamed  the  finish_ind_hd  routine
   build_vfile_select_init_info,   and   gave   it  some  parameters
   (finish_ind_hd had none). Made separate logic  for  each  of  the
   vfile  select  access methods (long_key_head, short_key_head, and
   indexed_attr). Made each get it's  info  from  that  supplied  by
   permute,  on  which  attributes and conditions to be used for the
   access. Also  added  routine  check_for_additional_key_search  to
   find  out  if  it  is  cheaper  to do another vfile select on any
   conditions remaining against keys, or to leave  these  conditions
   to   be   handled   by   mu_compare_values,   as   specified   by
   build_select_op. Also put the  logic  for  doing  a  primary  key
   search  into  the  routine  build_vfile_seek_key_init_info. Added
   debug switch 1, to allow additional key conditions to  be  forced
   into being done via comparisons in mu_compare_values instead.

   81-07-19  Jim  Gray   :   added   logic   to   not   generate   a
   move-init-select  set of opreations for a tuple variable that has
   no effect on the select set. Previously this caused  not  in  and
   group  tuple varibles to be cross product with the results of the
   and group, even if they were not select. This way  the  user  can
   specify  if  he  wants  the  cross  product or not. Also, a tuple
   variable can particate in 1 of N and groups, not be in the select
   clause, and still not considered a no_tuple_effect T.V.

   81-07-21 Jim Gray :  added  logic  to  allow  use  of  a  permute
   specified range of values on a short key head or an indexed attr.

   81-07-22 Jim Gray :  added  a  simple  strategy  to  avoid  doing
   additional  key  searches  when  the number of primary key access
   tuples was small, thus improving performance  by  avoiding  vfile
   select  overhead  for small sets of data. The number used was put
   into a mrds data item.

   82-09-02 Mike Kubicar : added changes necessary to use the simple
   vector structure in place of the tuple structure.

   82-09-21 Davids: deleted references to file_io_array which was used
   to keep track of which solt in the rm_rel_info.iocb_ptr array an
   iocb was in. deleted the call to mu_open_iocb_manager and added a
   call to mu_cursor_manager_$get.

   82-10-01 Davids: changes to use the new search specification structure.
   This included creation of two new internal procedures.
   build_key_or_index_init_info took the place of build_vfile_seek_key_init_info
   and build_vfile_select_init_info. build_key_values_list takes the
   place of build_ksl the difference is that all conditions on the attributes
   that are part of the key are recorded and the flag is set indicating that
   the attributes have no more conditions on them. references to key_src_list
   have been removed and replaced with key_values_list. The key_values_list is
   what is actually passed to the search program, the search spec is created
   by the code that needs it.

   82-10-12 Davids: modifications so that the module will compile. Removed 
   the assignment to file_id which is no longer used. Removed from internal
   proc extract_attr references to rm_attr_info.varying which no longer
   exists. move_info.bit_move and move_info.var_move are no longer set
   in that routine. 

   82-10-25 Davids: In the internal proc alloc_init_info assigned
   init_info.val_ptr = null (). In the internal proc build_key_values_list
   assign key_values_list.fwd_ptr = null () after the structure is allocated.
   This assures that tests for null pointers will work.

   82-10-26 Davids: Modified so that long key head and short key head init
   infos correctly record their type instead of recording a type of total
   primary key. This required using the type parameter in the
   build_key_or_index_init_info internal proc that was there but not used.
   Also changed the collection_index for ordered sequential to be the rel_id
   instead of the primary_key id so that there is now no difference between
   ordered and unordered sequential (the implementation of 
   mu_sec_get_tuple$next requires the rel_id collection to be used).
   Also so that the new element in the search_vars.info structure,
   record_collection_cursor_ptr, is set. The record collection cursor is
   needed to do relation manager get_tuple_by_id calls. Both the cursor 
   pointed to by the cursor_ptr and the cursor pointed to by the 
   record_collection_cursor_ptr can be over the same tuple variable
   since the record_collection_cursor will not be used until the cursor
   has located all the tuples.

   82-10-27 Davids: changed the calls to build_key_or_index_init_info
   for the short key head  and index cases to pass a pointer to the
   array instead of the first element in the array which was incorrect.

   82-10-29 Added the assignment of move_info.bit_move and var_move
   in the internal proc extract_attr. These assignments were incorrected
   removed on 82-10-12. Since rm_attr_info.varying no longer exists a
   call to mu_data_class$varying in made instead.

   82-11-01 Davids: added code to set move_info.sbit_len in the extract_attr
   internal proc. This was inadvertenly removed eariler.

   82-11-11 Mike Kubicar: Put back code to make a distinction between ordered
   and unordered searches.  Due to a vrm_relmgr_ bug, primary key index ids
   must be used for ordered searches.

   83-02-28 Davids: explicitly declared variables that were declared by
   context of implication and removed declarations to variables that
   were never referenced.

   83-04-04 Mike Kubicar : Took out the distinction code again.  This time
   for sure.

   83-04-24 Mike Kubicar : Significant changes to the way search programs
   are generated have been added.  In addition to a comparason list,
   this module will now also generate a search specification.  This search
   spec will be given to relation manager when the searching task is being
   done.  The search spec is built by procedure "build_select_op".
   During the loop which counts the number of conditions on attributes,
   the condition is checked to see if it can be passed directly to relation
   manager.  If so, this is noted and the condition removed from the
   "attr_list" structure.  After the loop, a search spec is built in addition
   to the comparison list.  Also, since the search spec built is better than
   the one generated from key lists, "build_key_values_list" and
   "build_key_or_index_init_info" have been removed.  A search spec will
   be built which can retrieve keyed (indexed) tuples efficiently during
   a mrds_dsl_search "select" operation.

   83-05-24 R. Harvey: added the build_vectors routine which will build a
   simple_typed_vector and an id_list for each tuple variable based upon
   what is being returned to the caller and what is needed by MRDS for
   comparisons.

   83-05-31 Mike Kubicar : Updated to use the new (version 4) search spec
   and relation cursors.

   83-08-04 Mike Kubicar : Added code to set up all the element id lists
   needed by the search program.  The element_id_list_segment is evenly
   divided among all the tuple variables.

   84-07-08 Thanh Nguyen : Added code to set the c_ai_ptrs (attribute ptrs)
   of the comp_val_list.  These pointers make the rm_attr_info and then the
   rm_domain_info to be accessible for checking on the decoding of an
   attribute.

   85-01-06 Thanh Nguyen : Modified code to set the output descriptor to be
   the same as the user_desc when decode_declare is in used, and c_ai_ptrs
   for each element (of array not the entire array) in the comp_val_list.

   85-04-08 Thanh Nguyen - Added code to set the max_tids to be either 
   max_tids_returned_per_call or max_safe_tids_returned_per_call depending on 
   the scope of the relation is shared or not.

   85-06-14 Thanh Nguyen - Added code to set max_tids to be 
   max_tids_returned_per_call and not to check for the scope flags if the
   relation is temporary (rm_rel_info.file_type = 3).  Also rewrote
   the calculation method for the size of the element_id_list structure.

   85-10-13 John Hergert: Modified the fix of 84-07-08 to fix TR's phx19901
   and phx11536. This included adding code to find out that if an attribute
   that is being compared in a qualifier is being compared to an expression,
   the attribute should be decoded.
*/
%page;
	rdbi_ptr = dbcb.rdbi_ptr;			/* initialize */
	num_dims = 0;

	pvp = path_var_ptr;

	range_ptr = dbcb.range_ptr;
	ti_ptr = dbcb.ti_ptr;

	ti_ntuples_init = tuple_info.num_tuples;

	pa_ptr = null;
	select_area_ptr = dbcb.select_area_ptr;
	/* We start on a new select expression, so turn scopes_changed flag and shared mode flag off. */
	dbcb.scopes_changed = "0"b;
	dbcb.non_shared_to_shared = "0"b;


	sv_nvars_init = range.num_vars;		/* init search vars for and group */
	allocate search_vars in (select_area);		/* select_area allocs never freed. It
						   is re-init at the start of each new S.E.. */
	string (search_vars.new_val) = "0"b;

	so_nops_init = 3 * range.num_vars + 3;		/* set up search ops */
	allocate search_ops in (select_area);		/* select_area allocs never freed. It
						   is re-init at the start of each new S.E.. */

	search_ops.ic = 1;
	search_ops.nops = 1;

	search_ops.op.code (1) = PICKUP_SVP;		/* first op is to pick up search vars */
	search_ops.op.info_ptr (1) = sv_ptr;
	search_ops.op.var_ind (1) = 0;
	search_ops.op.good_xfer (1) = 1;
	search_ops.op.err_xfer = 0;

	i = 0;
	allocate pvp_array in (select_area);		/* select_area allocs never freed. It
						   is re-init at the start of each new S.E.. */
	do xp = pvp repeat xp -> path_var.fwd_thd while (xp ^= null);
	     i = i + 1;
	     pvp_array (i) = xp;			/* build array of path var ptrs */
	end;
	max_pv = i;
	next_element_id_list_ptr = dbcb.element_id_list_segment_ptr;

	do i = max_pv by -1 to 1;			/* process variables in determination order */

	     pvp = pvp_array (i);
	     vind = path_var.var_index;
	     alp = path_var.alp;
	     elp = path_var.elp;
	     rmri_ptr,
		search_vars.info.ri_ptr (vind) = range.tup_var.ri_ptr (vind); /* fill in search var info */

	     search_vars.info.ntids (vind),
		search_vars.info.ctid (vind) = 0;
	     current_max_tids_per_call = mrds_data_$max_tids_returned_per_call;
	     if rm_rel_info.file_type ^= 3 then do;
		/* file_type = 3 only when the relation is temporary */
		current_scope_ptr = rm_rel_info.scope_flags_ptr;
		if current_scopes_flags.permits.read_attr |
		   current_scopes_flags.permits.delete_tuple |
		   current_scopes_flags.permits.modify_attr then
		   if ^current_scopes_flags.prevents.modify_attr |
		     (^current_scopes_flags.prevents.append_tuple &
		      ^current_scopes_flags.prevents.delete_tuple) then
		      current_max_tids_per_call = mrds_data_$max_safe_tids_returned_per_call;
	     end;
	     search_vars.info.maxtids(vind) = current_max_tids_per_call;
	     search_vars.info.ta_ptr (vind) = next_element_id_list_ptr;
	     next_element_id_list_ptr = addrel (search_vars.info.ta_ptr (vind),
		current_max_tids_per_call + 2);	
	     /* There are two words of header in an element id list */
	     element_id_list_ptr = search_vars.info.ta_ptr (vind);
	     element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
	     element_id_list.number_of_elements = 0;

	     if path_var.in_select_clause | path_var.in_and_group then do; /* ignore un-used T.V.'s */

		     mi = search_ops.nops + 1;	/* set up the search operators */
		     ii = search_ops.nops + 2;
		     search_ops.nops,
			si = search_ops.nops + 3;

		     search_ops.op.code (mi) = MOVE;
		     search_ops.op.code (ii) = INIT;
		     search_ops.op.code (si) = SEL;
		     search_ops.op.var_ind (mi),
			search_ops.op.var_ind (ii),
			search_ops.op.var_ind (si) = vind;
		     search_ops.op.good_xfer (mi),
			search_ops.op.good_xfer (ii),
			search_ops.op.good_xfer (si) = 1;
		     search_ops.op.err_xfer (mi) = 0;
		     search_ops.op.err_xfer (ii) = -2;
		     search_ops.op.err_xfer (si) = -3;
		     search_ops.op.info_ptr (mi),
			search_ops.op.info_ptr (ii),
			search_ops.op.info_ptr (si),
			cur_mi_ptr,
			cur_ii_ptr = null;

		     go to process_var (path_var.access_method); /* go do stuff depend. on determ. method */


process_var (1):					/* total primary key */

		     j = rm_rel_info.nkey_attr;
		     aip_ptr = addr (rm_rel_info.key_attr_ptrs (1));
		     collection_index = rm_rel_info.primary_key_index_id;
		     go to cont2;

process_var (2):					/* long key head */

		     opr_ind = 0;
		     j = path_var.attr_index;		/* set number of key head attrs used */
		     aip_ptr = addr (rm_rel_info.key_attr_ptrs (1)); /* point to list of key attributes */
		     collection_index = rm_rel_info.primary_key_index_id;
		     goto cont2;

process_var (3):					/* short key head */

		     opr_ind = 0;			/* init opr insert. index */
		     j = 1;			/* only one key attribute used in a short key head */
		     collection_index = rm_rel_info.primary_key_index_id;
		     goto cont2;

process_var (4):					/* indexed attr */

		     opr_ind = 0;			/* init opr insert. index */

		     j = 1;			/* only one attr secondary key indexing allowed */
		     collection_index = rm_rel_info.attr_ptrs (path_var.attr_index) -> rm_attr_info.index_id;
		     go to cont2;



process_var (5):					/* unordered sequential */
process_var (6):					/* ordered sequential (not used) */


		     collection_index = rm_rel_info.rel_id;
		     go to cont2;

cont2:
		     call build_select_op ();
		     call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, (vind), collection_index,
			dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open,
			dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr,
			search_vars.info.relation_cursor_ptr (vind), icode);
		     if icode ^= 0
		     then call error (icode);


		end;				/* end of processing one variable */
	end;					/* loop through variables of and group */

	rvi = search_ops.nops + 1;			/* fill in last search ops */
	search_ops.nops,
	     rni = search_ops.nops + 2;
	search_ops.op.code (rvi) = RETVAL;
	search_ops.op.code (rni) = RETNUL;
	search_ops.op.var_ind (rvi),
	     search_ops.op.var_ind (rni),
	     search_ops.op.good_xfer (rni),
	     search_ops.op.err_xfer (rvi),
	     search_ops.op.err_xfer (rni) = 0;
	search_ops.op.good_xfer (rvi) = -1;
	search_ops.op.info_ptr (rvi),
	     search_ops.op.info_ptr (rni) = null;

	call build_vectors;

	code = 0;

exit:	;
	return;
%page;
build_select_op: proc;

/* Procedure to build info for select operator */

	dcl     attr_desc		 bit (36) aligned;	/* Descriptor for the attribute currently being looked at */
	dcl     attr_rai_ptr	 ptr;		/* Pointer to attribute's rm_attr_info */
	dcl     attr_rdi_ptr	 ptr;		/* Pointer to attribute's rm_domain_info */

	dcl     1 constraint_entry	 based (constraint_entry_ptr), /* Info for a condition that can be in search spec */
		2 next_entry	 ptr,		/* Next constraint in list */
		2 constraint_info,
		  3 field_id	 fixed bin,	/* Attribute's position in relation */
		  3 operator_code	 fixed bin,	/* Comparison operator */
		  3 value_ptr	 ptr,		/* Value to be compared */
		  3 value_field_id	 fixed bin,	/* Field to be compared if not zero */
		  3 mbz		 bit (18);	/* To fill out structure */
	dcl     constraint_entry_ptr	 ptr;

	dcl     1 constraint_list,			/* The list of constraint_entries */
		2 number_of_constraints fixed bin,	/* How many in list */
		2 head_of_list	 ptr;		/* The list */

          dcl     expression             bit (1);
	dcl     k			 fixed bin;	/* Loop index */
	dcl     last_cond_ptr	 ptr;		/* Last condition looked at that can't be in search spec */
	dcl     pred_data_type	 fixed bin;	/* Constant, attribute value, or expression */
	dcl     pred_desc		 bit (36) aligned;	/* Predicate data descriptor */
	dcl     pred_ptr		 ptr;		/* Pointer to the node in the predicate
						   tree that contains the operand */
	dcl     pred_var_ind	 fixed bin;	/* Tuple variable id of predicate */
	dcl     ss_possible		 bit (1);		/* True if condition can be passed to relation manager */

	allocate select_info in (select_area);		/* set up select info */ /* select_area allocs never freed. It
   is re-init at the start of each new S.E.. */
	search_ops.op.info_ptr (si) = seli_ptr;
	select_info.tuple_info_index = vind;
	select_info.tid_ptr = addr (tuple_info.tuple.tuple_id (vind));
	constraint_list.number_of_constraints = 0;
	constraint_list.head_of_list = null ();
	if elp ^= null then /* if have exprs */
	     count = expr_list.nexprs;
	else /* if no exprs */
	     count = 0;
	expression = "1"b;

/*
*
*  Now we need to run through the list of condtions on attributes.  We are
*  going to create two structures.  A search specification to be passed
*  to relation manager, and a condition list for mrds to interpret at
*  tuple select time.  It is best to give things to relation manager so
*  we'll do this whenever we can.  A condition can be used by relmgr if it
*
*  1) Is not an expression to be evaluated after the tuple is retrieved
*  2) Does not compare attributes within the tuple to be retrieved
*  3) Compares the attribute to a constant with the same type descriptor
*
*  Otherwise mrds must do the comparison.  The following loop looks for
*  conditions which meet the above criteria.  If it finds one, it adds
*  an entry to the constraint list and removes it from the condition
*  list for the attribute.  Otherwise it merely increments the count of
*  the number of items in the mrds comparison list.
*
*/

	do k = 1 to attr_list.nattr;
	     last_cond_ptr = null ();
	     do condp = attr_list.info.cond_ptr (k) repeat cond.fwd_thd
		while (condp ^= null ());
		attr_rai_ptr = rm_rel_info.attr_ptrs (attr_list.info.index (k));
		attr_rdi_ptr = attr_rai_ptr -> rm_attr_info.domain_ptr;
		attr_desc = attr_rdi_ptr -> rm_domain_info.db_desc;
		pred_ptr = cond.pl_ptr;
		pred_var_ind = fixed (pred_ptr -> pred_leaf.id.var_id);
		pred_data_type = pred_ptr -> pred_leaf.data_type;
		if pred_data_type = EXPRES		/* Compare to an expression? */
		then ss_possible = "0"b;
		else do;
			if pred_data_type = CONST	/* Compare to constant? */
			then pred_desc = pred_ptr -> pred_leaf.lit_desc_ptr -> bit36a;
			else if pred_data_type = ATTR /* Compare to another attribute */
			then pred_desc = pred_ptr -> pred_leaf.ai_ptr ->
				rm_attr_info.domain_ptr -> rm_domain_info.db_desc;
			else call sub_err_ (mrds_error_$internal_error,
				MODULE_NAME, "s", null (), 0,
				"A predicate was found which is neither a constant, attribute, or expression.");
			ss_possible = (pred_desc = attr_desc)
			     & (pred_var_ind ^= vind);
		     end;
		if ^ss_possible then do;
			count = count + 1;
			last_cond_ptr = condp;	/* The last condition looked at that can't be passed to relmgr */

/*			range.tup_var (vind).needed_bits.attr (attr_rai_ptr -> rm_attr_info.defn_order) = "1"b; */
		     end;
		else do;

/* Add the condition to the constraint list */

			allocate constraint_entry in (select_area);
			constraint_entry.constraint_info.field_id =
			     attr_rai_ptr -> rm_attr_info.model_defn_order;
			if cond.op_code = OTT_EQ
			then constraint_entry.constraint_info.operator_code
				= EQUAL_OPERATOR_CODE;
			else if cond.op_code = OTT_NE
			then constraint_entry.constraint_info.operator_code
				= NOT_EQUAL_OPERATOR_CODE;
			else if cond.op_code = OTT_LT
			then constraint_entry.constraint_info.operator_code
				= LESS_OPERATOR_CODE;
			else if cond.op_code = OTT_LE
			then constraint_entry.constraint_info.operator_code
				= LESS_OR_EQUAL_OPERATOR_CODE;
			else if cond.op_code = OTT_GT
			then constraint_entry.constraint_info.operator_code
				= GREATER_OPERATOR_CODE;
			else if cond.op_code = OTT_GE
			then constraint_entry.constraint_info.operator_code
				= GREATER_OR_EQUAL_OPERATOR_CODE;
			else call sub_err_ (mrds_error_$internal_error,
				MODULE_NAME, "s", null (), 0,
				"An unknown comparison operator was found in an attribute's condition list.");
			if pred_data_type = CONST
			then constraint_entry.constraint_info.value_ptr
				= pred_ptr -> pred_leaf.lit_ptr;
			else do;

/*				range.tup_var (pred_var_ind).needed_bits.attr (fixed (pred_ptr -> pred_leaf.id.attr_id)) = "1"b; */
				call extract_attr (pred_var_ind,
				     pred_ptr -> pred_leaf.ai_ptr);
				constraint_entry.constraint_info.value_ptr
				     = move_info.t_ptr;
			     end;
			constraint_entry.value_field_id = 0;
			constraint_entry.mbz = "0"b;
			constraint_list.number_of_constraints
			     = constraint_list.number_of_constraints + 1;
			constraint_entry.next_entry =
			     constraint_list.head_of_list;
			constraint_list.head_of_list = constraint_entry_ptr;


/* Now splice the condition out of the condition list for the attribute */

			if last_cond_ptr = null ()	/* Delete head of list */
			then attr_list.info (k).cond_ptr = cond.fwd_thd;
			else last_cond_ptr -> cond.fwd_thd = cond.fwd_thd;
		     end;
	     end;
	end;


/* Now build the search specification */


	rss_maximum_number_of_constraints = constraint_list.number_of_constraints;
	if rss_maximum_number_of_constraints = 0
	then rss_number_of_and_groups = 0;
	else rss_number_of_and_groups = 1;
	allocate relation_search_specification in (select_area);
	relation_search_specification.head.version = SPECIFICATION_VERSION_4;
	relation_search_specification.head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE;
	relation_search_specification.head.pad = "0"b;
	relation_search_specification.head.subset_specification_ptr = null ();
	relation_search_specification.maximum_number_of_constraints =
	     rss_maximum_number_of_constraints;
	relation_search_specification.number_of_and_groups =
	     rss_number_of_and_groups;
	relation_search_specification.flags.return_unique_tuples = "0"b;
	relation_search_specification.flags.mbz = "0"b;
	relation_search_specification.range.type = LOW_RANGE_TYPE;
	relation_search_specification.range.size = current_max_tids_per_call;
	relation_search_specification.and_group (1).number_of_constraints =
	     rss_maximum_number_of_constraints;
	relation_search_specification.and_group (1).flags
	     .collection_id_supplied = "1"b;
	relation_search_specification.and_group (1).flags.mbz = "0"b;
	relation_search_specification.and_group (1).search_collection_id =
	     collection_index;
	constraint_entry_ptr = constraint_list.head_of_list;


/*
*
*   Now fill in the constraint list.  Note that if there is nothing in
*   the constraint list, the search spec generated will be for every
*   tuple in the relation.
*
*/

	do k = 1 to constraint_list.number_of_constraints;
	     relation_search_specification.and_group (1).constraint (k) =
		constraint_entry.constraint_info, by name;
	     constraint_entry_ptr = constraint_entry.next_entry;
	end;
	select_info.relation_search_specification_ptr = relation_search_specification_ptr;


/* Now build the comparison array */

	if count = 0 then
	     select_info.cvla_ptr = null;		/* no conditions, select everything in range */
	else do;					/* must build comp val array */

		cvla_nlists_init = 1;		/* Will be greater if we allow ors */
		allocate cvl_array in (select_area);	/* select_area allocs never freed. It
						   is re-init at the start of each new S.E.. */
		select_info.cvla_ptr = cvla_ptr;
		cvl_nvals_init = count;		/* build comp val list */
		call alloc_comp_val_list;
		cvl_array.list_ptr (1) = cvl_ptr;
		nv = 0;				/* init. val counter */
		comp_val_list.rel_id = rm_rel_info.rel_id;
%page;
		do k = 1 to attr_list.nattr;		/* find remaining conditions in attr list */

		     if attr_list.info.cond_ptr (k) ^= null then do;
			     do condp = attr_list.info.cond_ptr (k) repeat cond.fwd_thd while (condp ^= null);

				rai_ptr = rm_rel_info.attr_ptrs (attr_list.info.index (k));
				rdi_ptr = rm_attr_info.domain_ptr;

				nv = nv + 1;	/* incr. val counter */
				comp_val_list.val.attr_ind (nv) = attr_list.info.index (k);
				comp_val_list.val.op (nv) = cond.op_code;
				comp_val_list.val.exp_ptr (nv),
				     comp_val_list.val.erslt_ptr (nv) = null;
				comp_val_list.val.desc1 (nv) = rm_domain_info.db_desc;
				pl_ptr = cond.pl_ptr; /* go process the operand */
				comparison_var_id = fixed (pred_leaf.id.var_id);
				compare_within_tuple = (comparison_var_id = vind);

				call complete_comparison_item (pred_leaf.data_type, compare_within_tuple, ^expression);
			     end;			/* loop through conditions */
			end;			/* if attr referenced and not used */
		end;				/* loop through attr list */
%page;
		if elp ^= null then /* have expressions to look at */

		     do k = 1 to expr_list.nexprs;

			pl_ptr = expr_list.info.epl_ptr (k);
			nv = nv + 1;
			comp_val_list.val.op (nv) = expr_list.info.op_code (k);
			comp_val_list.val.exp_ptr (nv) = pred_leaf.expr_ptr;
			comp_val_list.val.erslt_ptr (nv) = pred_leaf.lit_ptr;
			comp_val_list.val.desc1 (nv) = pred_leaf.rslt_desc;

			pl_ptr = expr_list.info.pl_ptr (k); /* go process the comparand */
			comparison_var_id = fixed (pred_leaf.id.var_id);
			compare_within_tuple = (comparison_var_id = vind);
			call complete_comparison_item (pred_leaf.data_type, compare_within_tuple, expression);
		     end;				/* loop through exprs */
	     end;					/* building comp val array */

     end build_select_op;
%page;
complete_comparison_item: proc (data_type, compare_within_tuple, expr_caller_sw);
	dcl     data_type		 fixed bin parm;	/* INPUT: 1 => constant
						   2 => attribute
						   3 => expression */
	dcl     compare_within_tuple	 bit (1) parm;	/* INPUT: ON => both items to be compared
						   depend on the same tuple. */
          dcl     expr_caller_sw          bit (1) parm;     /* INPUT: ON => called when evaluating exprsession */


/*	if data_type = ATTR
	then range.tup_var (fixed (pred_leaf.id.var_id)).needed_bits.attr (fixed (pred_leaf.id.attr_id)) = "1"b;
	else if data_type = EXPR
	then range.tup_var (fixed (pred_leaf.id.var_id)).whole_tuple_selected = "1"b;
*/
          comp_val_list.c_ai_ptr2(nv) = null;

	if ^compare_within_tuple then do;
		go to between_tuples (data_type);

between_tuples (1): ;				/* constant */
		comp_val_list.val.match_ptr (nv) =
		     pred_leaf.lit_ptr;
		comp_val_list.val.desc2 (nv) =
		     pred_leaf.lit_desc_ptr -> bit36a;
		go to end_between_tuples;

between_tuples (2): ;				/* attr. in db. */
		call extract_attr (fixed (pred_leaf.id.var_id), pred_leaf.ai_ptr);
		comp_val_list.val.match_ptr (nv) =
		     move_info.t_ptr;
		rai_ptr = pred_leaf.ai_ptr;
		rdi_ptr = rm_attr_info.domain_ptr;

		comp_val_list.val.desc2 (nv) = rm_domain_info.db_desc;
		comp_val_list.val.attr_ind2 (nv) = fixed (pred_leaf.id.attr_id);
		go to end_between_tuples;

between_tuples (3): ;				/* expressions */
		call make_eval_expr_mi (pred_leaf.expr_ptr, (fixed (pred_leaf.id.var_id)),
		     fixed (pred_leaf.id.var_id));
		comp_val_list.val.match_ptr (nv) =
		     pred_leaf.lit_ptr;
		comp_val_list.val.desc2 (nv) = pred_leaf.lit_desc_ptr -> bit36a;
		go to end_between_tuples;
end_between_tuples: ;
	     end;					/* between_tuples */
	else do;					/* within_tuple */
		go to within_tuple (data_type);
within_tuple (1):	;				/* constant */
						/* This case should not occur because a constant
						   does not depend on values out of a tuple. */

		go to between_tuples (1);

within_tuple (2):	;				/* attr. in db. */
		comp_val_list.val.attr_ind2 (nv) = fixed (pred_leaf.id.attr_id);
		call prepare_attr_cvl (expr_caller_sw);
		go to end_within_tuple;

within_tuple (3):	;				/* expressions */
		call prepare_expr_cvl;
		go to end_within_tuple;
end_within_tuple:	;
	     end;					/* within_tuple */

     end complete_comparison_item;
%page;
prepare_expr_cvl: proc;

/* This routine sets up values in the comp_val_list
   when the second item to be compared is an expression
   and both values to be compared are from the same tuple. */
	comp_val_list.val.desc2 (nv) = pred_leaf.lit_desc_ptr -> bit36a;
	comp_val_list.val.exp_ptr2 (nv) = pred_leaf.expr_ptr;
	comp_val_list.val.erslt_ptr2 (nv) = pred_leaf.lit_ptr;
     end prepare_expr_cvl;
%page;
prepare_attr_cvl: proc (expr_sw);

dcl expr_sw bit(1) parm; /* indicates that first attribute is an expression. That
	             means this value must be decoded. */

/* This routine sets up values in the comp_val_list
   when the second item to be compared is a db attribute
   and both values to be compared are from the same tuple. */
	rai_ptr = pred_leaf.ai_ptr;
	rdi_ptr = rm_attr_info.domain_ptr;
	if expr_sw then do;  /* must decode to compare */
	     comp_val_list.c_ai_ptr2 (nv) = pred_leaf.ai_ptr;
	     comp_val_list.val.desc2 (nv) = rm_domain_info.user_desc;
	end;
	else /* can compare internally */
	     comp_val_list.val.desc2 (nv) = rm_domain_info.db_desc;

     end prepare_attr_cvl;
%page;
alloc_comp_val_list: proc;

/* Allocate comp_val_list structure and peform a partial initialization. */
	allocate comp_val_list in (select_area);	/* select_area allocs never freed. It
						   is reinitialized for each new selection expression. */
	unspec (comp_val_list.val) = "0"b;
	do i = 1 to cvl_nvals_init;
	     match_ptr,
		comp_val_list.val (i).exp_ptr,
		comp_val_list.val (i).exp_ptr2,
		comp_val_list.val (i).erslt_ptr2,
		comp_val_list.val (i).erslt_ptr = null ();
	end;					/* loop thru comp_val_list.val */
	dcl     i			 fixed bin;
     end alloc_comp_val_list;
%page;
alloc_move_info: proc;

/* Procedure to allocate and link in a move info structure */

	allocate move_info in (select_area);		/* select_area allocs never freed. It
						   is re-init at the start of each new S.E.. */
	if cur_mi_ptr = null then /* if first */
	     search_ops.op.info_ptr (mi) = mi_ptr;
	else cur_mi_ptr -> move_info.fwd_thd = mi_ptr;
	unspec (move_info) = "0"b;
	move_info.fwd_thd = null;
	move_info.s_ptr,
	     move_info.t_ptr = null ();
	cur_mi_ptr = mi_ptr;

     end alloc_move_info;
%page;
extract_attr: proc (var_ind, raip);

/* procedure to set up a move info to extract an attribute value from
   a tuple and place it in the literal pool, stored in accordance with Multics
   data type standards. */

	dcl     raip		 ptr;
	dcl     var_ind		 fixed bin;

	rdi_ptr = raip -> rm_attr_info.domain_ptr;
	call alloc_move_info;
	call alloc_lit (addr (rm_domain_info.db_desc),
	     move_info.t_ptr, move_info.tbit_len);
	move_info.extr_attr = "1"b;
	move_info.bit_move = ^(mu_data_class$varying (
	     addr (raip -> rm_attr_info.domain_ptr -> rm_domain_info.db_desc)));
	move_info.var_move = ^move_info.bit_move;
	move_info.var_ind = var_ind;
	move_info.sbit_len = raip -> rm_attr_info.bit_length;
	move_info.s_desc = rm_domain_info.db_desc;
	move_info.tuple_var_index = var_ind;
	move_info.tuple_attr_index = raip -> rm_attr_info.defn_order;
     end extract_attr;
%page;
make_eval_expr_mi: proc (ep, tp, vi);

/* procedure to make a move_info to evaluate an expression */

	dcl     ep		 ptr;
	dcl     tp		 fixed bin;
	dcl     vi		 fixed bin;

	call alloc_move_info;
	move_info.expr = "1"b;
	move_info.s_ptr = ep;
	move_info.tuple_var_index = tp;
	move_info.var_ind = vi;

     end make_eval_expr_mi;
%page;
alloc_lit: proc (ldp, lp, lbl);

/* Procedure to allocate a literal in the literal pool */

	dcl     lbl		 fixed bin (35);
	dcl     (ldp, lp)		 ptr;

	li.encd_proc = "0"b;
	li.src_ptr,
	     li.srcd_ptr,
	     li.encdd_ptr = null;
	li.litd_ptr = ldp;
	li.encd_blen = 0;
	call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), icode);
	if icode ^= 0 then call error (icode);
	lbl = li.lit_blen;
	lp = li.lit_ptr;

     end alloc_lit;
%page; build_vectors: proc;

/* Here is where we build the 'shortened' simple_typed_vector for each tuple variable.
   If the whole tuple has been selected, the 'whole' one in the resultant is used. */

	do i = 1 to range.num_vars;
	     bv_stv_ptr = tuple_info.tuple (i).tuple_ptr; /* simple_typed_veector for whole 'view' */
	     bv_ri_ptr = range.tup_var (i).ri_ptr;	/* rm_rel_info ptr */
	     bv_idl_ptr = bv_ri_ptr -> rm_rel_info.id_list_ptr; /* id_list for whole 'view' */
	     if range.tup_var (i).whole_tuple_selected
	     then do;				/* just grab what's already available */
		     range.tup_var (i).stv_ptr = bv_stv_ptr;
		     range.tup_var (i).idl_ptr = bv_idl_ptr;
		end;
	     else do;				/* Build a simple_typed_vector and an id_list */
		     il_number_of_ids = bv_ri_ptr -> rm_rel_info.num_attr; /* Build it oversize */
		     allocate id_list in (select_area) set (id_list_ptr);
		     id_list.version = ID_LIST_VERSION_1;
		     range.tup_var (i).idl_ptr = id_list_ptr;

		     id_list.number_of_ids = 0;
		     do k = 1 to il_number_of_ids;
			if range.tup_var (i).needed_bits.attr (k)
			then do;			/* get the proper id for relation */
				id_list.number_of_ids = id_list.number_of_ids + 1;
				id_list.id (id_list.number_of_ids) = bv_idl_ptr -> id_list.id (k);
			     end;
		     end;
		     if id_list.number_of_ids ^= 0
		     then do;
			     stv_number_of_dimensions = id_list.number_of_ids;
			     allocate simple_typed_vector in (select_area) set (simple_typed_vector_ptr);
			     simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
			     range.tup_var (i).stv_ptr = simple_typed_vector_ptr;

			     stv_number_of_dimensions = 0; /* use for walking through the vector */
			     do k = 1 to il_number_of_ids; /* walk the WHOLE relation */
				if range.tup_var (i).needed_bits.attr (k)
				then do;
					stv_number_of_dimensions = stv_number_of_dimensions + 1;
					simple_typed_vector.dimension (stv_number_of_dimensions).value_ptr =
					     bv_stv_ptr -> simple_typed_vector.dimension (k).value_ptr;
				     end;
			     end;
			end;			/* ids to move */
		     else do;			/* no ids to move */
			     range.tup_var (i).stv_ptr = null ();
			end;
		end;				/* build simple_typec_vector */
	end;					/* walk through tuple vars */


	dcl     bv_idl_ptr		 ptr;
	dcl     bv_stv_ptr		 ptr;
	dcl     bv_ri_ptr		 ptr;
	dcl     i			 fixed bin;
	dcl     k			 fixed bin;

     end build_vectors;
%page;
error: proc (cd);

/* Error Procedure */

	dcl     cd		 fixed bin (35);

	code = cd;
	go to exit;

     end error;
%page;
	dcl     path_var_ptr	 ptr parm;	/* Input: ptr to path through tuple variables */
	dcl     (xp,				/* work ptr */
	        pa_ptr,				/* to pvp_array */
	        cur_ii_ptr,				/* current pointers for alloc routines */
	        cur_mi_ptr,
                  next_element_id_list_ptr,
	        aip_ptr)		 ptr;		/* to array of attr info ptrs */

	dcl     (code,				/* Output:  status code */
	        icode)		 fixed bin (35);	/* internal status code */

	dcl     (i, j,				/* internal indexes */
	        vind,				/* current var index */
	        ii, mi, si, rni, rvi,			/* indexes into search ops */
	        opr_ind,				/* index to indicate when to add inter op. */
	        count,				/* counter */
	        nv,
	        max_pv)		 fixed bin;	/* highest path var */



	dcl     1 ed		 aligned,		/* encode descriptor */
		2 const		 bit (12) init ("101011000000"b) unal,
		2 len		 fixed bin (23) unal;

	dcl     rotate_ops		 (6) fixed bin init (1, 2, 5, 6, 3, 4); /* used to rotate inequalities
						   rotate_ops(1) =>  = becomes  =
						   rotate_ops(2) => ^= becomes ^=
						   rotate_ops(3) =>  < becomes  >
						   rotate_ops(4) => <= becomes >=
						   rotate_ops(5) =>  > becomes  <
						   rotate_ops(6) => >= becomes <= */
	dcl     pvp_array		 (sv_nvars_init) ptr based (pa_ptr);
	dcl     1 li		 aligned like lit_info;
	dcl     1 current_scopes_flags aligned based (current_scope_ptr) like scope_flags;
          dcl     current_scope_ptr      ptr;

	dcl     (mrds_data_$max_attributes,
	        mrds_data_$max_id_len,
	        mrds_data_$max_safe_tids_returned_per_call,
	        mrds_data_$max_tids_returned_per_call,
	        mrds_data_$max_select_items) ext fixed bin (35);

	dcl     (addr,
                   addrel,
	        fixed,
	        null,
	        rel,
	        string,
	        unspec)		 builtin;

	dcl     bit36a		 bit (36) aligned based;
	dcl     MODULE_NAME		 char (22) init ("mrds_dsl_gen_srch_prog");
	dcl     mrds_dsl_make_literal$alloc entry (ptr, ptr, fixed bin (35));
	dcl     mrds_error_$internal_error fixed bin (35) ext static;
	dcl     comparison_var_id	 fixed bin;	/* Index of tuple variable for second comparison value of zero. */
	dcl     compare_within_tuple	 bit (1);		/* 1 => both comparison values depend on the
						   same tuple. */
	dcl     collection_index	 bit (36) aligned;	/* index of the collection to be searched */
	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr,
				 ptr, ptr, fixed bin (35));
	dcl     mu_data_class$varying	 entry (ptr) returns (bit (1) aligned);
	dcl     sub_err_		 entry () options (variable);
	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
	dcl     current_max_tids_per_call fixed bin (35);
%page;
%include mdbm_scope_info;
%page;
%include dm_element_id_list;
%page;
%include dm_operator_constants;
%page;
%include dm_range_constants;
%page;
%include dm_relation_spec;
%page;
%include dm_specification_head;
%page;
%include vu_typed_vector;
%page;
%include dm_id_list;
%page;
%include mrds_dbcb;
%page;
%include mrds_predicate_tree;
%page;
%include mrds_optimize_tables;
%page;
%include mrds_search_ops;
%page;
%include mrds_search_vars;
%page;
%include mrds_range;
%page;
%include mrds_tuple_info;
%page;
%include mrds_lit_info;
%page;
%include mrds_expressions;
%page;
%include mdbm_rm_db_info;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mdbm_rm_domain_info;
%page;
%include mdbm_index;
%page;
%include mdbm_rtrv_info;
%page;
%include mdbm_ind_sel_info;
%page;
%include mdbm_comp_val_list;
%page;
%include mdbm_descriptor;
%page;
%include mdbm_seg_area;
%page;
%include mrds_select_area;
%page;
%include mrds_debug_names;

     end mrds_dsl_gen_srch_prog;
