/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
     For new parser, modified the way that the range and select list pointers
     are set.
                                                   END HISTORY COMMENTS */



mrds_dsl_permute:
     proc (dbcb_ptr, ag_ptr, pvp, cost, code);
%page;
/*
   BEGIN_DESCRIPTION
   INPUT:

   dbcb_ptr  -  points to a valid dbcb in which dbcb.pred_ptr points to a valid
   predicate  tree.

   ag_ptr - points to an and_group list to be used in finding a search path.



   OUTPUT:

   pvp  -  points  to  a  search  path  with  the last variable being the first
   variable in the list.

   cost - the calculated cost of this search path.

   code - may be 0 or any of the codes returned by mu_get_rel_size.
   END_DESCRIPTION


   MRDS_DEBUG_TOOL SWITCH DEFINITIONS:

   bit 1 = display each new low cost path as it is determinied.

   bit 2 = display each permutation step.

   bit 3 = use the path defined by the order of the range clause.

   bit 4 = display the access method cost calculation details

   bit 5 = display details of final lowest cost path

   bits 6 thru 9 = not used.

   NOTES for mrds_debug_tool

   bit 1 displays paths  starting  with  the  last  variable  to  be
   determined   and  working  back  to  the  first  variable  to  be
   determined.

   bit 2 displays partial paths starting with the first path  to  be
   determined  and  working  forward to the variable currently being
   looked at.

   bit 3 causes the order of the range clause to be use as the order
   of  searching  of  relations  for tuples satisfying the selection
   expression when it is turned on.

   bit 4 causes the results of the calc_sub_path_cost subroutine  to
   be  output.  This includes the cost of doing each type of useable
   access method, plus the low cost access method chosen,  and  it's
   resulting partial path cost.

   bit 5 causes the details of all the conditions, and  details  for
   the  final  path  determined  as  the  lowest  cost  path  to  be
   displayed.




   HISTORY:

   79-10-01 Rickie E.  Brinegar: Initially written using large portions of code
   from mrds_dsl_calc_cost.

   79-12-01  Rickie  E.  Brinegar: Modified to handle the case where the number
   of  variables in the range clause is greater than the number of variables in
   the and group.

   79-12-10  Rickie  E.   Brinegar:  Modified to make the proper transfers when
   using rev_ops.

   79-12-11  Rickie  E.   Brinegar:  Modified to make proper use of the op_code
   variable when adding a condition to a range variable list.

   80-01-14  Rickie  E.  Brinegar: Modified to keep conditions on attributes in
   the same relation.

   80-01-18  Rickie E.  Brinegar: Modified to look at all the conditions on the
   primary key when deciding if short_key may be used.

   80-01-23  Rickie  E.   Brinegar:  Modified  to properly determine sequential
   paths for tuple variables not found in the and group.

   80-01-25  Rickie  E.   Brinegar:  Modified to add the range variables not in
   this and group to the end of the search path as a sequential search.

   80-02-08  Rickie  E.   Brinegar:  Modified  to  properly  determine  when  a
   expression should be evaluated in a search path.

   80-02-09  Jim  Gray:  Modified  to  remove  bad  coding  in  while clause of
   add_to_attr_list,  so  that both a null ptr, and a structure value depending
   on that value on not in the same if statement.

   80-02-11  Rickie E.  Brinegar: Modified to correct the same problem that Jim
   Gray corrected, only through out the rest of the code.

   80-07-08  Rickie  E.  Brinegar: Modified to add the ability to generate only
   the  search  path defined by the order of the attributes in the range clause
   of the selection expresssion.  This is done by setting mrds_debug_switch bit
   3.

   80-08-14  Davids: answered tr7173 fixed as suggested in tr.  problem occured
   when  mrds  reversed  the order of A op B as it appeared in the where clause
   and  B  was  an expression.  Operator sense was reversed ok but it was still
   connected to A rather than B.

   80-10-17   Rickie   E.   Brinegar:  Modified  add_to_expr_list  to  properly
   subscript expr_list.info.op_code.  This was in response to TR7908.

   81-01-13  Rickie  E.   Brinegar: Modified to reuse the structures allocated.
   These include path_var, attr_list, expr_list, cond.  This was in response to
   TR8567.

   81-02-24  Rickie E.  Brinegar: Commented out the calling of code that has to
   do only with blocked file structures.

   81-03-27 Jim Gray : added dbcb_ptr parameter  to  mu_get_rel_size
   as part of getting rid of mus_ptr_man module.

   81-06-01 Jim Gray : changed to use new resultant structure,  thus
   blocked file code deleted.

   81-06-29 Roger Lackey : added the use of dbcb.no_optimize flag q

   81-07-02 Jim Gray : changed getting of relation tuple count  from
   a  call to mu_get_rel_size, to getting it from the statistics now
   kept in the rm_rel_info structure for that relation.

   81-07-07 Jim Gray : made changes to allow correct calculation  of
   path cost, done via multiplying number of times that a particular
   I/O cost will be incurred. These changes  involved:  1)  re-write
   calc_sub_path_cost  to  take into account the currently available
   access methods, compute the expected number of  tuples  retrieved
   for that access method, compute the access cost based on times it
   will be incurred 2) change the  interface  to  what  used  to  be
   unique_index  (now  long_key)  and index_range (now short_key) to
   allow needed info to be passed back, this included  the  addition
   of  recognition  of  long key head access. 3) added the unordered
   sequential type of access method  4)  changed  the  interface  to
   find_attributes   and   permutations   to  include  a  multiplier
   paramater, to be used in properly calculating sub_path  costs  5)
   Changed handling of not_in_and_group tuple variables, so that the
   implied cross  product  is  done  in  the  fastest  manner.  This
   involves  forcing a sequential access method for not in and_group
   tuple variables, and considering them just  as  the  other  tuple
   variables  are.  6)  Also added many comments to help clarify the
   logic and purpose of the major internal procedures. 7) Added  the
   debug   switch   4,   to  display  the  results  of  the  changed
   calc_sub_path_cost routine. 8) added count_conditions subroutine,
   and changes to long_key/short_key to take into account the number
   of conditions, and the condition types, in estimating the  number
   of tuples selected by an access method.

   81-07-14 Jim Gray : made  some  adjustments  to  the  changes  of
   07-07.   1)  expanded  the  long_key  subroutine  to  allow  >  1
   condition, along with the = conditions for primary keys, and  key
   heads,  and  renamed  the routine equal_key. 2) changed short_key
   not to have to consider  the  =  condition,  now  that  equal_key
   handles  1st key attr for this case 3) improved the info returned
   for the condition against a tuple variable, or a particular  key.
   4)  improved  the  formulas  for  conditions  costing, and tuples
   selected 5) changed the key head formula to the exponential  form
   for  better behavior close to a fraction of 1/1. 6) added info to
   path_var structure to  force  gen_srch_prog  to  use  the  access
   method chosen by permute

   81-07-16 Jim Gray : had to modify copy_attr_list to  put  pointer
   to new copy of the cond structure in the path_var, now that it is
   saved there in order to pass info to gen_srch_prog.

   81-07-17 Jim Gray : added a debug switch option  to  display  all
   the  details  for  the final lowest cost path found. Also changed
   logic dealing with attr_list entries, so that array elements  are
   addressed on an attribute definition order basis.

   81-07-18 Jim Gray : removed logic referring to  cost  =  0  as  a
   control  in  the  permutations  program.  This  was  done for two
   reasons. First this control was part of the old not in and  group
   logic  that  was thrown away, and second, the most efficient path
   was not being found for the case of one of  the  tuple  variables
   having a zero population. In the last case the 0 tuple rel should
   go first always, and result in an and  group  cost  of  0.0  Also
   changed  calc_sub_path_cost  to not do un-needed work in the case
   of unpopulated relations.

   81-07-19 Jim Gray : added logic to handle tuple variables with no
   effect   on  the  select  set.  They  are  dropped  from  further
   consideration in the low cost path, but passed back  to  optimize
   for further no tuple effect checks.

   81-07-21 Jim Gray : added the ability to favor a range of  values
   specified  against  a  short  key  head  or  indexed attr, and to
   remember the details for gen srch prog.

   81-08-03 Jim Gray : fixed problem introduced by last change,  the
   =  condition was not being favored over >, <=, etc. conditions if
   it came first in the condition list.

   81-09-21  Rickie  E.   Brinegar:  Changed  the  assignment of two expr_list
   structures  to  each  other  to  be done using an unspec to avoid subscript
   ranged conditions.

   82-06-04 Mike Kubicar : Added fix for TR phx12306.  The problem was
   that permute would sometimes change its mind in the middle of a
   selection's where clause and decide that an equals comparison is better
   than the range one it was working on.  Unfortunately, it would not
   completely change it's internal representation to reflect this fact.

   82-07-20 Ronald B. Harvey: Made fix for TR phx12925. This involved fixing
   an improperly constructed do statement in get_attr_list. A test could not
   be generated, but it was clear that the statement was in error.

   82-09-16 Davids: Modified the way that the best condition for an indexed
                    attribute is choosen, created the find_index_attr internal
                    procedure. This takes into account not only the precedence
                    order of the equal, range, inequality and not-equal
                    operations but the number of duplicates for each index
                    (obtained from rm_attr_info.number_of_dups). The one with
                    the fewest duplicates will be chosen, if two or more have
                    the same number of dups the one defined first within the
                    relation will be chosen. Note that the number of dups for
                    a vfile type database is an estimate and equal for all
                    of the indices.

                    Modified the internal proc calc_sub_path_cost tono longer
                    assume the equal distribution of dups throughout all
                    indices in a relation but to use the number of dups 
                    returned from the call to the internal proc short_key
                    (which ends up calling find_index_attr).

                    Removed references to the constant cost values for the
                    different access methods and replaced them with references
                    to elements in the dbcb structure. Costs will be dependent
                    on the type of database, i.e. vfile or page_file.

82-12-15  Davids:  Modified the copy_expr_list procedure by explicitly setting
the  number  of expressions in the copy_to_ptr -> path_var.elp -> expr_list to
the original number it was allocated with.  The number of expressions recorded
is reduced from the number the structure was allocated with since the original
number is based on a maximum possible number while the number in the structure
is  the  actual number of expressions.  This was needed because it is possible
to  get  a  string  size  condition  when  different and-groups have different
numbers  of  expressions  and  the  expr_list  structures and being copied and
re-used.  Fixes TR 14382

   83-04-04 Mike Kubicar : Removed code to generate an unordered sequential
   search.  vfile_relmgr_ can now handle all searches on a record collection
   cursor correctly.

   83-10-01 Bert Moberg: Added code to the permutations subroutine to not
   try all possible permutations if the number of tuple variables is very
   large (=> ENOUGH_TUPLE_VARIABLES_TO_NOT_TRY_ALL_POSSIBLE_PERMUTATIONS,
   currently = 5).  The current path must be predicted to select <= 1 tuple
   (<= PATH_DOES_NOT_EXPAND) at every level where permutations are skipped.
   If this true, it implies that the exact order is not as important, since
   the levels will be executed the same number of times.  In all cases, all
   permutations will be tried for the first
   NUMBER_OF_LEVELS_THAT_MUST_BE_PERMUTED (currently 2).

83-10-24 Roger Lackey : Changed the dcl for index_attr_number_of_dups from 
                        fixed bin to fixed bin (35).
*/
%page;
%include mrds_dbcb;
%page;
%include mrds_range;
%page;
%include mrds_predicate_tree;
%page;
%include mrds_optimize_tables;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_attr_info;
%page;
%include mdbm_seg_area;
%page;
%include mrds_select_area;
%page;
%include mrds_debug_names;
%page;
	dcl     (m_d_p_i, level, number_of_variables) fixed bin;

	dcl     (cost, current_path_cost) float bin (63);

	dcl     (display_low_cost_paths, display_path_permutations,
	        display_access_method_costs, use_range_order) bit (1) unal;

	dcl     (
	        attr_list_free_ptr	 init (null),
	        cond_free_ptr	 init (null),
	        current_path_ptr	 init (null),
	        expr_list_free_ptr	 init (null),
	        last_condp		 init (null),
	        low_cost_path_ptr	 init (null),
	        path_ptr		 init (null),
	        path_var_free_ptr	 init (null),
	        range_order_path_ptr	 init (null),
	        work_path_ptr	 init (null),
	        work_ptr		 init (null)
	        )			 ptr;

	dcl     (
	        mrds_data_$max_attributes,
	        mrds_data_$max_id_len,
	        mrds_data_$max_tup_var,
	        sys_info$max_seg_size
	        )			 fixed bin (35) ext;

	dcl     code		 fixed bin (35);

	dcl     variable_array	 (mrds_data_$max_tup_var) fixed bin;

	dcl     (addr, ceil, fixed, max, null, rel, substr, unspec) builtin;

	dcl     ioa_		 entry options (variable);
	dcl     mdb_display_path_$path entry (ptr, ptr);

	dcl     (temp_current_path_multiplier, current_path_multiplier) float bin (63);
						/* number ot times access cost will be incurred */
	dcl     finished		 bit (1);		/* on => end of generating all permutations */
	dcl     CONDITION_COST_FACTOR	 (1:6) float bin (27) init (1.5, 0.2, (4) (0.5));
						/* weighting for "=", "^=", and other comparisons */
	dcl     condition_array	 (1:6) char (2) init ("=", "^=", "<", "<=", ">", ">=")
				 int static options (constant); /* char values for displaying condition operators */
	dcl     access_method_name	 (1:6) char (20) int static options (constant)
				 init ("Total primary key", "Long key head", "Short key head",
				 "Indexed attribute", "Sequential", "Sequential");
	dcl     first_pass		 bit (1);		/* on => still building a path to compare against */
	dcl     no_tuple_effect_number fixed bin;	/* number of tuple variable with no select set effect */
	dcl     no_tuple_effect_ptr	 ptr;		/* to list of no tuple effect T.V.'s */
	dcl     last_no_tuple_effect_ptr ptr;		/* to last no tuple effect T.V. on list */
	dcl     dummy_good_enough	 bit (1);
%page;
	code = 0;

/* set mrds_debug_tool switches */

	display_low_cost_paths = substr (db_mrds_dsl_permute, 1, 1);
	display_path_permutations = substr (db_mrds_dsl_permute, 2, 1);
	display_access_method_costs = substr (db_mrds_dsl_permute, 4, 1);

	if substr (db_mrds_dsl_permute, 3, 1) | dbcb.no_optimize then
	     use_range_order = "1"b;
	else use_range_order = "0"b;
	select_area_ptr = dbcb.select_area_ptr;
	range_ptr = dbcb.range_ptr;
	number_of_variables = range.num_vars;
	no_tuple_effect_number = 0;
	no_tuple_effect_ptr, low_cost_path_ptr, current_path_ptr = null;
	cost = 0.;
	variable_array (1) = 1;
	allocate path_var in (select_area);		/* set up minimum cost path */
	path_var.alp, path_var.elp = null;
	low_cost_path_ptr = pvp;
	do m_d_p_i = 2 to number_of_variables;
	     variable_array (m_d_p_i) = m_d_p_i;
	     work_ptr = pvp;
	     allocate path_var in (select_area);
	     path_var.alp, path_var.elp = null ();
	     work_ptr -> path_var.fwd_thd = pvp;
	end;
	path_var.fwd_thd = null ();
	m_d_p_i = 1;
	finished = "0"b;
	first_pass = "1"b;
	do while (^finished);			/* generate all permutations of the path */
	     current_path_ptr = null;
	     current_path_cost = 0.;


/* NOTE: in all comments, T.V. is short hand for tuple variable */

	     current_path_multiplier = 1;		/* previously selected tuples don't exists for first T.V. */
	     call
		find_attributes (variable_array (m_d_p_i), current_path_multiplier,
		current_path_cost, code);
	     if code ^= 0 then
		return;
	     current_path_ptr = pvp;
	     level = 1;
	     if number_of_variables > 1 then do;
		     if path_var.in_and_group | path_var.in_select_clause then
			temp_current_path_multiplier =
			     current_path_multiplier * path_var.number_tuples_selected;
		     else temp_current_path_multiplier = current_path_multiplier;

		     call
			permutations (temp_current_path_multiplier, current_path_cost,
			level + 1, dummy_good_enough, code);
		end;
	     else do;
		     low_cost_path_ptr = current_path_ptr;
		     current_path_ptr = null;
		     cost = current_path_cost;
		end;
	     if code ^= 0 then
		return;
	     code = 0;
	     if use_range_order then
		finished = "1"b;
	     else m_d_p_i = m_d_p_i + 1;

	     if m_d_p_i > number_of_variables then
		finished = "1"b;

	     if current_path_ptr ^= null then do;
		     work_ptr = current_path_ptr -> path_var.fwd_thd;
		     do while (current_path_ptr ^= null);
			call free_structures (current_path_ptr);
			current_path_ptr = work_ptr;
			if current_path_ptr ^= null then
			     work_ptr = current_path_ptr -> path_var.fwd_thd;
		     end;
		end;
	end;
%page;
/* add the no tuple effect variables to the end of the low cost path,
   they are needed for no_tuple_effect checks in optimize,
   and will be skipped by gen_srch_prog */

	do pvp = low_cost_path_ptr repeat path_var.fwd_thd
	     while (path_var.fwd_thd ^= null ());

	end;

	path_var.fwd_thd = no_tuple_effect_ptr;

/* display the final low cost path found, if the debug switch is set */

	if substr (db_mrds_dsl_permute, 5, 1) then
	     call display_final_path_details ();

/* perpare final search path by putting it in reverse order expected by mrds_dsl_optimize  */

	do pvp = low_cost_path_ptr repeat path_var.fwd_thd
	     while (path_var.fwd_thd ^= null);
	end;
	path_ptr = pvp;				/* reverse list for mrds_dsl_optimize */
	do m_d_p_i = 1 to number_of_variables - 1 + no_tuple_effect_number;
	     do current_path_ptr = low_cost_path_ptr
		repeat current_path_ptr -> path_var.fwd_thd
		while (current_path_ptr -> path_var.fwd_thd ^= path_ptr);
	     end;
	     path_ptr -> path_var.fwd_thd = current_path_ptr;
	     path_ptr = current_path_ptr;
	end;
	path_ptr -> path_var.fwd_thd = null;
	return;
%page;
find_attributes:
     proc (var_index, multiplier, cost, code);


/* DESCRIPTION:

   this routine gets a path_var structure for this tuple variable filled in.
   This includes adding the list of conditions for this tuple variable
   that can be satisfied at this point, depending on what tuple variables
   preceed it in the search path generated so far */

	dcl     multiplier		 float bin (63);	/* times the current access cost will  be incurred */

	dcl     (
	        base_variable_index,			/* index of base var. */
	        current_term,			/* index to current term in and group */
	        f_a_i,				/* internal index */
	        left_sub_tree_variable_index,		/* left leaf var index */
	        op_code,				/* working op code */
	        other_variable_index,			/* index of other var. */
	        right_sub_tree_variable_index,		/* right leaf var index */
	        var_index
	        )			 fixed bin;	/* Input:  index of variable we are working with */

	dcl     code		 fixed bin (35);	/* internal status code */

	dcl     cost		 float bin (63);	/* internal  cost */

	dcl     (
	        done,				/* internal flag */
	        found,				/* internal flag */
	        variable_index_in_and_group
	        )			 bit (1);		/* internal flag */

	dcl     (
	        base_variable_leaf_ptr init (null),	/* to leaf of base var */
	        other_variable_leaf_ptr init (null)
	        )			 ptr;		/* to leaf of other var */

	dcl     sub_path_cost	 float bin (63);	/* cost of the current path */

	dcl     ops_array		 (5:10) fixed bin int static options (constant)
				 init (1, 2, 3, 5, 4, 6);
	dcl     rev_ops_array	 (6) fixed bin int static options (constant)
				 init (1, 2, 5, 6, 3, 4);




	variable_index_in_and_group = "0"b;

	if path_var_free_ptr = null then
	     allocate path_var in (select_area);	/* Allocations in select_area are never freed.  This area
						   is reinitd at the beginning of each new S. E.. */
	else do;
		pvp = path_var_free_ptr;
		path_var_free_ptr = path_var_free_ptr -> path_var.fwd_thd;
	     end;

	path_var.alp, path_var.elp, path_var.fwd_thd = null;
	path_var.var_index = var_index;
	rmri_ptr = range.tup_var.ri_ptr (var_index);

	call get_attr_list (rm_rel_info.num_attr, alp);

	path_var.alp = alp;
	do f_a_i = 1 to attr_list.nattr;
	     attr_list.info (f_a_i).cond_ptr = null;
	     attr_list.info.index = 0;
	end;

	current_term = 1;
	done = "0"b;
	do while (^done);				/* look for all terms in var index */

	     found = "0"b;
	     do f_a_i = current_term to and_group.num_terms while (^found);
		pn_ptr = and_group.term_ptr (f_a_i);
		left_sub_tree_variable_index = fixed (pred_node.id.lleaf_id.var_id);
		right_sub_tree_variable_index =
		     fixed (pred_node.id.rleaf_id.var_id);
		if left_sub_tree_variable_index = var_index then do;
						/* if left leaf is in var index */
			base_variable_leaf_ptr = pred_node.lbr;
			base_variable_index = left_sub_tree_variable_index;
			op_code = ops_array (fixed (pred_node.id.op_code));
			other_variable_leaf_ptr = pred_node.rbr;
			other_variable_index = right_sub_tree_variable_index;
			found = "1"b;
		     end;
		else if right_sub_tree_variable_index = var_index then do;
						/* if right leaf in var. */
			base_variable_leaf_ptr = pred_node.rbr;
			base_variable_index = right_sub_tree_variable_index;
			op_code =
			     rev_ops_array (ops_array (fixed (pred_node.id.op_code)));
			other_variable_leaf_ptr = pred_node.lbr;
			other_variable_index = left_sub_tree_variable_index;
			found = "1"b;
		     end;
	     end;
	     current_term = f_a_i;			/* remember where to start again */
	     if ^found then
		done = "1"b;

	     else do;				/* have term with leaf in var. */
		     variable_index_in_and_group = "1"b;
		     if other_variable_index = base_variable_index then do;
						/* ignore terms where both leaves insame var */
			     if base_variable_leaf_ptr -> pred_leaf.expr_ptr ^= null then
				/* if is expr in this var */
				call
				     add_to_expr_list (base_variable_leaf_ptr,
				     other_variable_leaf_ptr, op_code);
			     else if other_variable_leaf_ptr -> pred_leaf.expr_ptr ^= null
			     then do;
				     op_code =
					rev_ops_array (ops_array (fixed (pred_node.id.op_code)));
						/* changes < to >, */
						/*         <= to =>, */
						/*         => to =<, */
						/*         > to < */
				     call
					add_to_expr_list (other_variable_leaf_ptr,
					base_variable_leaf_ptr, op_code);
				end;		/*  expr in right leaf */
			     else call
				     add_to_attr_list (base_variable_leaf_ptr,
				     other_variable_leaf_ptr, op_code); /* if no expr leaves */
			end;
		     else if base_variable_leaf_ptr -> pred_leaf.expr_ptr ^= null then
			/* if expr */
			call
			     add_to_expr_list (base_variable_leaf_ptr,
			     other_variable_leaf_ptr, op_code);
		     else call
			     add_to_attr_list (base_variable_leaf_ptr,
			     other_variable_leaf_ptr, op_code);
		end;				/* if have leaf in prime variable */
	end;					/* looking for all terms in var index */


/* for tuple variables not participating in this and_group
   we use a path_var bit as an indicator. This will force calc_sub_path_cost
   to use sequential access method for cost calcualtion,
   as this is the method needed for the implied cross product */

	sub_path_cost = 0.0;
	code = 0;

	if ^variable_index_in_and_group then
	     path_var.in_and_group = "0"b;
	else path_var.in_and_group = "1"b;

	path_var.in_select_clause = range.tup_var.used (path_var.var_index);

	call calc_sub_path_cost (multiplier, sub_path_cost, code);
	cost = sub_path_cost;

	return;
%page;
add_to_attr_list:
     proc (bp, op, opc);

/* procedure to add term to attr. list */

	dcl     (
	        bp,				/* base_variable_leaf_ptr */
	        op,				/* other_variable_leaf_ptr */
	        savep		 init (null),
	        work_ptr		 init (null)
	        )			 ptr;

	dcl     ptr_templ		 ptr based;

	dcl     (attr_ind, opc)	 fixed bin;	/* op_code */

	dcl     end_of_list		 bit (1);

	work_ptr = current_path_ptr;
	end_of_list = "0"b;
	do while (^end_of_list);
	     if work_ptr = null then
		end_of_list = "1"b;
	     else if work_ptr -> path_var.var_index = fixed (op -> pred_leaf.var_id)
	     then end_of_list = "1"b;
	     else work_ptr = work_ptr -> path_var.fwd_thd;
	end;

	if work_ptr ^= null | op -> pred_leaf.data_type = CONST
	     | bp -> pred_leaf.id.var_id = op -> pred_leaf.id.var_id then do;
		attr_ind = fixed (bp -> pred_leaf.id.attr_id);

		if attr_list.info.cond_ptr (attr_ind) = null then do;
						/* if first cond. */
			savep = addr (attr_list.info.cond_ptr (attr_ind));
			attr_list.info.index (attr_ind) = attr_ind;
		     end;
		else do;				/* else find end of linked list */
			do condp = attr_list.info.cond_ptr (attr_ind)
			     repeat cond.fwd_thd while (cond.fwd_thd ^= null);
			end;
			savep = addr (cond.fwd_thd);
		     end;

		if cond_free_ptr = null then /* get a condition structure */
		     allocate cond in (select_area);	/* Allocations in select_area are never freed.  This area
						   is reinit at the beginning of each new S. E.. */
		else do;
			condp = cond_free_ptr;
			cond_free_ptr = cond_free_ptr -> cond.fwd_thd;
		     end;

		savep -> ptr_templ = condp;		/* set the values of the condition structure */
		cond.op_code = opc;
		cond.pl_ptr = op;
		cond.fwd_thd = null;
	     end;

     end add_to_attr_list;
%page;
add_to_expr_list:
     proc (bp, op, opc);

/* Procedure to add expr to expr list */

	dcl     end_of_list		 bit (1);
	dcl     opc		 fixed bin;
	dcl     (
	        bp,
	        op,
	        work_ptr		 init (null)
	        )			 ptr;

	end_of_list = "0"b;
	work_ptr = current_path_ptr;
	do while (^end_of_list);
	     if work_ptr = null then
		end_of_list = "1"b;
	     else if work_ptr -> path_var.var_index
		     = fixed (op -> pred_leaf.id.var_id) then
		end_of_list = "1"b;
	     else work_ptr = work_ptr -> path_var.fwd_thd;
	end;

	if work_ptr ^= null | op -> pred_leaf.data_type = CONST
	     | bp -> pred_leaf.id.var_id = op -> pred_leaf.id.var_id then do;

		if path_var.elp = null then do;	/* if first */
			el_nexprs_init = and_group.num_terms;

			if expr_list_free_ptr = null then
			     allocate expr_list in (select_area); /* Allocations in select_area are never freed.  It
						   is reinit at the beginning of each new S. E.. */
			else do;
				elp = expr_list_free_ptr;
				expr_list_free_ptr =
				     expr_list_free_ptr -> expr_list.info (1).epl_ptr;
			     end;

			expr_list.nexprs = 0;
			path_var.elp = elp;
		     end;
		expr_list.nexprs = expr_list.nexprs + 1;
		expr_list.info.epl_ptr (expr_list.nexprs) = bp;
		expr_list.info.pl_ptr (expr_list.nexprs) = op;
		expr_list.info.op_code (expr_list.nexprs) = opc;
	     end;

     end add_to_expr_list;

     end find_attributes;
%page;
calc_sub_path_cost:
     proc (multiplier, cost, code);

/* DESCRIPTION:

   this routine computes the cost of accessing the current tuple variable,
   in it's current position in the search path, thus taking into
   account how the previous tuple variables will affect the useable access methods,
   and the number of occurences of the access of this tuple variable
   See the comments on the Cost Calculation Constants */


	var_index = path_var.var_index;
	path_var.lk_key_ind = 0;			/* unused */
	relation_size = rm_rel_info.current_tuple_population;

/* FORMULAS FOR NUMBER OF TUPLES SELECTED:

   L =   T / (T - D) gives the number of tuples selected by a single index value.
   where T = number of tuples in rel, D = is the number (or an estimate) of the
   duplicate values of that index.

   Of course if L is the number selected by "=",
   then (T - L) is the number selected by "^=".

   The number of tuples to bump that selected by an "=" condition
   for the case of "<", ">=", etc conditions uses the formula

   L +    (L / T) * (T - L) where L is the result of the above formula.
   (T - L) is the number of values
   not selected by an "=" condition, and (L/T) is the percentage
   of the tuple selected by the "=" condition, so taking that percent
   of the remaining tuples suffices to insure about twice as many selected for
   a ">" condition etc.
   Note that for L = T, ot L = 0, the result is 0 added tuples.
   If T is 0, we don't have to worry about this formula.


   For key head accesses, rather than indexed attributes,
   we use the formula L = T ** (1 - (number_used_key_attrs / total_key_attrs))
   to approximate the selectivity of a key head search for the "=" condition.

   The other formulas remain the same.

   After computing selected tuples, we have to worry about how
   additional conditions (comparisons) will reduce the tuples select.
   This is done with the formula T / (C + 1),
   where C is the cost of conditions remaining.
*/

/* go through all access methods useable on this tuple variable,
   and compute the expected number of tuples selected and
   the cost of each access method. then choose the access
   method having the lowest cost for this tuple variable */

	if relation_size = 0
	     | (^path_var.in_select_clause & ^path_var.in_and_group) then do;

/* for empty relations avoid un-needed work, since
   they always get a cost of 0.

   For T.V.'s not in the select clause
   and not in this and group,
   that will be dropped from consideration by permutations,
   just fill in the bare essentials. */

		if rm_rel_info.ready_mode = RETRIEVE_ONLY then
		     path_var.access_method = UNORDERED_SEQUENTIAL;
		else path_var.access_method = ORDERED_SEQUENTIAL;
		path_var.second_cond_ptr, path_var.cond_ptr = null ();
		path_var.attr_index = 0;
		path_var.number_tuples_selected = relation_size;
		cost, path_var.cost, access_method_cost = 0.0;
	     end;
	else do;
		do i = 1 to 6;			/* init the costs */
		     access_method (i).cost = INFINITY;
		end;

/* get the number of conditions used against this tuple variable */

		call
		     count_conditions (tv_condition_count, tv_condition_cost,
		     tv_equal_condition, tv_not_equal_condition);

		if path_var.in_and_group then do;	/* force sequential for not in and group T.V. cost */

/* CHECK ON TOTAL PRIMARY KEY OR LONG KEY HEAD POSSIBILITIES */

			call equal_key (total, equal_head, equal_fraction, equal_key_count);

			if total then do;		/* entire primary key useable */

/* this access method needs the entire primary key attrs
   to have at least one = condition specified against each.
   It will uniquely select one tuple using a seek_key */

				access_method (1).code = TOTAL_PRIMARY_KEY;
				access_method (1).condition_count =
				     tv_condition_count - equal_key_count;
				access_method (1).conditions_cost =
				     tv_condition_cost
				     - (equal_key_count * CONDITION_COST_FACTOR (OTT_EQ));
				access_method (1).tuples_selected = 1; /* unique primary key => 1 tuple */
				access_method (1).cost = dbcb.access_costs.total_primary_key_cost;
			     end;

			if equal_head then do;	/* 1 or more key head attr useable */

/* this case considers where a vfile select can be used
   to do a seek_head on the primary key. It only works where
   it needs at least one equal condition
   on each key head attribute in order to work */

/* we can make a bad estimate of the tuples selected
   by a key head, using the linear relatioship:
   rel_size * (1 - (key_head_attr_count / total_key_attr_count))
   An alternative formula that that works better for the fraction close to 1 is
   rel_size ** (1 - key_head_attr_count / total_key_attr_count),
   but both apply only to the case with the condition "=",
   in general more tuples are selected by ">", etc.
   and the tuples selected must be increased for that case. */

				access_method (2).code = LONG_KEY_HEAD;
				access_method (2).condition_count =
				     tv_condition_count - equal_key_count;
				access_method (2).conditions_cost =
				     tv_condition_cost
				     - (equal_key_count * CONDITION_COST_FACTOR (OTT_EQ));
				access_method (2).tuples_selected =
				     relation_size ** (1 - equal_fraction);
				tuples_selected_temp =
				     access_method (2).tuples_selected
				     / (access_method (2).conditions_cost + 1);
				access_method (2).tuples_selected = ceil (tuples_selected_temp);
				access_method (2).cost =
				     (dbcb.access_costs.access_cost * access_method (2).tuples_selected)
				     + dbcb.access_costs.access_overhead;
			     end;

/* CHECK ON SHORT KEY HEAD AND INDEXED ATTR POSSIBILITIES */

			call
			     short_key (short_head, short_fraction, indexed_attr,
			     key_head_condition_cost, key_head_not_equal_condition,
			     key_head_range, key_head_attr_id, key_head_cond_ptr,
			     key_head_2nd_cond_ptr, indexed_attr_condition_cost,
			     index_attr_equal_condition, index_attr_not_equal_condition,
			     index_attr_range, index_attr_id, index_attr_cond_ptr,
			     index_attr_2nd_cond_ptr, index_attr_number_of_dups);

			if short_head then do;	/* the 1st key attr useable as head with other than "=" */

/* for the first attribute of a primary key, we can use
   vfile select, looking for a key head value.
   The previous method already handled "=" conditions,
   so now we look at all the other conditions, >, <, ^=, etc. */

				access_method (3).code = SHORT_KEY_HEAD;
				access_method (3).condition_count =
				     tv_condition_count - 1 - fixed (key_head_range);
						/* only one condition used for access unless range */
				access_method (3).conditions_cost =
				     tv_condition_cost - key_head_condition_cost;
				if key_head_not_equal_condition then do;
					if short_fraction = 1.0 then
					     access_method (3).tuples_selected = relation_size - 1;
					else access_method (3).tuples_selected =
						relation_size
						- (relation_size ** (1 - short_fraction));
						/* "^=" => T - L */
				     end;
				else do;		/* other than "=" or "^=" condition */
					if short_fraction = 1.0 then
					     access_method (3).tuples_selected = 1;
					else access_method (3).tuples_selected =
						relation_size ** (1 - short_fraction);
					access_method (3).tuples_selected =
					     access_method (3).tuples_selected
					     + (access_method (3).tuples_selected / relation_size)
					     * (relation_size - access_method (3).tuples_selected);
						/* ">", etc.
						   => L + ((L/T) * (T - L)) */
				     end;
				tuples_selected_temp =
				     access_method (3).tuples_selected
				     / (access_method (3).conditions_cost + 1);
				access_method (3).tuples_selected = ceil (tuples_selected_temp);
				access_method (3).cost =
				     (dbcb.access_costs.access_cost * access_method (3).tuples_selected)
				     + dbcb.access_costs.access_overhead;
			     end;

			if indexed_attr then do;

/*
   A  secondary  index is available for access.  We can estimate the
   tuples  selected as rel_size / unique_index_values.  for the case
   where  the condition is "=".  The "=" if present is forced as the
   access  indexed  attr  if  more  than  one  index or condition is
   present.   For  other  than  "=",  the  index selectivity must be
   changed, to show more tuples selected than for an = condition.
*/

				relation_index_selectivity =
				     relation_size / (relation_size - index_attr_number_of_dups);
				GT_LT_SELECTED_TUPLES =
				     relation_index_selectivity
				     + ((relation_index_selectivity / relation_size)
				     * (relation_size - relation_index_selectivity));

				NE_SELECTED_TUPLES = relation_size - relation_index_selectivity;

				access_method (4).code = INDEXED_ATTR;
				access_method (4).condition_count =
				     tv_condition_count - 1 - fixed (index_attr_range);
						/* only one condition being used for access unless range */
				access_method (4).conditions_cost =
				     tv_condition_cost - indexed_attr_condition_cost;
				if index_attr_not_equal_condition then
				     access_method (4).tuples_selected = NE_SELECTED_TUPLES;
						/* ^= => T - L */
				else do;
					access_method (4).tuples_selected =
					     relation_index_selectivity; /* "=" => L */
					if ^index_attr_equal_condition then
					     access_method (4).tuples_selected =
						GT_LT_SELECTED_TUPLES; /* ">", etc. => L + (L/T)*(T-L) */
				     end;
				tuples_selected_temp =
				     access_method (4).tuples_selected
				     / (access_method (4).conditions_cost + 1);
				access_method (4).tuples_selected = ceil (tuples_selected_temp);
				access_method (4).cost =
				     (dbcb.access_costs.access_cost * access_method (4).tuples_selected)
				     + dbcb.access_costs.access_overhead;
			     end;
		     end;


/* for sequential retrievals, the number of tuples that actually
   statisfy the query will depend on the number of conditions specified,
   the greater number of conditions usually meaning fewer tuples retrieved.
   The number of conditions is factored in using the formula:
   relation_size / (condition_count + 1)
   an alternative formula considered was:
   (0.9 ** condition_count) * relation_size  */

		access_method (5).code = UNORDERED_SEQUENTIAL;
		access_method (5).condition_count = tv_condition_count;
		access_method (5).conditions_cost = tv_condition_cost;
		tuples_selected_temp = relation_size / (tv_condition_cost + 1);
		access_method (5).tuples_selected = ceil (tuples_selected_temp);
		access_method (5).cost =
		     dbcb.access_costs.us_access_cost * relation_size;

/* now that all access methods have had their relative costs evaluated,
   chose the lowest cost access method for this tuple variable */

		lowest_cost = INFINITY;
		lowest_cost_index = 0;
		do i = 1 to 6;
		     if lowest_cost > access_method (i).cost then do; /* found a lower cost */
			     lowest_cost = access_method (i).cost;
			     lowest_cost_index = i;
			end;
		end;

		if lowest_cost_index = 0 then do;	/* we screwed up */
			code = mrds_error_$rst_logic_error;
			access_method_cost = 1;	/* dummy values for error */
			path_var.access_method = UNORDERED_SEQUENTIAL;
			path_var.number_tuples_selected = 0;
		     end;
		else do;
			code = 0;
			path_var.access_method = access_method (lowest_cost_index).code;
			path_var.number_tuples_selected =
			     access_method (lowest_cost_index).tuples_selected;
			access_method_cost = access_method (lowest_cost_index).cost;
		     end;


/* point to condition and attribute to be used for access method */

		if path_var.access_method ^= TOTAL_PRIMARY_KEY
		     & path_var.access_method ^= LONG_KEY_HEAD then do;

/* reset attrs/conditions selected by equal key */

			do i = 1 to rm_rel_info.nkey_attr;

			     j = rm_rel_info.key_attr_ptrs (i) -> rm_attr_info.defn_order;

			     attr_list.info.attr_selected (j) = "0"b;

			     do condp = attr_list.info.cond_ptr (j) repeat cond.fwd_thd
				while (condp ^= null ());
				cond.condition_selected = "0"b;
			     end;

			end;

		     end;

/* for a long = key head, remember the number of key head attrs used.
   for indexed attr or short key head, remember the condition used
   and the attribute on which that condition appeared.
   Set the appriopriate bits in the condition and attr_list strucutres
   so that gen_srch_prog will know what to do. */

		if path_var.access_method = LONG_KEY_HEAD
		     | path_var.access_method = TOTAL_PRIMARY_KEY then do;
			path_var.second_cond_ptr, path_var.cond_ptr = null ();
			path_var.attr_index = equal_key_count; /* use to save length of key head */
		     end;
		else if path_var.access_method = INDEXED_ATTR then do;
			path_var.cond_ptr = index_attr_cond_ptr;
			path_var.second_cond_ptr = index_attr_2nd_cond_ptr;
			path_var.attr_index = index_attr_id;

			path_var.cond_ptr -> cond.condition_selected = "1"b;
			if path_var.second_cond_ptr ^= null () then
			     path_var.second_cond_ptr -> cond.condition_selected = "1"b;
			path_var.alp -> attr_list.info.attr_selected (path_var.attr_index) =
			     "1"b;
		     end;
		else if path_var.access_method = SHORT_KEY_HEAD then do;
			path_var.cond_ptr = key_head_cond_ptr;
			path_var.second_cond_ptr = key_head_2nd_cond_ptr;
			path_var.attr_index = key_head_attr_id;

			path_var.cond_ptr -> cond.condition_selected = "1"b;
			if path_var.second_cond_ptr ^= null () then
			     path_var.second_cond_ptr -> cond.condition_selected = "1"b;
			path_var.alp -> attr_list.info.attr_selected (path_var.attr_index) =
			     "1"b;
		     end;
		else do;
			path_var.second_cond_ptr, path_var.cond_ptr = null ();
			path_var.attr_index = 0;
		     end;



/* the new cost will be the old cost, plus
   the times this current access method cost will be incurred
   The addition to the cost so far, is done outside this routine
   as is the multiplication of the new number of tuples selected.
   The overall formula is cost = cost + (previously_selected * access_cost) */

		path_var.cost, cost = (multiplier * access_method_cost);

	     end;

/* optional debug display */

	if display_access_method_costs then do;

		call ioa_ ("^3/RELATION STATISTICS");
		call
		     ioa_ ("^-Tuple variable:  ^a^/^-In and group:  ^[yes^;no^]",
		     range.tup_var (path_var.var_index).name, path_var.in_and_group);
		call
		     ioa_ ("^-In select clause:  ^[yes^;no^]", path_var.in_select_clause)
		     ;
		call
		     ioa_ ("^-Relation size:  ^d^/", relation_size);

		if relation_size ^= 0
		     & (path_var.in_select_clause | path_var.in_and_group) then do;

			call ioa_ ("^/ACCESS METHOD COST ARRAY");

			do i = 1 to 6;

			     call ioa_ ("^/^a", access_method_name (i));
			     if access_method (i).cost = INFINITY then
				call ioa_ ("^-This method not useable.");
			     else do;
				     call
					ioa_ (
					"^-Access method cost:  ^f^/^-Tuples selected:  ^d^/^-Conditions:  ^d"
					, access_method (i).cost,
					access_method (i).tuples_selected,
					access_method (i).condition_count);
				     call
					ioa_ ("^-Conditions cost:  ^f",
					access_method (i).conditions_cost);
				end;

			end;
		     end;

		call ioa_ ("^/ACCESS METHOD CHOSEN^/");

		call ioa_ ("^a", access_method_name (path_var.access_method));
		call
		     ioa_ ("^-Computed cost:  ^f^/^-Multiplier:  ^f", path_var.cost,
		     multiplier);
		if path_var.access_method = TOTAL_PRIMARY_KEY
		     | path_var.access_method = LONG_KEY_HEAD then
		     call ioa_ ("^-Equal key attrs used:  ^d", path_var.attr_index);
		else if path_var.access_method = SHORT_KEY_HEAD
			| path_var.access_method = INDEXED_ATTR then do;
			if path_var.second_cond_ptr = null () then
			     call
				ioa_ ("^-Condition used:  ^a",
				condition_array (path_var.cond_ptr -> cond.op_code));
			else call
				ioa_ ("^-Conditions used:  ^a  &  ^a",
				condition_array (path_var.cond_ptr -> cond.op_code),
				condition_array (path_var.second_cond_ptr -> cond.op_code));
			call
			     ioa_ ("^-Attribute used:  ^a",
			     rm_rel_info.attr_ptrs (path_var.attr_index) -> rm_attr_info.name)
			     ;
		     end;

		call ioa_ ("^/SEARCH PATH SO FAR USING THIS TUPLE VARIABLE");
		call
		     ioa_ ("^-Cost of path at this point:  ^f",
		     current_path_cost + path_var.cost);

		do temp_path_ptr = current_path_ptr
		     repeat temp_path_ptr -> path_var.fwd_thd
		     while (temp_path_ptr ^= null ());

		     call
			ioa_ ("^-Tuple variable:  ^a",
			range.tup_var.name (temp_path_ptr -> path_var.var_index));

		end;

		call
		     ioa_ ("^-Tuple variable:  ^a^/",
		     range.tup_var.name (path_var.var_index));

	     end;

	return;



	dcl     var_index		 fixed bin;

	dcl     tuples_selected_temp	 float bin (63);	/* temp to allow ceil operation */
	dcl     index_attr_range	 bit (1);		/* on => range of values available for key access */
	dcl     key_head_range	 bit (1);		/* on => range of values available for key access */
	dcl     key_head_2nd_cond_ptr	 ptr;		/* to second condition in range */
	dcl     index_attr_2nd_cond_ptr ptr;		/* to second condition in range */
	dcl     GT_LT_SELECTED_TUPLES	 float bin (27);	/* number of tuples to bump select$ed for other than "=" */
	dcl     NE_SELECTED_TUPLES	 float bin (27);	/* number of tuples to bump selected for "^=" */
	dcl     key_head_condition_cost float bin (27);	/* cost of condition against short key head */
	dcl     key_head_not_equal_condition bit (1);	/* on => "^=" against short key head used */
	dcl     key_head_cond_ptr	 ptr;		/* pointer to condition used for short key head */
	dcl     key_head_attr_id	 fixed bin;	/* index of attr for short key head usage */
	dcl     indexed_attr_condition_cost float bin (27); /* cost of condition against indexed attr used */
	dcl     index_attr_equal_condition bit (1);	/* on => "=" condition agsint indexed attr */
	dcl     index_attr_not_equal_condition bit (1);	/* on => "^=" condition used against indexed attr */
	dcl     index_attr_number_of_dups fixed bin (35); /* number of duplicates in the selected index */
	dcl     index_attr_id	 fixed bin;	/* index of attribute used by secondary index method */
	dcl     index_attr_cond_ptr	 ptr;		/* to condtion for used index attr */
	dcl     relation_index_selectivity float bin (27);/* number of tuples selected by an "="
						   on an index value, for 1 index attr  */
	dcl     temp_path_ptr	 ptr;		/* used for displaying current search path */
	dcl     equal_key_count	 fixed bin;	/* number of key attributes involved */
	dcl     tv_condition_count	 fixed bin;	/* number of conditions/expressions against this T.V. */
	dcl     tv_condition_cost	 float bin (27);	/* const of conditions against this T.V. */
	dcl     tv_equal_condition	 bit (1);		/* on => = condition appears against T.V. */
	dcl     tv_not_equal_condition bit (1);		/* on => "^=" condition appears agsinst this T.V. */
	dcl     (i, j)		 fixed bin;	/* loop index */
	dcl     lowest_cost		 float bin (63);	/* temp for saving lowest cost seen so far */
	dcl     lowest_cost_index	 fixed bin;	/* access method array index for lowest cost */
	dcl     mrds_error_$rst_logic_error fixed bin (35) ext; /* program in error */
	dcl     total		 bit (1);		/* on => entire primary key useable */
	dcl     equal_head		 bit (1);		/* on => key equal_head useable */
	dcl     short_head		 bit (1);		/* on => key short_head useable */
	dcl     indexed_attr	 bit (1);		/* on => a  indexed attribute can be used for access */
	dcl     (equal_fraction, short_fraction) float bin (27); /* percentage of total key useable in hey head */
	dcl     multiplier		 float bin (63);	/* number of times this access cost will be incurred */
	dcl     access_method_cost	 float bin (27);	/* cost of using this access method */
	dcl     cost		 float bin (63);	/* cost of path so far */

/* the array slots are used as follows:
   1 => total primary key
   2 => long key head
   3 => short key head
   4 => secondary index
   5 => unordered sequential
   6 => ordered sequential */

	dcl     1 access_method	 dimension (1:6),	/* array for saving costs, tuples selected */
		2 code		 fixed bin,	/* encoding for the access method */
		2 tuples_selected	 fixed bin (35),	/* expected number of tuples that this method will return */
		2 cost		 float bin (63),	/* cost of this access method */
		2 condition_count	 fixed bin,	/* number of conditions involved */
		2 conditions_cost	 float bin (27);	/* cost of conditions against this T.V. */

	dcl     RETRIEVE_ONLY	 fixed bin init (5) int static options (constant);
						/* scope retrieve ready mode */

	dcl     INFINITY		 init (10e37) float bin (63) int static options (constant);

	dcl     (code, relation_size)	 fixed bin (35);
%page;
equal_key:
     proc (total_primary_key, equal_key_head, useable_key_fraction,
	useable_key_attrs);


/* Procedure to determine if a unique index is useable */

/* DESCRIPTION:

   the total_primary_key and useable_key_fraction will be set
   if the tuple variable can be accessed by unique primary key value

   the equal_key_head and useable_key_fraction will be set if
   the tuple variable can be accessed by a key head
   using 1 or more key head attributes using = conditions

   To qualify for total key or long key head,
   there must be the total key or long key head in the users view
   of this tuple variables relation.

   The conditions must involved only constants, or references to other
   tuples variables that have already appeared in the search path,
   and thus have thier values available.

   The longest possible key head for an N attr key is N-1. */


	u_i_i = 0;
	total_primary_key, equal_key_head, useable = "0"b;
	useable_key_fraction = 0.0;
	if rm_rel_info.nkey_attr = rm_rel_info.model_nkey_attr then do;
						/* if not a partial key sub_model */
		useable = "1"b;
		u_i_i = 1;
		done = "0"b;
		do while (^done);
		     rai_ptr = rm_rel_info.key_attr_ptrs (u_i_i);
		     if attr_list.info.cond_ptr (rm_attr_info.defn_order) = null then
			useable = "0"b;		/* attr not referenced by a condition */
		     else do;			/* attr referenced */


/* look for a useable "=" condition on this attribute in the primary key */

			     equal_found = "0"b;
			     do condp = attr_list.info.cond_ptr (rm_attr_info.defn_order)
				repeat cond.fwd_thd while (condp ^= null () & ^equal_found);
						/* look for an "=" condpition */
				if cond.op_code = OTT_EQ then do; /* only if equality */
					pl_ptr = cond.pl_ptr;
					if fixed (pred_leaf.id.var_id) = var_index then
					     useable = "0"b;
					if useable then do; /* if good so far, check for problems */
						if pred_leaf.data_type ^= CONST then do;
							end_of_list = "0"b;
							work_ptr = current_path_ptr;
							do while (^end_of_list);
							     if work_ptr = null then
								end_of_list = "1"b;
							     else if work_ptr -> path_var.var_index
								     = fixed (pred_leaf.id.var_id) then
								end_of_list = "1"b;
							     else work_ptr = work_ptr -> path_var.fwd_thd;
							end;
							if work_ptr = null then
							     useable = "0"b;
						     end;
						if useable then do;
							equal_found = "1"b; /* still useable => good "=" condition */
							cond.condition_selected = "1"b; /* remember which condition used */
							attr_list.info
							     .attr_selected (rm_attr_info.defn_order) = "1"b;
						/* remember attr used */
						     end;
					     end;
				     end;
			     end;
			     if ^equal_found then
				useable = "0"b;	/* can only use it if had an "=" condition */
			end;			/* if refer. */
		     if useable then do;
			     if u_i_i < rm_rel_info.nkey_attr then
				u_i_i = u_i_i + 1;
			     else done = "1"b;
			end;
		     else do;
			     done = "1"b;
			     u_i_i = u_i_i - 1;	/* back up to last useable key attr */
			end;
		end;				/* loop thru key attr */

	     end;					/* not partial key sub_model */

	useable_key_attrs = u_i_i;

	if useable then do;
		total_primary_key = "1"b;
		useable_key_fraction = 1.0;
	     end;

	if ^useable & /* not total key available */
	     u_i_i >= 1 & u_i_i < rm_rel_info.nkey_attr then do; /* >= 1 key head attrs useable */
		equal_key_head = "1"b;
		useable_key_fraction = u_i_i / rm_rel_info.nkey_attr;
						/* ranges from 1/N to N-1/N */
	     end;


	dcl     u_i_i		 fixed bin;

	dcl     (end_of_list, useable) bit (1);

	dcl     work_ptr		 ptr init (null);

	dcl     equal_found		 bit (1);		/* on => a good "=" condition found against this key attr */
	dcl     total_primary_key	 bit (1);		/* on => can use entire primary key as unique index */
	dcl     equal_key_head	 bit (1);		/* on => can use 1 or more attrs of key head with "=" */
	dcl     useable_key_fraction	 float bin (27);	/* percent of key attrs useable as key head */
	dcl     done		 bit (1);		/* on => exit key attr loop */
	dcl     useable_key_attrs	 fixed bin;	/* number of key attributes involved */

     end equal_key;
%page;
short_key:
     proc (key_head, useable_key_fraction, secondary_index,
	key_head_condition_cost, key_head_not_equal_condition, key_head_range,
	key_head_attr_id, key_head_cond_ptr, key_head_2nd_cond_ptr,
	index_attr_condition_cost, index_equal_condition,
	index_not_equal_condition, index_attr_range, index_attr_id,
	index_attr_cond_ptr, index_attr_2nd_cond_ptr, index_attr_number_of_dups);


/* Procedure to check to see if secondary indexed or key heads are referenced */

/* DESCRIPTION:

   if the tuple variable can be access by key head, using other than an = condition
   then the key_head bit is set, as well as the useable_key_fraction

   if the tuple variable can be accessed by secondary index,
   then the secondary_index bit is set

   if neither is possible, then neither bit is set */


	key_head_attr_id, index_attr_id = 0;
	key_head_2nd_cond_ptr, key_head_cond_ptr, index_attr_2nd_cond_ptr,
	     index_attr_cond_ptr = null ();
	key_head_not_equal_condition, index_equal_condition,
	     index_not_equal_condition, key_head_range, key_head, index_attr_range,
	     useable = "0"b;			/* init */
						/* Determine if there is a condition
						   on the first attribute of the primary key.  This will make
						   a key head. */

/* a key head on the first key attribute is useable as an access
   method for this tuple variable under the following circumstances:
   1) the first key order attribute has at least one condition on it
   2) the condition involves constants, or a value from a tuple
   variable that has appeared previously in the search path */

	key_head_condition_cost = 0.0;
	i_r_i = 0;
	do i_r_j = 1 to rm_rel_info.nkey_attr;
	     rai_ptr = rm_rel_info.key_attr_ptrs (i_r_j); /* find the key head */
	     if rm_attr_info.key_order = 1 then do;
		     i_r_i = i_r_j;
		     i_r_j = rm_rel_info.nkey_attr + 1;
		end;
	end;
	if i_r_i ^= 0 then do;			/* if key head found */
		rai_ptr = rm_rel_info.key_attr_ptrs (i_r_i);
		if attr_list.info.cond_ptr (rm_attr_info.defn_order) ^= null ()
		then do;


/* look through all conditions on the single key head attr
   until a usable one is found, and remember it.
   Continue looking for usable conditions until the lowest cost one is found */

			do condp = attr_list.info.cond_ptr (rm_attr_info.defn_order)
			     repeat cond.fwd_thd while (condp ^= null);
			     pl_ptr = cond.pl_ptr;
			     condition_used = "0"b;
			     if cond.op_code ^= OTT_EQ then do; /* "=" handled by equal_key */

				     if pred_leaf.data_type = CONST then
					condition_used, useable = "1"b;
				     else do;
					     end_of_list = "0"b;
					     work_ptr = current_path_ptr;
					     do while (^end_of_list);
						if work_ptr = null then
						     end_of_list = "1"b;
						else if work_ptr -> path_var.var_index
							= fixed (pred_leaf.id.var_id) then
						     end_of_list = "1"b;
						else work_ptr = work_ptr -> path_var.fwd_thd;
					     end;
					     if work_ptr ^= null then
						condition_used, useable = "1"b;
					end;
				end;
			     if condition_used then do;
				     key_head_condition_cost =
					max (key_head_condition_cost,
					CONDITION_COST_FACTOR (cond.op_code));
				     if key_head_cond_ptr = null () then do;
					     key_head_attr_id = rm_attr_info.defn_order;
						/* save first condition found */
					     key_head_cond_ptr = condp;
					end;
				     else if key_head_cond_ptr -> cond.op_code ^= OTT_EQ then do;
					     if cond.op_code ^= OTT_NE & ^key_head_range then do;


/* favor a range condition over just a >, >=, etc */

						     if key_head_cond_ptr ^= null () then do;
							     if ((key_head_cond_ptr -> cond.op_code = OTT_LT
								| key_head_cond_ptr -> cond.op_code = OTT_LE)
								& (cond.op_code = OTT_GT | cond.op_code = OTT_GE))
								|
								((key_head_cond_ptr -> cond.op_code = OTT_GT
								| key_head_cond_ptr -> cond.op_code = OTT_GE)
								& (cond.op_code = OTT_LT | cond.op_code = OTT_LE))
							     then do;
								     key_head_range = "1"b;
								     key_head_2nd_cond_ptr = condp;
								end;
							end;
						     if ^key_head_range
							& key_head_cond_ptr -> cond.op_code = OTT_NE then do;
							     key_head_attr_id = rm_attr_info.defn_order;
						/* favor <, >, <=, >=
						   over ^= condition, as = will not occur */
							     key_head_cond_ptr = condp;
							end;
						end;
					end;
				end;
			end;
		     end;
	     end;
	if useable then do;
		key_head = "1"b;
		if key_head_cond_ptr -> cond.op_code = OTT_NE then
		     key_head_not_equal_condition = "1"b;
		useable_key_fraction = 1 / rm_rel_info.nkey_attr; /* ranges from 1.0 to 1/N */
	     end;

/* a secondary index access method can be used under the following circumstances:
   1) for this tuple variable, we have a secondary indexed attr with at least
   one condition specified against it
   2) that condition references either a constant, or a tuple variable
   that precedes this one in the current path */


	secondary_index, useable = "0"b;		/* init */
	index_attr_condition_cost = 0.0;
	if rm_rel_info.indexed then do;		/* if exists sec. ind. */
		do i_r_i = 1 to rm_rel_info.num_attr;
		     rai_ptr = rm_rel_info.attr_ptrs (i_r_i);
		     if rm_attr_info.index_attr then do;/* if indexed */


/* 
   look through all conditions on this attribute, find the one which
   will select the fewest number of tuples. Relational operator
   precedence is equal, range, in-equality, not-equal. Within each
   class the index with the fewest duplicate values will be chosen.
*/

			     do condp = attr_list.cond_ptr (rm_attr_info.defn_order)
				repeat cond.fwd_thd while (condp ^= null);
				pl_ptr = cond.pl_ptr;
				condition_used = "0"b;
				if pred_leaf.data_type = CONST then
				     condition_used, useable = "1"b;
				else do;
					end_of_list = "0"b;
					work_ptr = current_path_ptr;
					do while (^end_of_list);
					     if work_ptr = null then
						end_of_list = "1"b;
					     else if work_ptr -> path_var.var_index
						     = fixed (pred_leaf.id.var_id) then
						end_of_list = "1"b;
					     else work_ptr = work_ptr -> path_var.fwd_thd;
					end;
					if work_ptr ^= null then
					     condition_used, useable = "1"b;
				     end;
				if condition_used then do;
					index_attr_condition_cost =
					     max (index_attr_condition_cost,
					     CONDITION_COST_FACTOR (cond.op_code));
					if index_attr_cond_ptr = null () then do;
						/* save 1st condition seen */
						index_attr_id = rm_attr_info.defn_order;
						index_attr_cond_ptr = condp;
						index_attr_number_of_dups = rm_attr_info.number_of_dups;
						index_attr_range = "0"b;
						index_attr_2nd_cond_ptr = null ();
					     end;
					else do;
						condition_completes_range = "0"b;
						if index_attr_cond_ptr ^= null () &
						     index_attr_id = rm_attr_info.defn_order
						then do;
							if ((index_attr_cond_ptr -> cond.op_code = OTT_LT
							     | index_attr_cond_ptr -> cond.op_code = OTT_LE)
							     & (cond.op_code = OTT_GT |
							     cond.op_code = OTT_GE))
							     |
							     ((index_attr_cond_ptr -> cond.op_code = OTT_GT
							     | index_attr_cond_ptr -> cond.op_code = OTT_GE)
							     & (cond.op_code = OTT_LT |
							     cond.op_code = OTT_LE))
							then condition_completes_range = "1"b;
						     end;
						call find_index_attr;

					     end;
				     end;
			     end;
			end;
		end;				/* loop thru attr */
	     end;					/* if sec. ind. exist */
	if useable then do;
		secondary_index = "1"b;
		if index_attr_cond_ptr -> cond.op_code = OTT_EQ then
		     index_equal_condition = "1"b;
		else if index_attr_cond_ptr -> cond.op_code = OTT_NE then
		     index_not_equal_condition = "1"b;
	     end;


	dcl     (end_of_list, useable) bit (1);

	dcl     (i_r_i, i_r_j)	 fixed bin;

	dcl     work_ptr		 ptr init (null);
	dcl     key_head_range	 bit (1);		/* on => exists range of values on the key head attr */
	dcl     key_head_2nd_cond_ptr	 ptr;		/* to second in range of values for key head range */
	dcl     index_attr_range	 bit (1);		/* on => attr chosen for selection has a range */
	dcl     index_attr_2nd_cond_ptr ptr;		/* to second value in a range condition */
	dcl     condition_used	 bit (1);		/* on => this key_head/index_attr
						   useable for this attr/condtions */
	dcl     condition_completes_range bit (1);	/* on => exists a range of values on an indexed attr */
	dcl     index_attr_id	 fixed bin;	/* index into attr_ptr array for chosen condition */
	dcl     index_attr_cond_ptr	 ptr;		/* pointer to chosen condition for index */
	dcl     index_attr_number_of_dups fixed bin (35); /* number of dups on index chosen for selection */
	dcl     key_head_attr_id	 fixed bin;	/* index into attr_ptr array |for key head attr */
	dcl     key_head_cond_ptr	 ptr;		/* pointer to chosen condition for key head */
	dcl     key_head_not_equal_condition bit (1);	/* on => "^=" appeared as condition on key head */
	dcl     index_equal_condition	 bit (1);		/* on => "=" condition on indexed attr */
	dcl     index_not_equal_condition bit (1);	/* on => "^=" on indexed attr */
	dcl     key_head		 bit (1);		/* on => first key attr useable as head */
	dcl     secondary_index	 bit (1);		/* on => some secondarily indexed attr useable */
	dcl     useable_key_fraction	 float bin (27);	/* percentage of key attrs useable as key head */
	dcl     key_head_condition_cost float bin (27);	/* cost of conditions on key head attr */
	dcl     index_attr_condition_cost float bin (27); /* cost of conditions on indexed attribute */
%page;
find_index_attr: proc;				/* all parameters are global, local vars start with fia_ */

	dcl     fia_current_cond	 fixed bin;	/* code for current condition on attribute */
	dcl     fia_select_cond	 fixed bin;	/* code for condition that will be used to select
                                                               a tuple unless a better condition is found */
	dcl     fia_COMPARE_SELECTION_TO_CURRENT (4, 4) fixed bin internal static init
				 (1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16);
						/* values of array are used to decide which
                                                               condition should be used to select the relation */

	if condition_completes_range
	then fia_current_cond = 4;
	else do;
		if condp -> cond.op_code > 3
		then fia_current_cond = 3;
		else fia_current_cond = condp -> cond.op_code;
	     end;

	if index_attr_range
	then fia_select_cond = 4;
	else do;
		if index_attr_cond_ptr -> cond.op_code > 3
		then fia_select_cond = 3;
		else fia_select_cond = index_attr_cond_ptr -> cond.op_code;
	     end;

	goto fia_do_something (fia_COMPARE_SELECTION_TO_CURRENT (fia_select_cond, fia_current_cond));


fia_do_something (1):				/* both conditions are = */
fia_do_something (6):				/* both conditions are ^= */
fia_do_something (11):				/* both conditions are an inequality */
	if index_attr_number_of_dups > rm_attr_info.number_of_dups
	then do;
		index_attr_cond_ptr = condp;
		index_attr_number_of_dups = rm_attr_info.number_of_dups;
		index_attr_id = rm_attr_info.defn_order;
		index_attr_range = "0"b;
		index_attr_2nd_cond_ptr = null ();
	     end;
	goto exit_find_index_attr;

fia_do_something (2):				/* select cond ^=, current cond = */
fia_do_something (3):				/* select cond is an inequality, current cond is = */
fia_do_something (4):				/* select cond is a range, current cond is = */
fia_do_something (10):				/* select cond is ^=, current cond is an inequality */
	index_attr_cond_ptr = condp;
	index_attr_number_of_dups = rm_attr_info.number_of_dups;
	index_attr_id = rm_attr_info.defn_order;
	index_attr_range = "0"b;
	index_attr_2nd_cond_ptr = null ();
	goto exit_find_index_attr;

fia_do_something (5):				/* select cond =, current cond ^= */
fia_do_something (7):				/* select cond is an inequality, current cond is a ^= */
fia_do_something (8):				/* select cond is a range, current cond is a ^= */
fia_do_something (9):				/* select cond is =, current cond is an inequality */
fia_do_something (12):				/* select cond is a range, current cond is an inequality */
						/* the following choices are not possible
                                                               because of the way a range is completed */
fia_do_something (13):				/* select cond is =, current cond completes a range */
fia_do_something (14):				/* select cond is ^=, current cond completes a range */
fia_do_something (16):				/* select cond is a range, current cond completes a range */
	goto exit_find_index_attr;

fia_do_something (15):				/* select cond is an inequality,
                                                               current cond completes a range */
	index_attr_2nd_cond_ptr = condp;
	index_attr_range = "1"b;
	goto exit_find_index_attr;

exit_find_index_attr:
	return;

     end find_index_attr;

     end short_key;

     end calc_sub_path_cost;
%page;
count_conditions:
     procedure (condition_count, condition_cost, equal_seen, not_equal_seen);

/* DESCRIPTION:

   If a tuple variable is to be accessed sequentially,
   the number of tuples selected during the search will depend on
   the number of conditions specified against the tuple variable attriubtes.
   This routine determines the count of those conditions.
   This includes the count of expressions.

   The different operators normally will select different numbers of tuples,
   the number increasing from lowest to highest when the operators are
   "=", a range using "<" and ">", a range using only a ">", ">=, "<", or "<=",
   and finally "^=" for the 4 major cases.
   Thus The following weightings for adding
   conditions have been used:

   ">", "<", ">=", or "<=" - - - add 0.5 for each condition

   "=" - - - add 1.5 for each condition

   "^=" - - - add 0.2 for each condition

   These costs for conditions are then factored into the tuples selected count
   as follows:

   For an access of all tuples in the relation = T tuples,
   the final count used is = T / (condition_cost + 1)

   For a case where the tuples are accessed via some key,
   this is modified to only consider the conditions remaining after
   the conditions used by the key search are subtracted
   thus the final count is = T / (TC - KC + 1)
   where TC = total condition cost and KC = key conditions cost

*/

	condition_count = 0;			/* init */
	condition_cost = 0.0;
	equal_seen = "0"b;
	not_equal_seen = "0"b;

	do i = 1 to rm_rel_info.num_attr;		/* look at all attrs in view of rel */

	     path_var.alp -> attr_list.info.attr_selected (i) = "0"b;
						/* reset for this T.V. */

	     do condp = path_var.alp -> attr_list.info.cond_ptr (i)
		repeat condp -> cond.fwd_thd while (condp ^= null ());

		condp -> cond.condition_selected = "0"b;/* reset for this T.V. */

		condition_cost =
		     condition_cost + CONDITION_COST_FACTOR (condp -> cond.op_code);
		condition_count = condition_count + 1;

		if condp -> cond.op_code = OTT_EQ then
		     equal_seen = "1"b;
		else if condp -> cond.op_code = OTT_NE then
		     not_equal_seen = "1"b;

	     end;

	end;

	if path_var.elp ^= null () then do;

		do i = 1 to path_var.elp -> expr_list.nexprs;
		     condition_cost =
			condition_cost
			+
			CONDITION_COST_FACTOR (path_var.elp
			-> expr_list.info (i).op_code);
		     condition_count = condition_count + 1;

		     if path_var.elp -> expr_list.info (i).op_code = 1 then
			equal_seen = "1"b;
		     else if path_var.elp -> expr_list.info (i).op_code = 2 then
			not_equal_seen = "1"b;
		end;

	     end;



	dcl     equal_seen		 bit (1);		/* on => an "=" condition exists against this relation */
	dcl     not_equal_seen	 bit (1);		/* on => a "^=" condition exists against this relation */
	dcl     condition_count	 fixed bin;	/* count of conditions against this relation */
	dcl     i			 fixed bin;	/* loop index */
	dcl     condp		 ptr;		/* local cond structure pointer */
	dcl     condition_cost	 float bin (27);	/* cost of conditions + expressions on this T.V. */

     end;
%page;
permutations:
     proc (multiplier_param, cost_param, level, good_enough_rtn, code);


/* DESCRIPTION:

   this routine will try all ordering of the tuple variables in this and_group,
   in an attempt to see how this ordering will affect possible access methoods,
   and the cost of using those methods, so that an overall lowest cost
   path through the tuple variables may be found
   tuple variables that are not in the and_group are treated equally with
   those in the and_group. the costing algorithm will put them
   in proper order in the final search path of tuple variables.

   Due to the changes on 10/01/83, this routine will no longer always try
   all possible orderings.  If the number of tuple variables is very large
   and the current path looks very good, the search will skip some of the
   permutations.  Currently, this is done by the simple method of checking
   if the sub-path will select only one tuple.  This should be done by looking
   at which tuple variable provide information to determine other tuple
   variable and only trying the permutations that have some chance of having
   different costs.  Unfortunally, this is much harder to do, so for now we
   will settle for the simple approach. 

   This routine now returns the bit good_enough, to indict the all lower levels
   in the sub-path examined meet the conditions required to skip doing all
   permutations.
 */

	dcl     (ENOUGH_TUPLE_VARIABLES_TO_NOT_TRY_ALL_POSSIBLE_PERMUTATIONS init (5),
	        PATH_DOES_NOT_EXPAND	 init (1),
	        NUMBER_OF_LEVELS_THAT_MUST_BE_PERMUTED init (2))
				 internal static options (constant);

	dcl     (current_variable_index, level, p_i, p_k, p_j) fixed bin;

	dcl     code		 fixed bin (35);

	dcl     (cost_param, current_path_cost, multiplier, multiplier_param,
	        temp_multiplier, sub_path_cost) float bin (63);

	dcl     (done, good_enough_rtn, good_enough, in_current_path, current_good_enough) bit (1);

	dcl     (
	        path_ptr		 init (null),
	        temp_fwd_thd	 init (null),
	        work_ptr		 init (null)
	        )			 ptr;

	good_enough_rtn = "0"b;
	multiplier = multiplier_param;
	current_path_cost = cost_param;
	current_variable_index = 1;
	do while (current_variable_index <= number_of_variables);
	     done = "0"b;
	     p_i = current_variable_index;
	     do while (^done & p_i ^> number_of_variables);
		sub_path_cost = 0.;			/* find this variable in the path. */
		do path_ptr = current_path_ptr
		     repeat path_ptr -> path_var.fwd_thd
		     while (path_ptr -> path_var.fwd_thd ^= null
		     & path_ptr -> path_var.var_index ^= variable_array (p_i));
		end;
		if path_ptr -> path_var.var_index ^= variable_array (p_i) then do;
						/* Does this variable already exist in the path? */
			pvp = null ();
			do while (pvp = null () & p_i ^> number_of_variables);
						/* Assume that this path is not good enough to cause skipping permutations */
			     current_good_enough = "0"b;
			     call
				find_attributes (variable_array (p_i), multiplier,
				sub_path_cost, code); /* No.  Create a path_var for it. */
			     if code ^= 0 then
				return;
			     if ^path_var.in_and_group & ^path_var.in_select_clause
			     then do;

/* a tuple variable with no effect on the select set was found,
   remove it from further considerations in the low cost path */

				     if no_tuple_effect_ptr = null () then do;
					     no_tuple_effect_ptr = pvp;
					     last_no_tuple_effect_ptr = pvp;
					end;
				     else do;
					     last_no_tuple_effect_ptr -> path_var.fwd_thd = pvp;
					     last_no_tuple_effect_ptr = pvp;
					end;

				     do p_j = p_i + 1 to number_of_variables;
					p_k = p_j - 1;
					variable_array (p_k) = variable_array (p_j);
				     end;

				     number_of_variables = number_of_variables - 1;
				     pvp = null ();
				     sub_path_cost = 0.0;
				     no_tuple_effect_number = no_tuple_effect_number + 1;

				     in_current_path = "1"b;
				     do while (p_i ^> number_of_variables & in_current_path);
					do path_ptr = current_path_ptr
					     repeat path_ptr -> path_var.fwd_thd
					     while (path_ptr -> path_var.fwd_thd ^= null ()
					     & path_ptr -> path_var.var_index
					     ^= variable_array (p_i));

					end;

					if path_ptr -> path_var.var_index = variable_array (p_i)
					then p_i = p_i + 1;
					else in_current_path = "0"b;

				     end;

				end;

			end;
			if pvp ^= null () then do;
						/* Check to see if the current path meets the "good enough" rule */
				if level > NUMBER_OF_LEVELS_THAT_MUST_BE_PERMUTED &
				     number_of_variables > ENOUGH_TUPLE_VARIABLES_TO_NOT_TRY_ALL_POSSIBLE_PERMUTATIONS
				     & path_var.number_tuples_selected <= PATH_DOES_NOT_EXPAND
				then current_good_enough = "1"b;
				if display_path_permutations then do;
					call
					     ioa_ (
					     "^/Current level: ^i  Current path cost: ^f  Sub path cost: ^f  Total: ^f"
					     , level, current_path_cost, sub_path_cost,
					     (current_path_cost + sub_path_cost));
					call
					     ioa_ ("^/Current variable: ^i   Current cost: ^f", p_i,
					     current_path_cost);
					call mdb_display_path_$path (current_path_ptr, dbcb_ptr);
					call mdb_display_path_$path (pvp, dbcb_ptr);
				     end;

/* check for the current path exceeding the cost of the lowest cost path
   found so far. If it is exceeded
   then we can discard further consideration of the current path
   We must not stop however, if the first reference low cost path
   has not been completely built yet (first_pass true) */

				if current_path_cost + sub_path_cost >= cost & ^first_pass
				then call free_structures (pvp); /* Yes. */
				else do;
					path_ptr -> path_var.fwd_thd = pvp; /* No. */
					current_variable_index = p_i;
					done = "1"b;
				     end;
			     end;
		     end;
		p_i = p_i + 1;
	     end;


/* check to see if this was the last variable that would make a complete
   path, and if so, was the current path a lower cost one than
   the lowest cost one seen so far. (done => lower cost)
   If this is the first path being built as a reference,
   then we must save it for comparison (first_pass true) */

	     if level >= number_of_variables & (done | first_pass) then do;
		     first_pass = "0"b;
		     if pvp ^= null then do;		/* a no_tuple_effect T.V. could have been last */
			     if path_var.in_select_clause | path_var.in_and_group then
				/* don't consider useless T.V.'s */
				multiplier = multiplier * path_var.number_tuples_selected;
			end;
		     cost = current_path_cost + sub_path_cost;
		     path_ptr = low_cost_path_ptr;
		     do work_ptr = current_path_ptr
			repeat work_ptr -> path_var.fwd_thd while (work_ptr ^= null);
						/* Copy the new, lower cost, path so that
						   modifications maybe made to the current path. */
			if path_ptr -> path_var.alp ^= null then
			     call free_attr_list (path_ptr);
			if path_ptr -> path_var.elp ^= null then
			     call free_expr_list (path_ptr);
			temp_fwd_thd = path_ptr -> path_var.fwd_thd;
			path_ptr -> path_var = work_ptr -> path_var;
			path_ptr -> path_var.fwd_thd = temp_fwd_thd;
			if work_ptr -> path_var.alp ^= null then
			     call copy_attr_list (path_ptr, work_ptr);
			if work_ptr -> path_var.elp ^= null then
			     call copy_expr_list (path_ptr, work_ptr);
			if work_ptr -> path_var.fwd_thd ^= null then
			     path_ptr = path_ptr -> path_var.fwd_thd;
			else path_ptr -> path_var.fwd_thd = null;
		     end;

		     if display_low_cost_paths then do; /* patch to display path */
			     do pvp = low_cost_path_ptr repeat path_var.fwd_thd
				while (path_var.fwd_thd ^= null);
			     end;
			     path_ptr = pvp;
			     do p_i = 1 to number_of_variables - 1;
				do work_ptr = low_cost_path_ptr
				     repeat work_ptr -> path_var.fwd_thd
				     while (work_ptr -> path_var.fwd_thd ^= path_ptr);
				end;
				path_ptr -> path_var.fwd_thd = work_ptr;
				path_ptr = work_ptr;
			     end;
			     path_ptr -> path_var.fwd_thd = null;
			     call ioa_ ("^/Cost: ^f", cost);
			     call mdb_display_path_$path (pvp, dbcb_ptr);
			     path_ptr = low_cost_path_ptr;
			     do p_i = 1 to number_of_variables - 1;
				do work_ptr = pvp repeat work_ptr -> path_var.fwd_thd
				     while (work_ptr -> path_var.fwd_thd ^= path_ptr);
				end;
				path_ptr -> path_var.fwd_thd = work_ptr;
				path_ptr = work_ptr;
			     end;
			     path_ptr -> path_var.fwd_thd = null;
			end;			/* end display path patch */

		     if level > 2 then do;		/* delete the last variable index generated so
						   we may look at the next variable index. */
			     do work_ptr = current_path_ptr
				repeat work_ptr -> path_var.fwd_thd
				while (work_ptr -> path_var.fwd_thd -> path_var.fwd_thd
				^= null);
			     end;
			     call free_structures (work_ptr -> path_var.fwd_thd);
			     good_enough_rtn = current_good_enough;
			     return;
			end;
		     else do;
			     call free_structures (current_path_ptr -> path_var.fwd_thd);
			     good_enough_rtn = current_good_enough;
			     return;
			end;
		end;
	     else if done then do;			/* It was not the last variable to look at.
						   Will this variable keep the path cost, so far,
						   beneath that of the existing path? */

		     if pvp = null () then
			temp_multiplier = multiplier;
		     else if ^path_var.in_and_group & ^path_var.in_select_clause then
			temp_multiplier = multiplier;
		     else temp_multiplier = multiplier * path_var.number_tuples_selected;

		     call permutations (temp_multiplier, current_path_cost + sub_path_cost,
			level + 1, good_enough, code);

		     if code ^= 0 then
			return;
		     good_enough_rtn = current_good_enough & good_enough;
		     call free_structures (path_ptr -> path_var.fwd_thd);
		end;
	     else if level >= number_of_variables	/* A variable to keep the cost below that of the
						   existing path was not found.  Back up a level. */
	     then do;
		     good_enough_rtn = current_good_enough;
		     return;
		end;

	     current_variable_index = current_variable_index + 1;
						/* Look for another path. */
	     if use_range_order then /* only one iteration t = 0.0 then */
		return;

	     if good_enough_rtn then /* Do not search more if this path is good enough */
		return;
	end;
	code = 0;
     end permutations;
%page;
free_structures:
     proc (path_var_ptr);

	dcl     work_ptr		 ptr init (null);

	dcl     path_var_ptr	 ptr;		/* Input: ptr to the path_var structure to be freed */

	if path_var_ptr ^= null () then do;

		path_var_ptr -> path_var.fwd_thd = path_var_free_ptr;
						/* Thread path_var structure onto its free list */
		path_var_free_ptr = path_var_ptr;
		path_var_ptr = null;

		if path_var_free_ptr -> path_var.alp ^= null then
		     call free_attr_list (path_var_free_ptr); /* if an attribute list structure exists put it and its
						   condition structures on their respective list */

		if path_var_free_ptr -> path_var.elp ^= null then
		     call free_expr_list (path_var_free_ptr); /* if an expression list structure exists put it on
						   its list */

	     end;

     end free_structures;
%page;
copy_attr_list:
     proc (copy_to_ptr, copy_from_ptr);

	dcl     (
	        copy_from_ptr,
	        copy_to_ptr,
	        from_work_ptr_1	 init (null),
	        from_work_ptr_2	 init (null),
	        to_work_ptr_1	 init (null),
	        to_work_ptr_2	 init (null)
	        )			 ptr;

	dcl     (c_a_l_i, c_a_l_j)	 fixed bin;

	call
	     get_attr_list (copy_from_ptr -> path_var.alp -> attr_list.nattr,
	     copy_to_ptr -> path_var.alp);






	from_work_ptr_1 = copy_from_ptr -> path_var.alp;
	to_work_ptr_1 = copy_to_ptr -> path_var.alp;


	to_work_ptr_1 -> attr_list = from_work_ptr_1 -> attr_list;

	c_a_l_j = from_work_ptr_1 -> attr_list.nattr;

	do c_a_l_i = 1 to c_a_l_j;
	     if from_work_ptr_1 -> attr_list.info (c_a_l_i).cond_ptr ^= null
	     then do;
		     from_work_ptr_2 =
			from_work_ptr_1 -> attr_list.info (c_a_l_i).cond_ptr;
		     if cond_free_ptr = null then
			allocate cond in (select_area)
			     set (to_work_ptr_1 -> attr_list.info (c_a_l_i).cond_ptr);
		     else do;
			     to_work_ptr_1 -> attr_list.info (c_a_l_i).cond_ptr =
				cond_free_ptr;
			     cond_free_ptr = cond_free_ptr -> cond.fwd_thd;
			end;
		     to_work_ptr_2 = to_work_ptr_1 -> attr_list.info (c_a_l_i).cond_ptr;
		     to_work_ptr_2 -> cond = from_work_ptr_2 -> cond;
		     if copy_from_ptr -> path_var.cond_ptr = from_work_ptr_2 then
			copy_to_ptr -> path_var.cond_ptr = to_work_ptr_2;

		     if copy_from_ptr -> path_var.second_cond_ptr = from_work_ptr_2 then
			copy_to_ptr -> path_var.second_cond_ptr = to_work_ptr_2;
		     from_work_ptr_2 = from_work_ptr_2 -> cond.fwd_thd;
		     do while (from_work_ptr_2 ^= null);
			if cond_free_ptr = null then
			     allocate cond in (select_area)
				set (to_work_ptr_2 -> cond.fwd_thd);
			else do;
				to_work_ptr_2 -> cond.fwd_thd = cond_free_ptr;
				cond_free_ptr = cond_free_ptr -> cond.fwd_thd;
			     end;
			to_work_ptr_2 = to_work_ptr_2 -> cond.fwd_thd;
			to_work_ptr_2 -> cond = from_work_ptr_2 -> cond;
			if copy_from_ptr -> path_var.cond_ptr = from_work_ptr_2 then
			     copy_to_ptr -> path_var.cond_ptr = to_work_ptr_2;

			if copy_from_ptr -> path_var.second_cond_ptr = from_work_ptr_2
			then copy_to_ptr -> path_var.second_cond_ptr = to_work_ptr_2;
			from_work_ptr_2 = from_work_ptr_2 -> cond.fwd_thd;
		     end;
		end;
	end;
     end copy_attr_list;
%page;
free_attr_list:
     proc (path_var_ptr);

	dcl     f_a_l_i		 fixed bin;

	dcl     (
	        path_var_ptr,
	        work_ptr		 init (null)
	        )			 ptr;

	condp = path_var_ptr -> path_var.alp -> attr_list.info (1).cond_ptr;
	path_var_ptr -> path_var.alp -> attr_list.info (1).cond_ptr =
	     attr_list_free_ptr;
	attr_list_free_ptr = path_var_ptr -> path_var.alp;
	path_var_ptr -> path_var.alp = null;

	do f_a_l_i = 1 to attr_list_free_ptr -> attr_list.nattr;
						/* put the condition structures on their free lists */
	     if condp ^= null then do;
		     work_ptr = cond.fwd_thd;
		     do while (condp ^= null);
			cond.fwd_thd = cond_free_ptr;
			cond_free_ptr = condp;
			condp = work_ptr;
			if condp ^= null then
			     work_ptr = cond.fwd_thd;
		     end;
		end;
	     if f_a_l_i ^= 1 then
		attr_list_free_ptr -> attr_list.info (f_a_l_i).cond_ptr = null;
	     if f_a_l_i < attr_list_free_ptr -> attr_list.nattr then
		condp =
		     attr_list_free_ptr -> attr_list.info (f_a_l_i + 1).cond_ptr;
	end;

     end free_attr_list;
%page;
get_attr_list:
     proc (num_of_attrs, alp_param);

	dcl     (
	        alp_param,				/* output parameter: ptr to attr_list structure */
	        work_ptr_1		 init (null),
	        work_ptr_2		 init (null)
	        )			 ptr;

	dcl     ptr_skel		 ptr based;

	dcl     num_of_attrs	 fixed bin;	/* input parameter: size of the attr_list.info array */

	dcl     in_attr_list_free_list bit (1) init ("0"b);

	work_ptr_2 = addr (attr_list_free_ptr);
	work_ptr_1 = attr_list_free_ptr;
	do while (^in_attr_list_free_list & work_ptr_1 ^= null);
	     if work_ptr_1 -> attr_list.nattr = num_of_attrs then do;
		     work_ptr_2 -> ptr_skel = work_ptr_1 -> attr_list.info (1).cond_ptr;
		     in_attr_list_free_list = "1"b;
		end;
	     else do;
		     work_ptr_2 = addr (work_ptr_1 -> attr_list.info (1).cond_ptr);
		     work_ptr_1 = work_ptr_1 -> attr_list.info (1).cond_ptr;
		end;
	end;

	if in_attr_list_free_list then
	     alp_param = work_ptr_1;
	else do;
		al_nattr_init = num_of_attrs;
		allocate attr_list in (select_area) set (alp_param);
	     end;
     end get_attr_list;
%page;
copy_expr_list:
     proc (copy_to_ptr, copy_from_ptr);

	dcl     (copy_from_ptr, copy_to_ptr) ptr;

	if expr_list_free_ptr = null then
	     allocate expr_list in (select_area)
		set (copy_to_ptr -> path_var.elp);
	else do;
		copy_to_ptr -> path_var.elp = expr_list_free_ptr;
		expr_list_free_ptr = expr_list_free_ptr -> expr_list.info (1).epl_ptr;
	     end;
	copy_to_ptr -> path_var.elp -> expr_list.nexprs = el_nexprs_init;
	unspec (copy_to_ptr -> path_var.elp -> expr_list) =
	     unspec (copy_from_ptr -> path_var.elp -> expr_list);
     end copy_expr_list;
%page;
free_expr_list:
     proc (path_var_ptr);

	dcl     path_var_ptr	 ptr;

	path_var_ptr -> path_var.elp -> expr_list.info (1).epl_ptr =
	     expr_list_free_ptr;
	expr_list_free_ptr = path_var_ptr -> path_var.elp;
	path_var_ptr -> path_var.elp = null;

     end free_expr_list;
%page;
display_final_path_details:
     procedure ();

/* this routine outputs optional debug information.
   That info includes the final lowest cost path found,
   and all the conditions against that path, the access methods
   used for each tuple variable and so on. */

	call ioa_ ("^/FINAL PATH,  COST = ^f^/", cost);

/* go through the path in the order it will be used for the search */

	order = 0;
	call ioa_ ("No tuple effect count:  ^d", no_tuple_effect_number);

	do pvp = low_cost_path_ptr repeat path_var.fwd_thd while (pvp ^= null ());

	     order = order + 1;
	     if ^path_var.in_select_clause & ^path_var.in_and_group then
		call ioa_ ("^/No tuple effect variables follow.");

/* output details on this tuple variable */

	     rmri_ptr = range.tup_var.ri_ptr (path_var.var_index);
	     call
		ioa_ ("^/Order: ^d      Tuple variable:  ^a", order,
		range.tup_var.name (path_var.var_index));

	     call ioa_ ("^14xIn and group:  ^[yes^;no^]", path_var.in_and_group);
	     call
		ioa_ ("^14xIn select clause:  ^[yes^;no^]",
		path_var.in_select_clause);
	     call
		ioa_ ("^14xAccess method:  ^a",
		access_method_name (path_var.access_method));
	     call
		ioa_ ("^14xTuples selected:  ^d", path_var.number_tuples_selected);

	     if path_var.access_method = TOTAL_PRIMARY_KEY
		| path_var.access_method = LONG_KEY_HEAD then
		call ioa_ ("^14xEqual key attrs used:  ^d", path_var.attr_index);
	     else if path_var.access_method = SHORT_KEY_HEAD
		     | path_var.access_method = INDEXED_ATTR then do;
		     if path_var.second_cond_ptr = null () then
			call
			     ioa_ ("^14xCondition used:  ^a",
			     condition_array (path_var.cond_ptr -> cond.op_code));
		     else call
			     ioa_ ("^14xConditions used:  ^a  &  ^a",
			     condition_array (path_var.cond_ptr -> cond.op_code),
			     condition_array (path_var.second_cond_ptr -> cond.op_code));
		     call
			ioa_ ("^14xAttribute used:  ^a",
			rm_rel_info.attr_ptrs (path_var.attr_index) -> rm_attr_info.name)
			;
		end;

	     if path_var.in_and_group then do;

/* output all conditions against this tuple variable,
   not in and group tuple variables have no conditions */

		     conditions = 0;
		     alp = path_var.alp;
		     if alp ^= null () then do;

			     do i = 1 to rm_rel_info.num_attr;

				rai_ptr = rm_rel_info.attr_ptrs (i);
				j = rm_attr_info.defn_order;
				if attr_list.info (j).cond_ptr ^= null () then do;

/* this attribute referenced by a condition */

					if conditions = 0 then /* first condition seen */
					     call ioa_ ("^/^14xCONDITION LIST");
					call
					     ioa_ ("^14xAttribute:  ^a^/^14xSelected:  ^[yes^;no^]",
					     rm_attr_info.name, attr_list.info (j).attr_selected);


/* output each condition on this attribute */

					do condp = attr_list.info (j).cond_ptr
					     repeat cond.fwd_thd while (condp ^= null ());

					     conditions = conditions + 1;
					     if cond.pl_ptr -> pred_leaf.data_type = CONST then
						call
						     ioa_ (
						     "^18xCompared(^d):  ""^a""  to:  CONSTANT",
						     conditions, condition_array (cond.op_code));
					     else do; /* compared to attribute */

						     call
							ioa_ ("^18xCompared(^d):  ""^a""  to:  ^a.^a",
							conditions, condition_array (cond.op_code),
							range.tup_var
							.
							name (fixed (cond.pl_ptr -> pred_leaf.id.var_id)),
							range.tup_var
							.
							ri_ptr (
							fixed (cond.pl_ptr -> pred_leaf.id.var_id))
							-> rm_rel_info
							.
							attr_ptrs (
							fixed (cond.pl_ptr -> pred_leaf.id.attr_id))
							-> rm_attr_info.name);
						end;
					     call
						ioa_ ("^18xSelected:  ^[yes^;no^]",
						cond.condition_selected);
					end;
				     end;
			     end;
			end;

/* were there any conditions seen */

		     call ioa_ ("^14xConditions: ^d", conditions);

		     expressions = 0;
		     elp = path_var.elp;
		     if elp ^= null () then do;

/* output comparison operators involving expressions */

			     call ioa_ ("^/^14xEXPRESSIONS");
			     do i = 1 to expr_list.nexprs;

				expressions = expressions + 1;
				call
				     ioa_ ("^18xCompared(^d):  ""^a""", expressions,
				     condition_array (expr_list.info.op_code (i)));
			     end;

			end;

		     call ioa_ ("^14xExpressions:  ^d", expressions);
		end;
	end;


	dcl     (i, j)		 fixed bin;	/* loop/array indexes */
	dcl     expressions		 fixed bin;	/* number of expressions seen */
	dcl     (order, conditions)	 fixed bin;	/* count of path order and conditions per T.V. */

     end;

     end mrds_dsl_permute;
