/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-04-19 by Thanh
     Nguyen. (see mrds #136)
  2) change(86-08-13,Hergert), approve(88-07-11,MCR7903),
     audit(88-07-06,Dupuis), install(88-08-01,MR12.2-1073):
     Removed changes installed on 84-11-02 to terminate domain procs. This
     slows things down and really doesnt need to be done.
                                                   END HISTORY COMMENTS */



mrds_dsl_close:
close:
     procedure ();

/* 
                   BEGIN_DESCRIPTION
   This  routine  is  to  be  called  with  "entry options (variable)", with a
   minimum  of  2 arguments, 1) a database index specifying the database to be
   closed,  and 2) an error code to be returned.  More than one database index
   may  be given.  the function performed is to "close" the database specified
   by   the  database  index  that  was  returned  from  a  previous  call  to
   mrds_dsl_open,  making  the  database  unusable  for  an  data manipulation
   operations  such  as  retrieve  or  modify.  if an error occurs, either all
   databases  in  the  list  of indexes, or none will be closed, the list will
   never be partially done.  Note that once the process of actually closing  a
   starts, any errors encountered are reported, but the database is not opened
   again.
                   END_DESCRIPTION
      
   PARAMETERS:

   database_index  - - (input) fixed bin(35), the integer returned from a call
   to  mrds_dsl_open,  specifying the database which is to be closed.  several
   database indexes may be given.

   error_code  -  -  (output)  fixed bin(35), error type encoding, 0 unless an
   error occurred.

   sub_error_  -  - (output) condition, signaled upon occurence of an error to
   provide more info



   HISTORY:

   76-02-01 R. G. Luebke: Initially written.

   77-07-01 O. Friesen: Modified to accomodate queued scope requests.

   77-11-01  R.   D.   Lackey:  Modified  to  add temporary fixed for handling
   dbcb.ret_fd_ptrs

   77-11-02 R. D. Lackey: Modified to make perm fixed to dbcb ret_fd_ptr

   79-05-31  Al  Kepner:  Modified to delete the segment for current selection
   expression allocations.

   79-07-01 Jim Gray : Rewritten to
   1) correct argument processing to leave user in known state upon error
   2) add sub_err_ reporting of errors, and structured error handling
   3) add control file closing logic for transaction mode created databases
   4) avoid calls to finish_file for non-ready files
   5) document the modules logic
   6) allow  handling  of  recursive  invocations,  so can use close as finish
   handler

   80-02-01   R.   Lackey:  Modified  to  change  call  to  mus_valid_iocb  to
   mcbm_util_$valid_iocb_detach

   80-03-01  Jim  Gray  :  Modified  to  clear  db indexes used by old version
   close/open.

   80-09-24 Jim Gray : Modified to correct control string for sub err mesg.

   80-09-30  Jim  Gray  :  Modified  to correctly get resultant model temp dir
   based on the opening index.

   80-10-20  Jim Gray : Modified to clean up temp segs now generated by search
   for tid arrays.

   80-11-03  Jim  Gray  :  Modified to change delete_$ptr to hcs_$delentry_seg
   calls for performance.

   80-11-10  Jim  Gray  : Modified to change delete_$path to hcs_$del_dir_tree
   and hcs_$delentry_file calls for performance.

   81-01-29 Jim Gray : removed references to mdbm_data_$current_version, using
   constants instead, to allow for future upgrades to db version.

   81-04-25  Jim  Gray  :  changed  declaration of mrds_data_$temp_seg_name to
   agree  with  change in mrds_data_, and increased the dbi_pic declaration to
   three digits, as part of increasing the opening capability from 64 to 128.

   81-05-29  Jim  Gray : modified to use the new resultant structure, also did
   away  with  call  to  mus_valid_iocb,  as  control  file  never used.  Also
   combined   mu_sec_close  into  this  module.   Also  changed  interface  to
   mrds_dsl_finish_file for efficiency.

   81-07-07  Rickie  E.  Brinegar : Changed calls to release_area_ to calls to
   release_temp_segments  so  that  the temporary segments are returned to the
   temporary segement free pool, and marked as free.

   82-10-06 Mike Kubicar : converted to use relation manager.  Specifically,
   the call to mrds_dsl_finish_file has been removed as this module has been
   deleted.  All scope deletion, cursor deletion, and relation closing is now
   done by this module.

   82-10-14 Davids: changed to call mu_cursor_manager_$destroy_all_no_free
   with the dbcb.cursor_ptrs_storage_ptr instead of the cursor_storage_area_ptr.
   Also to not call mu_cursor_manager_ at all if the cursor_ptrs_storage_ptr
   is null.

   82-10-15 Davids: changed so that the call to mu_cursor_manager_$destroy_all_no_free
   includes as a paramter dbcb.cursor_storage_area_ptr to conform to the new
   calling sequence of the entry.

   83-01-03 Roger Lackey : Changed in the close_database procedure ,
   call to mu_cursor_manager_$destroy_storage to 
   mu_cursor_manager_$cleanup_storage  the closing of the relation will
   be done in another place in this program.

   83-01-10  Roger Lackey : Changed to not call dbcb.relmgr_entries.close
   if oid was zero

   83-01-31  R. Harvey : Removed code to call release_temp_segment_ for the
   dbcb.*_area_ptr used by the 5 main dsl_ entries.

   83-02-01  Mike Kubicar : Added code to handle transaction processing.
   This is needed only in the delete_temp_rels procedure.  One transaction
   is started for each dm file database to be closed.

   83-02-02 Davids: Added a call to hcs_$get_uid_seg to compare the uid of the
   segment the dbc_ptr currently points to with what it was originally pointing to.
   If the uids don't match or the uid cannot be obtained it is assumed that the
   original segment has been deleted. Since the segment has been deleted there
   is no need to set the scope_lock or remove the open user so the code is skiped.
   The call to remove_resultant was taken out of the critical region protected
   by the scope lock since there was no need to have it protected. 

   83-03-11 Davids: Added calls to mu_temp_segments$delete_temp_segment to delete
   the MRDS.store, modify, delete, def_tr, and retrv temp segments.

   83-05-02 Davids: Modified to call mu_temp_segments$free_all_temp_segments or
   delete_all_temp_segments for the curdat, stadat, and selete_area segments
   (created in mrds_dsl_init_res). free is called if the segments were created
   in the pdir (determined by checking dbcb.resultant_in_pdir). delete is
   called for any other dir.

   83-05-04 Davids: Modified to remove the calls to delete the 5 dsl temp
   segments, the modules that get those temp segments now use the name
   MRDS || dbi so that they be deleted in 1 fell swoop. Same for deleting
   the rdbi segment, it was made a temp segmenbt with the same name as the
   others. Entries mu_temp_segment$delete_temp_segment and com_err_ were
   deleted.
 
   83-05-05 Davids: Changed calls to free_all_temp_segments to calls to
   release_all_temp_segments. The difference is that a release does a
   truncate to 0 length so that when a temp segment is reused it does
   not see stuff left over from a previous use which becuase mrds expects
   that a temp segment just obtained will be nothing but 0's caused a
   problem.

   83-05-24 Davids: Renamed the variable info_ptr to unused_ptr because
   the name info_ptr now has a ambiguous reference with a structure
   in the mrds_start_transaction include file and a name change is needed
   in order to compile and second the pointer is never used for anything.

   83-06-20 Davids: Removed check for old version database and the call
   to v1 code if it was an old version db (old version dbs can no longer
   be opened). Also removed overhead of checking to be sure that old version
   db indicies and new version db indices were not given in the same call -
   minor performance improvement.

   84-11-02 Thanh Nguyen: Added code to check and terminate all of the
   reference names of the check, encode, or decode procedure.

*/
%page;
/* check for valid argument list */

	num_ptrs = 0;
	call cu_$arg_list_ptr (al_ptr);		/* get number of arguments */
	nargs = arg_list.desc_count / 2;		/* = arg_count, if called with entry options(variable) */

	if nargs < 2 then do;
		call
		     sub_err_ (error_table_$wrong_no_of_args, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a ^a",
		     "The number of arguments =", arg_list.arg_count / 2, "was less than the minimum of 2,",
		     "or the entry was not declared ""options (variable)"".");
	     end;
	else do;

/* initialize the error code argument */

		if arg_list.code = SPECIAL then
		     desc_index = nargs + 1;
		else desc_index = nargs;
		num_ptrs = desc_index + nargs;	/* arg_list ptr array size */
		desc_ptr = arg_list.arg_des_ptr (desc_index + nargs);
						/* last arg descriptor */

		if desc_ptr -> descriptor_ovrly ^= fixed_bin_35_descr then
		     call
			sub_err_ (error_table_$bad_arg, caller_name, continue, unused_ptr, return_value, "^/^a",
			"The error code(last) argument is not declared ""fixed binary (35) aligned"".");
		else do;

			error_code_ptr = arg_list.arg_des_ptr (nargs);
			error_code, code = 0;	/* initialize */

/* initialize the "databases to be closed" list */

			work_area_ptr, db_close_list_ptr = null ();
			call get_temp_segment_ (caller_name, work_area_ptr, error_code);
			if error_code ^= 0 then
			     call
				sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a",
				"Unable to obtain a temporary segment for work space.");
			else do;

				work_area_ptr -> work_area = empty ();
				clean_up_condition = OFF;

				on cleanup
				     begin;	/* in case user does quit/release */
					clean_up_condition = ON;
					if ^substr (db_mrds_dsl_close, 1, 1) then
					     ;
					else on sub_error_ ; /* ignore sub_err_ calls during cleanup */
					call clean_up ();
				     end;

				on seg_fault_error goto exit; /* in case segment deleted via previous invocation */

/* process the list of database indexes for databases to be closed,
   making a list to be closed, if the database indexes are valid,
   and are not duplicated, by saving the resultant model pointers */

				arg_count = 1;
				do while (arg_count < nargs & error_code = 0);

				     call
					mu_convert_parameter$convert_input_parameter (arg_list.arg_des_ptr (arg_count),
					arg_list.arg_des_ptr (desc_index + arg_count), dbi_ptr, addr (fixed_bin_35_descr), work_area_ptr, error_code);
				     if error_code ^= 0 then do;
					     call
						sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a",
						"Database index argument in position", arg_count,
						"could not be converted to ""fixed binary (35) aligned"".");
					end;

/* make sure that this database index refers to a currently open database */

				     else if ^valid_index () then
					;

/* check for list duplicates */

				     else if ^unique_index () then
					;

/* add the index, and it's resultant model pointer to the close list */

				     else call add_index ();

/* advance to the next database index argument */

				     arg_count = arg_count + 1;

				end;

				if error_code ^= 0 then
				     ;
				else do;

/* process the list of valid/unique databases to be closed */

					proc_id = get_process_id_ ();

					do db_close_ptr = db_close_list_ptr repeat db_close.next while (db_close_ptr ^= null ());

/* when this point is successfully reached, all databases in the "close list"
   will be forcefully closed, that is closing will go to completion, ignoring
   errors encountered, with only the first error encountered being returned
   in the error code(others reported via sub_err_), and an error upon closing
   the first database in the list will not affect later closings
   this allows close to be used as a finish/cleanup handler & leaves user in known state */

					     call close_database ();

					end;
				     end;

/* get rid of the "close list" now that processing is complete */

exit:
				call clean_up ();

			     end;
		     end;
	     end;
%page;
valid_index:
     procedure () returns (bit (1));

/* check that the current database index refers to a database open by this process
   and set a pointer to the resultant model if the index is good */

	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
						/* look up db in table */

	if dbcb_ptr ^= null () then
	     valid = ON;

	else do;
		valid = OFF;
		error_code = mrds_error_$invalid_db_index;
		call
		     sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a", "The database index =", db_index,
		     "does not refer to a database open by this process.");
	     end;


	return (valid);


	dcl     valid		 bit (1);		/* on => good index */

     end;
%page;
unique_index:
     procedure () returns (bit (1));

/* check that this index has not apeared before in the close list */

	unique = ON;

	do db_close_ptr = db_close_list_ptr repeat db_close.next while (db_close_ptr ^= null () & error_code = 0);

	     if db_close.index ^= db_index then
		;
	     else do;

		     unique = OFF;
		     error_code = mrds_error_$list_duplicate;
		     call
			sub_err_ (error_code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ^a", "The database index =", db_index,
			"appears more than once in the argument list.");

		end;

	end;


	return (unique);


	dcl     unique		 bit (1);		/* on => good index */

     end;
%page;
add_index:
     procedure ();

/* add this index to the list of databases to be closed */

	allocate db_close set (db_close_ptr) in (work_area);

	db_close.index = db_index;
	db_close.dbcb_ptr = dbcb_ptr;
	db_close.next = null ();

/* link into the current list in user order */

	if db_close_list_ptr = null () then do;		/* first time */
		last_db_close_ptr = db_close_ptr;
		db_close_list_ptr = db_close_ptr;
	     end;
	else do;
		last_db_close_ptr -> db_close.next = db_close_ptr;
		last_db_close_ptr = db_close_ptr;
	     end;

     end;
%page;
close_database:
     procedure ();

/* This routine closes one database per call, using the database index,
   and resultant model pointer passed to it
*/

	dbcb_ptr = db_close.dbcb_ptr;
	close_index = db_close.index;
	rdbi_ptr = dbcb_ptr -> dbcb.rdbi_ptr;
	if rdbi_ptr = null () then
	     ;					/* no secure portion */
	else do;
		rmra_ptr = rm_db_info.ra_ptr;
		secured = "0"b;
		dbc_ptr = dbcb.dbc_ptr;

/* Files still in the ready state must be cleaned up.  That is, all scopes must
   be deleted in them. */

		call finish_files ();

/* temporary relations must be cleaned up */

		call delete_temp_rels ();

/* Close all non-temporary relations   */

		do x = 1 to rm_db_info.ra_ptr -> rm_rel_array.num_rels;

		     if rm_db_info.ra_ptr -> rm_rel_array.rel_data (x).ri_ptr ^= null then do;

			     oid = rm_db_info.ra_ptr -> rm_rel_array.rel_data (x).ri_ptr -> rm_rel_info.opening_id;
			     if oid ^= "0"b then do;
				     call dbcb.relmgr_entries.close (oid, code);
				     if code ^= 0 then call sub_err_ (code, caller_name,
					     continue, unused_ptr, return_value, "^/^a  ^a",
					     "Unable to close relation",
					     rm_db_info.ra_ptr -> rm_rel_array.rel_data (x).ri_ptr -> rm_rel_info.name);
				end;
			end;
		end;

/* Now delete all cursors and close the database */

		if dbcb.cursor_ptrs_storage_ptr ^= null ()
		then do;
			call mu_cursor_manager_$cleanup_storage (
			     dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr, code);
			if code ^= 0
			then call sub_err_ (code, caller_name, continue,
				unused_ptr, return_value,
				"^/Cursor storage could not be deleted.");
		     end;

/* set scope lock around critical section of database closing */

		temp_uid = "0"b;
		call hcs_$get_uid_seg (dbc_ptr, temp_uid, code);
		if code = 0 & dbcb.dbc_uid = temp_uid
		then do;
			call set_lock_$lock (dbc.scope_lock, mrds_data_$lock_wait_time, code);
			if code ^= 0 & /* allow recursion into this critical region */
			     ^(code = error_table_$invalid_lock_reset | code = error_table_$locked_by_this_process) then do;
				dbc.trouble_switch = "1"b;
				error_code = mrds_error_$inconsistent_close;
				call
				     sub_err_ (code, caller_name, continue, unused_ptr, continue, "^/^a ^d",
				     "Unable to set scope lock for this database index =", close_index);
			     end;
			else call remove_open_user ();
			call set_lock_$unlock (dbc.scope_lock, code);
			if code = 0 | code = error_table_$lock_not_locked then
			     ;			/* in case of recursion or locking error */
			else do;
				call
				     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d",
				     "Unable to unlock scope for database index =", close_index);
				if error_code ^= 0 then
				     ;
				else error_code = code;
			     end;
		     end;
		call remove_resultant ();

	     end;
     end;
%page;
delete_file_scope: procedure ();

/* remove this files scope prevent and permit operations from the active scopes */

	scope_ptr = dbcb.scope_ptr;
	dbc_ptr = dbcb.dbc_ptr;

	if dbc_ptr = null () | scope_ptr = null () then ; /* never set */
	else do;

		if scope_info.active_scopes = 0 then ;	/* nothing to do */
		else do;

/* find the file name in the scope array */

			found = "0"b;
			do i = 1 to scope_info.active_scopes while (^found);

			     if rm_rel_info.model_name ^= scope_info.scope.name (i) then ;
			     else do;
				     found = "1"b;

/* set the prevent/permit op codes from the scope for this file */

				     perm = NO_OP;
				     prev = NO_OP;

				     if scope_info.scope (i).flags.permits.read_attr then
					perm = perm + READ_ATTR;
				     if scope_info.scope (i).flags.permits.append_tuple then
					perm = perm + APPEND_TUPLE;
				     if scope_info.scope (i).flags.permits.delete_tuple then
					perm = perm + DELETE_TUPLE;
				     if scope_info.scope (i).flags.permits.modify_attr then
					perm = perm + MODIFY_ATTR;

				     if scope_info.scope (i).flags.prevents.read_attr then
					prev = prev + READ_ATTR;
				     if scope_info.scope (i).flags.prevents.append_tuple then
					prev = prev + APPEND_TUPLE;
				     if scope_info.scope (i).flags.prevents.delete_tuple then
					prev = prev + DELETE_TUPLE;
				     if scope_info.scope (i).flags.prevents.modify_attr then
					prev = prev + MODIFY_ATTR;

/* go delete the scope for this file */

				     call mrds_dsl_dl_fscope (dbcb.dbi, scope_info.scope.sm_name (i), perm, prev, code);
				     if code = 0 then ;
				     else if code = mrds_error_$unknown_proc_id then code = 0; /* amdb done on dbc */
				     else do;
					     call sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a^a^a",
						"Unable to delete scope for file """, scope_info.scope.sm_name (i), """ during finish of file.");
					     if error_code ^= 0 then ;
					     else error_code = code;
					end;

				end;

			end;

		     end;

	     end;

	declare found		 bit (1);		/* on => file found in scope array, quit search */
	declare (perm, prev)	 fixed bin (35);	/* permit and prevent bits */
     end;
%page;
delete_temp_rels:
     procedure ();


/*  First of all, start a transaction if necessary */

	mstxn_transactions_needed = dbcb.transactions_needed;
	mstxn_txn_id = "0"b;
	on cleanup call mstxn_cleanup;
	on any_other call mstxn_any_other;
%include mrds_start_transaction;
	if mstxn_code ^= 0
	then call sub_err_ (mstxn_code, caller_name, continue, unused_ptr,
		return_value, "^/A transaction could not be started for database index ^d.  ^/Error occurred while releasing tempory relation storage.", close_index);

	dbcb.user_started_transaction = user_started_transaction;

/* delete any temporary relation definitions remaining */

	if rm_db_info.tra_ptr -> rm_rel_array.num_rels > 0 then do;

/* Close all the open temporary relations */

		call mrds_dsl_define_temp_rel$del_trels (dbcb_ptr); /* delete any temp rels */

/* now remove the storage areas for temporary relations, now that they are no longer needed */

		if dbcb.retr_info_ptr = null () & dbcb.trel_info_ptr = null () then
		     ;
		else do;

			resultant_dir = mrds_dsl_resultant_storage$get_opening_temp_dir (close_index, code);
			if code ^= 0 then do;
				if error_code ^= 0 then
				     ;
				else error_code = code;
				call
				     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d",
				     "Unable to get the resultant model temporary directory for database index =",
				     close_index);
			     end;
			else do;

				do x = 1 by 1 to mrds_data_$max_sets;

				     if dbcb.retr_info_ptr = null () then
					;
				     else do;

					     fd_ptr = retrieve_info.ret_fd_ptr (x);
					     if fd_ptr = null () then
						;
					     else do;
						     vfile_type = "retrieve info";
						     call delete_vfile_seg ();
						     retrieve_info.ret_fd_ptr (x) = null ();
						end;

					end;

				     if dbcb.trel_info_ptr = null () then
					;
				     else do;

					     fd_ptr = trel_info.fd_ptr (x);
					     if fd_ptr = null () then
						;
					     else do;
						     vfile_type = "temp rel info";
						     call delete_vfile_seg ();
						     trel_info.fd_ptr (x) = null ();
						end;
					end;
				end;
			     end;
		     end;

	     end;

/* Finish the transaction.  If an error occurred, ignore it */

	mftxn_code = 0;
%include mrds_finish_transaction;
	if mftxn_code ^= 0
	then call sub_err_ (mftxn_code, caller_name, continue, unused_ptr,
		return_value, "^/A transaction could not be finished for database index ^d.  ^/Error occurred while releasing tempory relation storage.", close_index);


/***********
*
*   These routines are used by the transaction processing include files.
*   Restore_significant_data is called to reinitialize variables in case
*   of a rollback.  Should_rollback determines whether a transaction should
*   be rolled back or aborted on error.  Currently, it is always aborted.
*
**********/


restore_significant_data:
     proc;
     end restore_significant_data;



should_rollback:
     proc returns (bit (1));
	return ("0"b);
						/* There are no known cirumstances where a rollback is meaningful */
     end should_rollback;


     end delete_temp_rels;
%page;
finish_files:
     procedure ();

/* delete scopes on all files that the user has left still readied */

	do j = 1 to rm_rel_array.num_rels;

	     rmri_ptr = rm_rel_array.rel_data (j).ri_ptr;
	     call delete_file_scope ();

/* any errors were reported in the lower routine */

	     if code = 0 | error_code ^= 0 then
		;
	     else error_code = code;

	end;


     end;
%page;
remove_open_user:
     procedure ();

/* take this user out of the list of database openers */

	ul_ptr = pointer (dbc_ptr, dbc.open_users_ofs);

/* find the user in the list of database openers */

	do while (rel (ul_ptr) ^= NULL_OFFSET);

	     next_ul_ptr = pointer (dbc_ptr, user_list.next_open_ofs);

/* is this the right user in the list */

	     if user_list.process_id ^= proc_id then
		;
	     else do;

/* check that this is the right opening instance for this user in the user list */

		     if user_list.rdbi_bits ^= addr (rdbi_ptr) -> ptr_bit_string then
			;
		     else do;

/* correct opening instance, remove the user from the list of openers */

			     call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, code);
			     if code = 0 | code = error_table_$locked_by_this_process then
				;		/* allow recursion */
			     else do;
				     if error_code ^= 0 then
					;
				     else error_code = code;
				     call
					sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d",
					"Unable to remove this user from the list of database openers for database index =", close_index);
				end;

			     next_ul_ptr = pointer (null, NULL_OFFSET); /* set to exit loop */

			end;

		end;

/* go to next user in open list */

	     ul_ptr = next_ul_ptr;
	end;


     end;
%page;
remove_resultant:
     procedure ();

/* the secure and non-secure portions of the resultant model
   must be removed, since they are no longer needed */


/* close the secure portion of the resultant */

	if rdbi_ptr ^= null ()			/* clean up the extensible area */
	then call release_area_ (addr (rdbi_ptr -> rm_db_info.static_area));

	dbi_pic = dbcb.dbi;				/* format db opening index */

/* cleanup most of the temp segements created */

	if dbcb.resultant_in_pdir			/* segments in pdir may be resused */
	then call mu_temp_segments$release_all_temp_segments ("MRDS" || dbi_pic, code);
	else call mu_temp_segments$delete_all_temp_segments ("MRDS" || dbi_pic, code);
	if code ^= 0 & code ^= error_table_$argerr
	then call sub_err_ (code, caller_name, continue, unused_ptr, return_value,
		"Could not clean up the temp segments created.");

/* cleanup the rest */

	temp_seg_name = mrds_data_$temp_seg_name || dbi_pic; /* name for temp segs */
	if dbcb.resultant_in_pdir
	then call mu_temp_segments$release_all_temp_segments (temp_seg_name, code);
	else call mu_temp_segments$delete_all_temp_segments (temp_seg_name, code);
	if code ^= 0 & code ^= error_table_$argerr
	then call sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a",
		"Unable to release tid array search temp segs using the name:", temp_seg_name);


	call mu_database_index$reset_resultant_model_pointer (close_index, (dbcb_ptr));
						/* clear table entry */
	call hcs_$delentry_seg (dbcb_ptr, code);	/* delete dbcb */
	if code = 0 | code = error_table_$invalidsegno then
	     ;					/* previous invocation could have deleted */
	else do;
		if error_code ^= 0 then
		     ;
		else error_code = code;
		call
		     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^d ",
		     "Unable to delete the resultant model non-secure segment for database index =", close_index);
	     end;
	dbcb_ptr = null ();
     end;
%page;
delete_vfile_seg:
     procedure ();

/* routine to close, detach, and delete a vfile */

	if fd.iocb_ptr = null () then
	     ;
	else do;

		call iox_$close (fd.iocb_ptr, code);
		if code = 0 then
		     ;
		else do;
			if error_code ^= 0 then
			     ;
			else error_code = code;
			call
			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a ^a ^d", "Unable to close a", vfile_type,
			     "vfile for database index =", close_index);
		     end;

		call iox_$detach_iocb (fd.iocb_ptr, code);
		if code = 0 then
		     ;
		else do;
			if error_code ^= 0 then
			     ;
			else error_code = code;
			call
			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a ^a ^d", "Unable to detach a", vfile_type,
			     "vfile for database index =", close_index);
		     end;

		call iox_$destroy_iocb (fd.iocb_ptr, code);
		if code = 0 then
		     ;
		else do;
			if error_code ^= 0 then
			     ;
			else error_code = code;
			call
			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a ^a ^a ^d", "Unable to destroy a", vfile_type,
			     "vfile iocb for database index =", close_index);
		     end;

		fd.iocb_ptr = null ();

		if fd.name = BLANK then
		     ;
		else do;

			begin;

			     call hcs_$del_dir_tree (resultant_dir, (fd.name), code);
			     if code = error_table_$notadir | code = 0 then
				call hcs_$delentry_file (resultant_dir, (fd.name), code);

			     dcl	   hcs_$del_dir_tree      entry (char (*), char (*), fixed bin (35));
						/* deletes sub directory contents */
			     dcl	   hcs_$delentry_file     entry (char (*), char (*), fixed bin (35));
						/* deletes segs and empty dirs */
			     dcl	   error_table_$notadir   fixed bin (35) ext; /* entry was not a directory */

			end;

			if code = 0 then
			     ;
			else do;
				if error_code ^= 0 then
				     ;
				else error_code = code;
				call
				     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a^a^a ^a ^a ^d",
				     "Unable to delete the segment """, fd.name, """ for a", vfile_type, "vfile for database index =", close_index);
			     end;

			fd.name = BLANK;

		     end;

	     end;


     end;
%page;
clean_up:
     procedure ();

/* remove the "close list" working area */

	if work_area_ptr = null () then
	     ;
	else do;

		call release_temp_segment_ (caller_name, work_area_ptr, code);
		if code = 0 then
		     ;
		else do;
			if error_code ^= 0 then
			     ;
			else error_code = code;
			call
			     sub_err_ (code, caller_name, continue, unused_ptr, return_value, "^/^a",
			     "Unable to release the working space temporary segment.");
		     end;

		work_area_ptr = null ();

	     end;




     end;
%page;
	dcl     db_index		 fixed bin (35) based (dbi_ptr), /* data base index of db to close (input) */
	        error_code		 fixed bin (35) based (error_code_ptr); /* status return error_code */

	dcl     (
	        nargs,				/* number of args */
	        i,
	        x,
	        j
	        )			 fixed bin;	/* length of argument */

	dcl     resultant_dir	 char (168);	/* resultant model directory pathname */
	dcl     secured		 bit (1) unal;	/* on if db is secured */

	dcl     proc_id		 bit (36) aligned;	/* process id for this user */

	dcl     (dbi_ptr, error_code_ptr) ptr;

	dcl     next_ul_ptr		 ptr;		/* ptr to next user_list entry */
	dcl     ptr_bit_string	 bit (72) unal based; /* bit string format of pointer */
	dcl     code		 fixed bin (35);	/* internal status code */

	dcl     never_readied	 bit (36) init ((36)"0"b); /* if file_array.id = this, then never readied */
	dcl     temp_uid		 bit (36) aligned;	/* uid of segment that dbc_ptr currently points to */

/*		Multics subroutines 		*/

	dcl     cu_$arg_list_ptr	 entry (ptr),
	        hcs_$delentry_seg	 entry (ptr, fixed bin (35)), /* deletes segs without ref names */
	        hcs_$get_uid_seg	 entry (ptr, bit (36) aligned, fixed bin (35)),
	        get_process_id_	 entry returns (bit (36)),
	        iox_$close		 entry (ptr, fixed bin (35)),
	        iox_$detach_iocb	 entry (ptr, fixed bin (35)),
	        iox_$destroy_iocb	 entry (ptr, fixed bin (35)),
	        set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
	dcl     mu_temp_segments$delete_all_temp_segments entry (char (*), fixed bin (35));
						/* cleans up search temp segs */
	dcl     mu_temp_segments$release_all_temp_segments entry (char (*), fixed bin (35));
	dcl     dbi_pic		 pic "999";	/* format for database index in temp seg name */
	dcl     temp_seg_name	 char (26);	/* name used for search temp segs */

/*		other subroutines		*/

	dcl     mu_database_index$reset_resultant_model_pointer entry (fixed bin (35), ptr),
	        mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr),
	        mrds_dsl_define_temp_rel$del_trels entry (ptr),
	        mu_de_queue_user	 entry (bit (1), bit (1), ptr, ptr, fixed bin (35));

/*		external data		*/

	dcl     sub_err_		 entry options (variable); /* error reporting routine */
	dcl     caller_name		 char (15) init ("mrds_dsl_close"); /* name of calling routine */
	dcl     continue		 char (1) init ("c"); /* continue after printing err mesg */
	dcl     unused_ptr		 ptr init (null ());/* unused */
	dcl     return_value	 fixed bin (35) init (0); /* unused */
	dcl     OFF		 bit (1) init ("0"b); /* false */
	dcl     ON		 bit (1) init ("1"b); /* true */
	dcl     1 db_close		 aligned based (db_close_ptr), /* list element for database to close */
		2 next		 ptr,		/* to next database on list */
		2 index		 fixed bin (35),	/* database index */
		2 dbcb_ptr	 ptr;		/* pointer to resultant */
	dcl     db_close_ptr	 ptr;		/* points to close list element */
	dcl     db_close_list_ptr	 ptr;		/* points to head of list */
	dcl     last_db_close_ptr	 ptr;		/* points to last on list */
	dcl     arg_count		 fixed bin;	/* current argument number */
	dcl     mrds_error_$invalid_db_index fixed bin (35) ext,
	        error_table_$wrong_no_of_args fixed bin (35) ext, /* <2 arguments */
	        mrds_error_$list_duplicate fixed bin (35) ext, /* index >1 times in list */
	        mrds_data_$lock_wait_time fixed bin ext,
	        mrds_data_$max_sets	 fixed bin ext,
	        mrds_data_$max_data_length fixed bin ext,
	        mrds_error_$inconsistent_close fixed bin (35) ext,
	        error_table_$locked_by_this_process fixed bin (35) ext,
	        error_table_$invalid_lock_reset fixed bin (35) ext,
	        sys_info$max_seg_size	 fixed bin (35) ext;
	dcl     work_area		 area (1024) based (work_area_ptr); /* space for close list */
	dcl     work_area_ptr	 ptr;		/* points to close list area */
	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
						/* gets working space */
	dcl     NOT_READY		 bit (1) init ("0"b); /* file not currently readied */
	dcl     NULL_OFFSET		 bit (18) init ((18)"1"b); /* mrds version of null offset */
	dcl     vfile_type		 char (20) varying; /* retrieve info, or temp rel info */
	dcl     any_other		 condition;
	dcl     cleanup		 condition;	/* signaled during release */
	dcl     clean_up_condition	 bit (1);		/* on => cleanup signaled */
	dcl     BLANK		 char (1) init (" "); /* space character */
	dcl     close_index		 fixed bin (35);	/* local version of db_index */
	dcl     sub_error_		 condition;	/* signaled by sub_err_ call */
	dcl     mrds_error_$unknown_proc_id fixed bin (35) ext; /* Process not known to mrds database */
	dcl     mrds_data_$temp_seg_name char (23) ext;	/* common name for temp segments */
	dcl     error_table_$bad_arg	 fixed bin (35) ext;/* bad subroutine argument */
	dcl     error_table_$argerr	 fixed bin (35) ext;/* given if no temp segs of given name found */
	dcl     descriptor_ovrly	 bit (36) unal based; /* overlay for descriptor word */
	dcl     desc_index		 fixed bin;	/* offset to start of descriptor ptrs in arg list */
	dcl     SPECIAL		 fixed bin init (8);/* => extra ptr in arg_list */
	dcl     fixed_bin_35_descr	 bit (36) init ("100000100000000000000000000000100011"b);
						/* descriptor for fixed bin(35) */
	dcl     seg_fault_error	 condition;	/* signaled when invalid segment number used */
	dcl     error_table_$lock_not_locked fixed bin (35) ext; /* lock not set */
	dcl     error_table_$invalidsegno fixed bin (35) ext; /* bad segment number */
	dcl     mu_convert_parameter$convert_input_parameter entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
						/* gets db_index  */
	dcl     mrds_dsl_dl_fscope	 entry options (variable); /* Delete db scopes */
	dcl     mu_cursor_manager_$cleanup_storage entry (ptr, ptr, fixed bin (35));
	dcl     release_area_	 entry (ptr);	/* cleans up define_area_ areas */
	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
						/* removes temp work space */
	dcl     oid		 bit (36) aligned;
	dcl     mrds_dsl_resultant_storage$get_opening_temp_dir entry (fixed bin (35), fixed bin (35)) returns (char (168));
						/* gets temp dir for db_index */
	dcl     (addr, empty, fixed, null, pointer, rel, substr) builtin;
%page;
%include mdbm_rm_db_info;
%page;
%include mdbm_rm_rel_info;
%page;
%include mdbm_rm_rel_array;
%page;
%include mdbm_scope_info;
%page;
%include mrds_dbcb;
%page;
%include mdbm_dbc;
%page;
%include mdbm_users;
%page;
%include mdbm_descriptor;
%page;
%include mdbm_arg_list;
%page;
%include mrds_fd;
%page;
%include mrds_new_scope_modes;
%page;
%include mrds_retrieve_info;
%page;
%include mrds_trel_info;
%page;
%include mrds_debug_names;
     end;

