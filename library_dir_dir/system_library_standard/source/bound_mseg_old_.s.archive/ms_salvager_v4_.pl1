/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


ms_salvager_v4_: proc (a_mptr, a_code);

/* Modified for version 3 message segments by J. Stern, 10/30/74 */
/* Modified to use mseg_error_ by J. Stern, 11/12/75 */

dcl (
     mseg_dir,					/* mseg directory name */
     comp1)					/* 1st component of directory name */
     char (168);

dcl (
     mseg_name,					/* mseg entryname */
     comp2)					/* 2nd component of directory name */
     char (32);

dcl (
     i,						/* do loop index */
     dir_len,					/* length of mseg directory */
     saved_blocks init (0),				/* number of saved message blocks */
     saved_messages init (0),				/* number of saved messages (internal) */
     original_messages,				/* number of messages before salvaging */
     tsaved_blocks,					/* number of saved blocks per pass */
     tsaved_messages)				/* number of saved messages per pass */
     fixed bin;

dcl (alloc_len,					/* length of allocation bit string */
     block_offset,					/* offset to a message block */
     block_size,					/* size of message block */
     hdr_alloc_len,					/* number of allocation bits used for header */
     mseg_data_v4_$block_size ext,
     seg_size,					/* maximum size of a segment */
     hdr_size,					/* number of words in header before alloc_bits */
     trailer_offset) fixed bin (18);

dcl (
     a_code,					/* error code (argument) */
     code,					/* error code, (internal) */
     error_table_$fatal_error ext
     ) fixed bin (35);

dcl  reason char (40);				/* reason for salvager failure */

dcl  forward bit (1) aligned;				/* ON if salvage is forward */

dcl (addr, addrel, bit, divide, fixed, null, ptr, rel, size, substr) builtin;

dcl (a_mptr,					/* pointer to message segment (argument) */
     end_ptr,					/* pointer to last message for salvage pass */
     last_backward_ptr init (null),			/* pointer to last saved message in backward salvage */
     last_forward_ptr init (null),			/* pointer to last saved message in forward salvage */
     last_saved_ms_ptr,				/* pointer to last message saved in a pass */
     salv_ptr)					/* pointer to beginning point for salvage */
     ptr;

dcl  mseg_access_class bit (72) aligned;		/* message segment access class */

dcl  hdr_ms_mask bit (36*max_hdr_ms_len) aligned based;	/* for zeroing out header message */

dcl  ring_brackets (3) fixed bin(3) init(1,4,4);		/* for setting ring brackets of copy */

dcl 1 new_hash_table aligned,				/* hash table regenerated by salvage */
    2 last_in_bucket (0:511) bit (18) unaligned init ((512) (18) "0"b);

/*  */

%include mseg_hdr_v4;
declare version_number fixed bin init (4) int static options (constant);
dcl      header_pattern bit (36) aligned init ((18) "01"b);	/* header identification pattern */
 declare mptr pointer;
%include ms_block_trailer_v4;


dcl  admin_gate_$guaranteed_eligibility_on ext entry;

dcl  expand_path_ ext entry
    (ptr, fixed bin, ptr, ptr, fixed bin (35));

dcl  copy_seg_$no_message entry
    (char(*), char(*), char(*), char(*), char(*), bit(1) aligned, fixed bin(35));

dcl  hcs_$get_max_length_seg entry (ptr, fixed bin (18), fixed bin (35));

dcl  hcs_$set_ring_brackets ext entry
    (char (*), char (*), (3) fixed bin (3), fixed bin (35));

dcl  hcs_$truncate_seg ext entry
    (ptr, fixed bin (18), fixed bin (35));

dcl  read_allowed_ entry
    (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);

dcl  hcs_$fs_get_path_name entry
    (ptr, char(*), fixed bin, char(*), fixed bin(35));

dcl  hcs_$get_access_class_seg ext entry
    (ptr, bit (72) aligned, fixed bin (35));

dcl  ms_salv_util_v4_ ext entry
    (bit (1) aligned, ptr, ptr, ptr, fixed bin (18), fixed bin (18), fixed bin (18), fixed bin (18),
     bit (72) aligned, fixed bin, fixed bin, ptr);

dcl  mseg_error_v4_ entry options (variable);

dcl  set_lock_$lock ext entry
    (bit (36)aligned, fixed bin, fixed bin (35));

/*  */

	mptr = a_mptr;				/* copy argument */

	call admin_gate_$guaranteed_eligibility_on ();	/* lock the message segment in case */
	call set_lock_$lock (mptr -> mseg_hdr_v4.lock, 20, code);	/* it is not already locked */

	call hcs_$get_access_class_seg (mptr, mseg_access_class, code);
	if code ^= 0 then do;
	     reason = "Cannot get access class.";
	     go to GRIPE;
	end;

	call hcs_$get_max_length_seg (mptr, seg_size, code);
	if code ^= 0 then do;
	     reason = "Cannot get max length.";
	     go to GRIPE;
	end;

	mptr -> mseg_hdr_v4.switches.sip = "1"b;			/* turn on "salvage in progress" flag */

	block_size = fixed (mptr -> mseg_hdr_v4.block_size, 18);	/* fetch block size */
	if block_size <= 0 | block_size > seg_size
	then block_size = fixed (mseg_data_v4_$block_size, 18); /* take default and hope it's right */

	alloc_len = divide (seg_size, block_size, 18, 0); /* compute length of allocation bits */

	hdr_size = divide ((fixed (rel (addr (mptr -> mseg_hdr_v4.alloc_bits)), 18))*36 + alloc_len+35, 36, 18, 0);

	if hdr_size > seg_size then do;		/* forget it */
	     code = error_table_$fatal_error;
	     go to FIN;
	end;

	hdr_alloc_len = divide (hdr_size+block_size-1, block_size, 18, 0); /* compute alloc bits used by header */

	trailer_offset = fixed (block_size-size (ms_block_trailer), 18); /* compute trailer offset */

	original_messages = mptr -> mseg_hdr_v4.number_of_messages;

/*  */

	begin;

dcl  new_alloc_bits bit (alloc_len) init (""b) aligned;	/* new allocation bit string */

	     do i = 1 to hdr_alloc_len;		/* turn on header allocation bits */
		substr (new_alloc_bits, i, 1) = "1"b;
	     end;

	     if mptr -> mseg_hdr_v4.first_ms_offset ^= ""b		/* non-zero first message offset */
	     then do;				/* set up for forward salvage */
		salv_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18));
		end_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18));
		forward = "1"b;			/* first attempt forward salvage */
	     end;
	     else go to BACKWARD;			/* try backward salvage */

/* salvage */

SALVAGE_LOOP:

	     tsaved_messages = 0;			/* initialize number of saved messages per pass */
	     last_saved_ms_ptr = null;		/* initialize pointer to last saved message */
	     call ms_salv_util_v4_
		(forward, salv_ptr, addr (new_alloc_bits), addr (new_hash_table),
		block_size, seg_size, alloc_len, hdr_alloc_len, mseg_access_class,
		tsaved_messages, tsaved_blocks, last_saved_ms_ptr);
	     saved_messages =			/* add in number of saved messages */
		saved_messages + tsaved_messages;
	     saved_blocks =				/* add in number of saved blocks */
		saved_blocks + tsaved_blocks;
	     if last_saved_ms_ptr = end_ptr		/* total success? */
	     then go to REST_OF_HEADER;

	     if tsaved_messages ^= 0			/* partial success? */
	     then do;				/* yes */

		if (forward)			/* forward salvage? */
		then last_forward_ptr =		/* yes, save pointer to last good message */
		     last_saved_ms_ptr;

		else				/* backward salvage */
		last_backward_ptr =			/* save pointer to last good message */
		     last_saved_ms_ptr;

	     end;

	     if (forward)				/* first pass at salvaging? */
	     then
BACKWARD:		if mptr -> mseg_hdr_v4.last_ms_offset ^= ""b	/* non-zero last message offset */
		then do;				/* yes, prepare for next pass */
		     forward = "0"b;		/* set direction of salvage */
		     salv_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18)); /* set salvaging pointer */
		     end_ptr = ptr (mptr, fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18)); /* set hopeful end of salvage ptr */
		     go to SALVAGE_LOOP;
		end;

/*  */

/* join message fragments */

	     if saved_messages ^= 0			/* any success in salvaging? */
	     then do;				/* yes */

		if last_forward_ptr ^= null		/* forward salvage partly successful */
		then do;				/* yes */

		     if last_backward_ptr ^= null	/* backward salvage partly successful? */
		     then do;			/* yes */
			addrel (last_forward_ptr, trailer_offset) -> ms_block_trailer.f_offset =
			     bit (fixed (rel (last_backward_ptr), 18), 18);
			addrel (last_backward_ptr, trailer_offset) -> ms_block_trailer.b_offset =
			     bit (fixed (rel (last_forward_ptr), 18), 18);
		     end;

		     else				/* backward salvage unsuccessful */
		     do;
			mptr -> mseg_hdr_v4.last_ms_offset =	/* reset last message offset in header */
			     bit (fixed (rel (last_forward_ptr), 18), 18);
			addrel (last_forward_ptr, trailer_offset) -> ms_block_trailer.f_offset =
			     "0"b;		/* zero out next offset of new last message */
		     end;

		end;

		else				/* forward salvage no good */
		do;				/* backward salvage must have been */
		     mptr -> mseg_hdr_v4.first_ms_offset =	/* reset first message offset */
			bit (fixed (rel (last_backward_ptr), 18), 18);
		     addrel (last_backward_ptr, trailer_offset) -> ms_block_trailer.b_offset =
			"0"b;			/* zero prev message offset of new 1st message */
		end;

	     end;

	     else					/* no messages saved */
	     mptr -> mseg_hdr_v4.first_ms_offset,
		mptr -> mseg_hdr_v4.last_ms_offset = (18) "0"b;	/* zero first and last offsets */

REST_OF_HEADER:

	     i = alloc_len - index (reverse (new_alloc_bits), "1"b) +1; /* get last used block index */
	     block_offset = i * block_size;		/* get offset of end of last block */
	     call hcs_$truncate_seg (mptr, block_offset, code); /* truncate to last used block */
	     mptr -> mseg_hdr_v4.block_size = block_size;		/* reset block size */
	     mptr -> mseg_hdr_v4.space_left =			/* reset space left */
		alloc_len - hdr_alloc_len - saved_blocks;
	     mptr -> mseg_hdr_v4.alloc_bits = new_alloc_bits;	/* reset allocation bit string */
	     mptr -> mseg_hdr_v4.number_of_messages = saved_messages; /* set message count */
	     mptr -> mseg_hdr_v4.alloc_len = alloc_len;		/* set allocation bits length */
	     mptr -> mseg_hdr_v4.mseg_pattern = header_pattern;	/* set header pattern */
	     mptr -> mseg_hdr_v4.version_number = version_number;	/* set version number */
	     mptr -> mseg_hdr_v4.hash_table = new_hash_table;	/* copy new hash table */

	     if mptr -> mseg_hdr_v4.switches.ms_in_hdr		/* header message exists */
	     then if ^read_allowed_ (mseg_access_class, mptr -> mseg_hdr_v4.hdr_ms_access_class) /* bad access class */
		then do;				/* wipe out header message */
		     mptr -> mseg_hdr_v4.switches.ms_in_hdr = "0"b;
ZERO_HDR_MS:	     mptr -> mseg_hdr_v4.hdr_ms = ""b;
		     mptr -> mseg_hdr_v4.hdr_ms_access_class = (72) "0"b;
		end;
		else;				/* keep header message */
	     else go to ZERO_HDR_MS;			/* just to be neat */

	     mptr -> mseg_hdr_v4.switches.mip = "0"b;		/* turn off mip bit */
	     mptr -> mseg_hdr_v4.switches.os = "1"b;		/* indicate salvage occurred */
	     mptr -> mseg_hdr_v4.switches.sip = "0"b;		/* turn off salvage in progress bit */

	end;					/* of BEGIN block */

	if original_messages > saved_messages then
	     call mseg_error_v4_ (mptr, 0, "ms_salvager_v4_", "^d message(s) may be lost.",
	     original_messages - saved_messages);

FIN:

	a_code = code;				/* return code */
	return;

GRIPE:	call mseg_error_v4_ (mptr, code, "ms_salvager_v4_", reason);
	go to FIN;

     end ms_salvager_v4_;
