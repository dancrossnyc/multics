/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(86-06-12,GJohnson), approve(86-06-12,MCR7410),
     audit(86-06-17,Martinson), install(86-06-18,MR12.0-1079):
     Changed to use iox_ user_output.
                                                   END HISTORY COMMENTS */


/* format: style2 */
explain_doc:
edoc:
     proc;


/* HISTORY:
Written by Jim Paradise, fall 1980.
Modified:
03/03/81 by M. Pierret to include request loop and allow quitting
            without closing data base.
06/04/81 M. Pierret "Another section?" to "More information?",
            added "y" as acceptable answer, made description default.
            added -no_description, -nd control arguments.
10/19/81 by M. Pierret to use display_info instead of display_flags.

03/24/83 by J. Siwila to add menu displays for 12 groups of Multics 
            manuals and substring searching of input strings for mrds,
            linus, and mrpg manuals.  Also added "n" as acceptable
            answer to prompt and took short names out of display.
04/22/83 by Matthew Pierret:  Reformatted the HISTORY section so that it is
            useable by subsys maintenance tools.  Added a DESCRIPTION section.
           Changed to set display_info.short_name_flag to off by default.
           Added an automatic local_display_info, like display_info, upon
            which display_info is based (display_info_ptr = addr
            (local_display_info)).
05/24/83 by Matthew Pierret: Changed control arg processing loop to start
            at 2 instead of 1, as the first non-null value in the 
            control_argument array is the control_argument(2).
            Changed "-pathname" to "-database_pathname" and "-pn" to "-dbpn"
            in the control_argument array. Filled out the argument_type array
            to the same extent as the control_argument array.
07/15/83 by James Siwila:  Added -no_audience, -no_table_of_contents, and 
            -no_new_features control arguments and a facility for displaying 
            the 12 manual subsets when the menu facility is not available or 
            not invoked by the user.
09/01/83 by M. Pierret:  Removed -brief control argument.
09/23/83 by M. Pierret:  General cleanup of code. Changed headers and trailers
            of menus to be slightly more descriptive.  Changed error messages
            to be more descriptive and more complete.  Added support of
            -output_file.  Changed handling of groups by setting up an include
            file of based choice arrays (on for each group) with initial
            attributes of the choices for each group.  That way the GROUP case
            statement cases are reduce to allocating the proper choices array.
            Changed display of acceptable requests to be two-columned.
            Changed default database path to >doc>facilities_data_dir.
09/29/83 by M. Pierret:  Changed to always get new opening when -dbpn is
            specified, and to close the existing opening if there is one.
            Made -output_file_sw mean also -no_request_loop.
09/30/83 by Matthew Pierret: Changed to print "explain_doc must be followed..."
            instead of "Command name must be followed..." and to use a local
            variable for the code argument instead of (0) in calls in the 
            clean_up subroutine - dsl_$close was complaining about not getting
            a correctly declared argument. Changed cleanup routines to cleanup
            the screen if use_menu is on rather than video_is_on. Changed the
            "new user" group name to "new_user".
*/

/*
DESCRIPTION:
          This command retrieves information about a Multics documentaiton 
     manual stored in the online_doc.db database, and displays that information
     for the user.
     Usage: explain_doc ID {-control_args}; where ID may be a manual order
     number (e.g., AG93) or the full name or short name of a manual.
*/


/* Automatic */

	dcl     output_switch_name	 char (32);
	dcl     manual_id		 char (64) var;
	dcl     reply		 char (256) varying;
	dcl     request		 char (256) varying;
	dcl     mrds_database_path	 char (168);
	dcl     output_file_path	 char (168);

	dcl     (
	        accept_control_argument,
	        mrds_scope_set,
	        completely_processed_reply,
	        display_all_manuals,
	        enter_request_loop	 init ("1"b),
	        manual_number_found,
	        quit_signalled
	        )			 bit (1) aligned;
	dcl     (database_path_sw, output_file_sw)
				 bit (1) aligned init ("0"b);

	dcl     1 local_display_info	 aligned like display_info;

	dcl     (accept_idx, first_delimiter, idx, manual_number, number_of_manuals, request_idx, start_idx)
				 fixed bin;
	dcl     arg_len		 fixed bin;
	dcl     arg_idx		 fixed bin;
	dcl     nargs		 fixed bin;
	dcl     control_argument_idx	 fixed bin;
	dcl     code		 fixed bin (35);
	dcl     mrds_dbi		 fixed bin (35) init (0);
	dcl     current_mrds_dbi	 fixed bin (35) init (0);

	dcl     manual_array	 (200) fixed bin;
	dcl     (arg_ptr, output_ptr, work_area_ptr)
				 ptr;

/* Based */

	dcl     arg		 based (arg_ptr) char (arg_len);
	dcl     work_area		 area (sys_info$max_seg_size) based (work_area_ptr);

/* Constant */

	dcl     control_argument	 (1:29) char (32) varying options (constant)
				 init ("explain_doc", "-output_file", "-of", "-database_pathname", "-dbpn",
				 "-description", "-desc", "-audience", "-aud", "-table_of_contents", "-toc",
				 "-new_features", "-nf", "", "", "-no_request_loop", "-nrql", "-request_loop",
				 "-rql", "-all", "-a", "-no_description", "-no_desc", "-no_audience", "-no_aud",
				 "-no_table_of_contents", "-no_toc", "-no_new_features", "-no_nf") internal static;
	dcl     argument_type	 (1:29) char (64) varying options (constant)
				 init ("manual identifier", (2) (1)"output file pathname",
				 (2) (1)"database pathname", (24) (1)"") internal static;
	dcl     myname		 char (11) options (constant) init ("explain_doc") internal static;
	dcl     acceptable_requests	 (0:16) char (17) varying int static
				 init ("", "?", "yes", "y", "no", "n", "quit", "q", "description", "desc",
				 "audience", "aud", "table_of_contents", "toc", "new_features", "nf", "all");
	dcl     (
	        QUESTION_MARK_REQUEST_IDX
				 init (1),
	        FIRST_REQUEST_IDX	 init (2),
	        FIRST_SECTION_NAME_IDX init (8)
	        )			 fixed bin internal static options (constant);
	dcl     LOWER_CASE_ALPHA	 char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
	dcl     UPPER_CASE_ALPHA	 char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

/* Builtin */

	dcl     (addr, after, before, copy, empty, hbound, index, length, ltrim, null, rtrim, string, substr, translate,
	        unspec)		 builtin;

/* Condition */

	dcl     cleanup		 condition;


/* Entry */

	dcl     absolute_pathname_	 entry (char (*), char (*), fixed bin (35));
	dcl     absolute_pathname_$add_suffix
				 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     active_fnc_err_	 entry () options (variable);
	dcl     com_err_		 entry options (variable);
	dcl     complain		 entry variable options (variable);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
	dcl     cu_$af_return_arg	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
	dcl     display_doc		 entry (ptr, fixed bin (35), fixed bin, ptr, char (*) var, fixed bin (35));
	dcl     dsl_$close		 entry () options (variable);
	dcl     dsl_$dl_scope_all	 entry (fixed binary (35), fixed binary (35));
	dcl     dsl_$open		 entry options (variable);
	dcl     dsl_$retrieve	 entry options (variable);
	dcl     dsl_$set_scope_all	 entry options (variable);
	dcl     ioa_		 entry options (variable);
	dcl     online_doc_db_index$set_index
				 entry (fixed bin (35));
	dcl     online_doc_db_index$return_index
				 entry (fixed bin (35));
	dcl     command_query_	 entry () options (variable);
	dcl     define_area_	 entry (ptr, fixed bin (35));
	dcl     release_area_	 entry (ptr);
	dcl     unique_chars_	 entry (bit (*)) returns (char (15));

/* External */

	dcl     (
	        error_table_$noarg,
	        error_table_$badopt,
	        error_table_$bad_arg,
	        error_table_$not_act_fnc,
	        error_table_$active_function,
	        error_table_$noentry,
	        mrds_error_$tuple_not_found,
	        mrds_error_$invalid_db_index
	        )			 ext fixed bin (35);
	dcl     sys_info$max_seg_size	 ext fixed bin (35);

/* Menu dcls */

	dcl     video_data_$terminal_iocb
				 ptr external;
	dcl     (video_is_on, use_menu)
				 bit (1) aligned;
	dcl     1 user_io_window_info	 like window_position_info;
	dcl     reason		 char (512);

/* END OF DECLARATIONS */

/* format: indcomtxt,^indblkcom */

	output_ptr, work_area_ptr = null;
	mrds_scope_set, use_menu = "0"b;
	video_is_on = (video_data_$terminal_iocb ^= null);

	mrds_database_path = ">doc>facilities_data_dir>online_doc.db";

	manual_id = "";

	display_info_ptr = addr (local_display_info);
	string (display_info) = "0"b;
	display_info.header.order_number_flag, display_info.header.full_name_flag,
	     display_info.header.release_supported_flag, display_info.header.revision_flag,
	     display_info.text.description_flag = "1"b;

	call cu_$af_return_arg (nargs, (null), (0), code);
	if code = 0
	then call active_fnc_err_ (error_table_$active_function, myname, "");
	else if code ^= error_table_$not_act_fnc
	then do;
		call com_err_ (code, myname);
		return;
	     end;

	complain = com_err_;

	if nargs = 0
	then do;
		call complain (error_table_$noarg, myname, "^/Usage: ^a topic_name  {-control_args}", myname);
		return;
	     end;
	accept_control_argument = "0"b;		/* First argument cannot be a control argument. */
	control_argument_idx = 1;			/* First argument must be of argument_type (1) - topic name. */

ARGUMENT_PROCESSING_LOOP:
	do arg_idx = 1 to nargs;
	     call cu_$arg_ptr (arg_idx, arg_ptr, arg_len, code);
	     if index (arg, "-") ^= 1
	     then do;
		     goto ARG (control_argument_idx);

		/*** The argument is not a control argument.  If no control argument has
		     been processed yet, the argument is of type argument_type (1). If a
		     control argument has been processed but the last control argument does not
		     expect an arguemnt, control_argument_idx is 0 and this case is in error.
		     If an argument to a control argument is expected, it is of type
		     argument_type (control_argument_idx). */

ARG (0):						/* unexpected argument */
		     call complain (error_table_$badopt, myname, "Argument is out of place: ^a.", arg);
		     return;

ARG (1):						/* manual identifier, immediately follows the command name. */
		     if length (arg) + length (manual_id) + 1 > 64
		     then do;
			     call complain (error_table_$bad_arg, myname,
				"^/The manual identifier ""^a ^a"" exceeds the 64 character limit.", manual_id,
				arg);
			     return;
			end;
		     else if manual_id = ""
		     then manual_id = ltrim (rtrim (arg));
		     else manual_id = manual_id || " " || ltrim (rtrim (arg));
		     accept_control_argument = "1"b;	/* Next arg may be a control argument */
		     control_argument_idx = 1;	/* But next arg may also be more of manual_id */
		     goto NEXT_1;

ARG (2):						/* output file pathname */
		     call absolute_pathname_ (arg, output_file_path, code);
		     if code ^= 0
		     then do;
			     call complain (code, myname, "Output file pathname argument ^a.", arg);
			     return;
			end;

		     accept_control_argument = "1"b;
		     control_argument_idx = 0;
		     goto NEXT_1;

ARG (4):						/* database pathname */
		     call absolute_pathname_$add_suffix (arg, "db", mrds_database_path, code);
		     if code ^= 0
		     then do;
			     call complain (code, myname, "Data base pathname argument ^a.", arg);
			     return;
			end;

		     accept_control_argument = "1"b;
		     control_argument_idx = 0;
		     goto NEXT_1;

NEXT_1:
		end;
	     else if ^accept_control_argument
	     then do;

		/*** A control argument was specified, but the command was not expecting
		     a control argument at this point. It was expecting the argument
		     associated with control_argument(control_argument_idx), which is
		     described in argument_type (control_argument_idx).
		     It should never be the case that accept_control_argument is off and
		     control_argument_idx is equal to 0. */

		     call complain (error_table_$noarg, myname, "^a must be followed by a^[n^] ^a.",
			control_argument (control_argument_idx),
			(index ("aeiouh", substr (argument_type (control_argument_idx), 1, 1)) > 0),
			argument_type (control_argument_idx));
		     return;
		end;
	     else do;

		/*** The argument is a control argument and it is expected. Find the control
		     argument in the control_argument array. The index into this array identifies
		     the case to process in the following case statement (computed goto). */

		     do control_argument_idx = 2 to hbound (control_argument, 1)
			while (control_argument (control_argument_idx) ^= arg);
		     end;
		     if control_argument_idx > hbound (control_argument, 1)
		     then do;
			     call complain (error_table_$badopt, myname, "^a", arg);
			     return;
			end;

		     goto CONTROL_ARG (control_argument_idx);

		/*** Case of control argument with the index control_argument_idx.  In each
		     case where an argument is expected to follow the control argument,
		     accept_control_argument is turned off so that an error occurs if the
		     next argument is a control argument. If no argument is expected,
		     accept_control_argument is turned on, meaning that control arguments are
		     allowed, and control_argument_idx is set to 0, indicating that there is
		     no control argument expecting an argument. */


CONTROL_ARG (2):
CONTROL_ARG (3):					/* -output_file, -of */
		     output_file_sw = "1"b;
		     accept_control_argument = "0"b;
		     control_argument_idx = 2;
		     goto NEXT_ARG;

CONTROL_ARG (4):
CONTROL_ARG (5):					/* -database_pathname, -dbpn */
		     database_path_sw = "1"b;
		     accept_control_argument = "0"b;
		     control_argument_idx = 4;
		     goto NEXT_ARG;

CONTROL_ARG (6):
CONTROL_ARG (7):					/* -description, -desc */
		     display_info.text.description_flag = "1"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (8):
CONTROL_ARG (9):					/* -audience, -aud */
		     display_info.text.audience_flag = "1"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (10):
CONTROL_ARG (11):					/* -table_of_contents, -toc */
		     display_info.text.table_of_contents_flag = "1"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (12):
CONTROL_ARG (13):					/* -new_features, -nf */
		     display_info.text.new_features_flag = "1"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (14):
CONTROL_ARG (15):					/* "", "" */
		     goto NEXT_ARG;

CONTROL_ARG (16):
CONTROL_ARG (17):					/* -no_request_loop, -nrql */
		     enter_request_loop = "0"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (18):
CONTROL_ARG (19):					/* -request_loop, -rql */
		     enter_request_loop = "1"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (20):
CONTROL_ARG (21):					/* -all, -a */
		     string (display_info) = copy ("1"b, length (string (display_info)));
		     display_info.header.topics_flag = "0"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (22):
CONTROL_ARG (23):					/* -no_description, -nd */
		     display_info.text.description_flag = "0"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (24):
CONTROL_ARG (25):					/* -no_audience, -naud */
		     display_info.text.audience_flag = "0"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (26):
CONTROL_ARG (27):					/* -no_table_of_contents, -ntoc */
		     display_info.text.table_of_contents_flag = "0"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;

CONTROL_ARG (28):
CONTROL_ARG (29):					/* -no_new_features, -nnf */
		     display_info.text.new_features_flag = "0"b;
		     accept_control_argument = "1"b;	/* Next argument may be control argument */
		     control_argument_idx = 0;	/* No non-control argument argument is expected. */
		     goto NEXT_ARG;
NEXT_ARG:
		     ;
		end;
	end ARGUMENT_PROCESSING_LOOP;


	if ^accept_control_argument
	then do;

	     /*** An argument was expected since control_argument_idx is non-zero, and
		the argument was not optional, since accept_control_argument is off. */

		call complain (error_table_$noarg, myname, "^a must be followed by a^[n^] ^a.",
		     control_argument (control_argument_idx),
		     (index ("aeiouh", substr (argument_type (control_argument_idx), 1, 1)) > 0),
		     argument_type (control_argument_idx));
		return;
	     end;

	if output_file_sw
	then enter_request_loop = "0"b;

/**** End of argument processing.  Execute the command. */

	on cleanup call cleanup_all;

     /*** Prepare to access the online_doc data base by setting MRDS scope and/or
	opening the data base. */

	call online_doc_db_index$return_index (current_mrds_dbi);

	if database_path_sw
	then mrds_dbi = 0;				/* To guarantee a new opening. */
	else mrds_dbi = current_mrds_dbi;		/* Use existing opening if there is one. */

	if mrds_dbi = 0
	then do;

	     /*** The online_doc data base has not been opened yet in this process. Open it. */

		call open_data_base (mrds_database_path, mrds_dbi, code);
		if code ^= 0
		then call cleanup_and_abort (code,
			"^/^10xThe data base is temporarily out of service.  Try again shortly.^/^10xIf this problem persists, see your administrator.^s"
			, "");
	     end;

     /*** Set the MRDS scope to allow this opening to read and to prevent nothing */

	call dsl_$set_scope_all (mrds_dbi, 1, 0, 30, code);
	if code ^= 0
	then if code = mrds_error_$invalid_db_index
	     then do;

		/*** The index held by online_doc_db_index is incorrect. Reset it to zero and
		     re-open the data base. */

		     call online_doc_db_index$set_index (0);
		     call open_data_base (mrds_database_path, mrds_dbi, code);
		     if code ^= 0
		     then call cleanup_and_abort (code,
			     "^/^10xThe data base is temporarily out of service.  Try again shortly.^/^10xIf this problem persists, see your administrator.^s"
			     , "");
		     call dsl_$set_scope_all (mrds_dbi, 1, 0, 30, code);
		end;

	if code ^= 0
	then call cleanup_and_abort (code,
		"^/^10xThe data base is temporarily out of service.  Try again shortly.^/^10xIf this problem persists, see your administrator.^s"
		, "");
	mrds_scope_set = "1"b;
%page;
     /*** Set up query_info structure for later use in find_manual_number and nonmenu. */

	query_info.version = query_info_version_4;
	query_info.switches.yes_or_no_sw = "0"b;
	query_info.switches.suppress_name_sw = "1"b;
	query_info.switches.cp_escape_control = "11"b;
	query_info.switches.suppress_spacing = "0"b;
	query_info.switches.padding = "0"b;
	query_info.status_code = 0;
	query_info.query_code = 0;
	query_info.question_iocbp = null ();
	query_info.answer_iocbp = null ();
	query_info.repeat_time = 0;

     /*** Find the identifying manual_number of the manual specified by the caller.  */

	call find_manual_number (manual_id, display_all_manuals, manual_number_found, manual_number);

	code = 0;

	if display_all_manuals
	then do;

	     /*** Retrieve the identifying manual number of all manuals. */

		manual_number_found = "1"b;

		call dsl_$retrieve (mrds_dbi, "-range (x full_name_rel) -select x.manual_number", manual_number, code)
		     ;
		if code ^= 0
		then call cleanup_and_abort (error_table_$noentry,
			"^/No information was found about any manuals in the data base ^a.", mrds_database_path);

		number_of_manuals = 0;
		do while (code = 0 & number_of_manuals < hbound (manual_array, 1));

		     number_of_manuals = number_of_manuals + 1;
		     manual_array (number_of_manuals) = manual_number;

		     call dsl_$retrieve (mrds_dbi, "-another", manual_number, code);
		     if code ^= 0 & code ^= mrds_error_$tuple_not_found
		     then call cleanup_and_abort (code, "^/Could not retrieve information about all of the manuals.",
			     "");

		     code = 0;
		end;
	     end;

	if ^manual_number_found
	then call cleanup_and_abort (error_table_$noentry, "^/No manual information for ""^a""", rtrim (manual_id));

	if output_file_sw
	then do;

	     /*** Output should be directed to output_file_path. */

		output_switch_name = "online_doc_output" || unique_chars_ ("0"b);
		call iox_$attach_name (output_switch_name, output_ptr, ("vfile_ " || output_file_path || " -extend"),
		     null, code);
		if code ^= 0
		then call cleanup_and_abort (code, "^/Output could not be directed to ^a.", (output_file_path));
		call iox_$open (output_ptr, Stream_output, "0"b, code);
		if code ^= 0
		then call cleanup_and_abort (code, "^/Output could not be directed to ^a.", (output_file_path));
	     end;
	else output_ptr = iox_$user_output;

	quit_signalled = "0"b;

PRINT_AND_PROMPT_LOOP:
	do while (^quit_signalled);

	/*** Display information about selected manuals */

	     if string (display_info) ^= "0"b		/* Have something to print */
	     then if ^display_all_manuals
		then call display_doc (output_ptr, mrds_dbi, manual_number, display_info_ptr, "", code);
		else do idx = 1 to number_of_manuals;

			manual_number = manual_array (idx);
			call display_doc (output_ptr, mrds_dbi, manual_number, display_info_ptr, "", code);
		     end;

	     if enter_request_loop
	     then do;

		/*** Caller wants to be prompted for more information. Display prompt and
		     get caller's reply. */

		     call command_query_ (addr (query_info), reply, myname, "More information?");
		     string (display_info) = "0"b;	/* Assume nothing */
		     completely_processed_reply = "0"b;
		end;
	     else completely_processed_reply, quit_signalled = "1"b;
						/* Avoid processing of reply as there is none and exit prompt loop. */

PROCESS_REPLY_TO_PROMPT_LOOP:
	     do while (^completely_processed_reply);

	     /*** Process each request in the reply, where requests are delimited by " ". */

		reply = ltrim (reply);

		if index (reply, " ") = 0
		then do;
			request = reply;
			reply = "";
		     end;
		else do;
			request = before (reply, " ");
			reply = ltrim (after (reply, " "));
		     end;

		do request_idx = 0 to hbound (acceptable_requests, 1)
		     while (acceptable_requests (request_idx) ^= request);
		end;

		goto REQUEST (request_idx);

	     /*** Go to the case which handles the caller's request. */

REQUEST (0):					/* "" */
		completely_processed_reply = "1"b;
		goto NEXT_REQUEST;
REQUEST (1):					/* ? */
REQUEST (2):					/* yes */
REQUEST (3):					/* y */
		if request_idx = QUESTION_MARK_REQUEST_IDX
		then do;
			start_idx = FIRST_REQUEST_IDX;
			call ioa_ ("^/The following requests are acceptable:");
		     end;
		else do;
			start_idx = FIRST_SECTION_NAME_IDX;
			call ioa_ ("^/The following sections can be displayed:");
		     end;

		do accept_idx = start_idx by 2 to hbound (acceptable_requests, 1);
		     call ioa_ ("^7x^a^[,^35t^a,^;^s^]", acceptable_requests (accept_idx),
			(accept_idx < hbound (acceptable_requests, 1)),
			acceptable_requests (min (accept_idx + 1, hbound (acceptable_requests, 1))));
		end;

		if request_idx = QUESTION_MARK_REQUEST_IDX
		then completely_processed_reply = "1"b;
		else do;
			call command_query_ (addr (query_info), reply, myname,
			     "Which section(s) do you wish to see?");
			string (display_info) = "0"b;
			completely_processed_reply = "0"b;
		     end;
		goto NEXT_REQUEST;
REQUEST (4):
REQUEST (5):
REQUEST (6):
REQUEST (7):					/* no, n, quit, q */
		completely_processed_reply, quit_signalled = "1"b;
		goto NEXT_REQUEST;
REQUEST (8):
REQUEST (9):					/* description, desc */
		display_info.text.description_flag = "1"b;
		goto NEXT_REQUEST;
REQUEST (10):
REQUEST (11):					/* audience,  */
		display_info.text.audience_flag = "1"b;
		goto NEXT_REQUEST;
REQUEST (12):
REQUEST (13):					/* table_of_contents, toc */
		display_info.text.table_of_contents_flag = "1"b;
		goto NEXT_REQUEST;
REQUEST (14):
REQUEST (15):					/* new_features,  */
		display_info.text.new_features_flag = "1"b;
		goto NEXT_REQUEST;
REQUEST (16):					/* all */
		string (display_info.text) = copy ("1"b, length (string (display_info.text)));
		goto NEXT_REQUEST;
REQUEST (17):					/* invalid response */
		call ioa_ ("""^a"" is not a valid response. Type ? for a list of valid responses.", rtrim (request));
		completely_processed_reply = "1"b;
		string (display_info) = "0"b;		/* In case some flags were set because of this reply. */
		goto NEXT_REQUEST;

NEXT_REQUEST:
	     end PROCESS_REPLY_TO_PROMPT_LOOP;
	end PRINT_AND_PROMPT_LOOP;

	if code ^= 0
	then call complain (code, myname);

	call clean_up;

MAIN_RETURN:
	return;

/* cleanup procedures */


cleanup_and_abort:
     proc (cab_code, cab_err_msg, cab_err_msg_arg);

	dcl     cab_code		 fixed bin (35);
	dcl     cab_err_msg		 char (*) var;
	dcl     cab_err_msg_arg	 char (*);

	if use_menu
	then call cleanup_screen;
	call clean_up;
	call complain (cab_code, myname, cab_err_msg, cab_err_msg_arg);
	goto MAIN_RETURN;

     end cleanup_and_abort;

cleanup_all:
     proc;

	call cleanup_screen;
	call clean_up;

     end cleanup_all;

clean_up:
     proc;

	dcl     cu_code		 fixed bin (35) init (0);

	if output_ptr ^= null & output_file_sw
	then do;
		call iox_$close (output_ptr, (cu_code));
		call iox_$detach_iocb (output_ptr, (cu_code));
	     end;

	if mrds_scope_set
	then call dsl_$dl_scope_all (mrds_dbi, (cu_code));
	if current_mrds_dbi ^= 0 & current_mrds_dbi ^= mrds_dbi
	then call dsl_$close (current_mrds_dbi, (cu_code));
	if work_area_ptr ^= null
	then call release_area_ (work_area_ptr);

     end clean_up;

cleanup_screen:
     proc;

	if use_menu
	then call window_$clear_window (iox_$user_io, (0));


     end cleanup_screen;
%page;
find_manual_number:
     proc (fmn_manual_id, fmn_display_all_manuals, fmn_manual_number_found, fmn_manual_number);

	dcl     fmn_manual_id	 char (*) varying;
	dcl     fmn_display_all_manuals
				 bit (1) aligned;
	dcl     fmn_manual_number_found
				 bit (1) aligned;
	dcl     fmn_manual_number	 fixed bin;

	dcl     (manual_name, manual_id_string)
				 char (64) varying;
	dcl     headers		 (2) char (70) var;
	dcl     trailers		 (2) char (50) var;
	dcl     order_number	 char (4);

	dcl     (fits_order_number_pattern, fkey)
				 bit (1) aligned;

	dcl     choice		 fixed bin;
	dcl     group_name_idx	 fixed bin;
	dcl     manual_number	 fixed bin;

	dcl     menu_ptr		 ptr;

	dcl     (
	        LOWER_CASE_ALPHA	 char (26) init ("abcdefghijklmnopqrstuvwxyz"),
	        UPPER_CASE_ALPHA	 char (26) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
	        NUMERIC		 char (10) init ("0123456789"),
	        GROUP_PROMPT	 char (80) var
				 init ("Select from the list by typing the associated number and RETURN:")
	        )			 internal static options (constant);


	dcl     1 local_area_info	 aligned like area_info;
	dcl     1 local_menu_format	 like menu_format;
	dcl     1 local_menu_requirements
				 like menu_requirements;


	unspec (local_area_info) = "0"b;
	local_area_info.version = 1;
	local_area_info.control.extend = "1"b;
	local_area_info.owner = myname;
	local_area_info.size = sys_info$max_seg_size;
	local_area_info.areap = null;

	call define_area_ (addr (local_area_info), code);
	if code ^= 0
	then call cleanup_and_abort (code, "Cannot define area.", "");

	work_area_ptr = local_area_info.areap;

	fmn_display_all_manuals = "0"b;
	fmn_manual_number_found = "0"b;
	fmn_manual_number = 0;
	manual_id_string = translate (fmn_manual_id, LOWER_CASE_ALPHA, UPPER_CASE_ALPHA);

	if manual_id_string = "*"
	then do;
		fmn_display_all_manuals = "1"b;
		return;
	     end;


	if length (manual_id_string) >= 4 & length (manual_id_string) <= 8
	then do;

	     /*** This may be an order number.  See if manual_id_string fits the order number
		pattern, AA99{xxx}, and search for the manual with that order number if it
		fits the pattern. */

		fits_order_number_pattern = "1"b;
		if verify (substr (manual_id_string, 1, 2), LOWER_CASE_ALPHA) ^= 0
		then fits_order_number_pattern = "0"b;
		if verify (substr (manual_id_string, 3, 2), NUMERIC) ^= 0
		then fits_order_number_pattern = "0"b;

		if fits_order_number_pattern
		then do;
			order_number =
			     translate (substr (manual_id_string, 1, 4), UPPER_CASE_ALPHA, LOWER_CASE_ALPHA);
			call dsl_$retrieve (mrds_dbi,
			     "-range (x full_name_rel) -select x.manual_number -where x.order_number = .V.",
			     order_number, manual_number, code);
			if code = 0
			then fmn_manual_number_found = "1"b;
			else if code ^= mrds_error_$tuple_not_found
			then call cleanup_and_abort (code,
				"^/This unexpected error occurred while searching for order ^/number ^a.",
				order_number);
			code = 0;
		     end;
	     end;

	if ^fmn_manual_number_found
	then do;

	     /*** No manual was found when manual_id_string was interpreted as an order number.
		Try again using manual_id_string as a manual name. */

		manual_name = canonicalize_name (manual_id_string);
		call dsl_$retrieve (mrds_dbi, "-range (x name_rel) -select x.manual_number -where x.name = .V.",
		     manual_name, manual_number, code);
		if code = 0
		then fmn_manual_number_found = "1"b;
		else if code ^= mrds_error_$tuple_not_found
		then call cleanup_and_abort (code,
			"^/This unexpected error occurred while searching for manual name ""^a"".", (manual_name));
		code = 0;
	     end;

	if ^fmn_manual_number_found
	then do;

	     /*** No manual found with supplied name either. See if the supplied name
		identifies one of a set of common groups of manuals, as defined in group_name. */

		do group_name_idx = 1 to hbound (group_name, 1)
		     while (index (manual_name, group_name (group_name_idx)) = 0);
		end;
		if group_name_idx > hbound (group_name, 1)
		then call cleanup_and_abort (error_table_$noentry,
			"^/No manual with an order number or name corresponding^/to ""^a"" was found.",
			rtrim (manual_id_string));


		goto GROUP (group_name_idx);

	     /*** The manual_id_string specified does not match a manual name, but is one of a set
		of very commonly used terms.  Some of these terms refer to groups of manuals,
		such as the Multics Programming Manuals (MPM) or Multics Administrator's
		Manuals (MAM), or is the name of a product whose name does not match the
		name of the manual in which it is described, such as MRDS, LINUS or WORDPRO.
		For each case which deals with a group of manuals, allocate a structure
		which contains a choices array with all of the manual names.  The structures
		are declared with initial attributes in online_doc_groups.incl.pl1.  The
		choices array will be used to set up a menu or to print the choices.
		Those that deal with a single manual only just retrievpFor those that deals with a single manual only,
		just get the manual_number of the manual. */

GROUP (1):					/* mpm */
		alloc mpm_choices in (work_area);
		number_of_choices = mpm_choices.number_of_choices;
		choices_ptr = addr (mpm_choices.choices (1));
		goto END_GROUP_CASE;

GROUP (2):					/* mam */
		alloc mam_choices in (work_area);
		number_of_choices = mam_choices.number_of_choices;
		choices_ptr = addr (mam_choices.choices (1));
		goto END_GROUP_CASE;

GROUP (3):					/* i/o */
		alloc io_choices in (work_area);
		number_of_choices = io_choices.number_of_choices;
		choices_ptr = addr (io_choices.choices (1));
		goto END_GROUP_CASE;

GROUP (4):					/* cobol */
		alloc cobol_choices in (work_area);
		number_of_choices = cobol_choices.number_of_choices;
		choices_ptr = addr (cobol_choices.choices (1));
		goto END_GROUP_CASE;

GROUP (5):					/* wordpro */
		alloc wordpro_choices in (work_area);
		number_of_choices = wordpro_choices.number_of_choices;
		choices_ptr = addr (wordpro_choices.choices (1));
		goto END_GROUP_CASE;

GROUP (6):					/* emacs */
		alloc emacs_choices in (work_area);
		number_of_choices = emacs_choices.number_of_choices;
		choices_ptr = addr (emacs_choices.choices (1));
		goto END_GROUP_CASE;


GROUP (7):					/* sdn */
		alloc sdn_choices in (work_area);
		number_of_choices = sdn_choices.number_of_choices;
		choices_ptr = addr (sdn_choices.choices (1));
		goto END_GROUP_CASE;


GROUP (8):					/* plm */
		alloc plm_choices in (work_area);
		number_of_choices = plm_choices.number_of_choices;
		choices_ptr = addr (plm_choices.choices (1));
		goto END_GROUP_CASE;


GROUP (9):					/* xmail */
		alloc xmail_choices in (work_area);
		number_of_choices = xmail_choices.number_of_choices;
		choices_ptr = addr (xmail_choices.choices (1));
		goto END_GROUP_CASE;

GROUP (10):					/* pl1 */
		alloc pl1_choices in (work_area);
		number_of_choices = pl1_choices.number_of_choices;
		choices_ptr = addr (pl1_choices.choices (1));
		goto END_GROUP_CASE;


GROUP (11):					/* fortran */
		alloc fortran_choices in (work_area);
		number_of_choices = fortran_choices.number_of_choices;
		choices_ptr = addr (fortran_choices.choices (1));
		goto END_GROUP_CASE;


GROUP (12):					/* new_user */
		alloc new_user_choices in (work_area);
		number_of_choices = new_user_choices.number_of_choices;
		choices_ptr = addr (new_user_choices.choices (1));
		goto END_GROUP_CASE;


GROUP (13):					/* mrds */
		call dsl_$retrieve (mrds_dbi,
		     "-range (x full_name_rel) -select x.manual_number -where x.order_number = .V.", "AW53",
		     manual_number, code);
		if code = 0
		then fmn_manual_number_found = "1"b;
		else call cleanup_and_abort (code,
			"^/This programming error occurred while searching for^/the manual with order number ^a.",
			"AW53");
		goto END_GROUP_CASE;

GROUP (14):					/* linus */
		call dsl_$retrieve (mrds_dbi,
		     "-range (x full_name_rel) -select x.manual_number -where x.order_number = .V.", "AZ49",
		     manual_number, code);
		if code = 0
		then fmn_manual_number_found = "1"b;
		else call cleanup_and_abort (code,
			"^/This programming error occurred while searching for^/the manual with order number ^a.",
			"AZ49");
		goto END_GROUP_CASE;

GROUP (15):					/* mrpg */
		call dsl_$retrieve (mrds_dbi,
		     "-range (x full_name_rel) -select x.manual_number -where x.order_number = .V.", "CC69",
		     manual_number, code);
		if code = 0
		then fmn_manual_number_found = "1"b;
		else call cleanup_and_abort (code,
			"^/This programming error occurred while searching for^/the manual with order number ^a.",
			"CC69");
		goto END_GROUP_CASE;
	     end;

END_GROUP_CASE:
	if ^fmn_manual_number_found
	then do;

	     /*** No manual has been selected yet.  Give user a choice of which manual
		to see. */

		headers (1) = "The manual may refer to any of the following.";
		headers (2) = "On which manual do you wish to see information?";
		trailers (1) = "-";
		trailers (2) = "Type the associated number to select a manual.";

		if video_is_on
		then call setup_menu (use_menu);

		if use_menu
		then call menu ();			/* Select with a menu. */
		else call nonmenu ();		/* Select without a menu */
	     end;


	if fmn_manual_number_found
	then fmn_manual_number = manual_number;

	return;
%page;
/* **** Subroutines of find_manual_number, setup_menu, menu and nonmenu. */

setup_menu:
     proc (sm_use_menu);

	dcl     sm_use_menu		 bit (1) aligned;
	dcl     sm_code		 fixed bin (35);

	sm_code = 0;
	sm_use_menu = "0"b;

	user_io_window_info.version = window_position_info_version_1;
	call iox_$control (iox_$user_io, "get_window_info", addr (user_io_window_info), sm_code);
	if sm_code ^= 0
	then call sm_cleanup_and_return;

	call window_$clear_window (iox_$user_io, sm_code);
	if sm_code ^= 0
	then call sm_cleanup_and_return;

	local_menu_format.version = menu_format_version_1;
	local_menu_format.max_width = user_io_window_info.width;

	local_menu_format.n_columns = 1;
	local_menu_format.center_headers = "1"b;
	local_menu_format.center_trailers = "1"b;
	local_menu_format.pad = "0"b;
	local_menu_format.pad_char = "-";

	local_menu_requirements.version = menu_requirements_version_1;
	local_menu_format.max_height = hbound (choices, 1) + 5;

	if local_menu_format.max_height > user_io_window_info.extent.height
	then call sm_cleanup_and_return;

	call menu_$create (choices, headers, trailers, addr (local_menu_format), MENU_OPTION_KEYS, work_area_ptr,
	     addr (local_menu_requirements), menu_ptr, code);
	if code ^= 0
	then call sm_cleanup_and_return;

	call menu_$display (iox_$user_io, menu_ptr, sm_code);
	if code ^= 0
	then call sm_cleanup_and_return;

	sm_use_menu = "1"b;

SM_RETURN:
	return;

sm_cleanup_and_return:
     proc;

	call cleanup_screen;
	goto SM_RETURN;

     end sm_cleanup_and_return;

     end setup_menu;
%page;
menu:
     proc ();

/**** The menu subroutine displays a menu of manuals and returns the
      user's choice to find_manual_number by setting the value of manual_number.
      The menu must already be created and formatted. */

	dcl     got_choice		 bit (1) aligned;

	got_choice = "0"b;

	do while (^got_choice);

	     call menu_$get_choice (iox_$user_io, menu_ptr, null, fkey, choice, code);
	     if code ^= 0
	     then call cleanup_and_abort (code, "Unable to get menu choice.", "");

	     if fkey
	     then call window_$bell (iox_$user_io, 0);
	     else if choice = hbound (choices, 1)
	     then got_choice = "1"b;			/* None.  Exit. */
	     else if choice < hbound (choices, 1)
	     then do;

		/*** A valid choice was made. Get the manual number of the selected manual. */

		     got_choice = "1"b;
		     manual_name = canonicalize_name ((choices (choice)));

		     call dsl_$retrieve (mrds_dbi, "-range (x name_rel) -select x.manual_number -where x.name = .V.",
			manual_name, manual_number, code);
		     if code = 0
		     then fmn_manual_number_found = "1"b;
		     else if code = mrds_error_$tuple_not_found
		     then call cleanup_and_abort (code,
			     "^/The data base does not contain a complete selection of^/manuals. The ""^a"" manual is missing."
			     , (choices (choice)));
		     else call cleanup_and_abort (code, "^/This error occurred attempting to find the ""^a"" manual.",
			     (choices (choice)));

		     call window_$clear_window (iox_$user_io, code);
		     if code ^= 0
		     then call cleanup_and_abort (code, "Unable to clear window.", "");

		end;
	     else call window_$bell (iox_$user_io, 0);
	end;

	return;

     end menu;
%page;
nonmenu:
     proc ();

     /*** Display a list of manual names, as in a menu, and prompt the user for
	a choice. */

	dcl     got_choice		 bit (1) aligned;
	dcl     (choice, choice_idx)	 fixed bin;
	dcl     choice_string	 char (32) varying;


	display_info.display_leading_blank_line = "1"b;

	call ioa_ ("^/^5x^a^/", headers (1));

	do choice_idx = 1 to hbound (choices, 1);
	     call ioa_ ("^2x(^d) ^a", choice_idx, choices (choice_idx));
	end;

	got_choice = "0"b;
	do while (^got_choice);
	     call command_query_ (addr (query_info), choice_string, "", GROUP_PROMPT);
	     choice = cv_dec_check_ ((choice_string), code);
	     if code ^= 0
	     then call complain (code, myname, "^/You must reply with an integer number between 1 and ^d, inclusive.",
		     hbound (choices, 1));
	     else if choice < 1 | choice > hbound (choices, 1)
	     then call complain (code, myname, "^/You must reply with an integer number.", hbound (choices, 1));
	     else got_choice = "1"b;
	end;

	if choice ^= hbound (choices, 1)
	then do;
		manual_name = canonicalize_name ((choices (choice)));

		call dsl_$retrieve (mrds_dbi, "-range (x name_rel) -select x.manual_number -where x.name = .V.",
		     manual_name, manual_number, code);
		if code = 0
		then fmn_manual_number_found = "1"b;
		else if code = mrds_error_$tuple_not_found
		then call cleanup_and_abort (code,
			"^/The data base does not contain a complete selection of^/manuals. The ""^a"" manual is missing."
			, (choices (choice)));
		else call cleanup_and_abort (code, "^/This error occurred attempting to find the ""^a"" manual.",
			(choices (choice)));
	     end;

     end nonmenu;

     end find_manual_number;
%page;
open_data_base:
     proc (odb_mrds_database_path, odb_mrds_dbi, odb_code);

	dcl     odb_mrds_database_path char (*);
	dcl     odb_mrds_dbi	 fixed bin (35);
	dcl     odb_code		 fixed bin (35);

	call dsl_$open (odb_mrds_database_path, odb_mrds_dbi, 1, odb_code);
	if odb_code = 0
	then call online_doc_db_index$set_index (odb_mrds_dbi);

	return;

     end open_data_base;

canonicalize_name:
     proc (cn_input_string) returns (char (64) var);

	dcl     cn_input_string	 char (64) var;
	dcl     cn_canonical_name	 char (64) var;
	dcl     cn_string		 char (64) var;
	dcl     cn_temp_string	 char (64) var;

	cn_string = cn_input_string;

	cn_string = translate (cn_string, "__", "- ");
	do while (index (cn_string, "__") ^= 0);
	     cn_temp_string = after (cn_string, "__");
	     cn_string = before (cn_string, "__") || "_" || cn_temp_string;
	end;

	cn_canonical_name = translate (cn_string, LOWER_CASE_ALPHA, UPPER_CASE_ALPHA);

	return (cn_canonical_name);

     end canonicalize_name;
%page;
%include online_doc_groups;
%page;
%include query_info;
%page;
%include window_control_info;
%page;
%include display_doc_info;
%page;
%include iox_dcls;
%page;
%include iox_modes;
%page;
%include menu_dcls;
%page;
%include window_dcls;
%page;
%include area_info;

     end explain_doc;
