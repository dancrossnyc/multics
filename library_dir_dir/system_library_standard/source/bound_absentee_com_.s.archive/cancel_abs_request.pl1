/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format:  style2 */

cancel_abs_request:
car: procedure;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/*    This is a 7 command procedure.  It will cancel absentee, IO Daemon (eg,		*/
/* dprint/dpunch/plot), output (eg, enter_output_request), and retrieval requests from	*/
/* standard system queues.  It will also move absentee requests from one queue to	*/
/* another or will move IO Daemon or output requests from one queue and request type to	*/
/* another.								*/
/*									*/
/*    When the -user (or -admin) control argument is given, cancellations may be done	*/
/* for another user's requests and moves of another user's requests will use privileged	*/
/* message segment primitives which will preserve the original sender's identity.	*/
/*									*/


/****^  HISTORY COMMENTS:
  1) change(71-09-17,Stone), approve(), audit(), install():
      Modified by E. Stone.
  2) change(73-02-01,Capps), approve(), audit(), install():
      Modified by Dennis Capps to be cleverer about control seg name.
  3) change(73-04-17,Coren), approve(), audit(), install():
      Modified by Robert Coren to work on io_daemon queues.
  4) change(74-09-12,Stern), approve(), audit(), install():
      Modified by J. Stern to use message_segment_ "index" entries.
  5) change(75-06-24,Stern), approve(), audit(), install():
      Modified by J. Stern.
  6) change(76-04-15,Herbst), approve(), audit(), install():
      Modified by Steve Herbst.
  7) change(76-12-28,VanVleck), approve(), audit(), install():
      Modified by THVV.
  8) change(77-01-05,Vinograd), approve(), audit(), install():
      Modified by D. Vinograd to add entries cancel_retrieval_request and
      test_crr.
  9) change(78-05-01,Whitmore), approve(), audit(), install():
      Rewritten by J. C. Whitmore to add the move entries and several control
      args.
 10) change(78-12-01,Whitmore), approve(), audit(), install():
      Modified to recognize abs queue 0 and foreground queue.
 11) change(79-01-01,Whitmore), approve(), audit(), install():
      Modified to add as_abs subroutine entry and -sender arg to abs entries.
 12) change(80-04-01,Whitmore), approve(), audit(), install():
      Modified to warn user when daemon request is running.
 13) change(80-09-01,Palter), approve(), audit(), install():
      Modified by G. Palter to provide site-settable default absentee queues.
 14) change(82-01-01,GDixon), approve(), audit(), install():
      Modified by G. Dixon to support eor's user defined request types, and to
      add -print, -punch, -plot.
 15) change(84-07-01,Marker), approve(), audit(), install():
      Modified by C. Marker to search all queues by default.
 16) change(84-10-11,Margulies), approve(), audit(), install():
      Modified by BIM for mseg_message_info
 17) change(85-12-13,Lippard), approve(85-12-30,MCR7326),
     audit(86-10-27,GDixon), install(86-10-28,MR12.0-1200):
      Modified by Jim Lippard to use send_as_request_ instead of hcs_$wakeup.
 18) change(87-07-07,GDixon), approve(87-07-07,MCR7741),
     audit(87-07-07,Hartogs), install(87-08-04,MR12.1-1055):
     Include user_abs_attributes.incl.pl1 as part of splitting
     abs_message_format.incl.pl1.
 19) change(87-07-16,Lippard), approve(87-11-04,MCR7762),
     audit(87-11-04,Fawcett), install(87-11-30,MR12.2-1006):
      Modified to stop munging sender_id.
 20) change(90-06-20,Huen), approve(90-06-20,MCR8179), audit(90-07-17,Itani),
     install(90-08-21,MR12.4-1025):
     IO_Daemons_79: Change cancel_output_request and cancel_daemon_request
     so that if a request is already running to not delete it from the queue.
                                                   END HISTORY COMMENTS */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	dcl     MATCH_ID		 char (20);	/* global match id for all requests */
	dcl     admin_sw		 bit (1);
	dcl     all_sw		 bit (1);
	dcl     alp		 ptr;
	dcl     answer		 char (16) var;
	dcl     areap		 ptr;
	dcl     arg_did_match	 bit (1);
	dcl     arg_didnt_match	 bit (1);
	dcl     arg_dir_dir		 char (168);
	dcl     arg_dir_ent		 char (32);
	dcl     arg_no		 fixed bin;
	dcl     arglen		 fixed bin;
	dcl     argptr		 ptr;
	dcl     bad_msg_version	 bit (1);
	dcl     brief_sw		 bit (1);
	dcl     call_sys_log	 bit (1);
	dcl     code		 fixed bin (35);
	dcl     default_q		 fixed bin;
	dcl     dir		 char (168);
	dcl     end_msg_seg		 bit (1);
	dcl     entry		 fixed bin;	/* see named constants below. */
	dcl     entry_id_count	 fixed bin;
	dcl     first_arg		 fixed bin;
	dcl     first_q		 fixed bin;
	dcl     found_all_arg_match	 bit (1);
	dcl     found_one_match	 bit (1);
	dcl     gen_type		 char (32);
	dcl     id		 char (28);
	dcl     id_match_ms_id	 bit (72) aligned;
	dcl     id_msg		 char (32) var;
	dcl     idx		 fixed bin;
	dcl     input_seg		 char (32);
	dcl     last_q		 fixed bin;
	dcl     len		 fixed bin;
	dcl     long_msg		 char (256);	/* expanded error message from ioa_$rsnnl */
	dcl     max_q		 fixed bin;
	dcl     mode		 bit (36) aligned;
	dcl     mseg_idx		 (-1:4) fixed bin;	/* mseg index for queues with existing requests */
	dcl     mseg_name		 char (32);
	dcl     mseg_sender_id         char (32);
	dcl     msg		 char (136);	/* error message, long as one print line */
	dcl     msg_id_code		 fixed bin (71);	/* this is a clock reading actually */
	dcl     nargs		 fixed bin;
	dcl     old_ms_id		 bit (72) aligned;
	dcl     one_request_only	 bit (1);
	dcl     option		 char (32);
	dcl     path_id_count	 fixed bin;
	dcl     person		 char (28);
	dcl     project		 char (28);
	dcl     queue_no		 fixed bin;
	dcl     queue_pic		 pic "9";		/* for converting queue number to char */
	dcl     queue_sw		 bit (1);
	dcl     queue_type		 char (32);
	dcl     rdir		 char (168);
	dcl     req_dir_dir		 char (168);
	dcl     req_dir_ent		 char (32);
	dcl     req_dir_uid		 bit (36);
	dcl     reqp		 ptr;
	dcl     request_id_count	 fixed bin;
	dcl     rqt_sw		 bit (1);
	dcl     rseg		 char (32);
	dcl     saved_code		 fixed bin (35) init (0);
	dcl     search_all_sw	 bit (1);
	dcl     sender		 char (32);
	dcl     sender_id		 char (32);
	dcl     sender_sw		 bit (1);
	dcl     single_ms_id	 bit (72) aligned;
	dcl     sysdir		 char (168);
	dcl     target_default_q	 fixed bin;
	dcl     target_gen_type	 char (32);
	dcl     target_max_q	 fixed bin;
	dcl     target_mseg_idx	 fixed bin;	/* mseg index of target queue of a move */
	dcl     target_queue	 fixed bin;
	dcl     target_queue_type	 char (32);
	dcl     to_q_sw		 bit (1);
	dcl     to_rqt_sw		 bit (1);
	dcl     try_again		 bit (1);
	dcl     user		 char (32);
	dcl     verb		 char (8);
	dcl     wakeup_answering_service bit (1);

	dcl     1 br		 aligned,
		2 padding		 (9) bit (36),
		2 uid		 bit (36);

	dcl     1 local_asraci	 aligned like asr_abs_command_info;

	dcl     1 local_mseg_message_info like mseg_message_info aligned;

	dcl     arg		 char (arglen) unaligned based (argptr);

	dcl     CAR		 fixed bin int static options (constant) init (1); /* values assigned to the entry variable 	*/
	dcl     CDR		 fixed bin int static options (constant) init (2);
	dcl     COR		 fixed bin int static options (constant) init (3);
	dcl     CRR		 fixed bin int static options (constant) init (4);
	dcl     MAR		 fixed bin int static options (constant) init (5);
	dcl     MDR		 fixed bin int static options (constant) init (6);
	dcl     MOR		 fixed bin int static options (constant) init (7);
	dcl     ASC		 fixed bin int static options (constant) init (8); /* AS_CANCEL entry code */
	dcl     ASM		 fixed bin int static options (constant) init (9); /* AS_MOVE entry code */
	dcl     ASN		 fixed bin int static options (constant) init (10); /* AS_NEXT entry code */

	dcl     PATH		 fixed bin static options (constant) init (1); /* values assigned to type array (dcl in begin block) */
	dcl     ENTRY		 fixed bin static options (constant) init (2);
	dcl     ID		 fixed bin static options (constant) init (3);

	dcl     ID_CHARS		 char (11) int static options (constant) init ("0123456789.");
	dcl     CAPS		 char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	dcl     Q_name		 (-1:4) char (16) int static options (constant)
				 init ("foreground queue", "queue 1", "queue 1", "queue 2", "queue 3", "queue 4");

	dcl     abs_default_q	 fixed bin int static;
	dcl     abs_max_q		 fixed bin int static;
	dcl     abs_sysdir		 char (168) internal static init (">system_control_1");
	dcl     io_default_q	 fixed bin int static;
	dcl     io_max_q		 fixed bin int static;
	dcl     iod_sysdir		 char (168) int static init (">daemon_dir_dir>io_daemon_dir");
	dcl     not_initialized	 bit (1) int static init ("1"b);
	dcl     ret_default_q	 fixed bin int static;
	dcl     ret_max_q		 fixed bin int static;
	dcl     retriever_sysdir	 char (168) int static init (">daemon_dir_dir>volume_retriever");

	dcl     (cleanup, conversion, linkage_error, size) condition;

	dcl     re_read_label	 label;		/* where to go to try reading again */

	dcl     error_table_$bad_arg	 ext fixed bin (35);
	dcl     error_table_$bad_conversion ext fixed bin (35);
	dcl     error_table_$bad_segment ext fixed bin (35);
	dcl     error_table_$badopt	 ext fixed bin (35);
	dcl     error_table_$id_not_found ext fixed bin (35);
	dcl     error_table_$no_message ext fixed bin (35);
	dcl     error_table_$noarg	 ext fixed bin (35);
	dcl     error_table_$request_pending ext fixed bin (35);

	dcl     absolute_pathname_	 entry (char (*), char (*), fixed bin (35));
	dcl     check_star_name_$path	 entry (char (*), fixed bin (35));
	dcl     com_err_		 entry options (variable);
	dcl     command_query_	 entry options (variable);
	dcl     cu_$arg_count	 entry (fixed bin, fixed bin (35));
	dcl     cu_$arg_list_ptr	 entry (ptr);
	dcl     cu_$arg_ptr_rel	 entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
	dcl     enter_output_request$default_request_type entry (char (*), char (*), fixed bin, fixed bin, fixed bin (35));
	dcl     enter_output_request$request_type entry (char (*), char (*), char (*), fixed bin, fixed bin, fixed bin (35));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     get_system_free_area_	 entry (ptr);
	dcl     hcs_$star_		 entry (char (*), char (*), fixed bin, ptr, fixed bin, ptr, ptr, fixed bin (35));
	dcl     hcs_$status_long	 entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
	dcl     (ioa_, ioa_$rsnnl)	 entry options (variable);
	dcl     iod_info_$generic_type entry (char (*), char (32), fixed bin (35));
	dcl     iod_info_$queue_data	 entry (char (*), fixed bin, fixed bin, fixed bin (35));
	dcl     iod_info_$test	 entry (char (*));
	dcl     match_request_id_	 entry (fixed bin (71), char (*)) returns (bit (1) aligned);
	dcl     match_star_name_	 entry (char (*), char (*), fixed bin (35));
	dcl     message_segment_$add_index entry (fixed bin, ptr, fixed bin (24), bit (72) aligned, fixed bin (35));
	dcl     message_segment_$close entry (fixed bin, fixed bin (35));
	dcl     message_segment_$delete_index entry (fixed bin, bit (72) aligned, fixed bin (35));
	dcl     message_segment_$get_mode_index entry (fixed bin, bit (36) aligned, fixed bin (35));
	dcl     message_segment_$open	 entry (char (*), char (*), fixed bin, fixed bin (35));
	dcl     message_segment_$read_message_index entry (fixed bin, ptr, ptr, fixed bin (35));
	dcl     queue_admin_$add_index entry (fixed bin, ptr, bit (72) aligned, fixed bin (35));
	dcl     request_id_		 entry (fixed bin (71)) returns (char (19));
	dcl     send_as_request_$no_block entry (ptr, fixed bin, bit (72) aligned, fixed bin (35));
	dcl     suffixed_name_$make	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     sys_log_$error_log	 entry options (variable);
	dcl     system_info_$default_absentee_queue entry (fixed bin);

	dcl     (addr, after, before, currentsize, min, null, substr, rtrim, convert, unspec, verify, search, length) builtin;
%page;
%include abs_message_format;
%page;
%include as_request_header;
%page;
%include asr_abs_command;
%page;
%include dprint_msg;
%page;
%include mseg_message_info;
%page;
%include query_info_;
%page;
%include queue_msg_hdr;
%page;
%include retv_request;
%page;
%include user_abs_attributes;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


/* 
cancel_abs_request: 
car:	entry;					Main entry point. */

	if not_initialized then call init;
	id = "cancel_abs_request";
	sysdir = abs_sysdir;
	default_q = abs_default_q;
	max_q = abs_max_q;
	queue_type = "absentee";
	entry = CAR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


cancel_daemon_request:
cdr: entry;

/* This entry performs same functions as main entry but uses io_daemon request queues (dprint/dpunch/dplot) */

	if not_initialized then call init;
	id = "cancel_daemon_request";
	sysdir = iod_sysdir;
	default_q = io_default_q;
	max_q = io_max_q;
	queue_type, gen_type = "printer";
	entry = CDR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


cancel_output_request:
cor: entry;

/* This entry performs same functions as main entry but uses io_daemon request queues (enter_output_request) */

	if not_initialized then call init;
	id = "cancel_output_request";
	sysdir = iod_sysdir;
	gen_type = "printer";
	call enter_output_request$default_request_type (gen_type, queue_type, default_q, max_q, code);
	entry = COR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


cancel_retrieval_request:
crr: entry;

/* This entry performs the same function as the main entry but uses retrieval request queues */

	if not_initialized then call init;
	id = "cancel_retrieval_request";
	sysdir = retriever_sysdir;
	default_q = ret_default_q;
	max_q = ret_max_q;
	queue_type = "volume_retriever";
	entry = CRR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


move_abs_request:
mar: entry;

/* This entry will move an absentee request from one queue to another */

	if not_initialized then call init;
	id = "move_abs_request";
	sysdir = abs_sysdir;
	default_q = abs_default_q;
	max_q = abs_max_q;
	queue_type = "absentee";
	entry = MAR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


move_daemon_request:
mdr: entry;

/* This entry will move a dprint/dpunch/dplot request from one rqt/queue to another */

	if not_initialized then call init;
	id = "move_daemon_request";
	sysdir = iod_sysdir;
	default_q = io_default_q;
	max_q = io_max_q;
	queue_type, gen_type = "printer";		/* default to the printer queues */
	entry = MDR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


move_output_request:
mor: entry;

/* This entry will move an enter_output_request from one rqt/queue to another */

	if not_initialized then call init;
	id = "move_output_request";
	sysdir = iod_sysdir;
	gen_type = "printer";			/* default to the printer queues */
	call enter_output_request$default_request_type (gen_type, queue_type, default_q, max_q, code);
	entry = MOR;
	go to cmd_common;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


as_abs: entry (a_arglp, a_nargs, a_req_id_ret, a_code);

/* this entry is ONLY for the answering service "abs move", "abs cancel", and "abs next" commands */

	dcl     a_arglp		 ptr;		/* arg list ptr from abs xxx command - including the xxx */
	dcl     a_nargs		 fixed bin;	/* number of args in abs xxx arg list */
	dcl     a_req_id_ret	 fixed bin (71);	/* request id which we did xxx to */
	dcl     a_code		 fixed bin (35);	/* you guessed it! */

	if not_initialized then call init;
	alp = a_arglp;				/* copy the arg list pointer */
	a_req_id_ret = 0;				/* clear the value for now */
	a_code = 0;
	call cu_$arg_ptr_rel (1, argptr, arglen, a_code, alp); /* see which this is */
	if a_code ^= 0 then return;

	if arg = "cancel" then entry = ASC;		/* the abs cancel entry */
	else if arg = "move" then entry = ASM;		/* "   abs move     */
	else if arg = "next" then entry = ASN;		/* "   abs next      */
	else do;					/* undefined function */
		a_code = error_table_$bad_arg;
		return;
	     end;

	queue_type = "absentee";
	max_q = abs_max_q;
	default_q = abs_default_q;
	sysdir = abs_sysdir;
	id = "cancel_abs_request$as_abs";
	nargs = a_nargs;				/* copy the number of args given */
	call_sys_log = "1"b;			/* for the as_abs entry write errors to sys_log */
	go to common;				/* now join the command code */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


cmd_common:
	call cu_$arg_count (nargs, code);		/* get number of args for allocating variables in begin block */
	if code ^= 0 then do;
		call com_err_ (code, id);
		return;
	     end;
	call cu_$arg_list_ptr (alp);			/* get arglist ptr so begin block can get args */
	call_sys_log = "0"b;			/* for commands we use the standard com_err_ */


common:	brief_sw,					/* initialize switches to zero */
	     admin_sw,
	     sender_sw,
	     all_sw,
	     rqt_sw,
	     queue_sw,
	     to_q_sw,
	     to_rqt_sw,
	     wakeup_answering_service,
	     search_all_sw = "0"b;			/* default - look for callers own requests */
	request_id_count, path_id_count, entry_id_count = 0;
	MATCH_ID = "";				/* clear the global match id for all requests */
	person, project, sender = "";
	if (entry = ASN | entry = ASC) then one_request_only = "1"b;
	else one_request_only = "0"b;			/* match multiple requests unless ASN or ASC */

	mseg_idx (*) = 0;				/* no message segments open yet */
	target_mseg_idx = 0;
	reqp = null;

BLOCK:	begin;					/* allocate adjustable storage.		*/

	     dcl	   arg_dir_uid	      (nargs) bit (36);
	     dcl	   matched	      (nargs) fixed bin; /* matched (i) is number of requests matching arg i */
	     dcl	   msg_id		      (nargs) bit (72) aligned; /* message id of matched request */
	     dcl	   queue		      (nargs) fixed bin; /* queue where request is (if not starname) */
	     dcl	   req_seg	      (nargs) char (32); /* entry name of segment in request for arg i */
	     dcl	   starname	      (nargs) fixed bin; /* 0 = no star, 1 = normal star, 2 = double star */
	     dcl	   type		      (nargs) fixed bin; /* type of request identifier for arg i */
						/* 1 = PATH, 2 = ENTRY name, 3 = ID number */
	     dcl	   used_up	      (nargs) bit (1) unal; /* bit i TRUE if arg i to be ignored later */

	     arg_dir_uid (*) = ""b;
	     matched (*) = 0;
	     msg_id (*) = ""b;
	     queue (*) = 0;
	     req_seg (*) = "";
	     starname (*) = 0;
	     type (*) = 0;
	     used_up (*) = "0"b;

	     target_queue, first_q, last_q = -10;	/* init to illegal values */
	     target_default_q = default_q;		/* define in case of bad iod_tables */
	     target_max_q = max_q;
	     first_arg = 1;				/* start inital arg pass at arg 1, unless redefined */

	     on conversion begin;
		     code = error_table_$bad_conversion;
		     msg = "Illegal value for argument: " || option;
		     go to abort_cmd;		/* abort now */
		end;

	     on size begin;
		     code = error_table_$bad_conversion;
		     msg = "Value out of range for argument: " || option;
		     go to abort_cmd;
		end;

/*	Start of first pass over the arguments.  Locate request identifiers and check control args */

	     if entry = ASM | entry = ASC | entry = ASN then do; /* special case the as_abs entries */
		     used_up (1) = "1"b;		/* first arg was cancel, move, or next */
		     len = min (nargs, 4);		/* look at up to 3 more here */
		     do arg_no = 2 to len while (first_arg = 1); /* next args are user, proj and/or ID without ctl arg */
						/* allowable forms are <id> <user> and <user> <id> */
						/* where <user> is pers.proj or "pers proj" */
						/* any ctl arg terminates free form input */
			call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
			if code ^= 0 then do;
				msg = "First args assumed to be user and request id.";
				go to abort_cmd;
			     end;
						/* terminate on ctl arg or full path */
			if substr (arg, 1, 1) = "-" | substr (arg, 1, 1) = ">" then first_arg = arg_no;
			else if verify (arg, ID_CHARS) = 0 then do; /* this must be a request id */
				type (arg_no) = ID; /* mark it as an request id for later */
				request_id_count = request_id_count + 1; /* say we have one */
				one_request_only = "1"b; /* Opr will only give one id */
			     end;
			else if person = "" then do;	/* not ctl arg or ID, must be user name */
				used_up (arg_no) = "1"b; /* don't look at this again */
				admin_sw = "1"b;	/* say we have a user name */
				search_all_sw = "1"b; /* don't look at just our own requests */
				sender_id = arg;
				person = before (sender_id, ".");
				project = before (after (sender_id, "."), ".");
				if length (rtrim (person)) > 22 | search (substr (person, 1, 1), CAPS) = 0 then do;
					msg = "Invalid person name: " || person;
					go to abort_cmd;
				     end;
				if project = "" then do; /* try for "pers proj" form */
					call cu_$arg_ptr_rel (arg_no + 1, argptr, arglen, code, alp); /* peek at next arg */
					if code ^= 0 then first_arg = arg_no + 1; /* we may be done */
					else if length (arg) <= 9 & search (substr (arg, 1, 1), CAPS) ^= 0 then do;
						project = arg; /* if it looks like a project name, use it */
						arg_no = arg_no + 1; /* found it, advance index */
						used_up (arg_no) = "1"b;
					     end;
				     end;
			     end;
			else first_arg = arg_no;	/* not an id or pers/proj */
		     end;
		     if first_arg = 1 then first_arg = arg_no; /* if no ctl arg, go on with 4 */
		     if person ^= "" then if project = "" then project = "*"; /* no proj use * */
		     if entry = ASN then do;		/* for the abs next cmd we move the request into q 0 */
			     to_q_sw = "1"b;	/* mark as pre specified */
			     target_queue = 0;	/* this is the head of q 1 */
			end;
		end;

	     do arg_no = first_arg to nargs;
		if used_up (arg_no) then go to next_option;
		msg = "";				/* clear error message string */
		call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
		if code ^= 0 then do;
			msg = "Argument read error."; /* check the codes first time around only */
			go to abort_cmd;
		     end;

		if substr (arg, 1, 1) = "-" then do;	/* look for all allowable options */
			used_up (arg_no) = "1"b;
			option = arg;		/* save for better error messages */
			if option = "-admin" | option = "-am" | option = "-user" then do;
				arg_no = arg_no + 1;
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 | substr (arg, 1, 1) = "-" then do;
					msg = "No user name given with argument: " || option;
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				if admin_sw then do;
					msg = "Only one user name allowed. " || option;
					go to abort_cmd;
				     end;
				admin_sw = "1"b;	/* say we have a user name */
				search_all_sw = "1"b; /* look at all requests in the queues */
				sender_id = arg;	/* copy argument */
				person = before (sender_id, ".");
				project = before (after (sender_id, "."), ".");
				if person = "" then person = "*";
				if project = "" then project = "*";
				if (entry = ASC | entry = ASM | entry = ASN) & person = "*" then do;
					msg = "A user name other then ""*"" or blank must be given.";
					go to abort_cmd;
				     end;
			     end;
			else if option = "-brief" | option = "-bf" then brief_sw = "1"b; /* say brief option given */
			else if option = "-all" | option = "-a" then all_sw = "1"b; /* say all option given */
			else if option = "-queue" | option = "-q" then do;
				if queue_sw then do;/* duplicate option? */
					msg = "Duplicate queue specification argument: " || option;
					go to abort_cmd;
				     end;
				arg_no = arg_no + 1;/* get next argument - queue number */
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 | substr (arg, 1, 1) = "-" then do;
					msg = "Queue number missing.";
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				if (entry = CAR | entry = MAR | entry = ASC | entry = ASM | entry = ASN) &
				     (arg = "fg" | arg = "foreground") then queue_no = -1;
				else queue_no = convert (queue_no, arg); /* change to fixed bin */
				if ((entry = MAR | entry = CAR | entry = ASC | entry = ASM | entry = ASN) & queue_no < -1) |
				     ((entry = MDR | entry = MOR | entry = CDR | entry = COR | entry = CRR) & queue_no < 1) |
				     queue_no > 4 then do;
					msg = "Invalid queue: " || arg;
					go to abort_cmd;
				     end;
				queue_sw = "1"b;	/* indicate queue option given */
				first_q, last_q = queue_no;
			     end;
			else if (entry = CAR | entry = MAR | entry = ASC | entry = ASM | entry = ASN) &
			     (option = "-foreground" | option = "-fg") then do;
				if queue_sw then do;/* duplicate option? */
					msg = "Duplicate queue specification argument: " || option;
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				queue_no = -1;
				queue_sw = "1"b;	/* indicate queue option given */
				first_q, last_q = queue_no;
			     end;
			else if (entry = CAR | entry = MAR | entry = ASC | entry = ASM | entry = ASN) &
			     option = "-sender" then do;
				if sender_sw then do;
					msg = "Duplicate control argument: " || option;
					go to abort_cmd;
				     end;
				arg_no = arg_no + 1;
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 | substr (arg, 1, 1) = "-" then do;
					msg = "Sender name missing.";
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				sender_sw = "1"b;
				sender = arg;
			     end;
			else if (entry = CDR | entry = COR | entry = MDR | entry = MOR) & /* I/O Daemon request types */
			     (option = "-rqt" | option = "-request_type") then do;
				if rqt_sw then do;	/* duplicate option? */
					msg = "Duplicate control argument: " || option;
					go to abort_cmd;
				     end;
				arg_no = arg_no + 1;
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 | substr (arg, 1, 1) = "-" then do;
					msg = "Request type name missing.";
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				if (entry = CDR | entry = MDR) then do;
					call iod_info_$generic_type (arg, gen_type, code);
					if code ^= 0 then
					     if code = error_table_$id_not_found then do;
						     msg = "Unknown request type: " || arg;
						     go to abort_cmd;
						end;
					     else call err_proc (-1, 0, "Warning -- Unable to check request type ^a.", arg);
					else do;
						call iod_info_$queue_data (arg, default_q, max_q, code);
						if code ^= 0 then do;
							msg = "Unable to get default and max queues for: " || arg;
							go to abort_cmd;
						     end;
					     end;
					queue_type = arg;
				     end;
				else do;		/* must use enter_output_request to process	*/
						/*   request types for COR and MOR		*/
					call enter_output_request$request_type (arg,
					     gen_type, queue_type, default_q, max_q, code);
					if code ^= 0 then
					     if code = error_table_$id_not_found then do;
						     msg = "Unknown request type: " || arg;
						     go to abort_cmd;
						end;
					     else call err_proc (-1, 0, "Warning -- Unable to check request type ^a.", arg);
				     end;
				rqt_sw = "1"b;	/* say we got this arg */
			     end;
			else if (entry = MAR | entry = MDR | entry = MOR | entry = ASM) &
			     (option = "-to_queue" | option = "-tq" | option = "-to_q") then do;
						/* these recognize the -tq option */
				if to_q_sw then do; /* duplicate option? */
					msg = "Duplicate control argument: " || option;
					go to abort_cmd;
				     end;
				arg_no = arg_no + 1;/* get next argument - queue number */
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 | substr (arg, 1, 1) = "-" then do;
					msg = "Queue number missing for: " || option;
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				if (entry = MAR | entry = ASM) & (arg = "fg" | arg = "foreground") then queue_no = -1;
				else queue_no = convert (queue_no, arg); /* change to fixed bin */
				if ((entry = MAR | entry = ASM) & queue_no < -1) |
				     ((entry = MDR | entry = MOR) & queue_no < 1) |
				     queue_no > 4 then do;
					msg = "Invalid queue number: " || arg;
					go to abort_cmd;
				     end;
				target_queue = queue_no;
				to_q_sw = "1"b;
			     end;
			else if (entry = MDR | entry = MOR) &
			     (option = "-to_request_type" | option = "-to_rqt") then do;
						/* only MDR and MOR know about other request types */
				if to_rqt_sw then do; /* duplicate option? */
					msg = "Duplicate control argument: " || option;
					go to abort_cmd;
				     end;
				arg_no = arg_no + 1;
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 | substr (arg, 1, 1) = "-" then do;
					msg = "Request type name missing for: " || option;
					go to abort_cmd;
				     end;
				used_up (arg_no) = "1"b;
				if entry = MDR then do;
					call iod_info_$generic_type (arg, target_gen_type, code);
					if code ^= 0 then
					     if code = error_table_$id_not_found then do;
						     msg = "Unknown request type: " || arg;
						     go to abort_cmd;
						end;
					     else call err_proc (-1, 0, "Warning -- Unable to check request type ^a.", arg);
					else do;
						call iod_info_$queue_data (arg, target_default_q, target_max_q, code);
						if code ^= 0 then do;
							msg = "Unable to get default and max queues for: " || arg;
							go to abort_cmd;
						     end;
					     end;
					target_queue_type = arg;
				     end;
				else do;
					call enter_output_request$request_type (arg,
					     target_gen_type, target_queue_type,
					     target_default_q, target_max_q, code);
					if code ^= 0 then
					     if code = error_table_$id_not_found then do;
						     msg = "Unknown request type: " || arg;
						     go to abort_cmd;
						end;
					     else call err_proc (-1, 0, "Warning -- Unable to check request type ^a.", arg);
				     end;
				to_rqt_sw = "1"b;
			     end;
			else if (entry = COR | entry = MOR) &
			     (option = "-print" | option = "-pr") then do;
				gen_type = "printer";
				call enter_output_request$default_request_type (gen_type,
				     queue_type, default_q, max_q, code);
				if code ^= 0 then do;
					msg = "^/Default request type for printing unknown";
					go to abort_cmd;
				     end;
			     end;
			else if (entry = COR | entry = MOR) &
			     (option = "-punch" | option = "-pch") then do;
				gen_type = "punch";
				call enter_output_request$default_request_type (gen_type,
				     queue_type, default_q, max_q, code);
				if code ^= 0 then do;
					msg = "^/Default request type for punching unknown";
					go to abort_cmd;
				     end;
			     end;
			else if (entry = COR | entry = MOR) &
			     (option = "-plot") then do;
				gen_type = "plotter";
				call enter_output_request$default_request_type (gen_type,
				     queue_type, default_q, max_q, code);
				if code ^= 0 then do;
					msg = "^/Default request type for plotting unknown";
					go to abort_cmd;
				     end;
			     end;
			else if option = "-id" then do; /* we have a request ID type identifier */
				arg_no = arg_no + 1;
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 then do;
					msg = "Request match id missing for: " || option;
					go to abort_cmd;
				     end;
				if verify (arg, ID_CHARS) ^= 0 then do;
					msg = "Invalid request id: " || arg;
					go to abort_cmd;
				     end;
				type (arg_no) = ID; /* say this was given by id number */
				request_id_count = request_id_count + 1;
				if request_id_count = 1 then MATCH_ID = arg; /* save the global value */
				else MATCH_ID = ""; /* kill it if more than one */
				if entry = ASM then one_request_only = "1"b; /* an id means only one */
			     end;
			else if option = "-entry" | option = "-et" then do; /* also a segment identifier */
				arg_no = arg_no + 1;
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
				if code ^= 0 then do;
					msg = "Entry name missing for: " || option;
					go to abort_cmd;
				     end;
				type (arg_no) = ENTRY;
				entry_id_count = entry_id_count + 1;
			     end;
			else do;			/* Illegal option */
				code = error_table_$badopt;
				msg = option;
				go to abort_cmd;
			     end;
		     end;

/*	Not a control argument, must be a full or relative pathname */

		else do;
			if (entry = ASM | entry = ASC | entry = ASN) & substr (arg, 1, 1) ^= ">" then do;
				msg = "Not a full pathname: " || arg;
				go to abort_cmd;
			     end;
			type (arg_no) = PATH;	/* this one is a pathname */
			path_id_count = path_id_count + 1;
		     end;
next_option:   end;

/*	All the control arguments and pathnames passed the first test.  Now check for consistency */

	     if (request_id_count + path_id_count + entry_id_count) = 0 then do; /* Need at least one thing to cancel */
		     code = error_table_$noarg;	/* .. of course we could interpret this as cancel all */
		     msg = "No request identifiers given.";
abort_cmd:	     call err_proc (-1, code, msg, "");
		     if (entry = ASC | entry = ASM | entry = ASN) then
			if code = 0 then a_code = error_table_$bad_arg; /* be sure caller knows */
			else a_code = code;
		     return;
		end;

	     if request_id_count > 1 then /* for multiple -id args */
		if (path_id_count + entry_id_count) > 0 then do; /* can't have path or entry args */
			code = error_table_$bad_arg;
			msg = "Multiple -id args are incompatible with path or entry args.";
			go to abort_cmd;
		     end;
		else if one_request_only then do;	/* this is bad too */
			code = error_table_$bad_arg;
			msg = "Multiple -id args are not allowed.";
			go to abort_cmd;
		     end;

	     code = 0;

	     if (entry = ASM | entry = ASC | entry = ASN) & ^admin_sw then do;
		     code = error_table_$noarg;
		     msg = "No user name specified.";
		     go to abort_cmd;
		end;

	     if ^to_rqt_sw then do;			/* if no target specified, assume the same queue type */
		     target_queue_type = queue_type;
		     target_default_q = default_q;
		     target_max_q = max_q;
		     target_gen_type = gen_type;
		end;
	     else if target_queue_type = queue_type then to_rqt_sw = "0"b; /* same queue type */

	     if all_sw & queue_sw then do;		/* all and queue are incompatible */
		     msg = "The -all and -queue control arguments are incompatible.";
		     go to abort_cmd;
		end;

	     if (entry = MAR | entry = ASM) & ^to_q_sw then do;
		     msg = "Target queue for move not specified.";
		     go to abort_cmd;
		end;

	     if target_queue = -10 then target_queue = target_default_q; /* assume default if not set */

	     if ^queue_sw then all_sw = "1"b;

	     if one_request_only then brief_sw = "1"b;	/* if searching all Q's for one request */

	     if all_sw then do;			/* define the queues to search */
		     if (entry = MAR | entry = CAR | entry = ASC | entry = ASM) then first_q = -1;
		     else first_q = 1;
		     last_q = max_q;
		end;
	     else if ^queue_sw then first_q, last_q = default_q; /* use default if he didn't say */

	     if last_q > max_q then do;
		     msg = "Specified queue number is greater than maximum for: " || queue_type;
		     go to abort_cmd;
		end;

	     if queue_sw & /* if queue was given, check more */
		queue_type = "absentee" then do;	/* do we treat queue 0 and 1 as the same */
		     if (entry = MAR | entry = ASM | entry = ASN) &
			first_q = target_queue then go to same_q;
		     if first_q = 1 then first_q = 0;	/* he asked for 1, we look at 0 and 1 */
		end;				/* done with absentee stuff */

	     if (entry = MDR | entry = MOR) & ^to_rqt_sw & first_q = last_q & target_queue = first_q then do;
						/* same queue??? */
same_q:		     msg = "The same queue specified as source and target of move.";
		     go to abort_cmd;
		end;

	     if (entry = MDR | entry = MOR) & (target_gen_type ^= gen_type) then do; /* cross types? */
		     msg = "The target request type of move is not of the same generic type as the source.";
		     go to abort_cmd;
		end;

	     if to_q_sw then /* if moving, is the target defined? */
		if target_queue > target_max_q then do;
			msg = "Target queue number of move is greater than maximum for: " || target_queue_type;
			go to abort_cmd;
		     end;

	     if entry = MAR | entry = MDR | entry = MOR | entry = ASM | entry = ASN then verb = "move";
	     else verb = "cancel";			/* make messages clearer */

	     if admin_sw then
		user = rtrim (person) || "." || project;
	     else user = "*.*";			/* this will just format query message correctly */

/*	Check for valid star names in entry and path identifiers */

	     do arg_no = 1 to nargs;
		if ^used_up (arg_no) & type (arg_no) ^= ID then do; /* look at PATH and ENTRY args */
			call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
			if type (arg_no) = PATH then do; /* get the directory uid while we are here */
				call expand_pathname_ (arg, dir, input_seg, code);
				if code ^= 0 then do;
no_exp:					msg = "Unable to expand pathname for: " || arg;
					go to abort_cmd;
				     end;
				call expand_pathname_ (dir, arg_dir_dir, arg_dir_ent, code);
				if code ^= 0 then go to no_exp;
						/* Get the unique id of the directory containing the segment
						   so can still find it if path spelled differently */
				call hcs_$status_long (arg_dir_dir, arg_dir_ent, 1, addr (br), null, code);
				if code = 0 then arg_dir_uid (arg_no) = br.uid;
			     end;
			else dir = "";		/* avoid garbage */
			call check_star_name_$path (arg, code); /* segment name or starname */
			if code > 2 then do;	/* bad star name, forget it */
				used_up (arg_no) = "1"b;
				call err_proc (-1, code, "Argument ^a skipped.", arg);
				go to skip;
			     end;
			if code ^= 0 & one_request_only then do;
				code = error_table_$bad_arg;
				msg = "Starnames are not allowed by this command or with ""-id"" control argument.";
				go to abort_cmd;
			     end;
			starname (arg_no) = code;	/* record the name type */
			if code = 2 then do;	/* double star, be sure caller wants this */
				answer = "";
				query_info.version = query_info_version_4;
				query_info.yes_or_no_sw = "1"b;
				query_info.suppress_name_sw = "1"b;

				call ioa_$rsnnl ("^[your ^]requests^[ for ^a^;^s^]^[ from directory ^a^;^s^]",
				     msg, len, ^admin_sw, (user ^= "*.*"), user, (type (arg_no) = PATH), dir);

				call command_query_ (addr (query_info), answer, id,
				     "Do you want to ^a all ^a ^[in all ^a queues^;in ^a ^a^]?",
				     verb, msg, all_sw, queue_type, Q_name (last_q));
				if answer ^= "yes" then do;
					used_up (arg_no) = "1"b; /* skip this one in the future */
					go to skip;
				     end;
			     end;
		     end;
		else if ^used_up (arg_no) then
		     if ((path_id_count + entry_id_count) > 0) & MATCH_ID ^= ""
		     then used_up (arg_no) = "1"b;	/* special case the use of
						   -id N alone, otherwise this was the MATCH_ID source */

skip:	     end;

/*	if move command, open target queue */

	     if entry = MAR | entry = MDR | entry = MOR | entry = ASM then do;
		     if target_queue < 0 then
			mseg_name = rtrim (target_queue_type) || "_foreground.ms"; /* a -1 is the foreground queue */
		     else do;			/* otherwise convert the queue number */
			     queue_pic = target_queue;/* convert number to char */
			     mseg_name = rtrim (target_queue_type) || "_" || queue_pic || ".ms";
			end;
		     call message_segment_$open (sysdir, mseg_name, target_mseg_idx, code);
		     if code ^= 0 then do;
			     call err_proc (1, code, "Unable to open target message segment: ^a",
				rtrim (sysdir) || ">" || mseg_name);
			     return;
			end;
		end;

	     call get_system_free_area_ (areap);	/* get pointer to area - place to read message into */
	     mseg_message_info_ptr = addr (local_mseg_message_info);
	     unspec (mseg_message_info) = ""b;
	     mseg_message_info.version = MSEG_MESSAGE_INFO_V1;

	     on cleanup call cleaner_up;

	     queue_no = first_q;			/* set value of first queue to be searched */
	     try_again = "1"b;			/* try_again if salvaged mseg */
	     id_match_ms_id, single_ms_id = "0"b;
	     found_one_match, found_all_arg_match = "0"b;

queue_loop:					/* construct entry name of message segment */
	     if queue_no < 0 then
		mseg_name = rtrim (queue_type) || "_foreground.ms";
	     else do;
		     queue_pic = queue_no;		/* convert number to char */
		     mseg_name = rtrim (queue_type) || "_" || queue_pic || ".ms";
		end;

/* 	open message segment containing requests */

	     call message_segment_$open (sysdir, mseg_name, mseg_idx (queue_no), code);
	     if code ^= 0 then do;
message_error:	     if code ^= error_table_$no_message then
			call err_proc (1, code, "^a", mseg_name);
		     end_msg_seg = "1"b;		/* indicate that this mseg is done */
		     try_again = "1"b;		/* ready for next one */
		     go to next_msg;		/* free request and go on to next queue or phase */
		end;

	     if to_q_sw & target_mseg_idx = mseg_idx (queue_no) then do;
		     end_msg_seg = "1"b;		/* don't search target queue for match on -all */
		     go to next_msg;
		end;

	     call message_segment_$get_mode_index (mseg_idx (queue_no), mode, code);
	     if code ^= 0 then do;
		     call err_proc (-1, code, "Unable to check user's mode to message segment ^a.", mseg_name);
		     end_msg_seg = "1"b;
		     go to next_msg;
		end;
	     if admin_sw then do;			/* process must have read and delete access */
		     if (mode & "01100"b) ^= "01100"b then do; /* trouble */
			     call err_proc (-1, 0,
				"Process lacks access to read and delete another user's requests. ^a", mseg_name);
			     end_msg_seg = "1"b;
			     go to next_msg;
			end;
		end;
	     else if (mode & "00010"b) ^= "00010"b then do; /* otherwise process must have own access */
		     call err_proc (-1, 0, "Process lacks access to message segment.  ^a", mseg_name);
		     end_msg_seg = "1"b;
		     go to next_msg;
		end;

	     end_msg_seg = "0"b;			/* not at end of message segment yet */

/*	The first read from a message segment will be for the first message.  The own entry is used */
/*	to get the callers own messages.  In admin mode, we read every message. */

	     re_read_label = first_read;		/* come here if salvaged */

first_read:    mseg_message_info.own = ^search_all_sw;
	     mseg_message_info.message_code = MSEG_READ_FIRST;
	     call message_segment_$read_message_index
		(mseg_idx (queue_no), areap, mseg_message_info_ptr, code);

message_loop:
	     if code ^= 0 then
		if try_again & code = error_table_$bad_segment then do; /* salvaged!  Try again? */
			call err_proc (1, 0, "Warning:  message segment ^a has been salvaged.", mseg_name);
			try_again = "0"b;		/* avoid looping forever */
			go to re_read_label;
		     end;
		else go to message_error;		/* abort this mseg */

	     try_again = "1"b;			/* got a good message, allow for second salvage */
	     bad_msg_version = "0"b;			/* assume good format, then we check */

	     reqp = mseg_message_info.ms_ptr;
	     if reqp -> queue_msg_hdr.hdr_version ^= queue_msg_hdr_version_1 then bad_msg_version = "1"b;
	     rdir = reqp -> queue_msg_hdr.dirname;	/* if bad version, these will not be used */
	     rseg = reqp -> queue_msg_hdr.ename;
	     msg_id_code = reqp -> queue_msg_hdr.msg_time;

	     if bad_msg_version then do;
		     rseg = "Undefined_Segment_Name";	/* set this for messages */
		     if MATCH_ID ^= "" then go to next_msg; /* can't trust msg_id_code, so flush */
		end;
	     else do;				/* for good messages, find directory uid */
		     call expand_pathname_ (rdir, req_dir_dir, req_dir_ent, code);
		     call hcs_$status_long (req_dir_dir, req_dir_ent, 1, addr (br), null, code);
		     if code ^= 0 then do;
			     req_dir_uid = ""b;
			end;
		     else do;
			     req_dir_uid = br.uid;	/* save for the uid match */
			end;

		     if MATCH_ID ^= "" then do;	/* are we looking for one match id? */
			     if ^match_request_id_ (msg_id_code, MATCH_ID)
			     then go to next_msg;	/* if not this one, go on */
			end;

		     if sender_sw & sender ^= reqp -> request.sender then go to next_msg;
						/* check for RJE station sender if needed */
		end;

	     mseg_sender_id = mseg_message_info.sender_id;
	     if search_all_sw then do;		/* are we looking for a particular sender's request */
						/* and if so is this his request */
		     if (person ^= "*") & (person ^= before (mseg_sender_id, ".")) then go to next_msg;
		     if (project ^= "*") & (project ^= before (after (mseg_sender_id, "."), ".")) then go to next_msg;
		end;

	     arg_didnt_match = "0"b;			/* see if one request id didn't match this request */
	     arg_did_match = "0"b;			/* and if one did. */

	     do arg_no = 1 to nargs;			/* scan all request identifier arguments for a match */
		if ^used_up (arg_no) then do;
			if bad_msg_version then /* can we delete it anyway? */
			     if type (arg_no) = ENTRY & starname (arg_no) = 2 then go to found_match;
			     else if one_request_only then go to next_msg;
			     else go to next_arg;

			call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);

			if type (arg_no) = PATH | type (arg_no) = ENTRY then do;
				if type (arg_no) = PATH then do; /* get dir and entry name for argument */
					call expand_pathname_ (arg, dir, input_seg, code);
					if rdir ^= dir then /* directories do not match */
					     if arg_dir_uid (arg_no) ^= ""b & req_dir_uid ^= ""b then do; /* try uid match */
						     if arg_dir_uid (arg_no) ^= req_dir_uid then go to no_match; /* dir mismatch? */
						end;
					     else go to no_match; /* no valid uids & no dir match */
				     end;
				else do;		/* otherwise we just have an entry name */
					input_seg = arg;
					dir = "";
				     end;

				if starname (arg_no) = 2 then go to found_match; /* try for speed */

				call match_star_name_ (rseg, input_seg, code); /* see if entry names match */
				if code ^= 0 then
				     if queue_type = "absentee" then do; /* for absentee, check for .absin */
						/* if suffix missing - append it */
					     call suffixed_name_$make (input_seg, "absin", input_seg, code);
					     if code ^= 0 then do;
						     call err_proc (-1, code, " Argument ^a ignored.", arg);
						     used_up (arg_no) = "1"b;
						     go to no_match;
						end;
					     call match_star_name_ (rseg, input_seg, code); /* see if entry names match */
					     if code ^= 0 then go to no_match;
					end;
				     else go to no_match;
			     end;
			else do;			/* only thing left is a match ID */
				input_seg = "";
				dir = "";
				if ^match_request_id_ (msg_id_code, arg) then go to no_match;
				if arglen = 19 & ^one_request_only then starname (arg_no) = 2;
						/* all the digits, treat as starname */
				if id_match_ms_id = ""b then /* record first request id match */
				     id_match_ms_id = mseg_message_info.ms_id;
			     end;

/*		This request matches, record it for later or process if starname or full ID given. */
/*		Ignore the fact that one request can match more than one request identifier */
/*		(e.g., >dir>foo, -entry foo, -id <foo's id>)	*/

found_match:		matched (arg_no) = matched (arg_no) + 1; /* count number of matches */
			queue (arg_no) = queue_no;	/* record the queue */
			msg_id (arg_no) = mseg_message_info.ms_id; /* and message id */
			req_seg (arg_no) = rseg;	/* save the segment name for messages */

			if one_request_only then do;	/* handle different, all args must match 1 request */
				found_one_match = "1"b; /* some arg matched some request */
				arg_did_match = "1"b; /* got an arg matching this request */
				if id_match_ms_id ^= ""b then /* if some request id matched, it better be this one */
				     if id_match_ms_id ^= mseg_message_info.ms_id then go to no_match;
				if entry = ASN | entry = ASC then a_req_id_ret = reqp -> queue_msg_hdr.msg_time;
				go to next_arg;
			     end;

			if starname (arg_no) > 0 then do;
				if entry = CDR | entry = COR | entry = CAR | entry = CRR then
				     call delete_request (mseg_idx (queue_no), msg_id (arg_no), "1"b, code);
				else call move_request (mseg_idx (queue_no), msg_id (arg_no), code);
				if code ^= 0 then matched (arg_no) = matched (arg_no) - 1; /* request not found */
			     end;
			go to next_msg;
		     end;
		do while ("0"b);			/* skip next statement when falling through */
						/* i.e., when the arg was already used up */
no_match:		     arg_didnt_match = "1"b;
		end;
next_arg:	     end;

	     if arg_did_match & ^arg_didnt_match then do; /* the one_request_only case */
		     if found_all_arg_match then do;	/* more than one matched all_arg args */
bad_match:		     msg = "Specified arguments do not define a unique request.";
			     if entry = ASN | entry = ASC then a_req_id_ret = 0;
			     code = 0;
			     go to abort_cmd;
			end;
		     found_all_arg_match = "1"b;	/* this is the request we want (we hope) */
		     single_ms_id = mseg_message_info.ms_id;
		end;

next_msg:	     if reqp ^= null then do;			/* free up allotment in area if necessary */
		     free reqp -> request;
		     reqp = null;			/* indicate that freeing performed */
		end;
	     if end_msg_seg then /* this queue is done */
		if queue_no < last_q then do;		/* do we want to look at other queues */
			queue_no = queue_no + 1;	/* look at next priority level */
			go to queue_loop;
		     end;
		else go to delete_things;		/* now do the final deletions or moves */

	     old_ms_id = mseg_message_info.ms_id;	/* want to continue reading more requests */

/*	For each read after the first, read the next message in the queue  */

	     re_read_label = inc_read;		/* retries now come here */

inc_read:	     mseg_message_info.own = ^search_all_sw;
	     mseg_message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
	     mseg_message_info.ms_id = old_ms_id;
	     call message_segment_$read_message_index
		(mseg_idx (queue_no), areap, addr (mseg_message_info), code);
	     go to message_loop;

/*	Now we are ready to delete/move things specified uniquely if there was only a single match */

delete_things:
	     if one_request_only then do;		/* double check this case */
		     code = 0;			/* for error reporting */
		     if ^found_one_match then do;
			     if target_queue = -10 then /* if not moving, simple message */
				msg = "No matching request found.";
			     else msg = "No matching request found outside of " || Q_name (target_queue);
						/* hide Q 0, but accurate */
			     go to abort_cmd;
			end;
		     else if ^found_all_arg_match then go to bad_match;
		     else do;			/* delete/move the single request */
			     queue_no = -10;	/* mark as undefined for now */
			     do idx = 1 to nargs while (queue_no = -10);
				if ^used_up (idx) then
				     if msg_id (idx) = single_ms_id then do; /* this is it */
					     arg_no = idx; /* get ready for the internal procs */
					     queue_no = queue (arg_no);
					end;
			     end;
			     if queue_no = -10 then do; /* OOPS, Programming error */
				     msg = "Software error, try other arguments.";
				     go to abort_cmd;
				end;
			     if entry = ASC | entry = CAR | entry = CDR | entry = COR | entry = CRR then
				call delete_request (mseg_idx (queue_no), single_ms_id, "0"b, code);
			     else call move_request (mseg_idx (queue_no), single_ms_id, code);
			     if code ^= 0 then do;
				     msg = "Request already gone from " || Q_name (queue_no);
				     go to abort_cmd;
				end;
			end;
		     go to DONE;			/* omit the next bunch of loops */
		end;

	     do arg_no = 1 to nargs;			/* last time around, delete or move single matches */
		if ^used_up (arg_no) & starname (arg_no) = 0 then do;
			if matched (arg_no) > 1 then do; /* oops, multiple matches, complain */
				call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);

				if type (arg_no) = PATH then do; /* make up full path for error msg */
					call absolute_pathname_ (arg, msg, code); /* it expanded before ok */
					msg = "pathname " || substr (msg, 1, length (rtrim (msg))); /* mark the front with type */
				     end;
				else if type (arg_no) = ENTRY then msg = "entry " || arg;
				else msg = "match id " || arg;

				call ioa_$rsnnl ("Did not ^a requests:  ^d matches found for ^a", long_msg, len,
				     verb, matched (arg_no), msg);
				call err_proc (-1, 0, "^a", long_msg);
				used_up (arg_no) = "1"b;
			     end;
			else if matched (arg_no) = 1 then do; /* could have been no match */
				queue_no = queue (arg_no); /* queue we found it in */
				if entry = CAR | entry = CDR | entry = COR | entry = CRR then
				     call delete_request (mseg_idx (queue_no), msg_id (arg_no), "0"b, code);
				else call move_request (mseg_idx (queue_no), msg_id (arg_no), code);
				used_up (arg_no) = "1"b;
			     end;
		     end;
	     end;

	     if ^brief_sw then /* report any no-matches unless user said be quiet */
		do arg_no = 1 to nargs;
		     if matched (arg_no) = 0 & ^used_up (arg_no) then do;
			     call cu_$arg_ptr_rel (arg_no, argptr, arglen, code, alp);
			     if MATCH_ID ^= "" then id_msg = "ID " || rtrim (MATCH_ID) || " ";
			     else id_msg = "";
			     if type (arg_no) = PATH then do; /* make up full path for error msg */
				     call absolute_pathname_ (arg, msg, code); /* it expanded before ok */
				     msg = id_msg || "pathname " || msg; /* mark the front with type */
				end;
			     else if type (arg_no) = ENTRY then msg = id_msg || "entry " || arg;
			     else msg = "match id " || arg;
			     call ioa_$rsnnl ("Request^[s^;^] not found in ^a ^[^a^;queues^s^]:  ^a", long_msg, len,
				(starname (arg_no) > 0), queue_type, ^all_sw, Q_name (queue_no), msg);
			     call err_proc (-1, 0, "^a", long_msg);
			end;
		end;

/*	INTERNAL PROCEDURES WHICH MUST BE WITHIN THE SCOPE OF THIS BEGIN BLOCK FOLLOW		*/


/*	INTERNAL PROCEDURES - INSIDE BEGIN BLOCK	*/

move_request: proc (mseg_idx, msg_id, code);

	dcl     mseg_idx		 fixed bin;
	dcl     msg_id		 bit (72) aligned;
	dcl     code		 fixed bin (35);
	dcl     new_msg_id		 bit (72) aligned;
	dcl     req_ptr		 ptr init (null);
	dcl     msg_len		 fixed bin (24);
	dcl     try_again		 bit (1);

	on cleanup begin;
		if req_ptr ^= null then free req_ptr -> request;
	     end;

	try_again = "1"b;				/* allow retry on read */
	mseg_message_info.ms_ptr = null;		/* no current allocation */

read_again: mseg_message_info.own = ^admin_sw;
	mseg_message_info.message_code = MSEG_READ_SPECIFIED;
	mseg_message_info.ms_id = msg_id;
	call message_segment_$read_message_index
	     (mseg_idx, areap, addr (mseg_message_info), code); /* read the current message */
	if code ^= 0 then do;
forget_it:	if mseg_message_info.ms_ptr ^= null then free mseg_message_info.ms_ptr -> request;
		if code = error_table_$no_message then return;
		if try_again & code = error_table_$bad_segment then do; /* salvaged */
			try_again = "0"b;
			go to read_again;
		     end;
		call err_proc (-1, code, "Message segment error.", "");
		go to DONE;
	     end;

	req_ptr = mseg_message_info.ms_ptr;		/* so cleanup handler can function */
	msg_len = mseg_message_info.ms_len;

	if req_ptr -> request.state = STATE_TRANSITION |
	     req_ptr -> request.state = STATE_RUNNING then do;
		call ioa_$rsnnl ("Request ^a>^a ^a not moved.^/It is already running.", long_msg, len,
		     req_ptr -> request.dirname, req_ptr -> request.ename,
		     request_id_ (req_ptr -> request.msg_time));
		call msg_proc (rtrim (long_msg));
		return;
	     end;

	req_ptr -> request.state = STATE_UNPROCESSED;	/* reset state like a new request */

	if admin_sw then do;
		on linkage_error begin;		/* in case process faults on queue_admin_ gate */
			call err_proc (-1, 0, "Process lacks access to move another user's requests.", "");
			go to DONE;		/* just give up */
		     end;

		call queue_admin_$add_index (target_mseg_idx, addr (mseg_message_info), new_msg_id, code);
		if code ^= 0 then go to forget_it;
		revert linkage_error;
	     end;
	else do;
		call message_segment_$add_index (target_mseg_idx, req_ptr, msg_len, new_msg_id, code);
		if code ^= 0 then go to forget_it;
	     end;

	free req_ptr -> request;
	req_ptr = null;

	if entry = MAR | entry = ASM | entry = ASN then /* just for absentee */
	     wakeup_answering_service = "1"b;		/* tell AS to look over the queues */

/*	if that went well we can delete the old message from the original queue */

	call message_segment_$delete_index (mseg_idx, msg_id, code);
	if code ^= 0 then do;			/* duplicate messages exist */
		call err_proc (-1, code, "^/Message added to target queue, but not deleted from source. ^a",
		     req_seg (arg_no));
		go to DONE;
	     end;

	if ^brief_sw & ((starname (arg_no) > 0) | all_sw) then do; /* print message for multi-match */
		if entry = MAR | entry = ASM | entry = ASN then do;
			call ioa_$rsnnl ("Absentee request ^a^[ for ^a^;^s^] moved from ^a to ^a.",
			     long_msg, len, req_seg (arg_no), admin_sw,
			     sender_id, Q_name (queue_no), Q_name (target_queue));
			call msg_proc (rtrim (long_msg));
		     end;
		else call ioa_ ("Daemon request ^a^[ for ^a^;^s^] moved from ^a queue ^d to^[ ^a^;^s^] queue ^d.",
			req_seg (arg_no), admin_sw, sender_id,
			queue_type, queue_no, to_rqt_sw, target_queue_type, target_queue);
	     end;

	return;

     end move_request;

delete_request: proc (mseg_idx, msg_id, force_sw, code);

	dcl     mseg_idx		 fixed bin;
	dcl     msg_id		 bit (72) aligned;
	dcl     force_sw		 bit (1);
	dcl     code		 fixed bin (35);
	dcl     as_code		 fixed bin (35);
	dcl     req_ptr		 ptr init (null);
	dcl     msg_len		 fixed bin (24);
	dcl     try_again		 bit (1);
	dcl     answer		 char (12) var;
	dcl     rq_state		 fixed bin;

	on cleanup begin;
		if req_ptr ^= null then free req_ptr -> request;
	     end;

	as_code = 0;				/* be sure this is cleared */
	try_again = "1"b;				/* allow retry on read */
	mseg_message_info.ms_ptr = null;		/* no current allocation */

	if entry = CRR then go to re_try;		/* do we check for a running job? */
read_again: mseg_message_info.own = ^admin_sw;
	mseg_message_info.message_code = MSEG_READ_SPECIFIED;
	mseg_message_info.ms_id = msg_id;
	call message_segment_$read_message_index
	     (mseg_idx, areap, addr (mseg_message_info), code); /* read the current message */
	if code ^= 0 then do;
forget_it:	if mseg_message_info.ms_ptr ^= null then free mseg_message_info.ms_ptr -> request;
		if code = error_table_$no_message then return;
		if try_again & code = error_table_$bad_segment then do; /* salvaged */
			try_again = "0"b;
			go to read_again;
		     end;
		call err_proc (-1, code, "Message segment error.", "");
		go to DONE;
	     end;

	req_ptr = mseg_message_info.ms_ptr;		/* so cleanup handler can function */
	msg_len = mseg_message_info.ms_len;
	rq_state = req_ptr -> request.state;

	if entry = CAR | entry = ASC then do;		/* Absentee checks */
		if rq_state = STATE_TRANSITION | rq_state = STATE_RUNNING then do; /* already going */
			if entry = ASC then do;	/* avoid questions and return code */
				as_code = error_table_$request_pending;
			     end;
			else do;

				if type (arg_no) = ID & force_sw then go to bump_it; /* fully defined, don't ask */

				query_info.version = query_info_version_4;
				query_info.yes_or_no_sw = "1"b;
				query_info.suppress_name_sw = "0"b;

				answer = "";	/* clear the answer to be sure */

				call command_query_ (addr (query_info), answer, id,
				     "Request ^a>^a ^a is^[^xnow being considered for^] running.^/Do you wish to cancel and bump it^[^xif it is running^]?",
				     req_ptr -> request.dirname, req_ptr -> request.ename,
				     request_id_ (req_ptr -> request.msg_time), (rq_state = STATE_TRANSITION),
				     (rq_state = STATE_TRANSITION));

				if answer ^= "yes" then return; /* otherwise it is no or an error */


bump_it:				call send_as_wakeup (ASR_AC_CANCEL, req_ptr -> request.msg_time);

			     end;
		     end;
	     end;

	free req_ptr -> request;
	req_ptr = null;

	try_again = "1"b;

/* IO_Daemons 79: Warn user that running daemon request can not be cancelled
                 and leave the request in the queue */
re_try:   if (entry = COR | entry = CDR ) & (rq_state = STATE_RUNNING)
	     then call ioa_ ("Unable to cancel daemon request ^a^[ for ^a^;^s^] from ^a queue ^d.  It is already running.", 
 	       req_seg (arg_no), admin_sw, sender_id, queue_type, queue_no);
	     else do;
		/*   delete the message from the original queue */
		call message_segment_$delete_index (mseg_idx, msg_id, code);    
		if code ^= 0 then do;
		     if code = error_table_$no_message then return; /* someone got it first */
		     if try_again & code = error_table_$bad_segment then do;
			try_again = "0"b;
			go to re_try;
		     end;
		     call ioa_$rsnnl ("^/Unable to cancel request ^a from ^a queue ^d.", long_msg, len,
		     req_seg (arg_no), queue_type, queue_no);
		     call err_proc (-1, code, "^a", long_msg);
		     go to DONE;			/* stop trying now */
		     end;

		if (rq_state = STATE_RUNNING) |
    		      ^brief_sw & ((starname (arg_no) > 0) | all_sw) then do; /* print message for multi-match */
			if entry = CAR | entry = ASC then do;
			     call ioa_$rsnnl ("Absentee request ^a^[ for ^a^;^s^] cancelled^[ from ^a^;^s^].",
				long_msg, len, req_seg (arg_no), admin_sw, sender_id, all_sw, Q_name (queue_no));
			     call msg_proc (rtrim (long_msg));
			     end;
			     else if entry = CDR | entry = COR 
				then call ioa_ ("Daemon request ^a^[ for ^a^;^s^] cancelled^[ from queue ^d^;^s^].",
				req_seg (arg_no), admin_sw, sender_id, all_sw, queue_no);
			     else if entry = CRR
				then call ioa_ ("Retrieval request ^a^[ for ^a^;^s^] cancelled^[ from queue ^d^;^s^].",
				req_seg (arg_no), admin_sw, sender_id, all_sw, queue_no);
			     end;

		     end;

	          if code = 0 then code = as_code;		/* pass back if set */

     end delete_request;

err_proc: proc (severity, code, ctl_string, argument);

	dcl     severity		 fixed bin;
	dcl     code		 fixed bin (35);
	dcl     ctl_string		 char (*);
	dcl     argument		 char (*);

	if call_sys_log then

	     call sys_log_$error_log (severity, code, id, ctl_string, argument);

	else call com_err_ (code, id, ctl_string, argument);

	return;


msg_proc: entry (ctl_string);

	if call_sys_log then

	     call sys_log_$error_log (-1, 0, "", ctl_string); /* simple message */

	else call ioa_ (ctl_string);

	return;

     end err_proc;



/*	END OF INTERNAL PROCEDURES WITHIN THE SCOPE OF THE BEGIN BLOCK	*/


DONE:	end BLOCK;				/* of begin block */

	call cleaner_up;				/* free, close etc. */

	return;


/*	ENTRY POINTS TO SET TEST DIRECTORIES FOR EACH REQUEST TYPE		*/


test_car: test_mar: entry (test_sys_dir);		/* entry point for testing car and mar commands */

	dcl     test_sys_dir	 char (*);

	abs_sysdir = test_sys_dir;			/* copy name of test system directory */
	not_initialized = "1"b;			/* force definition of default and max queues */
	return;


test_cdr: test_mdr: entry (test_sys_dir);		/* must share entry because of iod_info_ */

	iod_sysdir = test_sys_dir;
	call iod_info_$test (test_sys_dir);
	not_initialized = "1"b;			/* force definition of default and max queues */
	return;


test_crr: entry (test_sys_dir);

	retriever_sysdir = test_sys_dir;
	not_initialized = "1"b;			/* force definition of default and max queues */
	return;

/*	INTERNAL PROCEDURES - OUTSIDE SCOPE OF BEGIN BLOCK		*/

cleaner_up: proc;

	dcl     ec		 fixed bin (35);
	dcl     i			 fixed bin;

	if reqp ^= null then do;
		free reqp -> request;
		reqp = null;
	     end;

	do i = -1 to 4;
	     if mseg_idx (i) ^= 0 then call message_segment_$close (mseg_idx (i), ec);
	end;

	if target_mseg_idx ^= 0 then call message_segment_$close (target_mseg_idx, ec);

	if wakeup_answering_service then call send_as_wakeup (ASR_AC_LOGIN, (0));

	return;

     end cleaner_up;



init: proc;

	call iod_info_$queue_data ("printer", io_default_q, io_max_q, code);
	if code ^= 0 then do;			/* attempt default action */
		io_max_q = 4;			/* the max max_q */
		io_default_q = 3;			/* as in the past */
	     end;

	abs_max_q = 4;				/* AS creates foreground queue and queues 0, 1, 2, 3, & 4 */
	call system_info_$default_absentee_queue (abs_default_q);
	if abs_default_q = 0 then abs_default_q = 3;
						/* default default queue is 3 */

	call hcs_$star_ (retriever_sysdir, "volume_retriever*.ms", 2, null, ret_max_q, null, null, code);
	if code ^= 0 then
	     ret_max_q = 3;				/* retriever never has more than three */
	ret_default_q = min (ret_max_q, 3);

	not_initialized = "0"b;			/* we have the values now */

	return;

     end init;


send_as_wakeup:
     procedure (P_function, P_request_id);

	dcl     P_function		 fixed bin parm;
	dcl     P_request_id	 fixed bin (71) parm;

	local_asraci.version = ASR_AC_INFO_VERSION_1;
	local_asraci.action_code = P_function;
	local_asraci.request_id = P_request_id;
	local_asraci.header.version = as_request_version_1;
	local_asraci.header.type = ASR_ABS_COMMAND;
	local_asraci.header.reply_channel = 0;

	call send_as_request_$no_block (addr (local_asraci), currentsize (local_asraci),
	     ""b, code);

	return;

     end send_as_wakeup;


     end cancel_abs_request;
