/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* format: style2 */
audit_editor:
     proc (p_buff_ptr, p_buff_len, p_actual_len, p_audited_iocb, p_code);

/* The audit_editor procedure is bound in with audit_, and is not
   an externally available entry. INput is in param_buffer (defined by p_buff_ptr,
   p_buff_len, and p_actual_len). param_buffer is also used for output from the
   editor.  If the string to be output is too large for the param_buffer as
   defined on entry, i.e. if p_buff_len is too small, param_buffer is
   redefined on the audit_ temp_seg pointed to by blk.temp_seg_ptr. To preserve
   "recursiveness" of audit_editor and audit_get_line(in audit_), the audit_editor
   uses a temp_seg  in calls to iox_$get_line as its input buffer. Also, to avoid
   edit buffer size problems, edit_buffer is based on a temp_seg.
   The requests supported by audit_editor are in the parse_request internal
   procedure, the addressing syntax is enforced by decode_address.

   12/08/78 Written by Lindsey L. Spratt
   Modified:
   11/26/79  by  Lindsey L. Spratt  to add prompting.
12/11/79  by  Lindsey L. Spratt to modify prompting, add "=" request, add short
names for requests (remove "." prefix).
03/20/81  by  Lindsey L. Spratt:  Remove blk.editor_prompt_terminator, use
	    blk.editor_prompt_string as an ioa_ control string.
*/


/* Parameter */

	dcl     p_buff_ptr		 ptr;
	dcl     p_buff_len		 fixed bin (21);
	dcl     p_actual_len	 fixed bin (21);
	dcl     p_audited_iocb	 ptr;
	dcl     p_code		 fixed bin (35);

/* Automatic */

	dcl     1 position_info	 like position_info_template;
	dcl     1 saved_audit_file_header
				 like audit_file_header;
	dcl     1 aut_last_return_line,
		2 not_in_string	 bit (1),
		2 string		 char (512) varying,
		2 position	 like position_template;
	dcl     1 current_position	 like position_template;
	dcl     1 begin_position	 like position_template;
	dcl     1 end_position	 like position_template;
	dcl     idx_of_first_non_white_space_char
				 fixed bin (35);
	dcl     level		 fixed bin;
	dcl     request_index	 fixed bin;
	dcl     code		 fixed bin (35);
	dcl     areap		 ptr;
	dcl     new_edit_buffer_ptr	 ptr;
	dcl     default_iocb	 ptr;
	dcl     request_line_length	 fixed bin;
	dcl     request_line_ptr	 ptr;
	dcl     no_last_return_line	 bit (1);
	dcl     edit_buffer_ptr	 ptr;
	dcl     string_delimiter	 char (1);
	dcl     auditing_iocb	 ptr;
	dcl     blkptr		 ptr;
	dcl     warn_user_on_bad_request
				 bit (1);
	dcl     (edit_buffer_length, new_edit_buffer_length)
				 fixed bin;
	dcl     (max_edit_buffer_length, max_request_line_length)
				 fixed bin;
	dcl     temp_seg_ptr	 (3) ptr;

/* Based */
	dcl     area		 area (2048) based (areap);
	dcl     request_line	 char (request_line_length) based (request_line_ptr);
	dcl     edit_buffer		 char (edit_buffer_length) based (edit_buffer_ptr);
	dcl     param_buffer	 char (p_actual_len) based (p_buff_ptr);
	dcl     new_edit_buffer	 char (new_edit_buffer_length) based (new_edit_buffer_ptr);

/* Builtin */

	dcl     null		 builtin;
	dcl     (addr, addrel, allocation, bin, hbound, index, length, ltrim, rtrim, search, substr, verify)
				 builtin;

/* Condition */

	dcl     cleanup		 condition;



/* Controlled */

	dcl     1 con_last_return_line controlled,
		2 not_in_string	 bit (1),
		2 string		 char (512) varying,
		2 position	 like position_template;

/* Entry */

	dcl     audit_file_position_$move_number
				 entry (ptr, bit (1), bit (1), bit (1), fixed bin, ptr, fixed bin (35));
	dcl     audit_file_position_$forward_search
				 entry (ptr, char (*) varying, ptr, fixed bin (35));
	dcl     audit_file_position_$backward_search
				 entry (ptr, char (*) varying, ptr, fixed bin (35));
	dcl     audit_file_position_$next
				 entry (ptr, ptr, fixed bin (35));
	dcl     audit_file_position_$previous
				 entry (ptr, ptr, fixed bin (35));
	dcl     audit_file_position_$last
				 entry (ptr, ptr, fixed bin (35));
	dcl     audit_file_position_$set_count
				 entry (ptr, ptr, fixed bin (35));

	dcl     get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35));
	dcl     release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
	dcl     get_system_free_area_	 entry () returns (ptr);
	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
	dcl     ioa_$ioa_switch	 entry options (variable);
	dcl     ioa_$ioa_switch_nnl	 entry options (variable);
	dcl     cu_$cp		 entry (ptr, fixed bin, fixed bin (35));
	dcl     abbrev_$expanded_line	 entry (ptr, fixed bin, ptr, fixed bin, ptr, fixed bin);
	dcl     search_file_	 entry (ptr, fixed bin, fixed bin, ptr, fixed bin, fixed bin, fixed bin,
				 fixed bin, fixed bin (35));

/* External */

	dcl     sys_info$max_seg_size	 fixed bin (35) ext;
	dcl     error_table_$empty_file
				 fixed bin (35) ext;
	dcl     error_table_$no_stmt_delim
				 fixed bin (35) ext;
	dcl     error_table_$end_of_info
				 fixed bin (35) ext;

/* Static */

	dcl     static_level	 fixed bin internal static init (0);
	dcl     NL		 char (1) internal static options (constant) init ("
");


/* Increment the count of the recursive invocations of the editor. */

	static_level = static_level + 1;
	level = static_level;

/* Push the last_return_line stack if its depth is less than
   the current level of recursion. The no_last_return_line switch is
   "1"b if there was no last_return_line at this level of recursion. */

	if allocation (con_last_return_line) < level
	then do;
		no_last_return_line = "1"b;
		allocate con_last_return_line;
	     end;
	else no_last_return_line = "0"b;
	on condition (cleanup)
	     begin;
		do while (allocation (con_last_return_line) >= level);
		     free con_last_return_line;
		end;
		static_level = level - 1;
	     end;

/* Put the contents of the last_return_line of this level in
   automatic storage, to insure reference to the correct value,
   regardless of additional recursion. */

	aut_last_return_line = con_last_return_line;
	warn_user_on_bad_request = "0"b;
	max_request_line_length = sys_info$max_seg_size * 4;
	max_edit_buffer_length = sys_info$max_seg_size * 4;
	position_info.any_tag = "0"b;
	current_position.component_number = -1;
	current_position.component_max_char_index = -1;
	current_position.component_ptr = null;
	current_position.char_index = -1;
	current_position.aep = null;

	areap = get_system_free_area_ ();
	call get_temp_segments_ ("audit_editor", temp_seg_ptr, code);
	if code ^= 0
	then do;
		p_code = code;
		return;
	     end;
	edit_buffer_ptr = temp_seg_ptr (1);
	new_edit_buffer_ptr = temp_seg_ptr (2);
	request_line_ptr = temp_seg_ptr (3);

/* Get the attached data, in blk, which describes various things about
   the audit file.  Make a snapshot of this data to protect against the result
   of further auditing while in the editor. */

	blkptr = p_audited_iocb -> iocb.attach_data_ptr;
	audit_file_header_ptr = blk.audit_file_header_ptr;
	saved_audit_file_header = audit_file_header;
	position_info.max_index = audit_file_header.max_index;
	position_info.begin_component = audit_file_header.begin_component;
	position_info.begin_index = audit_file_header.begin_index;
	position_info.file_limit = audit_file_header.filled;
	position_info.default_search_tag = "I";
	position_info.max_component = audit_file_header.max_component;
	position_info.current_component = audit_file_header.current_component;
	position_info.audit_fcb = blk.audit_fcb;
	position_info.dirname = blk.dirname;
	position_info.ename = blk.ename;
	position_info.audit_index = audit_file_header.audit_index;
	position_info.audit_ptr = blk.audit_ptr;
	position_info.last_entry_length = audit_file_header.last_entry_length;
	auditing_iocb = blk.auditing_iocb;
	default_iocb = blk.default_iocb;

/* Set up request_line, edit_buffer, current_position, begin_position,
   and end_position. */

	if p_actual_len = 3
	then do;					/* Editor triggered with line containing only editor request */
						/* sequence. Set edit_line to the input line preceding the */
						/* trigger sequence, get request_line from default_iocb. */
		call audit_file_position_$last (addr (current_position), addr (position_info), code);
		if code ^= 0
		then if code = error_table_$empty_file
		     then do;
			     call ioa_$ioa_switch (default_iocb, "Empty audit file.");
			     param_buffer = "";
			     p_actual_len = 0;
			     p_code = 0;
			     call finish;
			     return;
			end;
		     else do;
			     p_code = code;
			     call finish;
			     return;
			end;
		if default_iocb ^= auditing_iocb
		then do;
			call audit_file_position_$previous (addr (current_position), addr (position_info), code);
			if code ^= 0
			then do;
				p_code = code;
				call finish;
				return;
			     end;
		     end;
		begin_position, end_position = current_position;
		call replace_buffer_with_entry (current_position);
		if blk.current_flags.use_editor_prompt
		then call put_prompt;
		call iox_$get_line (default_iocb, request_line_ptr, 512, request_line_length, code);
		if code ^= 0
		then do;
			p_code = code;
			call finish;
			return;
		     end;
	     end;
	else if substr (param_buffer, p_actual_len - 1, 1) = "E"
	then do;					/* Editor triggered with line containing requests. Prepare to */
						/* warn user if part of the supplied request_line */
						/* fails. Set edit_line to most recent input line. */
		warn_user_on_bad_request = "1"b;
		request_line_length = p_actual_len - 2;
		request_line = substr (param_buffer, 1, p_actual_len - 3) || NL;
		call audit_file_position_$last (addr (current_position), addr (position_info), code);
		if code ^= 0
		then if code = error_table_$empty_file
		     then do;
			     call ioa_$ioa_switch (default_iocb, "Empty audit file.");
			     p_code = 1;
			     call finish;
			     p_code = 0;
			     return;
			end;
		     else do;
			     p_code = code;
			     call finish;
			     return;
			end;
		if default_iocb ^= auditing_iocb
		then do;
			call audit_file_position_$previous (addr (current_position), addr (position_info), code);
			if code ^= 0
			then do;
				p_code = code;
				call finish;
				return;
			     end;
		     end;
		call replace_buffer_with_entry (current_position);
		begin_position, end_position = current_position;
	     end;
	else do;					/* Set edit_line to the characters preceding the  trigger */
						/* sequence. Get the request_line from default_iocb. */
		edit_buffer_length = p_actual_len - 2;
		edit_buffer = substr (param_buffer, 1, p_actual_len - 3) || NL;
		call audit_file_position_$last (addr (current_position), addr (position_info), code);
		begin_position, end_position = current_position;
		if blk.current_flags.use_editor_prompt
		then call put_prompt;
		call iox_$get_line (default_iocb, request_line_ptr, 512, request_line_length, code);
		if code ^= 0
		then do;
			p_code = code;
			call finish;
			return;
		     end;
	     end;

/* Loop through the requests, getting new request_line's as necessary. */

	do while ("1"b);
	     begin_position, end_position = current_position;
	     code = 0;
	     call parse_request (request_index);	/* Get the label index of first request on request_line */
	     if request_index > 0			/* All non-zero indexes are valid requests. */
	     then goto LAB (request_index);
	     else if warn_user_on_bad_request
	     then do;				/* Print a station id since an error has occurred in processing. */
		     warn_user_on_bad_request = "0"b;
		     goto LAB (1);
		end;
	     else goto NEXT_REQUEST;			/* Zero index indicates no valid request found. */

/* Each label is an editor request call followed by a transfer to NEXT_REQUEST
   or a return. */

LAB (1):
	     call whoami;
	     goto NEXT_REQUEST;

LAB (2):
	     call colon;				/* Turns on the no_default_tag switch. */
	     goto NEXT_REQUEST;

LAB (3):
	     call print;				/* Print the lines between begin_index and end_index. */
	     goto NEXT_REQUEST;

LAB (4):
	     call substitute (code);			/* Substitute rep_str for reg_exp in edit_line. */
	     goto NEXT_REQUEST;			/* rep_str and reg_exp are parsed from
						   request_line by substitute. */

LAB (5):
	     p_code = 1;				/* Quit from the editor.  */
	     call finish;
	     p_code = 0;
	     return;

LAB (6):
	     call command_processor_escape;
	     goto NEXT_REQUEST;

LAB (7):
LAB (18):
	     call return_edit_line (code);		/* Return edit_line to audit_. */
	     if code = 0
	     then do;
		     p_code = 0;
		     call finish;
		     return;
		end;
	     else goto NEXT_REQUEST;

LAB (8):
LAB (19):
	     call get_last_line_returned;		/* Put the last line returned by */
	     goto NEXT_REQUEST;			/* the audit_editor in edit_line, and set position to its
						   location in the audit file. */

LAB (9):
LAB (20):
	     call return_newline;			/* Return a newline to audit_. */
	     p_code = 1;
	     call finish;
	     p_code = 0;
	     return;

LAB (10):
LAB (21):
	     call set_default_search_tag (position_info.default_search_tag, code);
						/* Set the default tag used in searching */
	     goto NEXT_REQUEST;			/* to tag_str, which is gotten from request_line. */

LAB (11):
LAB (22):
	     call audit_on;				/* Turn on auditting of the editor. */
	     goto NEXT_REQUEST;

LAB (12):
LAB (23):
	     call audit_off;			/* Turn off auditting of the editor. */
	     goto NEXT_REQUEST;

LAB (13):
LAB (24):
	     call print_type;			/* Print the type(tag) of the current entry */
	     goto NEXT_REQUEST;			/* (in edit_line). */

LAB (14):
LAB (25):
	     call execute_edit_line;			/* Execute (pass to the comand processor)  edit_line */
	     goto NEXT_REQUEST;			/* and continue processing editor requests. */

LAB (15):
LAB (26):
	     call abbrev_expand_edit_line;		/* Expand, using the abbrev processor, the  */
	     goto NEXT_REQUEST;			/* contents of edit_line, and replace edit_line with
						   the expanded version. */

LAB (16):
LAB (27):
	     call list_requests;
	     goto NEXT_REQUEST;

LAB (17):
	     call print_entry_number;
	     goto NEXT_REQUEST;			/* If the request line length is 0, a new line is gotten from the user.
						   In any case, the beginning of the loop is returned to. */

NEXT_REQUEST:
	     if code ^= 0
	     then do;
		     code = 0;
		     request_line_length = 0;
		     request_line = "";
		     if warn_user_on_bad_request
		     then do;
			     warn_user_on_bad_request = "0"b;
			     goto LAB (1);
			end;
		end;
	     if request_line_length < 2
	     then do;
		     position_info.any_tag = "0"b;
		     if blk.current_flags.use_editor_prompt
		     then call put_prompt;
		     call iox_$get_line (default_iocb, request_line_ptr, max_request_line_length, request_line_length,
			code);
		     if code ^= 0
		     then do;
			     p_code = code;
			     call finish;
			     return;
			end;
		     else warn_user_on_bad_request = "0"b;
		end;
	end;
	return;					/* End the main procedure, audit_editor. */

set_last_return_line_position:
     entry (p_position_ptr);
	dcl     1 p_position	 like position_template based (p_position_ptr);
	dcl     p_position_ptr	 ptr;
	con_last_return_line.position = p_position;
	return;					/* End set_last_return_line_position. */

/* The 14 following procedures are the various editor requests.
   After them are the procedures for parsing the request line,
   then the procedures for position control. */


whoami:
     proc;					/* Station identification. */
	call ioa_$ioa_switch (default_iocb, "audit editor ^v(at level ^d ^)", level - 1, level);
     end;

colon:
     proc;					/* Defeat entry type specificity in address searches. */
	position_info.any_tag = "1"b;
     end;

print:
     proc;					/* Print entries in the audit file from  */
	dcl     code		 fixed bin (35);

	code = 0;					/* begin position to end position. */
	if begin_position.aep = end_position.aep
	then call ioa_$ioa_switch_nnl (default_iocb, "^a", edit_buffer);
	else do;
		current_position = begin_position;
		begin_position = end_position;
		do while (current_position.aep ^= end_position.aep);
		     call replace_buffer_with_entry (current_position);
		     call ioa_$ioa_switch_nnl (default_iocb, "^a", edit_buffer);
		     call audit_file_position_$next (addr (current_position), addr (position_info), code);
		     if code = error_table_$end_of_info
		     then do;
			     call ioa_$ioa_switch (default_iocb, "EOF");
						/* There is no next entry. */
			     return;
			end;
		end;
		if code = 0
		then do;
			call replace_buffer_with_entry (current_position);
						/* The entry at end_position has yet to be printed. */
			call ioa_$ioa_switch_nnl (default_iocb, "^a", edit_buffer);
		     end;
	     end;
     end;

substitute:
     proc (p_code);
	dcl     (code, p_code)	 fixed bin (35);
	dcl     reg_exp		 char (512) varying based (reg_exp_ptr);
	dcl     rep_str		 char (512) varying;
	dcl     char_after_last_match	 fixed bin;
	dcl     match_index		 fixed bin;
	dcl     match_begin		 fixed bin;
	dcl     match_end		 fixed bin;
	dcl     start_next_search	 fixed bin;
	dcl     slash_amp_index	 fixed bin;
	dcl     reg_exp_ptr		 ptr;

	alloc reg_exp in (area);

	call get_string (reg_exp, "1"b, code);		/* Get the string to be replaced, a qedx
						   regular expression, from the request line. */
	if code ^= 0
	then do;
		p_code = code;
		free reg_exp in (area);
		return;
	     end;

	call get_string (rep_str, "0"b, code);		/* Get the replacement string from the request line. */
	if code ^= 0
	then do;
		p_code = code;
		free reg_exp in (area);
		return;
	     end;

	new_edit_buffer_length = 0;
	char_after_last_match = 1;

	do match_index = 1 by 1 while (char_after_last_match <= edit_buffer_length);
						/* Search edit_line for reg_exp. */
	     call search_file_ (addrel (reg_exp_ptr, 1), 1, length (reg_exp), edit_buffer_ptr, char_after_last_match,
		edit_buffer_length, match_begin, match_end, code);
	     if code ^= 0
	     then do;				/* No match for reg_exp was found, starting at  */
						/* char_after_last_match. */
		     if match_index > 1
		     then do;			/* At least one match has been found, so update */
						/*  the edit_line and return. */
			     if new_edit_buffer_length + 1 >= char_after_last_match
			     then do;
				     edit_buffer_length =
					new_edit_buffer_length + edit_buffer_length - char_after_last_match + 1;
				     edit_buffer =
					new_edit_buffer
					||
					substr (edit_buffer, char_after_last_match,
					edit_buffer_length - new_edit_buffer_length);
				end;
			     else do;
				     substr (edit_buffer, 1,
					edit_buffer_length + new_edit_buffer_length - char_after_last_match + 1)
					= new_edit_buffer || substr (edit_buffer, char_after_last_match);
				     edit_buffer_length =
					new_edit_buffer_length + edit_buffer_length - char_after_last_match + 1;
				end;
			     p_code = 0;
			     free reg_exp in (area);
			     return;
			end;
		     if code = 1
		     then call ioa_$ioa_switch (default_iocb, "Substitution failed.");
		     free reg_exp in (area);
		     p_code = code;
		     return;
		end;

/* If the match starts after char_after_last_match, then append the part
   of the edit_line between char_after_last_match and match_begin to the new_edit_line. */

	     if match_begin > char_after_last_match
	     then do;
		     new_edit_buffer_length = new_edit_buffer_length + match_begin - char_after_last_match;
		     new_edit_buffer =
			substr (new_edit_buffer, 1, new_edit_buffer_length - match_begin + char_after_last_match)
			|| substr (edit_buffer, char_after_last_match, match_begin - char_after_last_match);
		end;

/* Having found a match, rep_str indicates what characters are to be
   appended to the growing new_edit_line, instead of the characters in edit_line
   between match_begin and match_end.  Any unescaped ampersand (&) in
   rep_str is replaced by the matched string in edit_line. An escape is
   the two character sequence "\c".  The following loop searches for escapes
   and unescaped ampersands in rep_str. */


	     start_next_search = 1;

	     if rep_str = ""
	     then do;
		     new_edit_buffer_length = new_edit_buffer_length + length (rep_str) - start_next_search + 1;
		     new_edit_buffer =
			substr (new_edit_buffer, 1,
			new_edit_buffer_length - (length (rep_str) - start_next_search + 1))
			|| substr (rep_str, start_next_search);
		end;
	     else do while (start_next_search <= length (rep_str));
		     slash_amp_index = search (substr (rep_str, start_next_search), "\&");
		     if slash_amp_index = 0
		     then do;
			     new_edit_buffer_length =
				new_edit_buffer_length + length (rep_str) - start_next_search + 1;
			     new_edit_buffer =
				substr (new_edit_buffer, 1,
				new_edit_buffer_length - (length (rep_str) - start_next_search + 1))
				|| substr (rep_str, start_next_search);
			     start_next_search = length (rep_str) + 1;
			end;
		     else if substr (rep_str, start_next_search + slash_amp_index - 1, 1) = "&"
		     then do;
			     new_edit_buffer_length = new_edit_buffer_length + slash_amp_index - 1;
			     new_edit_buffer =
				substr (new_edit_buffer, 1, new_edit_buffer_length - slash_amp_index + 1)
				|| substr (rep_str, start_next_search, slash_amp_index - 1);
			     start_next_search = start_next_search + slash_amp_index;
			     if match_end >= match_begin
			     then do;
				     new_edit_buffer_length =
					new_edit_buffer_length + match_end - match_begin + 1;
				     new_edit_buffer =
					substr (new_edit_buffer, 1,
					new_edit_buffer_length - match_end + match_begin - 1)
					|| substr (edit_buffer, match_begin, match_end - match_begin + 1);
				end;
			end;
		     else if start_next_search + slash_amp_index > length (rep_str)
		     then do;
			     new_edit_buffer_length =
				new_edit_buffer_length + length (rep_str) - start_next_search + 1;
			     new_edit_buffer =
				substr (new_edit_buffer, 1,
				new_edit_buffer_length - length (rep_str) + start_next_search - 1)
				|| substr (rep_str, start_next_search);
			     start_next_search = length (rep_str) + 1;
			end;
		     else if substr (rep_str, start_next_search + slash_amp_index, 1) ^= "c"
		     then do;
			     new_edit_buffer_length = new_edit_buffer_length + slash_amp_index;
			     new_edit_buffer =
				substr (new_edit_buffer, 1, new_edit_buffer_length - slash_amp_index)
				|| substr (rep_str, start_next_search, slash_amp_index);
			     start_next_search = start_next_search + slash_amp_index;
			end;
		     else if start_next_search + slash_amp_index = length (rep_str)
		     then do;
			     new_edit_buffer_length =
				new_edit_buffer_length + length (rep_str) - start_next_search + 1;
			     new_edit_buffer = substr (rep_str, start_next_search);
			     start_next_search = length (rep_str) + 1;
			end;
		     else do;
			     new_edit_buffer_length = new_edit_buffer_length + slash_amp_index;
			     new_edit_buffer =
				substr (new_edit_buffer, 1, new_edit_buffer_length - slash_amp_index)
				|| substr (rep_str, start_next_search, slash_amp_index - 1)
				|| substr (rep_str, start_next_search + slash_amp_index + 1, 1);
			     start_next_search = start_next_search + slash_amp_index + 2;
			end;
		end;

	     if match_end < match_begin
	     then do;
		     new_edit_buffer_length = new_edit_buffer_length + 1;
		     new_edit_buffer =
			substr (new_edit_buffer, 1, new_edit_buffer_length - 1)
			|| substr (edit_buffer, match_begin, 1);
		     char_after_last_match = match_begin + 1;
		end;
	     else char_after_last_match = match_end + 1;
	     reg_exp = "";				/* A null reg_exp will cause search_file_ to use
						   the last non_null value of reg_exp. */
	end;

	free reg_exp in (area);
	edit_buffer_length = new_edit_buffer_length;
	edit_buffer = new_edit_buffer;
     end;


command_processor_escape:
     proc;
	call cu_$cp (request_line_ptr, request_line_length, code);
	request_line = "";
	request_line_length = 0;
     end;


return_edit_line:
     proc (p_code);
	dcl     p_code		 fixed bin (35);

	if request_line_length > 1
	then do;
		if substr (request_line, 1, request_line_length - 1) ^= ""
		then do;
			edit_buffer_length = request_line_length;
			edit_buffer = request_line;
			request_line_length = 0;
			request_line = "";
		     end;
	     end;


	if edit_buffer_length <= 512
	then do;
		aut_last_return_line.string = edit_buffer;
		aut_last_return_line.not_in_string = "0"b;
	     end;
	else do;
		aut_last_return_line.string = "";
		aut_last_return_line.not_in_string = "1"b;
	     end;
	p_code = 0;
     end;


get_last_line_returned:
     proc;
	if no_last_return_line
	then call ioa_$ioa_switch (default_iocb, "No previously returned line known.");
	else do;
		current_position = aut_last_return_line.position;
		begin_position = current_position;
		end_position = current_position;
		if aut_last_return_line.not_in_string
		then call replace_buffer_with_entry (current_position);
		else do;
			edit_buffer_length = length (aut_last_return_line.string);
			edit_buffer = aut_last_return_line.string;
		     end;
	     end;
     end;


return_newline:
     proc;
	p_actual_len = 1;
	param_buffer = NL;
     end;


set_default_search_tag:
     proc (p_default_search_tag, p_code);
	dcl     default_search_tag	 char (32) varying;
	dcl     p_default_search_tag	 char (*) varying;
	dcl     (p_code, code)	 fixed bin (35);

	call get_string (default_search_tag, "1"b, code);
	if code ^= 0
	then do;
		p_code = code;
		return;
	     end;
	if length (default_search_tag) > 2
	then do;
		call ioa_$ioa_switch (default_iocb, "Tag too long. ^a", default_search_tag);
		p_code = 1;
		return;
	     end;
	p_default_search_tag = default_search_tag;
	return;
     end;


audit_on:
     proc;
	default_iocb = p_audited_iocb;
     end;

audit_off:
     proc;
	default_iocb = auditing_iocb;
     end;

print_type:
     proc;
	call ioa_$ioa_switch (default_iocb, "^a", current_position.aep -> audit_entry.tag);
     end;

execute_edit_line:
     proc;
	call cu_$cp (addr (edit_buffer), length (rtrim (edit_buffer)), code);
     end;

abbrev_expand_edit_line:
     proc;
	dcl     out		 char (abline_len) based (outp);
	dcl     outp		 ptr,
	        abline_len		 fixed bin;
	dcl     abline		 char (512);

	call abbrev_$expanded_line (edit_buffer_ptr, edit_buffer_length, addr (abline), max_edit_buffer_length, outp,
	     abline_len);
	if abline_len > max_edit_buffer_length
	then do;
		call ioa_$ioa_switch (default_iocb, "Expanded line too long. ^/^a", out);
		request_line = "";
		request_line_length = 0;
		return;
	     end;
	edit_buffer_length = abline_len;
	edit_buffer = out;
     end;

list_requests:
     proc;
	call ioa_$ioa_switch (default_iocb, "^5x.        ->  who am I?");
	call ioa_$ioa_switch (default_iocb, "^5x:        ->  defeat default search tag");
	call ioa_$ioa_switch (default_iocb, "^5xp        ->  print");
	call ioa_$ioa_switch (default_iocb, "^5xs        ->  substitute");
	call ioa_$ioa_switch (default_iocb, "^5xq        ->  quit");
	call ioa_$ioa_switch (default_iocb, "^5x..       ->  command escape");
	call ioa_$ioa_switch (default_iocb, "^5x.r       ->  return edit buffer");
	call ioa_$ioa_switch (default_iocb, "^5x.l       ->  get last returned line");
	call ioa_$ioa_switch (default_iocb, "^5x.n       ->  return newline");
	call ioa_$ioa_switch (default_iocb, "^5x.d       ->  set default tag");
	call ioa_$ioa_switch (default_iocb, "^5x.on      ->  audit editting");
	call ioa_$ioa_switch (default_iocb, "^5x.off     ->  don't audit editting");
	call ioa_$ioa_switch (default_iocb, "^5x.type    ->  print tag of entry in buffer");
	call ioa_$ioa_switch (default_iocb, "^5x.exec    ->  execute edit buffer with call to command processor");
	call ioa_$ioa_switch (default_iocb, "^5x.expand  ->  expand abbrevs in edit buffer");
	call ioa_$ioa_switch (default_iocb, "^5x.?       ->  print this list");
     end;
print_entry_number:
     proc;
	if current_position.entry_number = 0 | (current_position.search_tag ^= position_info.default_search_tag)
	     | position_info.any_tag
	then call audit_file_position_$set_count (addr (current_position), addr (position_info), code);
	call ioa_$ioa_switch (default_iocb, "^d", current_position.entry_number);
     end;						/* End of print_entry_number.*/

put_prompt:
     proc;
	call ioa_$ioa_switch_nnl (default_iocb, blk.editor_prompt_string, (level > 1), level);
     end;						/* End of put_prompt.*/


/* The next group of procedures are concerned primarily with parsing the
   request line. */

parse_request:
     proc (p_index) recursive;
	dcl     (p_index, index)	 fixed bin;
	dcl     request_name_length	 fixed bin;
	dcl     request		 (27) char (12) varying static options (constant)
				 init (".", ":", "p", "s", "q", "..", ".r", ".l", ".n", ".d", ".on", ".off",
				 ".type", ".exec", ".expand", ".?", "=", "r", "l", "n", "d", "on", "off", "type",
				 "exec", "expand", "?");

	p_index = 0;
	if request_line_length < 2
	then do;					/* The request line is too short to contain any requests */
		p_index = 0;
		return;
	     end;
	else if (request_line_length = 2) & substr (request_line, 1, 1) = "."
	then do;					/* the "." (station id) request is only recognized when */
						/* immediately followed by a newline. */
		request_line_length = 0;
		request_line = "";
		p_index = 1;
		return;
	     end;
	else do;					/* This sets p_index to an appropriate request label */
						/* index if the request line begins with a recognizable */
						/* If no recognizable request begins the line, */
						/* p_index is set to 0. */
		call request_check;

		if p_index = 0
		then do;				/* The beginning of the request line is assumed */
						/* to be an address and is interpreted accordingly */
			call decode_address (code);
			if code ^= 0
			then do;
				if code = 1
				then call unrecognized_request;
				return;
			     end;
			else if request_line_length < 2
			then do;
				p_index = 3;	/* The request line contained only an address */
				begin_position = end_position;
						/* so the default is to print the current position. */
				return;
			     end;
			else do;			/* An address was gotten from the request line, */
						/* now the trailing request is gotten. */
				call request_check;
				if index > hbound (request, 1)
						/* No matching request found for beginning of request */
						/* line, so complain and return. */
				then call unrecognized_request;
				else p_index = index;
				return;
			     end;
		     end;
	     end;

request_check:
     proc;

/* The array request is looped through to find a match for the beginning
   of the request line. The loop starts at 2 because request(1), ".",
   is handled as a special case above. */

	do index = 2 to hbound (request, 1);
	     request_name_length = length (request (index));
	     if request_line_length >= request_name_length + 1
	     then if substr (request_line, 1, request_name_length) = request (index)
		then do;
			substr (request_line, 1, request_line_length - request_name_length) =
			     substr (request_line, request_name_length + 1);
			request_line_length = request_line_length - request_name_length;
			idx_of_first_non_white_space_char = verify (request_line, " 	");
			if idx_of_first_non_white_space_char > 1
						/* Leading white space exists and needs to be stripped off. */
			then do;
				substr (request_line, 1,
				     request_line_length - idx_of_first_non_white_space_char + 1) =
				     substr (request_line, idx_of_first_non_white_space_char,
				     request_line_length - idx_of_first_non_white_space_char + 1);
				request_line_length = request_line_length - idx_of_first_non_white_space_char + 1;
			     end;
			p_index = index;
			return;
		     end;
	end;
     end;

unrecognized_request:
     proc;
	call ioa_$ioa_switch (default_iocb, "audit editor: Unrecognized request. ^a",
	     substr (request_line, 1, request_line_length));
	request_line_length = 0;
	request_line = "";
	p_index = 0;
     end;
     end;



decode_address:
     proc (p_code);
	dcl     (code, p_code)	 fixed bin (35);
	dcl     (number, non_number_index)
				 fixed bin;
	dcl     forward		 bit (1);
	dcl     ch		 char (1);
	dcl     have_begin_position	 bit (1);
	dcl     match_string	 char (256) varying;
	dcl     continue		 bit (1);
	dcl     (abs_addr, add_addr, subtract_addr)
				 bit (1);
	dcl     1 new_current_position like position_template;
	dcl     1 new_begin_position	 like position_template;
	dcl     1 new_end_position	 like position_template;

	if index ("0123456789/<$,+-", substr (request_line, 1, 1)) = 0
	then do;
		p_code = 1;
		return;
	     end;
	forward = "1"b;
	abs_addr = "1"b;
	add_addr = "0"b;
	subtract_addr = "0"b;
	have_begin_position = "0"b;
	continue = "1"b;
	new_current_position = current_position;

	do while (request_line_length > 0 & continue);
	     substr (request_line, 1, length (ltrim (request_line))) = ltrim (request_line);
	     request_line_length = length (ltrim (request_line));
						/* Find position in request_line of leftmost non-numeric character. */
	     non_number_index = verify (request_line, "0123456789");
	     if non_number_index > 1
	     then do;				/* Convert the character representation of the number tofixed bin. */
		     number = bin (substr (request_line, 1, non_number_index - 1));
		     substr (request_line, 1, request_line_length - non_number_index + 1) =
			substr (request_line, non_number_index);
		     request_line_length = request_line_length - non_number_index + 1;
		     code = 0;
		     call audit_file_position_$move_number (addr (new_current_position), abs_addr, add_addr,
			subtract_addr, number, addr (position_info), code);
		     if code ^= 0
		     then if code = error_table_$end_of_info
			then code = 0;
			else do;
				request_line_length = 0;
				request_line = "";
				p_code = code;
				return;
			     end;
		end;
	     ch = substr (request_line, 1, 1);

/*  Process the next, and necessarily non-numeric, item
   on the request_line. */

	     if ch = "/"
	     then do;				/* Beginning of regular expression. */


		     call get_string (match_string, "1"b, code);
		     if code ^= 0
		     then do;
			     p_code = code;
			     return;
			end;

		     if forward
		     then call audit_file_position_$forward_search (addr (new_current_position), match_string,
			     addr (position_info), code);
		     else call audit_file_position_$backward_search (addr (new_current_position), match_string,
			     addr (position_info), code);
		     if code ^= 0
		     then do;
			     p_code = code;
			     call ioa_$ioa_switch (default_iocb, "Search failed. ^a", match_string);
			     request_line_length = 0;
			     request_line = "";
			     return;
			end;
		     forward = "1"b;
		     abs_addr = "0"b;
		end;
	     else if ch = "<"
	     then do;
		     forward = "0"b;
		     substr (request_line, 1, request_line_length - 1) = substr (request_line, 2);
		     request_line_length = request_line_length - 1;
		end;
	     else if ch = "$"
	     then if ^abs_addr
		then do;
			call ioa_$ioa_switch (default_iocb, "Syntax error in address.");
			request_line_length = 0;
			request_line = "";
			p_code = 1;
			return;
		     end;
		else do;
			call audit_file_position_$last (addr (new_current_position), addr (position_info), code);
			abs_addr = "0"b;
			substr (request_line, 1, request_line_length - 1) = substr (request_line, 2);
			request_line_length = request_line_length - 1;
		     end;
	     else if ch = "," | ch = ";"
	     then if have_begin_position
		then do;
			call ioa_$ioa_switch (default_iocb, "Syntax error in address.");
			request_line_length = 0;
			request_line = "";
			p_code = 1;
			return;
		     end;
		else do;
			new_begin_position = new_current_position;
			if ch = ","
			then new_current_position = current_position;
			have_begin_position = "1"b;
			substr (request_line, 1, request_line_length - 1) = substr (request_line, 2);
			request_line_length = request_line_length - 1;
			abs_addr = "1"b;
		     end;
	     else if ch = "+"
	     then do;
		     abs_addr = "0"b;
		     subtract_addr = "0"b;
		     add_addr = "1"b;
		     substr (request_line, 1, request_line_length - 1) = substr (request_line, 2);
		     request_line_length = request_line_length - 1;
		end;
	     else if ch = "-"
	     then do;
		     abs_addr = "0"b;
		     add_addr = "0"b;
		     subtract_addr = "1"b;
		     substr (request_line, 1, request_line_length - 1) = substr (request_line, 2);
		     request_line_length = request_line_length - 1;
		end;
	     else do;
		     continue = "0"b;
		end;

	end;
	new_end_position = new_current_position;
	if ^have_begin_position
	then new_begin_position = new_current_position;
	begin_position = new_begin_position;
	current_position = new_current_position;
	end_position = new_end_position;
	call replace_buffer_with_entry (current_position);
	p_code = 0;
     end;

get_string:
     proc (p_string, p_beginning_delim, p_code);
	dcl     (code, p_code)	 fixed bin (35);
	dcl     p_string		 char (*) varying;
	dcl     str		 char (512) varying;
	dcl     p_beginning_delim	 bit (1);
	dcl     search_string	 char (2);
	dcl     search_index	 fixed bin;

	if p_beginning_delim
	then do;					/* The string is supposed to begin with a delimiter,
						   so get it. */
		string_delimiter = substr (request_line, 1, 1);
		substr (request_line, 1, request_line_length - 1) = substr (request_line, 2);
		request_line_length = request_line_length - 1;
	     end;

	code = 2;
	str = "";
	search_string = "\" || string_delimiter;

	do while (request_line_length > 0 & code = 2);
	     search_index = search (request_line, search_string);
	     if search_index = 0
	     then call missing_delim;
	     else if substr (request_line, search_index, 1) = string_delimiter
	     then call add_rest_of_str;
	     else if search_index = request_line_length
	     then call missing_delim;
	     else if substr (request_line, search_index + 1, 1) ^= "c"
	     then call add_char_to_str;
	     else if search_index + 2 = request_line_length
	     then do;
		     str = str || substr (request_line, 1, search_index - 1)
			|| substr (request_line, search_index + 2, 1);
		     if blk.current_flags.use_editor_prompt
		     then call put_prompt;

		     call iox_$get_line (default_iocb, request_line_ptr, max_request_line_length, request_line_length,
			code);
		     if code = 0
		     then code = 2;
		end;
	     else if substr (request_line, search_index + 2, 1) = string_delimiter
	     then do;
		     str = str || substr (request_line, 1, search_index - 1) || string_delimiter;
		     substr (request_line, 1, request_line_length - (search_index + 2)) =
			substr (request_line, search_index + 3);
		     request_line_length = request_line_length - (search_index + 2);
		end;
	     else call add_char_to_str;
	end;

	if code = 2
	then call missing_delim;
	p_code = code;
	p_string = str;
	return;

missing_delim:
     proc;
	call ioa_$ioa_switch (default_iocb, "Missing delimiter. ^a", string_delimiter);
	request_line_length = 0;
	request_line = "";
	code = error_table_$no_stmt_delim;
	str = "";
     end;

add_rest_of_str:
     proc;
	str = str || substr (request_line, 1, search_index - 1);
	substr (request_line, 1, request_line_length - search_index) = substr (request_line, search_index + 1);
	request_line_length = request_line_length - search_index;
	code = 0;
     end;

add_char_to_str:
     proc;
	str = str || substr (request_line, 1, search_index);
	substr (request_line, 1, request_line_length - search_index) = substr (request_line, search_index + 1);
	request_line_length = request_line_length - search_index;
     end;
     end;



replace_buffer_with_entry:
     proc (position);
	dcl     1 position		 like position_template;

	edit_buffer_length = position.aep -> audit_entry.entry_length;
	edit_buffer = substr (position.aep -> audit_entry.string, 1, position.aep -> audit_entry.entry_length);
     end;

finish:
     proc;
	if p_code ^= 0
	then do;
		p_actual_len = 0;
		param_buffer = "";
	     end;
	else if edit_buffer_length > p_buff_len
	then do;
		p_buff_ptr = blk.temp_seg_ptr;
		blk.work_space = p_buff_ptr;
		blk.work_space_len = edit_buffer_length;
		p_buff_len = sys_info$max_seg_size * 4;
		p_actual_len = edit_buffer_length;
		param_buffer = edit_buffer;
	     end;

	else do;
		p_actual_len = edit_buffer_length;
		param_buffer = edit_buffer;
	     end;

	if allocation (con_last_return_line) > level
	then free con_last_return_line;
	static_level = level - 1;
	con_last_return_line.string = aut_last_return_line.string;
	con_last_return_line.not_in_string = aut_last_return_line.not_in_string;

	call release_temp_segments_ ("audit_editor", temp_seg_ptr, code);
	if code ^= 0
	then p_code = code;
     end;						/* Include */

%include iocbx;
%include audit_position;
%include audit_entry;
%include audit_block;
%include audit_file_header;
     end;
