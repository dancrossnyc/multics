/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(88-08-02,TLNguyen), approve(88-08-02,MCR7939),
     audit(88-09-14,Parisek), install(88-09-15,MR12.2-1110):
     The display_audit_file command will display an appropriate error message
     when a nonstandard pathname is specified for -ouput_file.
  2) change(88-09-23,TLNguyen), approve(88-09-23,MCR7939),
     audit(88-09-23,Parisek), install(88-09-26,MR12.2-1120):
     Move lines of code such that expand_pathname_ is called first to get the
     output_file_dir and output_file_entry.  Then call check_star_name_ given
     the output_file_entry, whose length is less or equal to 32 chars.
                                                   END HISTORY COMMENTS */


/* format: style2,ind3 */
display_audit_file:
daf:
   proc;

/* This command produces formatted output from an audit file produced by the
   audit_ I/O module.  The entries of the audit file which are displayed are
   chosen by determining the lowest and highest numbered entries which may be
   displayed as indicated by the positioning control arguments (-from, -to,
   -next, -last); then ascertaining which entries within this range have the
   correct string and class characteristics (as indicated by the -match,
   -exclude, and -class control arguments).  The format of the output is
   determined by the -reverse, -line_length, -metering, -entry_numbers, and
   -class_identifiers control arguments.  Additional format control is
   provided by the -append_nl, -no_append_nl, -insert_nl, and -no_insert_nl
   control arguments.  The output may be directed to an output file by the
   -output_file control argument.

   Written  1/1/79  by  Lindsey L. Spratt
   Modified:
   11/26/79  by  Lindsey Spratt: Use myname variable in calls to com_err_,
			   to correct error reporting of duplicate args.
   12/12/79  by  Lindsey Spratt: Add -insert_nl, -no_insert_nl, -append_nl,
			   -no_append_nl. Also fixed a bug in wrap_line
			   on printing long lines which don't end in a
			   new line.
   05/01/80  by  Lindsey Spratt: Spaces were being inserted at the beginning of
			   each line of output, this was removed for
			   "headerless" and "unwrapped" display.  The
			   ".audit" suffix is now assumed if not
			   supplied.
   10/27/80  by  Lindsey Spratt: The -output_file control argument was added.
	       The various ioa_ calls were changed to ioa_$ioa_switch calls
	       to use the newly added output_iocb_ptr. The simplest nnl
	       output case was modified to prevent ioa_ from stripping
	       trailing whitespace.
09/09/81 by Lindsey Spratt: Added checks for non-zero codes after the attach
	  and open calls for setting up the output file.  This fixes bug 22.
	  Also, made the argument to -class case insensitive and added some
	  code to validate that the argument does identify a class, bug 20.
            Improved the unrecognized control argument error message, bug 18.
11/12/81 by Lindsey Spratt: Fixed spelling in an error message.  Changed class
	  validation to use an internal static constant array of valid
	  classes, VALID_AUDIT_CLASS.
10/13/82 by Lindsey Spratt:  Fixed bug where all of the "strings" were being
	  placed in one long list, as opposed to separate lists for the
	  -match, -exclude and -class control args.  Added check to prevent
	  the specification of the audit file as the output file.
10/15/82 by Lindsey Spratt:  Added check of position entry number arguments to
	  prevent size conditions.  Added -str as a short name for -string.
	  Added check for arguments following control arguments which
	  require them.  Changed -fm to produce an error message if the
	  position specified is beyond the end of the file, rather than just
	  selecting the last line of the file.
*/

/* Automatic */

      dcl	    current_component_string
			       pic "zzzzzzzzzz9";
      dcl	    (match_begin, match_end)
			       fixed bin;
      dcl	    switchname	       char (32);
      dcl	    output_file_entry      char (32) init ("");
      dcl	    output_file_dir	       char (168) init ("");
      dcl	    pathname	       char (168) varying;
      dcl	    arg_number	       fixed bin (35);
      dcl	    bit_count	       fixed bin (24);
      dcl	    1 position_info	       like position_info_template;
      dcl	    1 position	       like position_template;
      dcl	    1 begin_position       like position_template;
      dcl	    1 end_position	       like position_template;
      dcl	    (iocb_ptr, area_ptr, arg_ptr, old_string_list_ptr, chain_ptr, string_list_ptr, match_string_list_ptr,
	    output_file_ptr, exclude_string_list_ptr, blkptr, match_class_string_list_ptr)
			       ptr init (null);
      dcl	    output_file_attach_description
			       char (256) varying;
      dcl	    output_iocb_ptr	       ptr;
      dcl	    code		       fixed bin (35);
      dcl	    arg_len	       fixed bin;
      dcl	    (nargs, argno, output_line_length)
			       fixed bin;
      dcl	    class_idx	       fixed bin;
      dcl     starname_type          fixed bin (2);

      dcl	    (have_begin, have_path, have_end, do_last_position, continuation, want_begin_addr, want_end_addr,
	    want_line_length, want_switchname, want_output_file, looking_for_string, found_string, string_sw,
	    have_switchname, have_displayed, display, control_argument, reverse, match, exclude, class,
	    processing_class_control_argument, class_identifiers, entry_numbers, metering, leader, insert_nl, header,
	    use_force_append_nl, use_force_insert_nl, force_insert_nl, force_append_nl, append_nl)
			       bit (1) init ("0"b);
      dcl	    1 begin_arg,
	      2 value	       char (32) varying,
	      2 value_is_string    bit (1),
	      2 abs	       bit (1),
	      2 add	       bit (1),
	      2 subtract	       bit (1);
      dcl	    1 end_arg	       like begin_arg;

/* Based */
      dcl	    arg		       based (arg_ptr) char (arg_len);
      dcl	    area		       area based (area_ptr);
      dcl	    1 string_list	       based (string_list_ptr),
	      2 next	       ptr,
	      2 string	       char (128) varying;


/* Builtin */
      dcl	    addr		       builtin;
      dcl     addrel                 builtin;
      dcl	    bin		       builtin;
      dcl     dim                    builtin;
      dcl	    divide                 builtin;
      dcl     fixed                  builtin;
      dcl     hbound                 builtin;
      dcl     index                  builtin;
      dcl	    length	       builtin;
      dcl     mod                    builtin;
      dcl	    null		       builtin;
      dcl     rtrim                  builtin;
      dcl     substr                 builtin;
      dcl	    translate	       builtin;
      dcl     verify                 builtin;

/* Condition */

      dcl	    cleanup	       condition;

/* Controlled */

/* Entry */
      dcl     check_star_name_       entry (char (*), bit (36) aligned, fixed bin (2), fixed bin (35));
      dcl	    cv_dec_check_	       entry (char (*), fixed bin (35)) returns (fixed bin (35));
      dcl	    get_line_length_$switch
			       entry (ptr, fixed bin (35)) returns (fixed bin (17));
      dcl	    unique_chars_	       entry (bit (*)) returns (char (15));
      dcl	    get_system_free_area_  entry () returns (ptr);
      dcl	    audit_file_position_$next
			       entry (ptr, ptr, fixed bin (35));
      dcl	    audit_file_position_$forward_search
			       entry (ptr, char (*) varying, ptr, fixed bin (35));
      dcl	    audit_file_position_$backward_search
			       entry (ptr, char (*) varying, ptr, fixed bin (35));
      dcl	    msf_manager_$open      entry (char (*), char (*), ptr, fixed bin (35));
      dcl	    msf_manager_$get_ptr   entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      dcl	    cu_$arg_count	       entry (fixed bin, fixed bin (35));
      dcl	    cu_$arg_ptr	       entry (fixed bin, ptr, fixed bin, fixed bin (35));
      dcl	    com_err_	       entry options (variable);
      dcl	    ioa_$ioa_switch	       entry options (variable);
      dcl	    ioa_$ioa_switch_nnl    entry options (variable);
      dcl     ioa_$rsnnl             entry options (variable);
      dcl	    audit_file_position_$move_number
			       entry (ptr, bit (1), bit (1), bit (1), fixed bin, ptr, fixed bin (35));
      dcl	    audit_file_position_$move_time
			       entry (ptr, bit (1), bit (1), bit (1), fixed bin (71), ptr, fixed bin (35));
      dcl	    audit_file_position_$previous
			       entry (ptr, ptr, fixed bin (35));
      dcl	    audit_file_position_$first
			       entry (ptr, ptr, fixed bin (35));
      dcl	    audit_file_position_$count_last
			       entry (ptr, ptr, fixed bin (35));
      dcl     pathname_              entry (char (*), char (*)) returns (char (168));
      dcl	    search_file_	       entry (ptr, fixed bin, fixed bin, ptr, fixed bin, fixed bin, fixed bin, fixed bin,
			       fixed bin (35));
      dcl	    expand_pathname_       entry (char (*), char (*), char (*), fixed bin (35));
      dcl	    expand_pathname_$add_suffix
			       entry (char (*), char (*), char (*), char (*), fixed bin (35));
      dcl	    hcs_$initiate	       entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr,
			       fixed bin (35));
      dcl	    hcs_$terminate_noname  entry (ptr, fixed bin (35));
      dcl	    current_entry_number   pic "zzzz9v";

/* External */

      dcl	    (
	    error_table_$unimplemented_version,
	    error_table_$noarg,
	    error_table_$bad_arg,
	    error_table_$nomatch,
	    error_table_$end_of_info,
	    error_table_$zero_length_seg,
	    error_table_$badopt
	    )		       fixed bin (35) ext;

/* Constant */

      dcl	    myname	       char (18) internal static options (constant) init ("display_audit_file");
      dcl	    NL		       char (1) internal static options (constant) init ("
");
      dcl	    UPPERCASE_LETTERS      init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ") internal static options (constant) char (26);
      dcl	    LOWERCASE_LETTERS      init ("abcdefghijklmnopqrstuvwxyz") internal static options (constant) char (26);
      dcl	    VALID_AUDIT_CLASS      (10) init ("I", "IL", "IC", "O", "OC", "E", "EL", "T", "TM", "TC") char (2)
			       varying internal static options (constant);

      header = "1"b;
      output_line_length = 0;
      old_string_list_ptr = null;
      area_ptr = get_system_free_area_ ();
      output_file_attach_description = "";
      output_iocb_ptr = iox_$user_output;
      want_output_file = "0"b;
      want_switchname = "0"b;
      looking_for_string = "0"b;
      found_string = "0"b;
      want_begin_addr = "0"b;
      want_end_addr = "0"b;
      want_line_length = "0"b;
      have_path = "0"b;
      have_begin = "0"b;
      have_end = "0"b;
      have_switchname = "0"b;
      match = "0"b;
      exclude = "0"b;
      class = "0"b;
      reverse = "0"b;
      entry_numbers = "0"b;
      class_identifiers = "0"b;
      metering = "0"b;
      leader = "0"b;
      insert_nl = "0"b;
      append_nl = "0"b;
      force_append_nl = "0"b;
      use_force_append_nl = "0"b;
      force_insert_nl = "0"b;
      use_force_insert_nl = "0"b;

      on cleanup call finish;

/*  Process the argument list. */

      call cu_$arg_count (nargs, code);
      if code ^= 0
      then
         do;
	  call com_err_ (code, myname);
	  call finish;
	  return;
         end;

      do argno = 1 to nargs;
         call cu_$arg_ptr (argno, arg_ptr, arg_len, code);
         if code ^= 0
         then
	  do;
	     call com_err_ (code, myname);
	     call finish;
	     return;
	  end;

         string_sw = "0"b;


/*  Determine whether the current arg is a control argument, or an
   argument.  The -string arg sets arg to the next argument in the argument list
   and forces its interpretation as a non-control argument  by
   turning control_argument off and forces its interpretation as a string by
   turning string_sw on.  Only -from, -last, -to, -next care about
   the string_sw.
*/

         if arg = "-string" | arg = "-str"
         then
	  do;
	     argno = argno + 1;
	     control_argument = "0"b;
	     call cu_$arg_ptr (argno, arg_ptr, arg_len, code);
	     if code ^= 0
	     then
	        do;
		 call com_err_ (code, myname);
		 call finish;
		 return;
	        end;
	     string_sw = "1"b;
	  end;
         else if substr (arg, 1, 1) = "-"
         then control_argument = "1"b;
         else control_argument = "0"b;


         if ^control_argument
         then if looking_for_string
	    then
	       do;				/* Get string for -match, -exclude, -class. */
		if old_string_list_ptr ^= null
		then old_string_list_ptr -> string_list.next = string_list_ptr;
		old_string_list_ptr = string_list_ptr;
		if processing_class_control_argument
		then
		   do;
		      string_list.string = translate (arg, UPPERCASE_LETTERS, LOWERCASE_LETTERS);
		      do class_idx = 1 to hbound (VALID_AUDIT_CLASS, 1)
		         while (string_list.string ^= VALID_AUDIT_CLASS (class_idx));
		      end;
		      if class_idx > hbound (VALID_AUDIT_CLASS, 1)
		      then
		         do;
			  call
			     com_err_ (error_table_$badopt, myname,
			     "^/^a is not a valid class specifier. Valid specifiers (any mixture of upper
and lower case) are: ^v(^a, ^)and ^a.", string_list.string, dim (VALID_AUDIT_CLASS, 1) - 1, VALID_AUDIT_CLASS);
			  return;
		         end;
		   end;
		else string_list.string = arg;
		found_string = "1"b;
		alloc string_list;
		string_list.next = null;
		string_list.string = "";
	       end;
	    else if want_switchname			/* Get switchname following -switch. */
	    then
	       do;
		switchname = arg;
		have_switchname = "1"b;
		want_switchname = "0"b;
	       end;
	    else if want_begin_addr			/* Get arg for -from or -last. */
	    then
	       do;
		have_begin = "1"b;
		want_begin_addr = "0"b;
		begin_arg.value = arg;
		begin_arg.value_is_string = string_sw;
	       end;
	    else if want_end_addr			/* Get arg for -to or -next. */
	    then
	       do;
		have_end = "1"b;
		want_end_addr = "0"b;
		end_arg.value = arg;
		end_arg.value_is_string = string_sw;
	       end;
	    else if want_line_length			/* Get line length following -line_length. */
	    then
	       do;
		want_line_length = "0"b;
		output_line_length = bin (arg);
		insert_nl = "1"b;
	       end;
	    else if want_output_file			/* Get path for output file. */
	    then
	       do;
		call expand_pathname_ (arg, output_file_dir, output_file_entry, code);
		if code ^= 0
		then
		   do;
		      call com_err_ (code, myname, "^/Unable to expand the pathname ""^a"".", arg);
		      call finish;
		      return;
		   end;

		want_output_file = "0"b;
		                                        /* validate an user 's entryname for -of */
		call check_star_name_ (output_file_entry, (CHECK_STAR_REJECT_WILD), starname_type, code);
		if code ^= 0
		then do;
		   call
		      com_err_ (code, myname, "^a", arg);
		      return;
		   end;
	                                                  /* good file name for -of */
		output_file_attach_description = "vfile_ " || arg;
		call
		   iox_$attach_name (unique_chars_ ("0"b) || ".daf", output_iocb_ptr,
		   (output_file_attach_description), null, code);
		if code ^= 0
		then
		   do;
		      call com_err_ (code, myname, "^/Unable to attach to the output file, ^a.", arg);
		      return;
		   end;
		call iox_$open (output_iocb_ptr, Stream_output, "0"b, code);
		if code ^= 0
		then
		   do;
		      call com_err_ (code, myname, "^/Unable to open the output file, ^a.", arg);
		      call iox_$detach_iocb (output_iocb_ptr, code);
		      return;
		   end;
	       end;
	    else if ^have_path			/* Get path for audit file. */
	    then
	       do;
		have_path = "1"b;
		call expand_pathname_$add_suffix (arg, "audit", position_info.dirname, position_info.ename, code);
		if code ^= 0
		then
		   do;
		      call com_err_ (code, myname, "^a", arg);
		      call finish;
		      return;
		   end;
	       end;
	    else
	       do;
		call com_err_ (error_table_$badopt, myname, "^/^a is not a known control argument.", arg);
		call finish;
		return;
	       end;


         else
	  do;

/*  Following is the basic control argument processing. */

	     call check_for_unfinished_control_argument (code);
	     if code ^= 0
	     then
	        do;
		 call finish;
		 return;
	        end;

	     if looking_for_string
	     then
	        do;
		 old_string_list_ptr = null;
		 processing_class_control_argument = "0"b;
		 looking_for_string = "0"b;
		 found_string = "0"b;
		 free string_list_ptr -> string_list;
		 string_list_ptr = null;
	        end;

	     if arg = "-from" | arg = "-fm"		/* -from */
	     then if have_begin
		then
		   do;
DUPARG:
		      call
		         com_err_ (error_table_$bad_arg, myname,
		         "^a may only be specified once per use of the command.", arg);
		      call finish;
		      return;
		   end;
		else
		   do;
		      want_begin_addr = "1"b;
		      begin_arg.abs = "1"b;
		      begin_arg.add = "0"b;
		      begin_arg.subtract = "0"b;
		   end;
	     else if arg = "-to"			/* -to */
	     then if have_end
		then goto DUPARG;
		else
		   do;
		      want_end_addr = "1"b;
		      end_arg.abs = "1"b;
		      end_arg.add = "0"b;
		      end_arg.subtract = "0"b;
		   end;
	     else if arg = "-next"			/* -next */
	     then if have_end
		then goto DUPARG;
		else
		   do;
		      want_end_addr = "1"b;
		      end_arg.abs = "0"b;
		      end_arg.add = "1"b;
		      end_arg.subtract = "0"b;
		   end;
	     else if arg = "-last"			/* -last */
	     then if have_begin
		then goto DUPARG;
		else
		   do;
		      want_begin_addr = "1"b;
		      begin_arg.abs = "0"b;
		      begin_arg.add = "0"b;
		      begin_arg.subtract = "1"b;
		   end;
	     else if arg = "-match"			/* -match */
	     then if match
		then goto DUPARG;
		else
		   do;
		      looking_for_string = "1"b;
		      match = "1"b;
		      found_string = "0"b;
		      alloc string_list in (area);
		      match_string_list_ptr = string_list_ptr;
		      string_list.string = "";
		      string_list.next = null;
		   end;
	     else if arg = "-exclude" | arg = "-ex"	/* -exclude */
	     then if exclude
		then goto DUPARG;
		else
		   do;
		      exclude = "1"b;
		      looking_for_string = "1"b;
		      found_string = "0"b;
		      alloc string_list in (area);
		      exclude_string_list_ptr = string_list_ptr;
		      string_list.string = "";
		      string_list.next = null;
		   end;
	     else if arg = "-class"			/* -class */
	     then if class
		then goto DUPARG;
		else
		   do;
		      processing_class_control_argument = "1"b;
		      looking_for_string = "1"b;
		      found_string = "0"b;
		      class = "1"b;
		      alloc string_list in (area);
		      match_class_string_list_ptr = string_list_ptr;
		      string_list.string = "";
		      string_list.next = null;
		   end;
	     else if arg = "-switch" | arg = "-sw"	/* -switch */
	     then want_switchname = "1"b;
	     else if arg = "-reverse" | arg = "-rv"	/* -reverse */
	     then reverse = "1"b;
	     else if arg = "-entry_numbers" | arg = "-etn"/* -entry_numbers */
	     then entry_numbers = "1"b;
	     else if arg = "-class_identifiers" | arg = "-cli"
						/* -class_identifiers */
	     then class_identifiers = "1"b;
	     else if arg = "-metering" | arg = "-mt"	/* -metering */
	     then metering = "1"b;
	     else if arg = "-no_header" | arg = "-nhe"	/* -no_header */
	     then header = "0"b;
	     else if arg = "-line_length" | arg = "-ll"	/* -line_length */
	     then want_line_length = "1"b;
	     else if arg = "-no_append_nl" | arg = "-nanl"
	     then
	        do;
		 force_append_nl = "0"b;
		 use_force_append_nl = "1"b;
	        end;
	     else if arg = "-append_nl" | arg = "-anl"
	     then
	        do;
		 force_append_nl = "1"b;
		 use_force_append_nl = "1"b;
	        end;
	     else if arg = "-no_insert_nl" | arg = "-ninl"
	     then
	        do;
		 force_insert_nl = "0"b;
		 use_force_insert_nl = "1"b;
	        end;
	     else if arg = "-insert_nl" | arg = "-inl"
	     then
	        do;
		 force_insert_nl = "1"b;
		 use_force_insert_nl = "1"b;
	        end;
	     else if arg = "-output_file" | arg = "-of"
	     then
	        do;
		 want_output_file = "1"b;
	        end;
	     else
	        do;
		 call com_err_ (error_table_$badopt, myname, "^/The control argument ""^a"" is not supported.", arg);
		 call finish;
		 return;
	        end;
	  end;
      end;					/* End of control argument processing. */
      call check_for_unfinished_control_argument (code);
      if code ^= 0
      then
         do;
	  call finish;
	  return;
         end;

      if output_line_length = 0			/* output_line_length wasn't set by -line_length. */
      then
         do;
	  output_line_length = get_line_length_$switch (output_iocb_ptr, code);
	  if code ^= 0
	  then output_line_length = 0;
         end;

/*  Set up the audit file to be displayed.  Initialize position_info
   (used by audit_file_position_ entries) in a fashion appropriate to whether
   or not the file is known to be currently in use.
*/

      if have_path
      then
         do;
	  call msf_manager_$open (position_info.dirname, position_info.ename, position_info.audit_fcb, code);
	  if code ^= 0
	  then
	     do;
	        call
		 com_err_ (code, myname, "^a^[>^]^a", position_info.dirname, position_info.dirname ^= ">",
		 position_info.ename);
	        call finish;
	        return;
	     end;
	  call msf_manager_$get_ptr (position_info.audit_fcb, 0, "1"b, audit_file_header_ptr, bit_count, code);
	  if code ^= 0
	  then
	     do;
	        call com_err_ (code, myname);
	        call finish;
	        return;
	     end;
	  if audit_file_header.version = 0
	  then
	     do;
	        call com_err_ (error_table_$zero_length_seg, myname);
	        call finish;
	        return;
	     end;
	  else if audit_file_header.version ^= audit_file_header_version_1
	  then
	     do;
	        call com_err_ (error_table_$unimplemented_version, myname);
	        call finish;
	        return;
	     end;
	  position_info.audit_index = audit_file_header.audit_index;
	  position_info.current_component = audit_file_header.current_component;
	  if position_info.current_component > 0
	  then
	     do;
	        call
		 msf_manager_$get_ptr (position_info.audit_fcb, position_info.current_component, "1"b,
		 position_info.audit_ptr, bit_count, code);
	        if code ^= 0
	        then
		 do;
		    current_component_string = position_info.current_component;
		    call com_err_ (code, myname, "^a>^a", pathname, current_component_string);
		    call finish;
		    return;
		 end;
	     end;
	  else position_info.audit_ptr = audit_file_header_ptr;
	  position_info.default_search_tag = "I";
	  position_info.any_tag = "1"b;
	  position_info.file_limit = audit_file_header.filled;
	  position_info.max_component = audit_file_header.max_component;
	  position_info.begin_component = audit_file_header.begin_component;
	  position_info.begin_index = audit_file_header.begin_index;
	  position_info.max_index = audit_file_header.max_index;
	  position_info.last_entry_length = audit_file_header.last_entry_length;
         end;
      else
         do;
	  call find_iocb (code);
	  if code ^= 0
	  then
	     do;
	        call com_err_ (code, myname);
	        call finish;
	        return;
	     end;
	  blkptr = iocb_ptr -> iocb.attach_data_ptr;
	  audit_file_header_ptr = blk.audit_file_header_ptr;
	  position_info.max_component = audit_file_header.max_component;
	  position_info.current_component = audit_file_header.current_component;
	  position_info.audit_fcb = blk.audit_fcb;
	  position_info.audit_index = audit_file_header.audit_index;
	  position_info.dirname = blk.dirname;
	  position_info.ename = blk.ename;
	  position_info.audit_ptr = blk.audit_ptr;
	  position_info.default_search_tag = "I";
	  position_info.any_tag = "1"b;
	  position_info.file_limit = audit_file_header.filled;
	  position_info.begin_component = audit_file_header.begin_component;
	  position_info.begin_index = audit_file_header.begin_index;
	  position_info.max_index = audit_file_header.max_index;
	  position_info.last_entry_length = audit_file_header.last_entry_length;
         end;


/* Compare the output_file to the audit_file, to ensure that they */
/* are not the same file. */

      if output_file_dir ^= ""
      then
         do;
	  call hcs_$initiate (output_file_dir, output_file_entry, "", 0, 0, output_file_ptr, code);
	  if output_file_ptr ^= null
	  then
	     do;
	        if output_file_ptr = audit_file_header_ptr
	        then
		 do;
		    call
		       com_err_ (error_table_$badopt, myname,
		       "^/The output file and the audit file may not be the same file, ^a^[>^]^a.", output_file_dir,
		       output_file_dir ^= ">", output_file_entry);
		    call finish;
		    return;
		 end;
	        call hcs_$terminate_noname (output_file_ptr, code);
	     end;
         end;

      if (entry_numbers | class_identifiers | metering)
      then leader = "1"b;

/*  If header is off, leave it off (and don't print a header). Otherwise, set
   header on if leader is on, off if leader is off.
*/

      if header
      then header = leader;

/* Make heuristic decision about whether or not to insert newlines and whether
or not to append newlines. Insert_nl is turned on if there is a leader and the
lines have a finite length (i.e., the output isn't going to a file).
*/

      if leader
      then if output_line_length ^= 0
	 then insert_nl, append_nl = "1"b;
	 else append_nl = "1"b;

/* If the user wants to force the state of either append_nl or insert_nl,
do so now.
*/

      if use_force_append_nl
      then append_nl = force_append_nl;
      if use_force_insert_nl
      then insert_nl = force_insert_nl;


/* Initialize begin_position and end_position to insure valid results if
   audit_file_position_$first or audit_file_position_$count_last is called.
*/

      begin_position.aep = null;
      begin_position.char_index = -1;
      begin_position.entry_number = -1;
      begin_position.search_tag = "";
      begin_position.component_ptr = null;
      begin_position.component_number = -1;
      begin_position.component_max_char_index = -1;

      end_position = begin_position;


/*  Find the appropriate values for begin_position and end_position.  The
   switches have_begin and have_end indicate, respecitvely, the setting of begin_arg
   and end_arg in the argument processing above.
*/

      if have_begin
      then
         do;
	  call audit_file_position_$count_last (addr (end_position), addr (position_info), code);
	  begin_position = end_position;
	  call get_position (begin_arg, begin_position, code);
	  if code ^= 0
	  then
	     do;
	        call com_err_ (code, myname, "Attempt to set beginning of display failed.");
	        call finish;
	        return;
	     end;
	  if have_end
	  then
	     do;
	        end_position = begin_position;
	        call get_position (end_arg, end_position, code);
	        if code ^= 0
	        then if code = error_table_$end_of_info
		   then code = 0;
		   else if code = error_table_$nomatch
		   then
		      do;
		         call com_err_ (0, myname, "^/No match was found searching for the end position.");
		         call finish;
		         return;
		      end;
		   else
		      do;
		         call com_err_ (0, myname, "^/Attempt to locate the last entry of the display failed.");
		         call finish;
		         return;
		      end;
	     end;
         end;
      else
         do;
	  call audit_file_position_$first (addr (begin_position), addr (position_info), code);
	  if code ^= 0
	  then
	     do;
	        call com_err_ (code, myname, "Could not get first position.  ^a", pathname_ (position_info.dirname, position_info.ename));
	        call finish;
	        return;
	     end;
	  end_position = begin_position;
	  if have_end
	  then
	     do;
	        call get_position (end_arg, end_position, code);
	        if code ^= 0
	        then if code = error_table_$end_of_info
		   then code = 0;
		   else if code = error_table_$nomatch
		   then
		      do;
		         call com_err_ (0, myname, "^/No match was found searching for the end position.");
		         call finish;
		         return;
		      end;
		   else
		      do;
		         call com_err_ (0, myname, "^/Attempt to locate the last entry of the display failed.");
		         call finish;
		         return;
		      end;
	     end;
	  else
	     do;
	        call audit_file_position_$count_last (addr (end_position), addr (position_info), code);
	        if code ^= 0
	        then
		 do;
		    call com_err_ (code, myname, "Attempt to set end of display failed.");
		    call finish;
		    return;
		 end;
	     end;
         end;

      if reverse
      then
         do;					/* Swap values of begin_position and end_position. */
	  position = end_position;
	  end_position = begin_position;
	  begin_position = position;
         end;

      position = begin_position;
      continuation = "0"b;

      if header
      then call
	    ioa_$ioa_switch (output_iocb_ptr, "^[entry ^]^[  time  cpu usage   paging ^]^[class ^]", entry_numbers,
	    metering, class_identifiers);

      if position.aep = end_position.aep
      then do_last_position = "1"b;
      else do_last_position = "0"b;
      have_displayed = "0"b;

/*  Continue processing entries as long as  position in the closed interval
   defined by begin_position and end_position.  Because of the reverse printing
   option, begin_position and end_position can be in any numeric relationship.
   Processing entries consists of  checking if the entry at "position"
   should be displayed by referring to the string_check and class_check procedures,
   if necessary, calling display_entry if the entry should be displayed,
   and advancing the position in the appropriate direction, if position is
   not end_position.
*/

      do while ((do_last_position | (position.aep ^= end_position.aep)) & code = 0);
         if match
         then
	  do;
	     call string_check ("1"b, position, display, code);
	     if code ^= 0
	     then
	        do;
		 call com_err_ (code, myname, "While checking for match.");
		 call finish;
		 return;
	        end;
	     if ^display
	     then goto NEXT_POSITION;
	  end;
         if exclude
         then
	  do;
	     call string_check ("0"b, position, display, code);
	     if code ^= 0
	     then
	        do;
		 call com_err_ (code, myname, "While checking for exclusion.");
		 call finish;
		 return;
	        end;
	     if ^display
	     then goto NEXT_POSITION;
	  end;
         if class
         then
	  do;
	     call class_check ("1"b, position, display);
	     if ^display
	     then goto NEXT_POSITION;
	  end;

         have_displayed = "1"b;
         call display_entry (position, continuation, append_nl, insert_nl, leader);
NEXT_POSITION:
         if ^do_last_position
         then if reverse
	    then call audit_file_position_$previous (addr (position), addr (position_info), code);
	    else call audit_file_position_$next (addr (position), addr (position_info), code);
         if (position.aep = end_position.aep)
         then do_last_position = ^do_last_position;
      end;

      if code ^= 0
      then
         do;
	  call com_err_ (code, myname);
	  call finish;
	  return;
         end;
      else if ^have_displayed
      then
         do;
	  call com_err_ (0, myname, "No entries were selected.");
	  call finish;
	  return;
         end;
      call finish;
      return;					/* Effective end of display_audit_file. */

get_position:
   proc (p_arg, p_position, p_code);

/* p_arg is set up by the control argument processing of -from, -last, -to,
   and -next. This procedure determines whether the positioning is to be done by string, time, or entry number.
   It does any necessary conversion of p_arg.value, then calls the appropriate
   audit_file_position_ entry. */

      dcl	    1 p_arg	       like begin_arg;
      dcl	    1 p_position	       like position_template;
      dcl	    1 position	       like position_template;
      dcl	    p_code	       fixed bin (35);
      dcl	    time_of_day	       pic "9999v.9";
      dcl	    hours		       fixed bin (17);
      dcl	    minutes	       fixed bin (9, 4);
      dcl	    arg_time_of_day	       fixed bin (71);
      dcl	    (value_is_string, value_is_time)
			       bit (1);

      p_code = 0;
      value_is_string = p_arg.value_is_string;
      value_is_time = "0"b;
      position = p_position;
      if ^value_is_string
      then if verify (p_arg.value, "0123456789.") ^= 0	/* Is p_arg.value a string? */
	 then value_is_string = "1"b;
	 else if index (p_arg.value, ".") ^= 0		/* Is p_arg.value a time? */
	 then if length (p_arg.value) > 1
	      then value_is_time = "1"b;
	      else value_is_string = "1"b;


      if value_is_string
      then
         do;
	  if p_arg.abs				/* p_arg.value is a string to be matched. */
	  then call audit_file_position_$forward_search (addr (position), p_arg.value, addr (position_info), p_code);
	  else if p_arg.add
	  then call audit_file_position_$forward_search (addr (position), p_arg.value, addr (position_info), p_code);
	  else call audit_file_position_$backward_search (addr (position), p_arg.value, addr (position_info), p_code);
         end;
      else if value_is_time
      then
         do;					/* p_arg.value is a time.  */
	  time_of_day = fixed (p_arg.value, 5, 1);
	  hours = time_of_day / 100;
	  minutes = time_of_day - hours * 100;
	  if (minutes >= 60) | (hours >= 24)
	  then
	     do;
	        p_code = error_table_$bad_arg;
	        return;
	     end;
	  arg_time_of_day = (hours * 3.6e9) + (minutes * 6e7);
	  call
	     audit_file_position_$move_time (addr (position), p_arg.abs, p_arg.add, p_arg.subtract, arg_time_of_day,
	     addr (position_info), p_code);
         end;
      else
         do;					/* p_arg.value is an entry_number. */
	  arg_number = cv_dec_check_ ((p_arg.value), p_code);
	  if p_code ^= 0
	  then return;
	  if arg_number > 2 ** 17
	  then p_code = error_table_$badopt;
	  else
	     do;
	        call
		 audit_file_position_$move_number (addr (position), p_arg.abs, p_arg.add, p_arg.subtract,
		 (arg_number), addr (position_info), p_code);
	     end;
         end;
      p_position = position;
   end;

string_check:
   proc (p_match, p_position, p_display, p_code);

/*  If the current entry contains a match for any of the regular expressions
   in the string_list indicated by p_match, then set p_display to p_match.
   Otherwise, set p_display to ^p_match.
*/

      dcl	    1 p_position	       like position_template;
      dcl	    (p_match, p_display)   bit (1);
      dcl	    chain_ptr	       ptr;
      dcl	    (p_code, code)	       fixed bin (35);

      p_code = 0;
      p_display = ^p_match;
      if p_match
      then chain_ptr = match_string_list_ptr;
      else chain_ptr = exclude_string_list_ptr;

      do while (chain_ptr ^= null);
         call
	  search_file_ (addrel (addr (chain_ptr -> string_list.string), 1), 1, length (chain_ptr -> string_list.string),
	  addr (p_position.aep -> audit_entry.string), 1, (p_position.aep -> audit_entry.entry_length), match_begin,
	  match_end, code);
         if code = 0
         then
	  do;
	     p_display = ^p_display;
	     return;
	  end;
         else if code ^= 1				/* code = 1 -> match not found. */
         then
	  do;
	     p_code = code;
	     return;
	  end;
         chain_ptr = chain_ptr -> string_list.next;
      end;
   end;


class_check:
   proc (p_match, p_position, p_display);

/*  If the class identifier of the current entry is in the  string_list
   indicated by p_match, then set p_display to p_match.  Otherwise, set
   p_display to ^p_match.
*/

      dcl	    1 p_position	       like position_template;
      dcl	    (p_match, p_display)   bit (1);

      p_display = ^p_match;
      if p_match
      then chain_ptr = match_class_string_list_ptr;
      else return;

      do while (chain_ptr ^= null);
         if substr (p_position.aep -> audit_entry.tag, 1, length (chain_ptr -> string_list.string))
	  = chain_ptr -> string_list.string
         then
	  do;
	     p_display = ^p_display;
	     return;
	  end;
         chain_ptr = chain_ptr -> string_list.next;
      end;
   end;


display_entry:
   proc (p_position, p_continuation, p_append_nl, p_insert_nl, p_leader);

/*  This controls the displaying of an entry.
   If p_continuation then place an asterisk in the first column of the
   entry field (as opposed to the leader field).
   If p_append_nl then add a newline and turn on p_continuation when
   the last character of the entry is not a newline.
   If p_insert_nl then use wrap_line to print the entry.
   If p_leader then use make_leader_string.
*/

      dcl	    (p_continuation, p_append_nl, p_insert_nl, p_leader)
			       bit (1);
      dcl	    leader_string	       char (80) varying;
      dcl	    1 p_position	       like position_template;

      if p_leader
      then call make_leader_string;

      if insert_nl
      then call wrap_line;
      else if append_nl
      then
         do;
	  call
	     ioa_$ioa_switch (output_iocb_ptr, "^[^a^x^;^s^]^[*^;^x^]^a", p_leader, leader_string, p_continuation,
	     substr (p_position.aep -> audit_entry.string, 1, p_position.aep -> audit_entry.entry_length));
	  if p_position.aep -> audit_entry.entry_length = 0
	  then p_continuation = "1"b;
	  else if substr (p_position.aep -> audit_entry.string, p_position.aep -> audit_entry.entry_length, 1) ^= NL
	  then p_continuation = "1"b;
	  else p_continuation = "0"b;
         end;
      else if p_leader
      then call
	    ioa_$ioa_switch_nnl (output_iocb_ptr, "^a^x^va", leader_string, p_position.aep -> audit_entry.entry_length,
	    p_position.aep -> audit_entry.string);
      else call
	    iox_$put_chars (output_iocb_ptr, addr (p_position.aep -> audit_entry.string),
	    (p_position.aep -> audit_entry.entry_length), code);

make_leader_string:
   proc;

/*  This constructs the leader according to the settings of three
   switches; entry_numbers, metering, and class_identifiers.
*/


      dcl	    time_of_day	       pic "9999v.9";
      dcl	    cpu_usage	       pic "zzz9v.999";
      dcl	    paging	       pic "zzzzz9v";
      dcl	    hours		       fixed bin (17);
      dcl	    minutes	       fixed bin (3, 1);
      dcl	    return_string	       char (32);
      dcl	    return_string_len      fixed bin;

      leader_string = "";
      if entry_numbers
      then
         do;
	  current_entry_number = position.entry_number;
	  leader_string = current_entry_number || " ";
         end;

      if metering
      then if p_position.aep -> audit_entry.time = -1
	 then
	    do;
	       call
		ioa_$rsnnl ("^vx*^vx*^vx*^vx", return_string, return_string_len,
		divide (length (time_of_day) + 1, 2, 17, 0),
		divide (length (cpu_usage) + 3 + length (time_of_day) + 1, 2, 17, 0),
		divide (length (cpu_usage) + 3 + length (paging) + 1, 2, 17, 0),
		divide (length (paging) + 1, 2, 17, 0));
	       leader_string = leader_string || substr (return_string, 1, return_string_len);
	    end;
	 else
	    do;
	       hours = divide (p_position.aep -> audit_entry.time, 3600000000, 17, 0);
	       minutes = mod (p_position.aep -> audit_entry.time, 3.6e9) / 6e7;
	       if hours > 24
	       then hours = 98;
	       time_of_day = hours * 100 + minutes;
	       if p_position.aep -> audit_entry.virtual_time / 1e6 > 9999
	       then cpu_usage = 9999;
	       else cpu_usage = p_position.aep -> audit_entry.virtual_time / 1e6;
	       if p_position.aep -> audit_entry.paging > 99999
	       then paging = 99999;
	       else paging = p_position.aep -> audit_entry.paging;
	       leader_string = leader_string || time_of_day || " " || cpu_usage || "   " || paging || " ";
	    end;

      if class_identifiers
      then leader_string = leader_string || " " || p_position.aep -> audit_entry.tag || "  ";
   end;

wrap_line:
   proc;

/*  wrap_line formats the output of an entry.  Newlines are inserted, and
   output is indented as necessary.
   Or, if the entry doesn't end in a newline.
   Indentation is necessary when the number
   of characters to the first newline (line_break) is greater than the output
   line length minus the length of the leader string minus 1 (allowable_entry_length).
*/

      dcl	    (allowable_entry_length, char_index, len, line_break)
			       fixed bin;
      char_index = 1;
      if p_leader
      then allowable_entry_length = output_line_length - length (leader_string) - 1;
      else allowable_entry_length = output_line_length - 1;
      continuation = p_continuation;
      char_index = 1;
      line_break = index (p_position.aep -> audit_entry.string, NL);

      if line_break > allowable_entry_length
      then
         do;					/* Insert a new_line.*/
	  len = allowable_entry_length;
	  call
	     ioa_$ioa_switch (output_iocb_ptr, "^[^a^;^s^]^x^[*^;^x^]^a", leader, leader_string, continuation,
	     substr (p_position.aep -> audit_entry.string, char_index, len));
	  continuation = "1"b;
         end;
      else if line_break > 0
      then
         do;					/* Print as is.*/
	  len = line_break;
	  call
	     ioa_$ioa_switch_nnl (output_iocb_ptr, "^[^a^;^s^]^x^[*^;^x^]^a", leader, leader_string, continuation,
	     substr (p_position.aep -> audit_entry.string, char_index, len));
	  continuation = "0"b;
         end;
      else
         do;
	  if p_position.aep -> audit_entry.entry_length - char_index + 1 > allowable_entry_length
	  then len = allowable_entry_length;
	  else len = p_position.aep -> audit_entry.entry_length - char_index + 1;

	  if append_nl | p_position.aep -> audit_entry.entry_length - char_index + 1 > allowable_entry_length
	  then
	     do;
	        call
		 ioa_$ioa_switch (output_iocb_ptr, "^[^a^;^s^]^x^[*^;^x^]^a", leader, leader_string, continuation,
		 substr (p_position.aep -> audit_entry.string, char_index, len));
	        continuation = "1"b;
	     end;
	  else
	     do;
	        call
		 ioa_$ioa_switch_nnl (output_iocb_ptr, "^[^a^;^s^]^x^[*^;^x^]^a", leader, leader_string, continuation,
		 substr (p_position.aep -> audit_entry.string, char_index, len));
	        continuation = "0"b;
	     end;
         end;
      char_index = char_index + len;

      do while (char_index < p_position.aep -> audit_entry.entry_length);
         line_break = index (substr (p_position.aep -> audit_entry.string, char_index), NL);

         if line_break > allowable_entry_length
         then
	  do;
	     len = allowable_entry_length;
	     call
	        ioa_$ioa_switch (output_iocb_ptr, "^[^vx^;^s^]^x^[*^;^x^]^a", leader, length (rtrim (leader_string)),
	        continuation, substr (p_position.aep -> audit_entry.string, char_index, len));
	     continuation = "1"b;
	  end;
         else if line_break > 0
         then
	  do;
	     len = line_break;
	     call
	        ioa_$ioa_switch_nnl (output_iocb_ptr, "^[^vx^;^s^]^x^[*^;^x^]^a", leader,
	        length (rtrim (leader_string)), continuation,
	        substr (p_position.aep -> audit_entry.string, char_index, len));
	     continuation = "0"b;
	  end;
         else
	  do;
	     if p_position.aep -> audit_entry.entry_length - char_index + 1 > allowable_entry_length
	     then len = allowable_entry_length;
	     else len = p_position.aep -> audit_entry.entry_length - char_index + 1;
	     if append_nl | p_position.aep -> audit_entry.entry_length - char_index + 1 > allowable_entry_length
	     then
	        do;
		 call
		    ioa_$ioa_switch (output_iocb_ptr, "^[^vx^;^s^]^x^[*^;^x^]^a", leader,
		    length (rtrim (leader_string)), continuation,
		    substr (p_position.aep -> audit_entry.string, char_index, len));
		 continuation = "1"b;
	        end;
	     else
	        do;
		 call
		    ioa_$ioa_switch_nnl (output_iocb_ptr, "^[^vx^;^s^]^x^[*^;^x^]^a", leader,
		    length (rtrim (leader_string)), continuation,
		    substr (p_position.aep -> audit_entry.string, char_index, len));
		 continuation = "0"b;
	        end;
	  end;
         char_index = char_index + len;
      end;
      p_continuation = continuation;
   end;
   end;

find_iocb:
   proc (p_code);

/*  Find an iocb for a switch currently using audit_. If a switchname was
   provided as an argument to daf, then use its iocb. Else, look at user_i/o
   to see if it is using audit_. If it isn't, walk through the attachments
   in order (using find_iocb_n) checking each for use of audit_. The first
   switch found using audit_ is returned.
*/

      dcl	    (code, p_code)	       fixed bin (35);
      dcl	    iox_$user_io	       ptr ext;
      dcl	    attach_description     char (32) varying based;
      dcl	    index		       fixed bin;
      dcl	    iox_$find_iocb_n       entry (fixed bin, ptr, fixed bin (35));
      dcl	    iox_$look_iocb	       entry (char (*), ptr, fixed bin (35));


      code = 0;

      if have_switchname
      then
         do;
	  call iox_$look_iocb (switchname, iocb_ptr, code);
	  if code ^= 0
	  then
	     do;
	        p_code = code;
	        return;
	     end;
         end;
      else if substr (iox_$user_io -> iocb.attach_descrip_ptr -> attach_description, 1, 6) = "audit_"
      then iocb_ptr = iox_$user_io;

      else
         do;
	  index = 1;
	  call iox_$find_iocb_n (index, iocb_ptr, code);
	  do while (code = 0);
	     if iocb_ptr -> iocb.attach_data_ptr ^= null
	     then if substr (iocb_ptr -> iocb.attach_descrip_ptr -> attach_description, 1, 6) = "audit_"
		then return;
	     index = index + 1;
	     call iox_$find_iocb_n (index, iocb_ptr, code);
	  end;
         end;
      p_code = code;
   end;
%page;
check_for_unfinished_control_argument:
   proc (p_code);
      dcl	    p_code	       fixed bin (35);
      p_code = error_table_$noarg;
      if want_begin_addr
      then call
	    com_err_ (p_code, myname, "^/ The ^[-last^;-from^] control argument must be followed by an address.",
	    begin_arg.subtract);
      else if want_end_addr
      then call
	    com_err_ (p_code, myname, "^/The ^[-to^;-next^] control argument must be followed by an address.",
	    end_arg.abs);
      else if want_output_file
      then call com_err_ (p_code, myname, "^/The -output_file control argument must be followed by a pathname.");
      else if looking_for_string & ^found_string
      then call
	    com_err_ (p_code, myname,
	    "^/The ^[-class^;-match and -exclude^] control argument^[^;s^] must be followed by a ^[class identifier^;string^]."
	    , processing_class_control_argument, processing_class_control_argument, processing_class_control_argument);
      else if want_switchname
      then call com_err_ (p_code, myname, "^/The -switch control argument must be followed by a switch name.");
      else if want_line_length
      then call com_err_ (p_code, myname, "^/The -line_length control argument must be followed by a line length.");
      else p_code = 0;
   end check_for_unfinished_control_argument;
%page;
finish:
   proc;
      if output_iocb_ptr ^= iox_$user_output
      then
         do;
	  call iox_$close (output_iocb_ptr, code);
	  call iox_$detach_iocb (output_iocb_ptr, code);
         end;
   end finish;
%include audit_block;
%include iocbx;
%include iox_dcls;
%include iox_modes;
%include audit_position;
%include audit_entry;
%include audit_file_header;
%include check_star_name;
   end;
