/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(1989-04-06,Vu), approve(1989-04-06,MCR8095), audit(1989-04-25,Lee),
     install(1989-05-10,MR12.3-1040):
     - output modes are returned even if the input modes string contains only
       audit modes (ie. audit_input).
     - The following builtin functions: after, before, empty, max, rtrim are
       now declared explicitly.
  2) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: style2,ind3 */
audit_:
audit_attach:
   proc (p_iocb_ptr, p_option_array, p_com_err_sw, p_code);


/* This program is the main driver for the "audit" module. It has entries
   for attachment (which also opens), for reading, writing, and detachment (which also precedes
   it with a close). The following I/O system calls are provided for this module:

   attach (open)	audit_$audit_attach
   close		audit_$audit_close
   detach		audit_$audit_detach
   get_chars	audit_$audit_get_chars
   get_line	audit_$audit_get_line
   put_chars	audit_$audit_put_chars
   control	audit_$audit_control
   modes		audit_$audit_modes

   Last Modified:

   12/01/78  Written by Lindsey L. Spratt  (from existing code by J. Stern, S. Webber, and R. Bratt)
   11/26/79  by  Lindsey L. Spratt  to support prompting in the editor.
   05/20/80  by  Lindsey L. Spratt  to fix -tc option and assume "audit" suffix.
   12/22/80  by  Lindsey L. Spratt: Change all mode string references from 256
	       char string to 512.
03/20/81  by  Lindsey L. Spratt:  remove "audit_editor_prompt_terminator="
	    mode.  Set default editor_prompt_string to 
	    "audit editor^[(^d)^]:^2x".
08/05/81 by Lindsey Spratt: Changed modes entry to use the mode_string_$parse
	  and mode_string_$delete entries to manipulate the mode strings.
	  Changed all calls to iox entries to be calls instead of function
	  references.  Changed from using the iocbx.incl.pl1 file to
	  iocb.incl.pl1.  Changed entry sequences to be calls instead of
	  functions, i.e. the returns (fixed bin(35)) was replaced by
	  including "p_code" in the entry parameters.
10/29/81 by Lindsey Spratt: Fixed conversion of ll= and pl= to only be
	  invoked if the respective strings are actually present to be
	  converted.  Also, added rtrimming of the unrecognized_modes string
	  in the calls of the before and after builtins.
	       Added initialization of the blk pointers
	  audit_file_header_ptr, temp_seg_ptr, work_area, audit_fcb,
	  begin_ptr, and audit_ptr.  Added checks for null pointers and
	  non-zero error codes to the detach entry.
11/12/81 by Lindsey Spratt:  Changed to call hcs_$assign_linkage as a
	  subroutine  instead of a function.
06/01/82 by Lindsey Spratt:  Was not honoring the maximum length of the audit
	  file when "adjusting" during the audit_detach operation, the
	  current_component and (audit_index - 1) were being used instead of
	  the max_component and max_index (set by the audit_file_size mode).
	  The audit_detach entry now checks the audit_file_header.filled
	  flag to determine if it should use the max component and index
	  (file_limit = "1"b) or the current_component and audit_index (file_limit =
	  "0"b).
06/03/82 by Lindsey Spratt:  Changed the setting of the bit count in 
            audit_detach to be the value of audit_index*9, instead of
            audit_index*9-9.
06/08/82 by Lindsey Spratt:  Removed the code which always set
	  audit_file_header.max_index to sys_info$max_seg_size*4 whenever
	  attaching to an audit file.  The max_index and max_componenet
	  values of the audit_file_header are now only set when initializing
	  an empty audit file and when setting the audit_file_size mode.
	  This makes max_index a reliable indicator of whether the "current"
	  audit file is supposed to be circular or not.  The setting of the
	  file_limit flag in blk.current_flags in audit_attach relies on
	  this fact.
06/09/82 by Lindsey Spratt: Added an any_other handler to audit_detach.
	  Changed detach logic to not use the bit-count-setting feature of
	  msf_manager_$adjust when adjusting the audit file, instead an
	  explicit set_bc_seg is done (when appropriate) to the final
	  component of the audit file.  All preceding components will have
	  had their bit counts correctly set by the "next_component"
	  operation of insert_line.
10/13/82 by Lindsey Spratt:  Moved setting of safety_sw off into the
	  audit_close entry.  This makes it possible for the standard
	  process epilogue handler to cause audit files to have their safety
	  switches turned off.  Previously, this was done in the
	  audit_detach entry, which does not get invoked during process
	  termination.
02/10/83 by Lindsey Spratt:  Fixed audit_line to set
	  audit_file_header.max_component to be the highest used component
	  number in the non-file_limit (non-circular file) case.
	  display_audit_file/audit_file_position_ relies on the
	  max_component to know where the audit file ends (in some
	  circumstances).  Fixed insert_line to set
	  audit_file_header.max_index to equal audit_file_header.audit_index
	  when working with a non-file_limit audit file.
03/02/83 by Lindsey Spratt:  More fixes to make all portions of code respect
	  the protocol that for "unlimited" (or non-circular) files
	  afh.max_index always equals afh.audit_index and afh.max_component
	  always equals afh.current_component.  For circular files,
	  afh.max_index is > afh.audit_index when afh.max_component =
	  afh.current_component, and afh.max_component is always >=
	  afh.current_component.  Also, fixed audit_suspend mode to have no
	  effect when audit is already suspended.
   */

/* Parameters */

      dcl	    (p_newmodes, p_oldmodes)
			       char (*);
      dcl	    p_real_order	       char (*);
      dcl	    p_code	       fixed bin (35);
      dcl	    (p_iocb_ptr, buff_ptr, p_info_ptr)
			       ptr;
      dcl	    (actual_len, buff_len) fixed bin (21);
      dcl	    p_option_array	       (*) char (*) var;
      dcl	    p_com_err_sw	       bit (1) aligned;
      dcl	    ptype		       fixed bin;
      dcl	    n		       fixed bin (21);
      dcl	    p_buff_ptr	       ptr;
      dcl	    (p_buff_len, p_actual_len)
			       fixed bin (21);

/* Entries */

      dcl	    cpu_time_and_paging_   entry (fixed bin, fixed bin (71), fixed bin);
      dcl	    get_temp_segment_      entry (char (*), ptr, fixed bin (35));
      dcl	    release_temp_segment_  entry (char (*), ptr, fixed bin (35));
      dcl	    decode_clock_value_    entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin (71), fixed bin,
			       char (4) aligned);
      dcl	    audit_editor	       entry (ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (35));
      dcl	    audit_editor$set_last_return_line_position
			       entry (ptr);
      dcl	    audit_file_position_$last
			       entry (ptr, ptr, fixed bin (35));
      dcl	    com_err_	       entry options (variable);
      dcl	    sub_err_	       entry options (variable);
      dcl	    expand_pathname_$add_suffix
			       entry (char (*), char (*), char (*), char (*), fixed bin (35));
      dcl	    ioa_$ioa_switch	       entry options (variable);
      dcl	    ioa_$ioa_switch_nnl    entry options (variable);
      dcl	    date_time_	       entry (fixed bin (71), char (*));
      dcl	    user_info_$homedir     entry (char (*));
      dcl	    hcs_$set_bc_seg	       entry (ptr, fixed bin (24), fixed bin (35));
      dcl	    hcs_$set_safety_sw_seg entry (ptr, bit (1), fixed bin (35));
      dcl	    hcs_$status_mins       entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
      dcl	    hcs_$set_ips_mask      entry (fixed bin, fixed bin);
      dcl	    hcs_$assign_linkage    entry (fixed bin, ptr, fixed bin (35));
      dcl	    abbrev_$expanded_line  entry (ptr, fixed bin, ptr, fixed bin, ptr, fixed bin);
      dcl	    msf_manager_$open      entry (char (*), char (*), ptr, fixed bin (35));
      dcl	    msf_manager_$get_ptr   entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      dcl	    msf_manager_$adjust    entry (ptr, fixed bin, fixed bin (24), bit (3), fixed bin (35));
      dcl	    msf_manager_$close     entry (ptr);

      dcl	    mode_string_$parse     entry (char (*), ptr, ptr, fixed bin (35));
      dcl	    mode_string_$delete    entry (ptr, (*) char (*), char (*), fixed bin (35));
      dcl	    mode_string_$combine   entry (ptr, ptr, char (*), fixed bin (35));

/* Constants */

      dcl	    any_other	       condition;

/* Static Variables */

      dcl	    SUFFIX	       char (32) varying init ("audit") internal static options (constant);
      dcl	    sio_open_desc	       char (20) varying init ("stream_input_output") static options (constant);
      dcl	    myname	       char (6) static options (constant) init ("audit_");
      dcl	    NL		       char (1) aligned static options (constant) init ("
");
      dcl	    AUDIT_MODE_NAMES       (12) char (32)
			       init ("audit_suspend", "audit_input", "audit_output", "audit_edit", "audit_trace",
			       "audit_use_editor_prompt", "audit_editor_prompt_string", "audit_epstr",
			       "audit_file_size", "audit_meter", "audit_transparent", "audit_trigger")
			       internal static options (constant);

/* Based */

      dcl	    mode_str	       char (512) varying based;
      dcl	    aut_input_string       char (actual_len) based (buff_ptr);
      dcl	    param_output_string    char (p_buff_len) based (p_buff_ptr);
      dcl	    param_input_string     char (p_actual_len) based (p_buff_ptr);

/* Automatic Variables */

      dcl	    out_ptr	       ptr;
      dcl	    type		       fixed bin (2);
      dcl	    bit_count24	       fixed bin (24);
      dcl	    mode_idx	       fixed bin (17);
      dcl	    records	       fixed bin;
      dcl	    newmodes	       char (64) varying;
      dcl	    unrecognized_modes     char (512);
      dcl	    order		       char (32);
      dcl	    (audited_iocb, blkptr, auditing_iocb)
			       ptr;
      dcl	    device	       char (32);
      dcl	    i		       fixed bin;
      dcl	    (tc, mask)	       fixed bin;
      dcl	    ename		       char (32);
      dcl	    time		       char (8);
      dcl	    dirname	       char (168);
      dcl	    tactual_len	       fixed bin (21);
      dcl	    extend	       bit (1);
      dcl	    request	       char (1);
      dcl	    set_last_return_line_position
			       bit (1) init ("0"b);
      dcl	    ab_buf	       char (512);
      dcl	    ab_len	       fixed bin;
      dcl	    temp_area	       area (2048);

/* External Variables */

      dcl	    sys_info$max_seg_size  fixed bin (24) ext;
      dcl	    error_table_$bad_mode_value
			       fixed bin (35) ext;
      dcl	    error_table_$bad_mode_syntax
			       fixed bin (35) ext;
      dcl	    error_table_$long_record
			       fixed bin (35) ext;
      dcl	    error_table_$empty_file
			       fixed bin (35) ext;
      dcl	    error_table_$noarg     fixed bin (35) ext;
      dcl	    error_table_$unimplemented_version
			       fixed bin (35) ext;
      dcl	    error_table_$not_detached
			       fixed bin (35) ext;
      dcl	    error_table_$noentry   fixed bin (35) ext;
      dcl	    error_table_$bad_arg   fixed bin (35) ext;

/* Builtins */

      dcl	    string	       builtin;
      dcl	    currentsize	       builtin;
      dcl	    clock		       builtin;
      dcl	    mod		       builtin;
      dcl	    (substr, addr, null, divide, hbound, index, length, size)
			       builtin;
      dcl     (after, before, empty, max, rtrim)
                                     builtin;


/*  */

/* attach --- subroutine to attach and open the audit module */



/* Look at option array and collect data */

      ename = "";
      audited_iocb = p_iocb_ptr;
      extend = "1"b;
      if hbound (p_option_array, 1) < 1
      then
         do;
	  if p_com_err_sw
	  then call com_err_ (error_table_$bad_arg, (myname), "No device name given.");
	  p_code = error_table_$bad_arg;
	  return;
         end;
      device = p_option_array (1);			/* device name must be first option */
      call iox_$find_iocb (device, auditing_iocb, p_code);
      if p_code ^= 0
      then
         do;
	  if p_com_err_sw
	  then call com_err_ (p_code, (myname), "^a", device);
	  return;
         end;
      do i = 2 to hbound (p_option_array, 1);		/* now search the options */
         if p_option_array (i) = "-tc" | p_option_array (i) = "-truncate"
         then extend = "0"b;
         else if p_option_array (i) = "-pn" | p_option_array (i) = "-pathname"
         then
	  do;
	     i = i + 1;
	     if i > hbound (p_option_array, 1)
	     then
	        do;
		 if p_com_err_sw
		 then call
		         com_err_ (error_table_$noarg, (myname),
		         "^/A pathname must be given with the the -pathname control argument.");
		 p_code = error_table_$noarg;
		 return;
	        end;
	     call expand_pathname_$add_suffix ((p_option_array (i)), (SUFFIX), dirname, ename, p_code);
	     if p_code ^= 0
	     then
	        do;
		 if p_com_err_sw
		 then call com_err_ (p_code, (myname), "^a", p_option_array (i));
		 return;
	        end;
	  end;
         else
	  do;
	     if p_com_err_sw
	     then call com_err_ (error_table_$bad_arg, (myname), "^/Unsupported option ^a.", p_option_array (i));
	     p_code = error_table_$bad_arg;
	     return;
	  end;
      end;
      if ename = ""
      then
         do;
	  call date_time_ (clock, time);		/* get time for default file name */
	  ename = time || ".audit";
	  call user_info_$homedir (dirname);		/* get default dirname */
         end;
      call hcs_$set_ips_mask (0, mask);			/* enter critical code */
      if audited_iocb -> iocb.attach_descrip_ptr ^= null ()
      then
         do;
	  call hcs_$set_ips_mask (mask, 0);
	  if p_com_err_sw
	  then call com_err_ (error_table_$not_detached, (myname));
	  p_code = error_table_$not_detached;
	  return;
         end;
      call hcs_$assign_linkage (size (blk), blkptr, p_code);
      if blkptr = null ()
      then
         do;					/* can't get storage for data */
	  call hcs_$set_ips_mask (mask, 0);
	  if p_com_err_sw
	  then call com_err_ (p_code, (myname));
	  return;
         end;
      audited_iocb -> iocb.attach_descrip_ptr = addr (blk.attach);
      audited_iocb -> iocb.attach_data_ptr = blkptr;
      audited_iocb -> iocb.detach_iocb = audit_detach;
      audited_iocb -> iocb.open = iox_$err_no_operation;
      audited_iocb -> iocb.close = audit_close;		/* Now fill in some stuff in the block */
      tc = index (device, " ");
      if tc = 0
      then tc = length (device);
      blk.attach = "audit_ " || substr (device, 1, tc);
      do i = 2 to hbound (p_option_array, 1);
         blk.attach = blk.attach || " ";
         blk.attach = blk.attach || p_option_array (i);
      end;
      blk.auditing_iocb = auditing_iocb;		/* fill in target iocb pointer */
      blk.default_iocb = audited_iocb;


/* Now the code to open the stream as well */

      blk.dirname = dirname;
      blk.ename = ename;
      blk.audit_file_header_ptr = null;
      blk.audit_fcb = null;
      blk.audit_ptr = null;
      blk.begin_ptr = null;
      blk.temp_seg_ptr = null;
      blk.work_space = null;
      audited_iocb -> iocb.get_line = audit_get_line;
      audited_iocb -> iocb.control = audit_control;
      audited_iocb -> iocb.put_chars = audit_put_chars;
      audited_iocb -> iocb.get_chars = audit_get_chars;
      audited_iocb -> iocb.open_descrip_ptr = addr (sio_open_desc);
      audited_iocb -> iocb.open_data_ptr = blkptr;
      audited_iocb -> iocb.modes = audit_modes;
      audited_iocb -> iocb.position = audit_position;

      call msf_manager_$open (blk.dirname, blk.ename, blk.audit_fcb, p_code);
      if p_code ^= 0
      then if p_code = error_table_$noentry
	 then
	    do;
	       call msf_manager_$get_ptr (blk.audit_fcb, 0, "1"b, blk.audit_ptr, bit_count24, p_code);
	       if p_code ^= 0
	       then
		do;
		   call hcs_$set_ips_mask (mask, 0);
		   if p_com_err_sw
		   then call
			 com_err_ (p_code, (myname),
			 "While attempting to get a pointer to component 0 of the audit file.");
		   return;
		end;
INIT_AUDIT_FILE:
	       audit_file_header_ptr = blk.audit_ptr;
	       blk.audit_file_header_ptr = blk.audit_ptr;
	       audit_file_header.last_entry_length = impossible_audit_entry_length;
	       audit_file_header.filled = "0"b;
	       audit_file_header.current_component = 0;
	       audit_file_header.unused1 = "0"b;
	       audit_file_header.pad2 = 0;
	       audit_file_header.begin_component = 0;
	       audit_file_header.begin_index =
		(4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8);
	       blk.begin_ptr = blk.audit_ptr;
	       audit_file_header.version = audit_file_header_version_1;
	       audit_file_header.last_entry_length = -1;
	       call truncate_audit_file;
	       audit_file_header.max_component = audit_file_header.current_component;
	       audit_file_header.max_index = audit_file_header.audit_index;
	    end;
	 else
	    do;
	       call hcs_$set_ips_mask (mask, 0);
	       if p_com_err_sw
	       then call
		     com_err_ (p_code, (myname), "While attempting to open audit file ^a^[>^]^a .", blk.dirname,
		     blk.dirname ^= ">", blk.ename);
	       return;
	    end;
      else if extend
      then
         do;
	  call msf_manager_$get_ptr (blk.audit_fcb, 0, "1"b, audit_file_header_ptr, bit_count24, p_code);
	  if p_code ^= 0
	  then
	     do;
	        call hcs_$set_ips_mask (mask, 0);
	        if p_com_err_sw
	        then call com_err_ (p_code, (myname), "While attempting to get pointer to component 0 of audit file.");
	        return;
	     end;
	  if audit_file_header.version = 0
	  then
	     do;
	        blk.audit_ptr = audit_file_header_ptr;
	        go to INIT_AUDIT_FILE;
	     end;
	  else if audit_file_header.version ^= audit_file_header_version_1
	  then
	     do;
	        call hcs_$set_ips_mask (mask, 0);
	        if p_com_err_sw
	        then call com_err_ (p_code, (myname));
	        p_code = error_table_$unimplemented_version;
	        return;
	     end;
	  call
	     msf_manager_$get_ptr (blk.audit_fcb, audit_file_header.current_component, "1"b, blk.audit_ptr, bit_count24,
	     p_code);
	  if p_code ^= 0
	  then
	     do;
	        call hcs_$set_ips_mask (mask, 0);
	        if p_com_err_sw
	        then call com_err_ (p_code, (myname), "While attempting to get pointer to audit file.");
	        return;
	     end;
	  call
	     msf_manager_$get_ptr (blk.audit_fcb, audit_file_header.begin_component, "1"b, blk.begin_ptr, bit_count24,
	     p_code);
	  if p_code ^= 0
	  then
	     do;
	        call hcs_$set_ips_mask (mask, 0);
	        if p_com_err_sw
	        then call
		      com_err_ (p_code, (myname), "While attempting to get pointer  to component ^d of audit file.",
		      audit_file_header.begin_component);
	        return;
	     end;
	  blk.current_flags.file_limit =
	     audit_file_header.max_index > audit_file_header.audit_index
	     | audit_file_header.max_component > audit_file_header.current_component;
         end;
      else
         do;
	  call msf_manager_$get_ptr (blk.audit_fcb, 0, "1"b, blk.audit_ptr, bit_count24, p_code);
	  if p_code ^= 0
	  then
	     do;
	        call hcs_$set_ips_mask (mask, 0);
	        if p_com_err_sw
	        then call
		      com_err_ (p_code, (myname), "While attempting to get pointer to component ^d of audit file.",
		      audit_file_header.current_component);
	        return;
	     end;
	  audit_file_header_ptr = blk.audit_ptr;
	  blk.audit_file_header_ptr = blk.audit_ptr;
	  audit_file_header.current_component = 0;
	  call
	     msf_manager_$adjust (blk.audit_fcb, 0,
	     ((4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8)) * 9, "110"b, p_code);
	  if p_code ^= 0
	  then
	     do;
	        call hcs_$set_ips_mask (mask, 0);
	        if p_com_err_sw
	        then call com_err_ (p_code, (myname), "While attempting to adjust audit file.");
	        return;
	     end;
	  call truncate_audit_file;
	  audit_file_header.begin_index = audit_file_header.audit_index;
	  audit_file_header.begin_component = 0;
	  audit_file_header.max_component = audit_file_header.current_component;
	  audit_file_header.max_index = audit_file_header.audit_index;
	  audit_file_header.filled = "0"b;
	  blk.begin_ptr = blk.audit_ptr;
         end;
      blk.audit_file_header_ptr = audit_file_header_ptr;
      blk.current_flags.read_audit = "1"b;
      blk.current_flags.write_audit = "1"b;
      blk.trigger = "!";
      blk.current_flags.edit = "1"b;
      blk.current_flags.use_editor_prompt = "1"b;
      blk.editor_prompt_string = "audit editor^[(^d)^]:^2x";

      blk.work_space = null;
      blk.work_space_len = 0;

      call hcs_$set_safety_sw_seg (blk.audit_file_header_ptr, "1"b, p_code);
						/* The audit_file_header_ptr always points at component 0 of the audit file, the safety switch on comp 0 is on when audit is attached and off when audit isn't attached. */

      call get_temp_segment_ ("audit_", blk.temp_seg_ptr, p_code);
      if p_code ^= 0
      then
         do;
	  call hcs_$set_ips_mask (mask, 0);
	  if p_com_err_sw
	  then call com_err_ (p_code, (myname), "While attempting to get temp seg.");
	  return;
         end;					/* Now propagate through all appropriate IOCB's */
      call iox_$propagate (audited_iocb);
      call hcs_$set_ips_mask (mask, 0);
      p_code = 0;
      return;


audit_detach:
   entry (p_iocb_ptr, p_code);
      p_code = 0;
      call hcs_$set_ips_mask (0, mask);
      blkptr = p_iocb_ptr -> iocb.attach_data_ptr;
      p_iocb_ptr -> iocb.open_descrip_ptr = null ();
      p_iocb_ptr -> iocb.open_data_ptr = null ();
      p_iocb_ptr -> iocb.attach_descrip_ptr, p_iocb_ptr -> iocb.attach_data_ptr = null ();
      p_iocb_ptr -> iocb.detach_iocb = iox_$err_not_attached;
      p_iocb_ptr -> iocb.open = iox_$err_not_attached;
      call iox_$propagate (p_iocb_ptr);

      on any_other
         begin;
	  call force_audit_suspension;
	  goto RETURN;
         end;

      if blkptr = null
      then return;
      else if blk.audit_file_header_ptr ^= null
      then
         do;
	  audit_file_header_ptr = blk.audit_file_header_ptr;
	  if ^(blk.current_flags.file_limit
	     & (audit_file_header.begin_component > audit_file_header.current_component
	     | (audit_file_header.begin_component = audit_file_header.current_component
	     & audit_file_header.begin_index >= audit_file_header.audit_index)))
	  then
	     do;
	        call hcs_$set_bc_seg (blk.audit_ptr, audit_file_header.audit_index * 9, p_code);
	        if p_code ^= 0
	        then goto RETURN;

/* Can't use the bit count setting feature of msf_manager_$adjust because it 
will attempt to set the bit counts of the preceding components to max_length,
which is not the correct value.  In any event, their bit counts have already 
been set. */

	        call
		 msf_manager_$adjust (blk.audit_fcb, audit_file_header.current_component,
		 9 * audit_file_header.audit_index, "011"b, p_code);
	        if p_code ^= 0
	        then goto RETURN;
	     end;
         end;
      if blk.temp_seg_ptr ^= null
      then
         do;
	  call release_temp_segment_ ("audit_", blk.temp_seg_ptr, p_code);
	  if p_code ^= 0
	  then goto RETURN;
         end;

      if blk.audit_fcb ^= null
      then call msf_manager_$close (blk.audit_fcb);
RETURN:
      revert any_other;
      call hcs_$set_ips_mask (mask, 0);
      return;

audit_close:
   entry (p_iocb_ptr, p_code);

      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = p_iocb_ptr -> iocb.attach_data_ptr;
      if blk.audit_file_header_ptr ^= null
      then call hcs_$set_safety_sw_seg (blk.audit_file_header_ptr, "0"b, p_code);
						/* The audit_file_header_ptr always points to the base of component 0 in the audit file. The safety switch on component 0 is on when audit is attached and off when it isn't.*/
      call hcs_$set_ips_mask (0, mask);
      audited_iocb -> iocb.open_descrip_ptr = null ();
      audited_iocb -> iocb.detach_iocb = audit_detach;
      call iox_$propagate (audited_iocb);
      call hcs_$set_ips_mask (mask, 0);
      p_code = 0;
      return;

/*  */

/* The following are dummy entries that pass on the given request */

audit_get_chars:
   entry (p_iocb_ptr, p_buff_ptr, p_buff_len, p_actual_len, p_code);
      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = audited_iocb -> iocb.attach_data_ptr;
      auditing_iocb = blk.auditing_iocb;
      call iox_$get_chars (auditing_iocb, p_buff_ptr, p_buff_len, p_actual_len, p_code);
      if p_code ^= 0
      then return;
      if blk.current_flags.read_audit
      then call audit_line ("IC", param_input_string);
      p_code = 0;
      return;

audit_modes:
   entry (p_iocb_ptr, p_newmodes, p_oldmodes, p_code);
      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = audited_iocb -> iocb.attach_data_ptr;
      auditing_iocb = blk.auditing_iocb;
      audit_file_header_ptr = blk.audit_file_header_ptr;
      if blk.current_flags.trace
      then call audit_line ("TM", rtrim (p_newmodes) || NL);
      unrecognized_modes = "";
      if length (rtrim (p_newmodes)) = 0
      then
         do;
	  call iox_$modes (blk.auditing_iocb, p_newmodes, p_oldmodes, p_code);
	  return;
         end;

      call mode_string_$parse (p_newmodes, addr (temp_area), mode_string_info_ptr, p_code);
      if p_code ^= 0
      then return;

      if mode_string_info.version ^= mode_string_info_version_2
      then call
	    sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
	    "^/Unable to use the mode_string_info structure.  Expecting version ^d, 
received version ^d.", mode_string_info_version_2, mode_string_info.version);
      if mode_string_info.number > 0
      then if mode_string_info.modes (1).version ^= mode_value_version_3
	 then call
	         sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
	         "^/Unable to use the mode_value structure. Expecting version ^d, 
received version ^d.", mode_value_version_3, mode_string_info.modes (1).version);

MODE_LOOP:
      do mode_idx = 1 to mode_string_info.number;
         newmodes = mode_string_info.modes (mode_idx).mode_name;
         if index (newmodes, "audit_") = 1
         then if newmodes = "audit_suspend"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else if mode_string_info.modes (mode_idx).boolean_value
	         then
		  do;
		     if ^blk.suspend
		     then call suspend_auditing ("", null);
		  end;
	         else
		  do;
		     string (blk.current_flags) = string (blk.saved_flags);
		     blk.suspend = "0"b;
		  end;

	    else if blk.suspend
	    then call
		  ioa_$ioa_switch (auditing_iocb,
		  "audit_: auditing suspended, no audit_ modes operations allowed except ^^audit_suspend");
	    else if newmodes = "audit_input"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.current_flags.read_audit = mode_string_info.modes (mode_idx).flags.boolean_value;
	    else if newmodes = "audit_transparent"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else if mode_string_info.modes (mode_idx).flags.boolean_value
	         then blk.default_iocb = auditing_iocb;
	         else blk.default_iocb = audited_iocb;

	    else if newmodes = "audit_file_size"
	    then if mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else if mode_string_info.modes (mode_idx).flags.char_valuep
	         then if mode_string_info.modes (mode_idx).char_value = "unlimited"
		    then
		       do;
			blk.begin_ptr = audit_file_header_ptr;
			audit_file_header.begin_component = 0;
			audit_file_header.begin_index =
			   size (audit_file_header) * 4 + 7 - mod (size (audit_file_header) * 4 + 7, 8);
			audit_file_header.max_index = audit_file_header.audit_index;
			audit_file_header.max_component = audit_file_header.current_component;
			audit_file_header.filled = "0"b;
			blk.current_flags.file_limit = "0"b;
		       end;
		    else
		       do;
			p_code = error_table_$bad_mode_value;
			return;
		       end;

	         else
		  do;
		     records = mode_string_info.modes (mode_idx).numeric_value;
		     if records <= 0
		     then
		        do;
			 p_code = error_table_$bad_mode_value;
			 return;
		        end;
		     audit_file_header.max_component = divide (records, 256, 17, 0);
		     audit_file_header.max_index = 4096 * (records - audit_file_header.max_component * 256);
		     blk.current_flags.file_limit = "1"b;
		  end;

	    else if newmodes = "audit_output"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.current_flags.write_audit = mode_string_info.modes (mode_idx).flags.boolean_value;
	    else if newmodes = "audit_edit"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.current_flags.edit = mode_string_info.modes (mode_idx).flags.boolean_value;
	    else if newmodes = "audit_trace"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.current_flags.trace = mode_string_info.modes (mode_idx).flags.boolean_value;
	    else if newmodes = "audit_meter"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.current_flags.meter = mode_string_info.modes (mode_idx).flags.boolean_value;
	    else if newmodes = "audit_trigger"
	    then if ^mode_string_info.modes (mode_idx).flags.char_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.trigger = mode_string_info.modes (mode_idx).char_value;
	    else if newmodes = "audit_use_editor_prompt"
	    then if ^mode_string_info.modes (mode_idx).flags.boolean_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.current_flags.use_editor_prompt = mode_string_info.modes (mode_idx).flags.boolean_value;
	    else if newmodes = "audit_editor_prompt_string" | newmodes = "audit_epstr"
	    then if ^mode_string_info.modes (mode_idx).flags.char_valuep
	         then
		  do;
		     p_code = error_table_$bad_mode_syntax;
		     return;
		  end;
	         else blk.editor_prompt_string = mode_string_info.modes (mode_idx).char_value;
      end MODE_LOOP;
      call mode_string_$delete (mode_string_info_ptr, AUDIT_MODE_NAMES, unrecognized_modes, p_code);
      if unrecognized_modes ^= "" & unrecognized_modes ^= "."
      then
         do;

	  /*** It is necessary to convert ll=NN and pl=NN, which mode_string_ produces, 
into llNN and plNN, which is the only form the tty_ dim currently understands.
Hopefully, any other io module under audit_ which gets ll=  and pl= modes will
also understand the other forms.
*/
	  if index (unrecognized_modes, "ll=") > 0
	  then unrecognized_modes =
		before (rtrim (unrecognized_modes), "ll=") || "ll" || after (rtrim (unrecognized_modes), "ll=");
	  if index (unrecognized_modes, "pl=") > 0
	  then unrecognized_modes =
		before (rtrim (unrecognized_modes), "pl=") || "pl" || after (rtrim (unrecognized_modes), "pl=");

	  call iox_$modes (blk.auditing_iocb, (unrecognized_modes), p_oldmodes, p_code);
         end;

/**** vp: tr phx19369 , display old modes when input modes are only audit modes ****/

         else call iox_$modes (blk.auditing_iocb, "", p_oldmodes, p_code);

      return;



audit_get_line:
   entry (p_iocb_ptr, p_buff_ptr, p_buff_len, p_actual_len, p_code);
      dcl	    file_char_array	       (0:sys_info$max_seg_size * 4) char (1) based (buff_ptr);
      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = audited_iocb -> iocb.attach_data_ptr;
      auditing_iocb = blk.auditing_iocb;
      buff_ptr = p_buff_ptr;
      buff_len = p_buff_len;
GET_LINE:
      if blk.work_space ^= null
      then
         do;					/* set up input_string on temp_seg. */
	  buff_ptr = blk.work_space;
	  actual_len = blk.work_space_len;
	  buff_len = sys_info$max_seg_size * 4;		/* if input_string bigger than p_string, fill p_string and return long_record */
						/* if input_string smaller than p_string, fill p_string and return. */
	  if actual_len > p_buff_len
	  then
	     do;
	        p_actual_len = p_buff_len;
	        param_input_string = substr (aut_input_string, 1, p_buff_len);
	        blk.work_space = addr (file_char_array (p_buff_len));
	        blk.work_space_len = actual_len - p_buff_len;
	        p_code = error_table_$long_record;
	        return;
	     end;
	  else
	     do;
	        p_actual_len = actual_len;
	        param_input_string = aut_input_string;
	        blk.work_space = null;
	        blk.work_space_len = 0;
	        p_code = 0;
	        return;
	     end;
         end;

      else
         do;
	  call iox_$get_line (auditing_iocb, p_buff_ptr, p_buff_len, p_actual_len, p_code);
	  if p_code ^= 0
	  then if p_code = error_table_$long_record
	       then
		do;
		   blk.work_space = blk.temp_seg_ptr;
		   blk.work_space_len = sys_info$max_seg_size * 4;
		   buff_len = blk.work_space_len;
		   buff_ptr = blk.work_space;
		   actual_len = p_buff_len;
		   substr (aut_input_string, 1, actual_len) = substr (param_input_string, 1, p_actual_len);
		   buff_ptr = addr (file_char_array (actual_len));
		   buff_len = buff_len - actual_len;
		   call iox_$get_line (auditing_iocb, buff_ptr, buff_len, actual_len, p_code);
		   if p_code ^= 0
		   then return;
		   buff_ptr = blk.temp_seg_ptr;
		   actual_len = actual_len + p_actual_len;
		   buff_len = blk.work_space_len;
		   blk.work_space_len = actual_len;
		end;
	       else return;

	  else actual_len = p_actual_len;
MORE_GET_LINE:
	  if ^(blk.current_flags.edit & (actual_len > 2))
	  then
	     do;
	        if blk.current_flags.read_audit
	        then call audit_line ("IL", aut_input_string);
	     end;
	  else if (substr (aut_input_string, actual_len - 2, 1) = blk.trigger)
	  then
	     do;
	        request = substr (aut_input_string, actual_len - 1, 1);
	        if request = "."
	        then
		 do;
		    if blk.current_flags.read_audit & (blk.default_iocb ^= blk.auditing_iocb)
		    then call audit_line ("IL", aut_input_string);
		    call
		       ioa_$ioa_switch (blk.default_iocb, "audit ^[input^]^[/^]^[output^]",
		       blk.current_flags.read_audit, blk.current_flags.read_audit & blk.current_flags.write_audit,
		       blk.current_flags.write_audit);
		    substr (aut_input_string, 1, actual_len - 2) = substr (aut_input_string, 1, actual_len - 3) || NL;
		    actual_len = actual_len - 2;
		 end;
	        else if request = "?"
	        then
		 do;
		    if blk.current_flags.read_audit & (blk.default_iocb ^= blk.auditing_iocb)
		    then call audit_line ("IL", aut_input_string);
		    call ioa_$ioa_switch (blk.default_iocb, "REQUESTS:");
		    call ioa_$ioa_switch (blk.default_iocb, "^a. -> who am I", blk.trigger);
		    call ioa_$ioa_switch (blk.default_iocb, "^a? -> what can I do", blk.trigger);
		    call ioa_$ioa_switch (blk.default_iocb, "^ae -> enter editor", blk.trigger);
		    call
		       ioa_$ioa_switch (blk.default_iocb, "^aE -> enter editor, process input line as edit requests",
		       blk.trigger);
		    call ioa_$ioa_switch (blk.default_iocb, "^aa -> abbrev expand input line", blk.trigger);
		    call ioa_$ioa_switch (blk.default_iocb, "^ar -> replay input line", blk.trigger);
		    call
		       ioa_$ioa_switch (blk.default_iocb, "^at -> transparent input line (do not log)", blk.trigger);
		    call ioa_$ioa_switch (blk.default_iocb, "^ad -> delete line", blk.trigger);
		    call ioa_$ioa_switch (blk.default_iocb, "^an -> no operation", blk.trigger);
		    call
		       ioa_$ioa_switch (blk.default_iocb, "NOTE:  above requests recognized only in audit_edit mode");
		    substr (aut_input_string, 1, actual_len - 2) = substr (aut_input_string, 1, actual_len - 3) || NL;
		    actual_len = actual_len - 2;
		 end;
	        else if request = "r"
	        then
		 do;
		    call ioa_$ioa_switch_nnl (blk.default_iocb, "^a", substr (aut_input_string, 1, actual_len - 3));
		    call
		       iox_$get_line (auditing_iocb, addr (file_char_array (actual_len - 3)),
		       buff_len - actual_len + 3, tactual_len, p_code);
		    if p_code ^= 0
		    then if p_code ^= error_table_$long_record
		         then return;
		         else if blk.work_space ^= null
		         then return;
		         else
			  do;
			     blk.work_space = blk.temp_seg_ptr;
			     blk.work_space_len = sys_info$max_seg_size * 4;
			     buff_ptr = blk.temp_seg_ptr;
			     buff_len = blk.work_space_len;
			     actual_len = tactual_len + actual_len - 3;
			     substr (aut_input_string, 1, actual_len) = substr (param_input_string, 1, actual_len);

			     buff_ptr = addr (file_char_array (actual_len));
			     buff_len = buff_len - actual_len;
			     call iox_$get_line (default_iocb, buff_ptr, buff_len, tactual_len, p_code);
			     if p_code ^= 0
			     then return;
			     buff_ptr = blk.temp_seg_ptr;
			     buff_len = blk.work_space_len;
			     actual_len = actual_len + tactual_len;
			     blk.work_space_len = actual_len;
			  end;
		    else actual_len = actual_len + tactual_len - 3;
		    goto MORE_GET_LINE;
		 end;
	        else if request = "e" | request = "E"
	        then
		 do;
		    if blk.current_flags.read_audit & (blk.default_iocb ^= blk.auditing_iocb)
		    then call audit_line ("IL", aut_input_string);
		    blk.work_space = null;
		    call audit_editor (buff_ptr, buff_len, actual_len, audited_iocb, p_code);
		    if p_code ^= 0
		    then if p_code = error_table_$empty_file
		         then call ioa_$ioa_switch (blk.default_iocb, "audit_: Can't edit, the audit file is empty.");
		         else call ioa_$ioa_switch (blk.default_iocb, "audit_: Error attempting to use editor.");
		    else
		       do;
			set_last_return_line_position = "1"b;
			if blk.current_flags.read_audit
			then call audit_line ("EL", aut_input_string);
		       end;
		 end;
	        else if request = "a"
	        then
		 do;
		    if blk.current_flags.read_audit & (blk.default_iocb ^= blk.auditing_iocb)
		    then call audit_line ("IL", aut_input_string);
		    substr (aut_input_string, 1, actual_len - 2) = substr (aut_input_string, 1, actual_len - 3) || NL;
		    actual_len = actual_len - 2;
		    call abbrev_$expanded_line (buff_ptr, (actual_len), addr (ab_buf), 512, out_ptr, ab_len);
		    if ab_len > 512
		    then if ab_len > buff_len
		         then
			  do;
			     buff_ptr = blk.temp_seg_ptr;
			     buff_len = ab_len;
			     actual_len = ab_len;
			     buff_ptr -> aut_input_string = out_ptr -> aut_input_string;
			     free out_ptr -> aut_input_string;
			  end;
		         else
			  do;
			     buff_len = ab_len;
			     actual_len = ab_len;
			     buff_ptr -> aut_input_string = out_ptr -> aut_input_string;
			     free out_ptr -> aut_input_string;
			  end;
		    else if ab_len > buff_len
		    then
		       do;
			buff_ptr = blk.temp_seg_ptr;
			buff_len = ab_len;
			actual_len = ab_len;
			aut_input_string = substr (ab_buf, 1, ab_len);
		       end;
		    else
		       do;
			actual_len = ab_len;
			substr (aut_input_string, 1, ab_len) = substr (ab_buf, 1, ab_len);
		       end;
		 end;
	        else if request = "d"
	        then
		 do;
		    blk.work_space = null;
		    blk.work_space_len = 0;
		    buff_ptr = p_buff_ptr;
		    buff_len = p_buff_len;
		    actual_len = 0;
		    goto GET_LINE;
		 end;
	        else if request = "n"
	        then
		 do;
		    if blk.current_flags.read_audit & (blk.default_iocb ^= blk.auditing_iocb)
		    then call audit_line ("IL", aut_input_string);
		    actual_len = actual_len - 2;
		    substr (aut_input_string, actual_len, 1) = NL;
		 end;
	        else if request = "t"
	        then
		 do;
		    actual_len = actual_len - 2;
		    substr (aut_input_string, actual_len, 1) = NL;
		 end;
	        else if blk.current_flags.read_audit
	        then call audit_line ("IL", aut_input_string);
	     end;
	  else if blk.current_flags.read_audit
	  then call audit_line ("IL", aut_input_string);

	  if actual_len > p_buff_len
	  then
	     do;
	        p_actual_len = p_buff_len;
	        param_input_string = substr (aut_input_string, 1, p_buff_len);
	        blk.work_space = addr (file_char_array (p_buff_len));
	        blk.work_space_len = actual_len - p_buff_len;
	        p_code = error_table_$long_record;
	        return;
	     end;
	  else
	     do;
	        p_actual_len = actual_len;
	        param_input_string = substr (aut_input_string, 1, actual_len);
	        blk.work_space = null;
	        blk.work_space_len = 0;
	        p_code = 0;
	        return;
	     end;
	  p_code = 0;
	  return;
         end;


audit_put_chars:
   entry (p_iocb_ptr, p_buff_ptr, p_buff_len, p_code);
      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = audited_iocb -> iocb.attach_data_ptr;
      auditing_iocb = blk.auditing_iocb;
      call iox_$put_chars (auditing_iocb, p_buff_ptr, p_buff_len, p_code);
      if p_code ^= 0
      then return;
      if blk.current_flags.write_audit
      then call audit_line ("OC", param_output_string);
      p_code = 0;
      return;


audit_position:
   entry (p_iocb_ptr, ptype, n, p_code);
      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = audited_iocb -> iocb.attach_data_ptr;
      auditing_iocb = blk.auditing_iocb;
      call iox_$position (auditing_iocb, ptype, n, p_code);
      return;


audit_control:
   entry (p_iocb_ptr, p_real_order, p_info_ptr, p_code);

      audited_iocb = p_iocb_ptr -> iocb.actual_iocb_ptr;
      blkptr = audited_iocb -> iocb.attach_data_ptr;
      audit_file_header_ptr = blk.audit_file_header_ptr;
      if blk.current_flags.trace
      then call audit_line ("TC", p_real_order || NL);
      order = p_real_order;
      if substr (order, 1, 6) = "audit_"
      then
         do;
	  order = substr (order, 7);
	  if order = "truncate"
	  then
	     do;
	        audit_file_header.current_component = 0;
	        call
		 msf_manager_$adjust (blk.audit_fcb, 0,
		 ((4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8)) * 9, "110"b,
		 p_code);
	        call truncate_audit_file;
	        audit_file_header.begin_index = audit_file_header.audit_index;
	        audit_file_header.begin_component = 0;
	        audit_file_header.filled = "0"b;
	        blk.begin_ptr = blk.audit_ptr;
	     end;
	  else if order = "modes"
	  then
	     do;
	        p_info_ptr -> mode_str = mode_string (p_code);
	     end;
	  else
	     do;
	        call iox_$control (blk.auditing_iocb, p_real_order, p_info_ptr, p_code);
	        return;
	     end;
         end;
      else if order = "io_call"
      then if p_info_ptr -> io_call_info.order_name = "audit_modes"
	 then
	    do;
	       call p_info_ptr -> io_call_info.report ("audit modes: ^a", mode_string (p_code));
	       return;
	    end;
	 else
	    do;
	       call iox_$control (blk.auditing_iocb, p_real_order, p_info_ptr, p_code);
	       return;
	    end;
      else if order = "resetread" | order = "abort"
      then
         do;
	  blk.work_space = null;
	  blk.work_space_len = 0;
	  call iox_$control (blk.auditing_iocb, p_real_order, p_info_ptr, p_code);
	  return;
         end;
      else
         do;
	  call iox_$control (blk.auditing_iocb, p_real_order, p_info_ptr, p_code);
	  return;
         end;
      p_code = 0;
      return;

/*  */

audit_line:
   proc (p_tag, p_string);
      dcl	    1 position	       like position_template;
      dcl	    1 previous_position    like position_template;
      dcl	    1 position_info	       like position_info_template;
      dcl	    bytes_required	       fixed bin (24);
      dcl	    max_entry_size	       fixed bin (24);
      dcl	    room_for_insertion     fixed bin (24);
      dcl	    trim_entry	       bit (1) init ("0"b);
      dcl	    p_tag		       char (*);
      dcl	    p_string	       char (*);

      call hcs_$set_ips_mask (0, mask);

      on any_other
         begin;
	  call force_audit_suspension;
	  goto RETURN;
         end;

      audit_file_header_ptr = blk.audit_file_header_ptr;
      position.aep = null;
      bytes_required = length (p_string) + 7 - mod (length (p_string) + 7, 8) + (4 * size (audit_entry));

      call set_max_entry_size;
      if bytes_required > max_entry_size
      then
         do;
	  bytes_required = max_entry_size;
	  trim_entry = "1"b;
         end;

      call get_room_for_insertion;
      do while (bytes_required > room_for_insertion);
         call adjust_indices;
         call get_room_for_insertion;
      end;

      call set_position_info;

      call insert (p_tag, p_string);
      if set_last_return_line_position
      then
         do;
	  set_last_return_line_position = "0"b;
	  call audit_editor$set_last_return_line_position (addr (position));
         end;

RETURN:
      revert any_other;
      call hcs_$set_ips_mask (mask, 0);
      return;

set_max_entry_size:
   proc;
      if ^blk.current_flags.file_limit
      then max_entry_size = sys_info$max_seg_size * 4;
      else if audit_file_header.max_component > 1
      then max_entry_size = sys_info$max_seg_size * 4;
      else if audit_file_header.max_component = 1
      then max_entry_size =
	    max (audit_file_header.max_index,
	    sys_info$max_seg_size * 4
	    - ((4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8)));
      else max_entry_size =
	    audit_file_header.max_index
	    - ((4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8));
   end;

get_room_for_insertion:
   proc;
      if ^blk.current_flags.file_limit
      then room_for_insertion = sys_info$max_seg_size * 4 - audit_file_header.audit_index;
      else if (audit_file_header.begin_component = audit_file_header.current_component)
	    & (audit_file_header.begin_index >= audit_file_header.audit_index) & audit_file_header.filled
      then room_for_insertion = audit_file_header.begin_index - audit_file_header.audit_index;
      else if audit_file_header.current_component = audit_file_header.max_component
      then room_for_insertion = audit_file_header.max_index - audit_file_header.audit_index;
      else room_for_insertion = sys_info$max_seg_size * 4 - audit_file_header.audit_index;
   end;

adjust_indices:
   proc;
      if ^blk.current_flags.file_limit
      then call next_component (audit_file_header.current_component, audit_file_header.audit_index, blk.audit_ptr);
      else if audit_file_header.begin_component = audit_file_header.current_component
	    & audit_file_header.begin_index >= audit_file_header.audit_index & audit_file_header.filled
      then
         do;
	  position.aep = addr (blk.begin_ptr -> file_char_array (audit_file_header.begin_index));
	  call hcs_$status_mins (blk.begin_ptr, type, bit_count24, p_code);
	  if audit_file_header.begin_index + (4 * currentsize (position.aep -> audit_entry)) + 7
	     - mod ((4 * currentsize (position.aep -> audit_entry)) + 7, 8) >= divide (bit_count24, 9, 24, 0)
	  then call next_component (audit_file_header.begin_component, audit_file_header.begin_index, blk.begin_ptr);
	  else audit_file_header.begin_index =
		audit_file_header.begin_index + (4 * currentsize (position.aep -> audit_entry)) + 7
		- mod ((4 * currentsize (position.aep -> audit_entry)) + 7, 8);
         end;
      else call next_component (audit_file_header.current_component, audit_file_header.audit_index, blk.audit_ptr);
   end;

next_component:
   proc (p_component_number, p_component_index, p_component_ptr);
      dcl	    p_component_number     fixed bin (17);
      dcl	    p_component_index      fixed bin (24);
      dcl	    p_component_ptr	       ptr;

      call hcs_$set_bc_seg (blk.audit_ptr, audit_file_header.audit_index * 9, p_code);
      if p_component_number = audit_file_header.max_component & blk.current_flags.file_limit
      then
         do;
	  p_component_number = 0;
	  p_component_index = (4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8);
	  p_component_ptr = audit_file_header_ptr;
	  audit_file_header.filled = "1"b;
         end;
      else
         do;
	  p_component_number = p_component_number + 1;
	  if ^blk.current_flags.file_limit
	  then audit_file_header.max_component = p_component_number;
	  p_component_index = 0;
	  call msf_manager_$get_ptr (blk.audit_fcb, p_component_number, "1"b, p_component_ptr, bit_count24, p_code);
         end;
   end;

set_position_info:
   proc;
      position_info.last_entry_length = audit_file_header.last_entry_length;
      position_info.max_component = audit_file_header.max_component;
      position_info.max_index = audit_file_header.max_index;
      position_info.begin_component = audit_file_header.begin_component;
      position_info.begin_index = audit_file_header.begin_index;
      position_info.current_component = audit_file_header.current_component;
      position_info.audit_index = audit_file_header.audit_index;
      position_info.audit_fcb = blk.audit_fcb;
      position_info.audit_ptr = blk.audit_ptr;
      position_info.default_search_tag = "";
      position_info.any_tag = "1"b;
      position_info.dirname = blk.dirname;
      position_info.ename = blk.ename;
      position_info.file_limit = audit_file_header.filled;
      position.char_index = audit_file_header.audit_index;
      position.component_number = audit_file_header.current_component;
      position.component_ptr = blk.audit_ptr;
      if position.component_number = audit_file_header.max_component & blk.current_flags.file_limit
      then position.component_max_char_index = audit_file_header.max_index;
      else position.component_max_char_index = sys_info$max_seg_size * 4;
      position.search_tag = "";
      position.entry_number = 0;
   end;

insert:
   proc (p_tag, p_string);
      dcl	    p_string	       char (*);
      dcl	    p_tag		       char (*);
      dcl	    virtual_time	       fixed bin (71);
      dcl	    paging	       fixed bin;
      dcl	    dev_paging	       fixed bin;
      dcl	    month		       fixed bin;
      dcl	    day		       fixed bin;
      dcl	    year		       fixed bin;
      dcl	    dow		       fixed bin;
      dcl	    zone		       char (4) aligned;
      dcl	    file_char_array	       (0:sys_info$max_seg_size * 4) char (1) unaligned based (blk.audit_ptr);
      position.aep = addr (file_char_array (audit_file_header.audit_index));

      if blk.current_flags.meter
      then
         do;
	  call cpu_time_and_paging_ (paging, virtual_time, dev_paging);
	  previous_position = position;
	  call audit_file_position_$last (addr (previous_position), addr (position_info), p_code);
	  if p_code = 0
	  then
	     do;
	        previous_position.aep -> audit_entry.virtual_time = virtual_time - blk.virtual_time;
	        previous_position.aep -> audit_entry.paging = paging - blk.paging;
	     end;

	  call decode_clock_value_ (clock, day, month, year, position.aep -> audit_entry.time, dow, zone);
	  blk.virtual_time = virtual_time;
	  blk.paging = paging;
         end;
      else position.aep -> audit_entry.time = -1;

      position.aep -> audit_entry.last_entry_length = audit_file_header.last_entry_length;
      if trim_entry
      then p_string = substr (p_string, 1, bytes_required - (4 * size (position.aep -> audit_entry)));
      position.aep -> audit_entry.entry_length = length (p_string);
      position.aep -> audit_entry.tag = p_tag;
      position.aep -> audit_entry.string = p_string;
      position.aep -> audit_entry.virtual_time = -1;
      position.aep -> audit_entry.paging = -1;
      audit_file_header.last_entry_length = position.aep -> audit_entry.entry_length;
      audit_file_header.audit_index = audit_file_header.audit_index + 4 * currentsize (position.aep -> audit_entry);
      audit_file_header.audit_index = audit_file_header.audit_index + 7 - mod (audit_file_header.audit_index + 7, 8);
      if ^blk.current_flags.file_limit
      then audit_file_header.max_index = audit_file_header.audit_index;
      return;
   end;

   end audit_line;

/*  */

force_audit_suspension:
   proc;
      dcl	    1 info	       aligned,
%include cond_info;

      dcl	    find_condition_info_   entry (ptr, ptr, fixed bin (35));

      call find_condition_info_ (null (), addr (info), p_code);
      call suspend_auditing (info.condition_name, info.loc_ptr);
   end force_audit_suspension;

suspend_auditing:
   proc (condition, p_ptr);
      dcl	    condition	       char (32) varying;
      dcl	    p_ptr		       ptr;
      if blk.suspend
      then return;
      blk.suspend = "1"b;
      string (blk.saved_flags) = string (blk.current_flags);
      string (blk.current_flags) = "0"b;
      if condition ^= ""
      then call ioa_$ioa_switch (p_iocb_ptr, "audit_: ^a on audit file by ^p, auditing suspended.", condition, p_ptr);
      return;
   end suspend_auditing;

mode_string:
   proc (p_code) returns (char (512) varying);
      dcl	    p_code	       fixed bin (35);
      dcl	    modes		       char (512);
      dcl	    mode_idx	       fixed bin (17);

      audit_file_header_ptr = blk.audit_file_header_ptr;
      modes = "";
      number_of_modes = 10;
      alloc mode_string_info in (temp_area);
      mode_string_info.version = mode_string_info_version_2;
MODE_LOOP:
      do mode_idx = 1 to hbound (mode_string_info.modes, 1);
         mode_value_ptr = addr (mode_string_info.modes (mode_idx));
         mode_value.flags = "0"b;
         mode_value.boolean_value = "0"b;
         mode_value.char_value = "";
         mode_value.numeric_value = 0;
         goto MODE (mode_idx);

MODE (1):
         mode_value.mode_name = "audit_input";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = blk.current_flags.read_audit;
         goto NEXT_MODE;

MODE (2):
         mode_value.mode_name = "audit_output";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = blk.current_flags.write_audit;
         goto NEXT_MODE;

MODE (3):
         mode_value.mode_name = "audit_edit";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = blk.current_flags.edit;
         goto NEXT_MODE;

MODE (4):
         mode_value.mode_name = "audit_trace";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = blk.current_flags.trace;
         goto NEXT_MODE;

MODE (5):
         mode_value.mode_name = "audit_meter";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = blk.current_flags.meter;
         goto NEXT_MODE;

MODE (6):
         mode_value.mode_name = "audit_transparent";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = (blk.default_iocb = blk.auditing_iocb);
         goto NEXT_MODE;

MODE (7):
         mode_value.mode_name = "audit_trigger";
         mode_value.flags.char_valuep = "1"b;
         mode_value.char_value = blk.trigger;
         goto NEXT_MODE;

MODE (8):
         mode_value.mode_name = "audit_file_size";
         if blk.current_flags.file_limit
         then
	  do;
	     mode_value.flags.numeric_valuep = "1"b;
	     mode_value.numeric_value =
	        (audit_file_header.max_component * 256) + divide (audit_file_header.max_index, 4096, 17, 0);
	  end;
         else
	  do;
	     mode_value.flags.char_valuep = "1"b;
	     mode_value.char_value = "unlimited";
	  end;
         goto NEXT_MODE;

MODE (9):
         mode_value.mode_name = "audit_use_editor_prompt";
         mode_value.flags.boolean_valuep = "1"b;
         mode_value.boolean_value = blk.current_flags.use_editor_prompt;
         goto NEXT_MODE;

MODE (10):
         mode_value.mode_name = "audit_editor_prompt_string";
         mode_value.flags.char_valuep = "1"b;
         mode_value.char_value = blk.editor_prompt_string;
         goto NEXT_MODE;

NEXT_MODE:
      end MODE_LOOP;

      call mode_string_$combine (mode_string_info_ptr, null, modes, p_code);

      return (modes);

   end mode_string;

truncate_audit_file:
   proc;

/* This program always sets up afh and blk.audit_ptr for
   afh.current_component = 0.
*/

      audit_file_header_ptr = blk.audit_file_header_ptr;
      call msf_manager_$get_ptr (blk.audit_fcb, 0, "1"b, blk.audit_ptr, bit_count24, p_code);
      if p_code ^= 0
      then
         do;
	  call com_err_ (p_code, "audit_");
	  return;
         end;
      audit_file_header.audit_index = (4 * size (audit_file_header)) + 7 - mod ((4 * size (audit_file_header)) + 7, 8);
      audit_file_header.last_entry_length = impossible_audit_entry_length;
   end truncate_audit_file;

/*  */

%include audit_block;
%page;
%include audit_entry;
%page;
%include audit_file_header;
%page;
%include audit_position;
%page;
%include io_call_info;
%page;
%include iocb;
%page;
%include iox_dcls;
%page;
%include mode_string_info;
   end;
