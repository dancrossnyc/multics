/****^  HISTORY COMMENTS:
  1) change(2016-03-10,GDixon), approve(2016-10-13,MCR10014),
     audit(2016-10-13,Swenson), install(2016-10-13,MR12.6f-0002):
     Test program to declare/invoke other program entrypoints from the command line.
  2) change(2016-06-29,GDixon), approve(2016-10-13,MCR10014),
     audit(2016-10-13,Swenson), install(2016-10-13,MR12.6f-0002):
     Version 01.01 of the user interface for call.
  3) change(2016-12-19,GDixon), approve(2017-01-14,MCR10014),
     audit(2017-01-14,Swenson), install(2017-01-14,MR12.6f-0014):
     call version 01.04, supporting revisions to call_dtype_fcns.incl.pl1.
                                                   END HISTORY COMMENTS */


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* It would be nice to support:						        */
	/*  - complex data types.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

	

call:
     proc;
cl:  entry;

/* ------------------------------------ *
 * Usage
 * ------------------------------------ */
display_usage:
     proc;

     call ioa_ ("^(^a^)",
"Syntax as a command:
  call {global_opts} virtual_entry {arg_value_specifiers}

Syntax as an active function:
  [call {global_opts} virtual_entry {arg_value_specifiers}]",
          "

Arguments:
virtual_entry
  character representation of an external entrypoint to be invoked.
  Format of this string is described in: virtual_entries.gi.info",
          "
arg_value_specifier
  one or more strings and options defining an argument to be passed to
  the entrypoint.  See ""List of arg_value_specifiers"".",
          "


List of arg_value specifiers:
-input arg_value {arg_options},
   -in arg_value {arg_options},
    -i arg_value {arg_options},
       arg_value {arg_options}",
	"
  gives an initial value for an entrypoint input argument before the 
  call is made.  -input is the default if no direction option is 
  given with an arg_value.",
	"
-inout arg_value {arg_options},
   -io arg_value {arg_options}
  sets the initial value of an entrypoint input-output argument 
  before the call is made.  The argument value is displayed after
  the entrypoint returns.",
	"

-output {arg_options},
   -out {arg_options},
     -o {arg_options}
  no arg_value is provided; entrypoint argument value is displayed 
  after the entrypoint returns. ",
	"
-outignore {arg_options},
   -ignore {arg_options},
       -ig {arg_options} 
  argument value is not displayed after the entrypoint returns.",
	"


List of arg_options:
-id ID
  gives a PL/I identifier naming the argument.
-return, -ret
  return this argument when call is invoked as an active function.",
	"
-octal, -oc
  displays an octal representation of storage for the argument,
  as well as the character string interpretation.",
	"

-code, -cd 
  argument is a Multics status code.  For an input argument,
  arg_value is a string naming a status code value.", 
	"
-date_time,
   -date, -dt,
   -time, -tm
  argument is a Multics clock value (fixed bin(71) aligned).  For an
  input argument, arg_value is a string representation of a date or
  time value.  For an output argument, clock value is converted to",
	"
  default process date_time, date, or time format.",
	"

-declare DECLARATION,
    -dcl DECLARATION
  argument has the attributes given in DECLARATION.  A descriptor 
  with these attributes is passed with this argument.",
	"
-addr DECLARATION
  for a pointer argument, set its value to point to storage 
  described by the PL/I DECLARATION, which is a single string
  defining data type and length attributes (e.g., ""char(20)"").",
	"
  For an input argument, the arg_value initializes this storage.
  For an output argument, the addressed storage is displayed.",
	"

-max_length M, -ml M
  for a string or area parameter with star extents (e.g., char(*), 
  char(*) var, bit(*), bit(*) var, area(*)), M is the length in
  characters, bits or area words of the corresponding argument.",
	"
-length L, -ln L
-length ID, -ln ID
  for a string argument, L gives the length in characters or bits to
  be displayed upon return from the entrypoint.  The ID format gives
  the identifier of another argument whose output value specifies",
	"
  the display length.",
          "


List of global options:
-all, -a
  Display all arguments upon return from virtual_entry.
-octal, -oc
  Display all arguments with an octal representation of their 
  storage.", 
	"
-debug INT, -db INT
  Display debug information as calling the virtual_entry proceeds.
  An INT equaling 1 provides basic debugging data; 2, 3, 4, or 5
  provides more details.",
          "


Example:
initiate_file_ has the following PL/I calling sequence:

   call initiate_file_( dir, entry, access_mode, ptr, bit_count, code);

The display_entry_point_dcl (depd) command displays the parameter types:

   depd initiate_file_",
          "
     dcl initiate_file_ entry(char(*), char(*), bit(*), ptr,
           fixed bin(24), fixed bin(35));

Invoke initiate_file_, specifying an initial value for each parameter:

   call initiate_file_ [wd]  my_file  100  -o  -o  -o -cd");
     call ioa_ ("^/^4-version:^-^a", CALL_VERSION);
     
     end display_usage;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Include file containing constants referenced in other static declarations below.  PL/I	        */
	/* requires such constants to appear in program source before these references.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

%include std_descriptor_types;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Main control flow of the call program.  Look for the following major tasks performed by the    */
	/* code below:								        */
	/*  1) Determine whether call was invoked as a command or active function (AF).		        */
	/*  2) Look for first positional argument to call, which names the virtual_entry (a subroutine    */
	/*     or function) to be called.  While accessing this first positional argument, global	        */
	/*     options may also be read.						        */
	/*  3) Convert the virtual entry to basic information about the routine to be called:             */
	/*      A) a PL/I entry variable corresponding to the virtual entry;			        */
	/*      B) entrypoint attributes:						        */
	/* 	  - subroutine or function						        */
	/*          - fixed parameter list or options(variable)				        */
	/*      C) for entrypoint with a fixed parameter list:				        */
	/*          - count of parameters						        */
	/*          - for each parameter: data type, alignment, and aggregate information	        */
	/*     The call_entry_info_ subroutine performs this task.  This routine also creates a	        */
	/*     translator_temp_ storage area, which call uses for most of its dynamic storage.	        */
	/*      - For an options(variable) entrypoint, entrypoint parameter information (C above) is not  */
	/*        available.							        */
	/*         - There is no information about parameter count or data types.		        */
	/*         - Such entrypoint must therefore be a subroutine; it cannot be a function, because     */
	/*           there are no parameter descriptors which could describe a returns attribute.	        */
	/*         - The call user must provide arg_value_specifications to indicate count of arguments   */
	/*           to be passed to the entrypoint in the arg_list.                                      */
	/*         - Each passed argument has data type: char(*) unaligned, unless its corresponding      */
	/*           arg_value_specification includes -dcl DECLARATION or -addr DECLARATION to specify a  */
	/*	   different data type.						        */
	/*         - call must pre-count the arg_value_specifications to get a subroutine argument count. */
	/*  4) Knowing the count of parameters declared for the target entry, or number of	        */
          /*     arg_value_specifications provided by the user for an options(variable) subroutine,         */
	/*     allocate array storage holding:						        */
	/*      - information about each parameter of the target entry;			        */
	/*      - information about each positional argument to call that corresponds to a parameter; and */
	/*      - space for the arg_list call must produce in order to call the target entry.	        */
	/*  5) Initialize the arg_list header, including argument counts.			        */
	/*  6) Expand information about each target parameter (coming from the actual parameter	        */
	/*     descriptors, or from the user's -dcl or -addr DECLARATIONs).                               */
	/*      - Information from each descriptor is stored in the t array of target structures.	        */
	/*  7) Loop through call's remaining arguments, looking for arg_value_specification info:	        */
	/*      - a direction option for each argument;					        */
	/*      - an initial value for an input argument; 				        */
	/*      - options specifying alternate data type for the argument, or actual argument size for    */
	/*        arguments passed to parameter having star extents; and			        */
	/*      - information about how to display an output argument.                                    */
	/*     Information for each arg_value_specification is stored in the s array of source structures.*/
	/*  8) Loop through the target parameters, allocating and initializing storage for each           */
	/*     corresponding argument.						        */
	/*      - All arguments are stored in the translator_temp_ storage area (step 3 above).	        */
	/*         - Exception: returns(char(*)... ) or returns(bit(*)...) return values get appended to  */
	/*	   call's stack frame by the called routine.  No storage is created for such return     */
	/*	   values before the routine is invoked.				        */
	/*      - A pointer to each argument's storage location goes into arg_list.arg_ptr(parmI).        */
	/*         - Exception: for returns(...(*)...), arg_list.arg_ptr(parmI) points to a storage       */
	/*	   location which the called routine fills in with a pointer to the return value that   */
	/*           it appends to call's stack frame.					        */
	/*      - A pointer to the (perhaps modified) target descriptor for parameter the goes into       */
	/*	arg_list.desc_ptr(parmI).						        */
	/*         - Exception: for returns(...(*)...), arg_list.desc_ptr(parmI) points to storage for    */
	/*	   an empty descriptor, which the called routine fills in with type/length of the       */
	/*	   returned string.							        */
	/*  9) Generate the call to the target entry, with our arg_list locating/describing its	        */
	/*     the arguments.							        */
	/* 10) After the target entry returns to call, display any output arguments to the user; or       */
	/*     return one of them as call's AF return string.  This involves:			        */
	/*      - Capturing data for returns(char(*)) or returns(bit(*)) functions that was appended to   */
	/*        call's stack when the target function returned.				        */
	/*      - Converting each parameter to be returned into a character string (or other requested    */
	/*	format) that is meaningful to (or requested by) the user.			        */
	/*									        */
	/* Please look for these major tasks, which are identified by TASK n in the comments below.       */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
%page;

/* ----------------------------------------- *
 * Declarations used throughout the program. *
 * ----------------------------------------- */

  dcl  CALL_VERSION char(20) varying int static options(constant) init("call.01.04");
  dcl (F init("0"b), T init("1"b)) bit(1) aligned int static options(constant);

  dcl  MaxLineLen fixed bin int static options(constant) init(80);
  dcl  NEG_SIGN_BITS bit(72) aligned int static options(constant) init((72)"1"b);
  dcl  NL char(1) int static options(constant) init("
");
  dcl  NULL_POINTER char(4) int static options(constant) init("-1|1");
  dcl  PROC char (4) int static options (constant) init ("call");
  dcl  ZEROb bit(1) int static options(constant) init("0"b);

  dcl (call_et_$array_unsupported,
       call_et_$bad_declaration,
       call_et_$dtype_unsupported,
       call_et_$no_entrypoint_info,
       call_et_$overflow_error,
       call_et_$parameter_type_unsupported,
       call_et_$star_extent_unresolved,
       call_et_$structure_unsupported,
       call_et_$underflow_error,
       error_table_$bad_arg,
       error_table_$bad_conversion,
       error_table_$bad_index,
       error_table_$badopt,
       error_table_$bigarg,
       error_table_$fatal_error,
       error_table_$inconsistent,
       error_table_$noarg,
       error_table_$no_r_permission,
       error_table_$not_act_fnc,
       error_table_$oldnamerr,
       error_table_$size_error,
       error_table_$smallarg,
       error_table_$too_many_args) fixed bin (35) ext static;

  dcl  assign_ entry (ptr, fixed bin, fixed bin(35), ptr, fixed bin, fixed bin(35));
  dcl  ioa_ entry () options (variable);
  dcl  ioa_$nnl entry () options (variable);
  dcl  ioa_$rsnnl entry() options(variable);

  dcl (addr, addrel, after, before, binary, char, codeptr, copy, divide, environmentptr,
       hbound, index, lbound, length, ltrim, maxlength, min, mod, null,
       reverse, rtrim, size, substr, unspec) builtin;

  dcl cleanup condition;
%page;

/* --------------------------------------------------------------------- *
 * TASK 1) Is call being invoked as a command or an active function?     *
 *         Display a usage message, if invoked with no arguments.	   *
 * --------------------------------------------------------------------- */

     entry_info_ptr = null;				/* Initialize cleanup-related variable referenced at      */
						/*  EXIT_call label (far below).		        */
						/*  This variable declared in: call_entry_info_.incl.pl1  */

  dcl  command bit (1) aligned;                             /* =T:  call invoked as a  command;		        */
						/* =F:  call invoked as an active function (AF)	        */
  dcl  af_retL fixed bin (21);
  dcl  af_retP ptr;
  dcl  af_ret char (af_retL) varying based(af_retP);	/* When called as active function, this is return value.  */

  dcl  gripe entry variable options(variable);		/* Either: com_err_ or active_fnc_err_		        */
  dcl  code fixed bin (35);

  dcl  cu_$arg_list_ptr entry() returns (ptr);		/* Internal procedure implements body of Task 1, as part  */
						/*  of the general arg processing mechanism used by call. */
     call argSetup( cu_$arg_list_ptr(), command, af_retP, af_retL, gripe);

     if ^argsRemain() then do;			/* If virtualEntry not given, just display usage message. */
	call display_usage();
	go to EXIT_call;
	end;

/* ------------------------------------------------------------------ *
 * TASK 2)						*
 * First positional argument gives virtualEntry to be called.	*
 *  - Global options may also be set at this time with certainty.     *
 *  NB: Some positional arguments may never be processed, if more are *
 *      given than correspond to parameters declared for virtualEntry.*
 * ------------------------------------------------------------------ */

  dcl 1 globalOpt aligned,                                  /* Structure to hold global options.		        */
      2 debug fixed bin(3) unsigned init(0),		/*  -debug: print debug info as call args are processed.  */
						/*   Accepts values: 0 - 5			        */
      2 xtra fixed bin(2);				/*  -all or -octal (given after virtualEntry)	        */
						/*   Output all arguments with octal representation.      */

  dcl 1 veArg aligned like source;			/* Structure to hold virtual_entry information.  It uses  */
						/*  just a part of the more general 'source' struct, in   */
  dcl  virtualEntry char (veArg.argL) based (veArg.argP);	/*  which each arg_value_specification data is kept.      */
						/*  That structure is declared below (in Task 4).	        */

     unspec(veArg) = ZEROb;				/* Initialize arg_value_specification data	        */
     veArg.argP = null();
     veArg.M, veArg.L, veArg.L_idX = Lunset;
     veArg.id = "virtual_entry";

     call argValue (0, veArg, globalOpt, code);		/* Get first positional_arg, describing virtualEntry.     */
     if code ^= 0 then do;
	call gripe (code, PROC, "Failed to get virtual_entry to be called.");
          return;
	end;

     globalOpt.xtra = veArg.xtra;			/* Copy positional -all or -octal option to globalOpt.    */
%page;
/* ----------------------------------------------------------------------- *
 * TASK 3) Convert virtualEntry to an entry variable.		     *
 * Get:							     *
 *  1) Subroutine/function flag;				     *
 *  2) Parameter count from calling sequence information;		     *
 *  3) Pointer to each parameter descriptor.			     *
 *  4) Entry variable for entrypoint to be called.		     *
 *  5) Pointer to our (translator_temp_-style) allocation area.            *
 * ----------------------------------------------------------------------- */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 3 begins...");

  dcl 1 ei aligned like entry_info_header based(entry_info_ptr);
						/* Structure to hold general entrypoint info.	        */

  dcl  entry_description char(2000) varying;		/* String to hold a complete description of virtualEntry  */
						/*  for display purposes, and perhaps as source from      */
						/*  which to fabricate entry descriptors.	        */
  dcl  entry_annotation char(100) var;			/* Details found by get_entry_point_dcl_$emacs.	        */

  dcl  get_entry_point_dcl_$emacs entry (char(*), fixed bin, fixed bin, char(*) var, char(32) var, char(100) var);

						/* Check whether entrypoint comes from PL/I generated     */
						/*  entry sequence and parameter descriptors; or from     */
						/*  a declaration string (in >sss>pl1.dcl, or user's      */
						/*  XXX_pl1.dcl file).			        */
     call get_entry_point_dcl_$emacs (virtualEntry, 0, 0, entry_description, "", entry_annotation);
     if entry_description = "" then do;			/* Out-of-luck if this routine fails to return anything.  */
	call gripe (call_et_$no_entrypoint_info, PROC, "(^a) ^a", entry_annotation, virtualEntry);
	go to EXIT_call;
	end;

     on cleanup begin;				/* Release storage created by call_entry_info_$from_XXX.  */
	call call_entry_info_$cleanup(entry_info_ptr);	/*  This is mostly our (translator_temp_-style) area.     */
	end;					/*  NB: entry_point_info was initialized in Task 1 above. */

     if entry_annotation = "dcl via parm descriptors" | entry_annotation = "abbrev" then do;
						/* Try to get the parm descriptors ourself, directly from */
						/*  the object segment's entrypoint parameter list.       */
						/*  "abbrev" annotation means entrypoint was not found in */
						/*  declare search paths (>sss>pl1.dcl, or user's .dcl)   */
	call call_entry_info_$from_virtual_entry (PROC, virtualEntry, 
	     globalOpt.debug, entry_info_ptr, code);
	if code ^= 0 then do;			/* Error, if virtualEntry could not be converted directly,*/
						/*  or no entry calling sequence was found.	        */
	     call gripe(code, PROC, "Getting entry parameter descriptors for virtual_entry ^a", virtualEntry);
	     go to EXIT_call;
	     end;
	end;
     
     else do;					/* get_entry_point_dcl_ returned declaration as a string. */
						/* Convert that string to an entrypoint parameter list.   */
	entry_description = "dcl " || 
	     reverse (before (reverse (virtualEntry), ">")) || " " || entry_description || ";";

	call call_entry_info_$from_declaration (PROC, virtualEntry, entry_description, 
	     globalOpt.debug, entry_info_ptr, code);
	if code ^= 0 then do;
	     call gripe(code, PROC, "Calling call_entry_info_$from_declaration.");
	     go to EXIT_call;
	     end;
	end;

     if ei.parm_count <= eiParmCountNotDetermined then do;	/* Be sure something gets reported to user if cannot get  */
						/*  entrypoint calling sequence.  Above calls to	        */
						/*  call_entry_info_$from_XXX should have returned a code */
						/*  in such cases.				        */
	call gripe(call_et_$no_entrypoint_info, PROC, "Could not determine parameter count from entry sequence.");
	go to EXIT_call;
	end;

     if ei.options_variable then do;			/* An options(variable) entrypoint is NEVER a function,   */
						/*  because it does not have a PL/I-defined calling       */
						/*  sequence that includes a <returns descriptor>, or     */
						/*  any <parameter descriptor>s.		        */
	call argValueGetCount(globalOpt.debug);		/*   - Allow our user to specify how many arguments to    */
	ei.parm_count = argValueCount;		/*     pass to the entrypoint.		        */
	end;
%page;
/* --------------------------------------------------------------------------- *
 * TASK 4) Declare data structures describing:			         *
 *  source:						         *
 *    Each describes an arg_value_specification in the call command line that  *
 *    corresponds to one of the arguments to be passed to the virtualEntry.    *
 *  target:						         *
 *    Each describes attributes of a parameter in the virtualEntry calling     *
 *    sequence; for an options(variable) entrypoint, each describes argument   *
 *    data attributes derived from corresponding arg_value_specification info. *
 * --------------------------------------------------------------------------- */

  dcl 1 source structure aligned based,                     /* Argument passed to call by command processor.	        */
      2 argP ptr,                                           /*  - ptr to the call argument for initial value.         */
      2 argL fixed bin(21),				/*  - length of call argument for initial value.	        */
      2 argOpt,					/*  Per-arg_value options:			        */
        3 dir fixed bin(3),				/*  -in, -inout, -out, -ig			        */
        3 ret bit (1),				/*  -return given (identifies call AF return value)       */
        3 fmt  fixed bin(3),				/*  -code, -date, -time, -date_time		        */
        3 xtra fixed bin(2),				/*  -octal (given with -inout or -out)		        */
        3 meta fixed bin(2),				/*  -dcl, -addr				        */
        3 dcl char(100) var,				/*  -dcl  DECLARATION 			        */
						/*  -addr DECLARATION given for a ptr arg_value	        */
        3 id char(20) var,				/*  -id ID				        */
        3 M fixed bin(24),				/*  -max_length M  given for a string/area arg_value      */
        3 L fixed bin(24),				/*  -length L     given for a string arg_value	        */
        3 L_id char(20) var,				/*  -length ID    given for a string arg_value	        */
      2 ad,					/*  -addr DECLARATION mapped to a descriptor.	        */
        3 desc like target.desc aligned,
        3 given bit(1) aligned,
        3 M_id char(20) var,				/*  -addr "char(M_id)" given for string/area arg_value    */
						/*   where M_id names another source.id which is a        */
						/*   input fixed-point size parameter.  That input value  */
						/*   is assigned to source.M.			        */
      2 argXref,					/* source(parmI) whose .id matches our source.L_id:       */
        3 L_idX fixed bin,				/*   s(source.L_idX).id = source.L_id		        */
        3 pad fixed bin;				/* Fill structure to even-word boundary.	        */

  dcl (DIRunset init(0), DIRin init(1), DIRinout init(2), DIRout init(3), DIRignore init(4)) 
       fixed bin(3) int static options(constant);
  dcl 1 DIR int static options(constant),
      2 name (0:4) char(10) var  init("", "-input", "-inout", "-output", "-outignore" ),
      2 abbr (0:4) char( 7) var  init("", "-in",    "-io",    "-out",    "-ignore"    ),
      2 tiny (0:4) char( 3) var  init("", "-i",     "",       "-o",      "-ig"        );

  dcl (FMTunset init(0),  FMTcode init(1), FMTdate init(2), FMTtime init(3), FMTdate_time init(4))
      fixed bin(3) int static options(constant);
  dcl 1 FMT int static options(constant),
      2 name (0:4) char(10) var init("", "-code", "-date", "-time", "-date_time"),
      2 abbr (0:4) char(5)  var init("", "-cd",   "-dt",   "-tm",   ""),
      2 kywd (0:4) char(9)      init("", "",      "date",  "time",  "date_time");

  dcl (METAunset init(0), METAdcl init(1), METAaddr init(2))
      fixed bin(2) int static options(constant);
  dcl 1 META int static options(constant),
      2 name (0:2) char(5) var  init("", "-dcl",     "-addr"),
      2 abbr (0:2) char(8) var  init("", "-declare", "");
						/* -declare is longer than -dcl, but less often used.     */

  dcl (XTRAunset init(0), XTRAall init(1), XTRAoctal init(2)) fixed bin(2) int static options(constant);
  dcl 1 XTRA int static options(constant),
      2 name (0:2) char(8) var  init("", "-all", "-octal"),
      2 abbr (0:2) char(8) var  init("", "-a",   "-oc");

  dcl  Lunset   init(-1)				fixed bin(24) int static options(constant);
%page;
  dcl 1 target structure aligned based,                     /* Each parameter of virtualEntry is described by this    */
						/*  structure.  Info comes from a descriptor found in one */
						/*  of three ways:	       			        */
						/*   - call_entry_info_$from_virtual_entry provides a     */
						/*     descriptor from calling sequence of virtualEntry;  */
						/*   - call_entry_info_$from_declaration produces a       */
						/*     descriptor from declaration's <parameter-set>s.    */
						/*   - for options(variable) entrypoint, arg_value_spec   */
						/*     provides info to create an argument <descriptor>.  */
      2 descP ptr,                                          /* ptr to calling seq parameter descriptor.	        */
      2 desc,                                               /* descriptor components (most from decode_descriptor_):  */
        3 fcnReturnValue bit(1) aligned,		/*   - On for last target, if ei.function is TRUE.        */
        3 type fixed bin,                                   /*   - type (see: std_descriptor_types.incl.pl1)	        */
        3 aligned bit(1) aligned,                           /*   - alignment (^packed)			        */
        3 size fixed bin(24),                               /*   - precision or size			        */
        3 scale fixed bin,                                  /*   - scale (for fixed-point numbers)		        */
        3 dimensionsCount fixed bin,                        /*   - number of dimension descriptors following the      */
                                                            /*     parameter descriptor.			        */
                                                            /*      =N means parm is an array with N dimensions.      */
                                                            /*      =0 means parm is a scalar.		        */
      2 dcl char(100) var,				/* descP converted to PL/I attributes.		        */
      2 storage,					/* 					        */
        3 case fixed bin,				/* See CASEname and argCase below for possible values.    */
        3 wordCount fixed bin(24),			/* Words needed to store this parameter.	        */
        3 P ptr,                                            /* Location of allocated storage for this target.	        */
        3 modifiedDesc aligned like arg_descriptor,         /* Storage to hold replacement descriptor with actual     */
                                                            /*  size of parm with star extents (char/bit/area).       */
        3 dcl_desc_bv bit(36) aligned;			/* arg_descriptor generated by -dcl DECLARATION	        */

  dcl (CASEnumeric init(1), CASEpointer init(2), CASEentry       init(3), 
       CASEarea    init(4), CASEstring  init(5), CASEreturnsStar init(6))
           fixed bin int static options(constant);
  dcl  CASEname (6) init("numeric", "pointer", "entry", "area", "string", "returns_star") char(20) var;

  dcl  SizeStar fixed bin (24) int static options (constant) init (16777215);  /* = "77777777"b3  */
                                                            /* size value in descriptor for parm with star extents    */
						/*   (bit/char/area parameter).		        */


argCase:						/* Classify target.desc.type in one of five CASE groups.  */
     proc (dtype) returns (fixed bin(3) unsigned);	/*  (returns char(*)... or returns(bit(*)... decision     */
						/*   is made in the argAssign(...) subroutine.)	        */
  dcl  dtype fixed bin;
     
     if      numeric_dtype(dtype)    then return(CASEnumeric);
     else if string_dtype(dtype)     then return(CASEstring);
     else if (dtype = pointer_dtype) then return(CASEpointer);
     else if (dtype = entry_dtype)   then return(CASEentry);
     else if (dtype = area_dtype)    then return(CASEarea); /* call makes many decisions based upon groups of         */
						/*  descriptor types.  Functions defining these groups    */
						/*  are in call_dtype_fcns.incl.pl1		        */

     else return(0);
     
     end argCase;
%page;
/* ---------------------------------------------------------------------------------------------------------------------- *
 * Notes on CASEreturnsStar:
           [Information gathered from examining PL/I compiler-generated calls to returns(char(*)) functions.]
 *  Functions with returns(char(*)) and returns(char(*) varying) are special cases in the call/return mechanism, 
 *  because the caller has no idea how much storage will be needed to hold the actual returned values; only the 
 *  called routine (the callee) knows.  
 *  Same special handling is needed for returns(bit(*)) and returns(bit(*) varying) strings.
 *    NB: Mechanism is the same for return values that are aligned or unaligned.  The value always ends up 
 *        aligned on word boundary.
 *
 *  A standard argument list (which is prepared by the caller when calling any subroutine or function) has the
 *  features described below.
 *   - Assume C is called entrypoint's parameter count.  For a function, this count includes the return value.
	argListP -> 2 header,
		    3 arg_count fixed bin(17) unsigned unal init(C),
		    ...
		    3 desc_count fixed bin(17) unsigned unal init(C),
		    ...
		  2 parmP (C) ptr,
		  2 descP (C) ptr;
 *  So for a function, the Cth parameter is the function return value.  
 *
 *  BEFORE calling a function having one of the returns(xxx(*)...) values:
 *   - The caller provides storage in his stack frame for two temporary variables (fabricated by PL/I compiler):
 *      - rvP, an aligned pointer which the callee will set to location of the actual function return value.
 *             The storage holding rvP is usually unset, but may be set to a null() value.
 *      - rv_desc, an argument descriptor which the callee sets to describe the actual length of the return value.
 *             The storage holding rv_desc is usually unset, but may be unspec(rv_desc)="0"b before the call.
 *   - The caller then constructs the argument list used to invoke the function.  For the return value, the caller sets:
         argListP -> parmP(C) = addr(rvP)  
         argListP -> descP(C) = addr(rv_desc)
 *   - The call command (this program) must actually declare storage locations to hold the rvP and rv_desc values.
 *      - rvP is stored in target.storage.P
 *      - rv_desc is stored in target.storage.modifiedDesc
 *
 *  DURING the call, the callee provides its own space to hold storage for its return value.  Either 
 *  the callee calculates how much space is needed, and allocates just that amount.  Or perhaps the callee declares a
 *  an extra-large variable; but wants to return only the space actually used within that variable.  In either case,
 *  the actual value to be returned is referred to as actual_return_value in the next paragraphs.
 *
 *  RETURNING to the caller, the callee:
     - extends the caller's stack, adding enough storage to hold the actual_return_value;
     - copies the actual_return_value to this storage location (at end of the caller's stack).  This overwrites data 
       formerly in the callee's stack; but since the callee is about to return, this data is no longer needed.
     - sets information in the caller-supplied argument list for the location and size of the actual_return_value:
        case: when actual_return_value is char(*); or
        case: when actual_return_value is bit(*):
          argListP -> parmP(C) -> rvP = addr(actual_return_value);
          argListP -> descP(C) -> rv_desc = descriptor_with(type(actual_return_value), length(actual_return_value))
 *
        case: when actual_return_value is char(*) varying; or
        case: when actual_return_value is bit(*)  varying:
          argListP -> parmP(C) -> rvP = addrel(addr(actual_return_value),+1);  
			[that is, rvP points after length word of varying string, at start of string chars/bits]
          argListP -> descP(C) -> rv_desc = descriptor_with(type(actual_return_value), maxlength(actual_return_value))
       Remember that rvP and rv_desc are variables created/known by the caller, and located in the caller's stack frame.

     NB: if rv_desc.flag = "1"b, then rv_desc.size is fixed bin(24) unsigned; else rv_desc.size is fixed bin(12) unsigned.
 *
 *  AFTER the call, the caller uses rvP and rv_desc to access the actual_return_value, either:
 *   - assigning it to a local variable known to the caller program; or
 *   - passing it as an argument to some other subroutine; etc.
 *  The call command (this program) uses rvP and rv_desc to display/return this actual_return_value.
 * ---------------------------------------------------------------------------------------------------------------------- */
%page;
/* -------------------------------------------------------------------- *
 * TASK 4) continues:					  *
 * Allocate adjustable-size arrays of the above structures, one element *
 * for each parameter defined by the entrypoint's calling sequence.     *
 *  NB: For an entrypoint having no parameters, and when user gave no   *
 *      arg_value_specifications, these ARRAYS ARE NOT ALLOCATED.       *
 * -------------------------------------------------------------------- */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 4 begins...");

  dcl (lP, sP, tP) ptr init(null);
  dcl 1 s (ei.parm_count) aligned like source based(sP);	/* Source elements: one for each argument to be passed.   */

  dcl 1 t (ei.parm_count) aligned like target based(tP);	/* Target elements: one for each entrypoint parameter, or */
						/*   arg_value_specification.			        */

  dcl 1 l aligned based(lP),				/* Standard Multics arg_list.			        */
      2 header like arg_list.header,
      2 argP  (ei.parm_count) ptr,			/*  - argP  for each parameter passed to virtualEntry     */
      2 descP (ei.parm_count) ptr;			/*  - descP for each parameter passed to virtualEntry     */

  dcl 1 auto_l aligned automatic,			/* Use this arg_list stub when no arguments are passed.   */
      2 header like arg_list.header;

  dcl  parmI fixed bin;                                     /* Index for selecting elements from structures above.    */
  dcl  refI fixed bin;

  dcl  areaP ptr;					/* Allocation area provided by call_entry_info_$from_XXX  */
     areaP = ei.areaP;

     if ei.parm_count > 0 then do;			/* Allocate structure arrays, and arg_list.	        */
	sP = allocate(areaP, size(s));		/*  allocate routine in: translator_temp_alloc.incl.pl1   */
	tP = allocate(areaP, size(t));
	lP = allocate(areaP, size(l));
	end;
     else lP = addr(auto_l);				/*  - Use arg_list header, if no parameters needed.       */


/* ----------------------------------------------------------------- *
 * TASK 5) Initialize arg_list to be used in calling the subroutine. *
 * ----------------------------------------------------------------- */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 5 begins...");
     
     unspec(l) = ZEROb;				/* Not initializing pad bits in l can cause erroneous     */
						/*  gate_error condition: Wrong number of arguments given.*/
     l.call_type = Interseg_call_type;			/* Initialize argument list type.		        */
     l.arg_count  = ei.parm_count;			/* Set counts in header.			        */
     l.desc_count = ei.parm_count;

%page;
/* ----------------------------------------------------------------- *
 * TASK 6) Examine entrypoint calling sequence information.	         *
 *  - Get a PL/I declare statement for each parameter.	         *
 * ----------------------------------------------------------------- */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 6 begins...");
						/* Default descriptor for options(variable) arguments.    */
  dcl 1 charStarUnal_Descriptor aligned int static options(constant),
      2 flag	      bit (1) unal init(T),
      2 type	      fixed bin (6) unsigned unal init(char_dtype),
      2 packed	      bit (1) unal init(T),
      2 number_dims	      fixed bin (4) unsigned unal init(0),
      2 size	      fixed bin (24) unsigned unal init(SizeStar);

     if tP ^= null then do;
	unspec(t) = ZEROb;				/* Initialize t array of target structure elements.       */

	if ^ei.options_variable then do;		/* For non-options(variable) entrypoint:	        */
	     t(*).descP = entry_info.descriptor_ptrs(*);	/*  - Store ptr to each entry parameter descriptor in t.  */
						/*    These were provided by call_entry_info_$from_XXX.   */

	     if globalOpt.debug >= 3 then call ioa_("");	/* Put blank line before parameter desc debug output.     */

	     do parmI = lbound(t,1) to hbound(t,1);	/* Decode parameter descriptor data for each target elem. */
		call get_entry_parm_info(parmI, ei, t(parmI), globalOpt.debug);
		end;
	     end;
	else do;					/* For options(variable) subroutine:		        */
	     t(*).descP = addr(charStarUnal_Descriptor);	/*  - assume all parameters are: char(*) unaligned.  This */
	     t(*).desc.type = char_dtype;		/*    assumption may be overridden, as arguments to call  */
	     t(*).desc.size = SizeStar;		/*    are processed.			        */
	     t(*).dcl = "char(*)";
	     end;
	end;
%page;
/* --------------------------------------------------------------------------- *
 * TASK 7)						         *
 * Loop through arguments to call; look for arg_value_specification info.      *
 * Each specifies a DIRxxx value, and perhaps an initial value, for its        *
 * corresponding argument passed to an entrypoint parameter.	         *
 *  - Info about each arg_value is stored in a source structure.               *
 *  - Any per-parameter option following the parameter is stored in	         *
 *    source.aOpt substructure.				         *
 *  - Any options(variable) parameter info (-dcl DECLARATION) is stored in     *
 *    a t structure array element.				         *
 * --------------------------------------------------------------------------- */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 7 begins...");
     
  dcl 1 src  aligned like source based(addr(s(parmI)));	/* Create a short name for s(parmI) structure element.    */
  dcl 1 targ aligned like target based(addr(t(parmI)));	/* Create a short name for t(parmI) structure element.    */

     if sP ^= null then
HAVE_ARGUMENTS:
     do;
	unspec(s) = ZEROb;				/* Initialize arg_value_specification data	        */
	s(*).argP = null();
	s(*).M, s(*).L, s(*).L_idX = Lunset;

ARG_VALUES_LOOP:				
	do parmI = lbound(s,1) to hbound(s,1);		/* Try to get arg_value_specification for each argument.  */

	     if ei.function & (parmI = ei.parm_count) then
		src.id = "retValue";		/* Assign a default value for source.id		        */
	     else src.id = "parm" || int2digits(parmI);


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Note:  It's OK for a function return value to not have a corresponding arg_value spec.  If it  */
	/* has one, it might include: an -out direction or -return option, and -octal format, or even an  */
	/* -addr DECLARATION, telling call how to format data pointed to by a return pointer.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

	     if argsRemain() then			/* Try only as long as more arguments to call remain      */
ARGS_REMAIN:   do;					/*  to be examined.				        */
		call argValue(parmI, src, globalOpt, code);
						/* argValue reports some errors itself; but it always     */
						/*  returns the noarg error without reporting.  Only this */
						/*  code knows how to report meaning of such an error.    */
		if code ^= 0 then do;		/*  Here, it means "User forgot to initialize parameter." */
		     call gripe(code, PROC, "No argument value for: dcl ^a ^a", src.id, targ.dcl);
		     go to EXIT_call;
		     end;
	     

  dcl 1 parmDesc aligned like arg_descriptor based(targ.descP);
						/* Create an overlay for the actual target descriptor.    */

  dcl 1 d aligned like target.desc based(dP);		/* Create a short name for target.desc substructure.      */
  dcl  dP ptr;					/*  This substructure changes if -addr is given.	        */
     dP = addr(targ.desc);

                    if (src.fmt = FMTcode) then
		     if substr(src.id,1,length("parm")) = "parm" then
		          substr(src.id,1,length("parm")) = "code";
		     else if src.id = "retValue" then
		          src.id = "retCode";		/* Change default ID field to better identify code parms. */


  dcl  arg_desc_bv bit(36) aligned;			/* Provide a descriptor representing -addr DECLARATION.   */
  dcl  call_scalar_dcl_ entry (ptr, char(*), uns fixed bin(3), char(256) var, bit(36) aligned, char(*) var,
	fixed bin(35));
						/* Provide a pointer descriptor if -addr DECLARATION      */
						/*  given for an argument of options(variable) subr.      */
  dcl 1 pointer_Descriptor aligned int static options(constant),
      2 flag	      bit (1) unal init(T),
      2 type	      fixed bin (6) unsigned unal init(pointer_dtype),
      2 packed	      bit (1) unal init(F),
      2 number_dims	      fixed bin (4) unsigned unal init(0),
      2 size	      fixed bin (24) unsigned unal init(0);

		/* Verify that -addr DECLARATION given only for parm that is a scalar pointer_dtype.	        */
		if src.meta = METAaddr & length(src.argOpt.dcl) > 0 then do;
		     if ei.options_variable then do;	/* For options(variable) entrypoint, make this arg a ptr. */
			targ.descP = addr(pointer_Descriptor);
			targ.desc.type = pointer_dtype;
			targ.desc.aligned = T;
			targ.dcl = "ptr";
			end;
		     else if ^((d.type = pointer_dtype) & (d.dimensionsCount = 0)) then do;
			call gripe(error_table_$bad_arg, PROC,
			     "-addr argument given for non-pointer variable: dcl ^a ^a;", src.id, targ.dcl);
			go to EXIT_call;
			end;
						/* Is -addr DECLARATION valid?		        */
		     call call_scalar_dcl_ (areaP, "dcl " || src.argOpt.id || " " || src.argOpt.dcl || ";",
			globalOpt.debug, "", arg_desc_bv, src.ad.M_id, code);
		     if code ^= 0 then do;
			call gripe(code, PROC, "DECLARATION error: -addr ""^a"" ", src.argOpt.dcl);
			go to EXIT_call;
			end;
		     call decode_descriptor(addr(arg_desc_bv), src.ad.desc);
		     if ^supported_by_call_dtype(src.ad.desc.type) then do;
						/* Validate that descriptor type is one call can handle.  */
						/* call makes many decisions based upon groups of         */
						/*  descriptor types.  Functions defining these groups    */
						/*  are in call_dtype_fcns.incl.pl1		        */
			call gripe(error_table_$bad_arg, PROC, 
			     "DECLARATION not supported by call: -addr ""^a"" ", src.argOpt.dcl);
			go to EXIT_call;
			end;
		     src.ad.given = T;
		     dP = addr(src.ad.desc);		/* NB: Remaining tests depend on DECLARATION storage type,*/
		     end;				/*  rather than the pointer parameter, itself.	        */

		/* Verify that -dcl DECLARATION is valid.					        */
		if src.meta = METAdcl & length(src.argOpt.dcl) > 0 then do;
  dcl  dcl_id char(20) var;
		     call call_scalar_dcl_ (areaP, "dcl " || src.argOpt.id || " " || src.argOpt.dcl || ";",
			globalOpt.debug, "", targ.dcl_desc_bv, dcl_id, code);
		     if code ^= 0 then do;
			call gripe(code, PROC, "DECLARATION error: -dcl ""^a"" ", src.argOpt.dcl);
			go to EXIT_call;
			end;
		     if dcl_id ^= "" then do;
			call gripe(call_et_$bad_declaration, PROC, "invalid size: -dcl ""^a"" ", src.argOpt.dcl);
			go to EXIT_call;
			end;
		     call decode_descriptor(addr(targ.dcl_desc_bv), targ.desc);
		     if ^supported_by_call_dtype(targ.desc.type) then do;
						/* Validate that descriptor type is one call can handle.  */
			call gripe(error_table_$bad_arg, PROC, 
			     "DECLARATION not supported by call: -dcl ""^a"" ", src.argOpt.dcl);
			go to EXIT_call;
			end;
		     targ.descP = addr(targ.storage.dcl_desc_bv);
		     targ.dcl = src.argOpt.dcl;
		     end;

		/* Verify that arg_value -code corresponds to parm that is fixed bin(35), or fixed bin(17)        */
		if src.fmt = FMTcode then do;	
		     if ^((d.type = FIXED_BIN) & ((d.size = 35 | d.size = 17)) &
			(d.scale = 0) & d.aligned & (d.dimensionsCount = 0)) then do;
			call gripe(error_table_$bad_arg, PROC,
			     "-code argument given for non-status code parameter: dcl ^a ^a;", src.id, targ.dcl);
			go to EXIT_call;
			end;
		     end;

		/* Verify that arg_value -date_time, -date, or -time corresponds to parm that is fixed bin(71)    */
		if src.fmt = FMTdate_time | src.fmt = FMTdate | src.fmt = FMTtime then do;	
		     if ^((d.type = real_fix_bin_2_dtype) & (d.size = 71) &
			(d.scale = 0) & d.aligned & (d.dimensionsCount = 0)) then do;
			call gripe(error_table_$bad_arg, PROC,
			     "^a argument given for non-clock parameter: dcl ^a ^a;", 
			     FMT.name(src.fmt), src.id, targ.dcl);
			go to EXIT_call;
			end;
		     end;

		/* Verify that -max_length count given only for string/area data types with star extents.	        */
		if src.M ^= Lunset then do;
		     if ^star_extent_dtype(d.type) then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-max_length ^d given^[ with -addr ""^a""^;^s^] for data type
        which is not a string or an area: dcl ^a ^a;",
			     src.M, src.ad.given, src.dcl, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     if ^(d.size = SizeStar) then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-max_length ^d given^[ with -addr ""^a""^;^s^] without star extent: dcl ^a ^a;", 
			     src.M, src.ad.given, src.dcl, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     end;

		/* Verify that -length L given only for string data types.   */
		if src.L ^= Lunset then do;
		     if ^string_dtype(d.type) then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-length ^d given^[ with -addr ""^a""^;^s^] for non-string: dcl ^a ^a;", 
			     src.L, src.ad.given, src.dcl, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     end;

		/* Verify that -length ID given only for string data types.				        */
		if length(src.L_id) > 0 then do;
		     if ^string_dtype(d.type) then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-length ^a given^[ with -addr ""^a""^;^s^] for non-string: dcl ^a ^a;", 
			     src.L_id, src.ad.given, src.dcl, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     end;
		end ARGS_REMAIN;

	     else if ^targ.desc.fcnReturnValue then do;
						/* OK if no arg_value spec given for function return val, */
		call gripe(error_table_$noarg, PROC, "No argument value for: parm^d ^a", parmI, targ.dcl);
		go to EXIT_call;			/*  but other parameters need corresponding arg_value.    */
		end;

	     end ARG_VALUES_LOOP;
	end HAVE_ARGUMENTS;
%page;
/* --------------------------------------------------------------------------- *
 * TASK 7) continues:					         *
 *  1) Check -addr "char(M_id)" arg_value, to make sure corresponding          *
 *     s(parmI).id = M_id is an input, fixed binary variable that can be       *
 *     assigned to source.M.					         *
 *  2) Check -length L_id arg_value, to make sure corresponding                *
 *     s(parmI).id = L_id is an output, fixed binary variable that can be      *
 *     assigned to source.L.					         *
 * --------------------------------------------------------------------------- */

     if sP ^= null then 
HAVE_SOURCE_SPECS:
     do;
SOURCE_SPECS_LOOP:
	do parmI = lbound(s,1) to hbound(s,1);
	     if length(src.ad.M_id) > 0 then 
ADDR_DECL_REFERENCE:
	     do;
		refI = sourceWithID(src.ad.M_id);
		if refI > 0 then do;
		     if ^parmIsFixedBin(s(refI), t(refI)) | s(refI).ad.given then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-addr ""^a"" references arg_value not fixed binary (unsuitable as a length): dcl ^a ^a;",
			     src.dcl, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     else if s(refI).dir > DIRinout then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-addr ""^a"" references arg_value not an input value: dcl ^a ^a; (^a)",
			     src.dcl, s(refI).id, t(refI).dcl, DIR.name(s(refI).dir));
			go to EXIT_call;
			end;
		     else if refI = parmI then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-addr ""^a"" references its own parameter: dcl ^a ^a;",
			     src.dcl, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     else do;
			src.M = argFixedBinValue(s(refI), t(refI), null());
			if src.M = SizeStar then do;	/* Error converting s(refI).argP/argL to fixed bin(24).   */
			     call gripe (error_table_$bad_conversion, PROC, 
				"-addr ""^a"" references an arg_value with -id ^a not convertible to fixed bin(24)",
				src.dcl, src.ad.M_id);
			     go to EXIT_call;
			     end;
			src.ad.desc.size = src.M;	/* Change char(*) to char(M)			        */
			end;
		     end;
		else do;
		     call gripe (error_table_$oldnamerr, PROC,
			"-addr ""^a"" references an ID not found on any other arg_value specification.", src.dcl);
		     go to EXIT_call;
		     end;
		end ADDR_DECL_REFERENCE;

	     if length(src.L_id) > 0 then
LENGTH_REFERENCE:
	     do;
	          refI = sourceWithID(src.L_id);
		if refI > 0 then do;
		     if ^parmIsFixedBin(s(refI), t(refI)) then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-length ^a is not fixed binary (unsuitable as a length): dcl ^a ^a;",
			     src.L_id, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     else if refI = parmI then do;
			call gripe (error_table_$bad_arg, PROC,
			     "-length ^a references its own parameter: dcl ^a ^a;",
			     src.L_id, src.id, targ.dcl);
			go to EXIT_call;
			end;
		     else
			src.argXref.L_idX = refI;
		     end;
		else do;
		     call gripe (error_table_$oldnamerr, PROC,
			"-length ^a references an ID not found on any other arg_value specification.", src.L_id);
		     go to EXIT_call;
		     end;
		end LENGTH_REFERENCE;

	     end SOURCE_SPECS_LOOP;
	end HAVE_SOURCE_SPECS;
%page;
/* ---------------------------------------------------------------- *
 * TASK 8)					        *
 * - Loop through parameters, allocating parameter storage, and     *
 *   initializing storage per arg_value specs.		        *
 * - Set arg_list.parmP(i) and arg_list.descP(i) values.            *
 * ---------------------------------------------------------------- */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 8 begins...");
     
  dcl 1 parmSummary aligned,
      2 parmsNotSupported fixed bin,			/* Count of parameter data types not supported by call.   */
      2 convertFailed fixed bin,			/* Count of positional args corresponding to parm	        */
						/*  initial values, encountering conversion errors.       */
      2 totalStorageNeeded fixed bin(35);		/* Count of word-aligned storage words needed to hold     */
						/*  large-size parameters.			        */

     if tP ^= null then do;
	parmSummary = 0;				/* Initialize all summary structure elements to 0.        */
	do parmI = lbound(t,1) to hbound(t,1);
	     call argAssign (parmI, s(parmI), t(parmI), globalOpt.debug, 
		l.argP(parmI), l.descP(parmI), areaP, parmSummary);
	     end;
	if ^((parmSummary.parmsNotSupported = 0) & (parmSummary.convertFailed = 0)) then 
	     go to EXIT_call;			/* Any errors were reported by argAssign.  Exit after     */
						/*   all parameters were examined.		        */
	end;
%page;
/* ------------------------------------------------------------------ *
 * TASK 9)					          *
 *  - All parms are of supported type, and all storage is assigned.   *
 *  - Our arg_list has been allocated and set.		          *
 *  - Now ready to call the subroutine or function.	          *
 * Call to a function differs only in how call command post-processes *
 *   its final parameter, which is the function return value.         *
 * ------------------------------------------------------------------ */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 9 begins...");
     
  dcl output char(3000) varying;			/* Variables to hold debug information about a parameter. */
  dcl outputD char(80) varying;
  dcl outPrefix char(100) varying;

     outPrefix = ei.entrypoint.nameString;		/* Possibly use entrypoint name (w/o path) in msgs.       */

     if globalOpt.debug >= 2 & tP ^= null() then do;    	/* Display arguments in the constructed arg list before   */
						/*  calling the subroutine?  This includes showing how    */
						/*  any function return value has been initialized.       */
	call ioa_ ("-- Argument List --------------------");
	do parmI = lbound(t,1) to hbound(t,1);
	     call debugOutputArg(parmI, s(parmI), t(parmI), l.argP(parmI), l.descP(parmI), command, output, outputD);
	     call ioa_(" ^va @ ^p = ^a", maxlength(s(parmI).id), s(parmI).id, l.argP(parmI), output);
	     call ioa_(" ^vx desc @ ^p^42t^a", maxlength(s(parmI).id)-length("desc "), l.descP(parmI), outputD);
	     end;
	end;
     else if globalOpt.debug >= 2 then 
	call ioa_ ("-- No Arguments- --------------------");

     if globalOpt.debug > 0 then do;			/* Separate our debug data from called subr's output      */
	call ioa_ ("-- Calling ^a -----------------------", outPrefix);
	outPrefix = NL || "--  returns: -----------------------" || copy("-",length(outPrefix)) || NL;
	end;
     else do;
	outPrefix = "-- Return from: " || outPrefix || " -------" || NL;
	if command then call ioa_("");		/* Separate command from its output by a blank line.      */
	end;

  dcl  cu_$generate_call entry (entry, ptr);

     call cu_$generate_call (ei.entryVar, addr (l));	/* Actually call the subroutine with our arg_list.        */

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* TASK 10)								        */
	/* Process output parameters and/or function return values from the target entry.  Display those  */
	/* values to the user; or for an AF invocation, return one of the values as the AF return string. */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     if globalOpt.debug >= 5 then
	call ioa_ ("Task 10 begins...");
     

     do parmI = 1 to ei.parm_count;			/* Resolve source.L_id references, storing L_id's output  */
	refI = s(parmI).L_idX;			/*  value in source.L			        */
	if refI ^= Lunset then 
	     s(parmI).L = argFixedBinValue(s(refI), t(refI), l.argP(refI));
	end;

     if command then do;				/* call as a COMMAND: display output parameters.	        */
  dcl  outS bit(1) aligned;
	do parmI = 1 to ei.parm_count;
	     if globalOpt.xtra = XTRAoctal then src.xtra = XTRAoctal;
						/* Map global -octal onto per-parameter -octal setting.   */
	     outS = (globalOpt.xtra = XTRAall) | (src.xtra = XTRAoctal ) | 
		  (src.dir >= DIRinout & src.dir < DIRignore) | 
		  targ.desc.fcnReturnValue;
	     if (src.dir = DIRin) | (src.dir = DIRignore) then outS = F;
						/* Allow -in and -ignore to override global -all, -octal  */
	     if outS then do;
		call convertOutputArg(parmI, s(parmI), t(parmI), l.argP(parmI), l.descP(parmI), command, output);
		call ioa_("^a ^va ^a", outPrefix, maxlength(src.id), src.id, output);
		outPrefix = "";
		end;
	     end;
	end;
     else do;					/* call as an AF: Return only one value.  But which one?  */
	do parmI = 1 to ei.parm_count;		/*  - Foremost, return any nonzero -code value	        */
	     if s(parmI).dir = DIRout & s(parmI).fmt = FMTcode then do;
		call convertOutputArg(parmI, s(parmI), t(parmI), l.argP(parmI), l.descP(parmI), command, af_ret);
		if af_ret ^= "" then go to EXIT_call;
		end;
	     end;
	do parmI = 1 to ei.parm_count;		/*  - Otherwise, return FIRST parm with -return.	        */
	     if s(parmI).ret & (s(parmI).fmt ^= FMTcode) then do;
		call convertOutputArg(parmI, s(parmI), t(parmI), l.argP(parmI), l.descP(parmI), command, af_ret);
		go to EXIT_call;
		end;
	     end;
	parmI = ei.parm_count;			/*  - Otherwise, return any function return value.        */
	if (parmI > 0) then
	     if targ.fcnReturnValue & (s(parmI).dir ^= DIRignore) then
		call convertOutputArg(parmI, s(parmI), t(parmI), l.argP(parmI), l.descP(parmI), command, af_ret);
	end;

EXIT_call:					/* Label used to exit entire call program.	        */
     call call_entry_info_$cleanup(entry_info_ptr);	/*  Cleanup any translator_temp_ storage created by       */
     return;					/*  call_entry_info_$from_XXX routines.		        */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Major subroutines that perform the tasks needed to construct an argument list and call the     */
	/* virtual_entry.								        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


/* ----------------------------------------------------------------- *
 * Get information about each parameter from entrypoint parameter    *
 * descriptor.  Store information for each parameter in a	         *
 * target structure entry (passed as the t parameter below).         *
 * ----------------------------------------------------------------- */

get_entry_parm_info:
     proc (i, e, t, debug);

  dcl  i fixed bin;					/* index of parameter whose info is wanted.          (in) */
  dcl 1 e aligned like entry_info_header;		/* entry point header information, needed to         (in) */
						/*  determine if callee is a function.		        */
  dcl 1 t aligned like target;			/* structure in which parameter info is stored.   (inout) */
  dcl  debug fixed bin(3) unsigned;			/* debug setting.				   (in) */

     call decode_descriptor(t.descP, t.desc);
     if ^supported_by_pl1_dtype(t.desc.type) then do;	/* call makes many decisions based upon groups of         */
	t.dcl = "";				/*  descriptor types.  Functions defining these groups    */
	return;					/*  are in call_dtype_fcns.incl.pl1		        */
	end;

     t.desc.fcnReturnValue = ((i = ei.parm_count) & ei.function);
     t.dcl = descriptorString (t.descP);

     if debug >= 3 then
	if t.desc.fcnReturnValue 
	then call ioa_ ("    returns(^a);", t.dcl);
	else call ioa_ ("    dcl parm^a ^a;", int2digits(i), t.dcl);

     end get_entry_parm_info;


/* ------------------------------------------------------------ *
 * Decode the descriptor info.			    *
 *  - This subroutine called in many places, so centralize the  *
 *    code here.					    *
 * ------------------------------------------------------------ */

decode_descriptor:
     proc (descP, desc);
     
  dcl  descP ptr;
  dcl 1 desc aligned like target.desc;

  dcl  decode_descriptor_ entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin (24), fixed bin);

  dcl  packed bit (1) aligned;

     call decode_descriptor_(descP, 0, desc.type, packed, desc.dimensionsCount, desc.size, desc.scale);
     desc.aligned = ^packed;
     
     end decode_descriptor;


/* ------------------------------------------------------------ *
 * Find source structure in s array whose .id matches a         *
 * given input.					    *
 *  - Caller has tested that s array has been allocated.        *
 * ------------------------------------------------------------ */

sourceWithID:					/* ID lookup function.			        */
     proc (idNeeded) returns(fixed bin);

  dcl  idNeeded char(20) var;
  dcl  i fixed bin;

     do i = lbound(s,1) to hbound(s,1);
	if s(i).id = idNeeded then
	     return(i);
	end;
     return(0);
     end sourceWithID;

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: argAssign								        */
	/*									        */
	/* Functions:  For each parameter in the calling sequence, create a corresponding argument:       */
	/*  1) Validate that parameter type is supported by this call program.  Call does not support:    */
	/*       complex numbers, array or structure parameters.				        */
	/*       non-PL/I data types							        */
	/*  2) Place parameter into one of six parameter cases used by call.		                  */
	/*  3) For fixed bin numbers, and bit strings, an initial value may be specified as an octal or   */
	/*     hexadecimal representation.  Set the octHex flag as a modifier for the target case.        */
	/*  4) Determine how much space is needed to hold the actual argument.		        */
	/*  5) Allocate space to hold the argument in our area (created by call_entry_info_$from_XXX).    */
	/*  6) For output arguments, determine an appropriate initial value (since caller did not         */
	/*     specify one.)							        */
	/*  7) Initialize argument storage with the given (or determined) initial value.  Modify	        */
	/*     descriptor for parameter types with star extents, specifying actual (max)length of the     */
	/*     argument being passed.							        */
	/*  8) Fill-in call's generated arg_list, with:					        */
	/*      - ptr to (perhaps modified) parameter descriptor				        */
	/*      - ptr to the allocated, initialized argument storage			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

argAssign:
     proc (i, src, targ, debugI, listArgP, listDescP, areaP, pl);	

  dcl  i fixed bin;                                         /* parameter index being assigned.                   (in) */
  dcl 1 src structure aligned like source;		/* parameter arg_value specification.		   (in) */
  dcl 1 targ structure aligned like target;		/* parameter descriptor information.		   (in) */
  dcl  debugI fixed bin(3) unsigned;			/* debug:  >=3 means display allocation size info.   (in) */
  dcl  listArgP ptr;				/* ptr to our arg_list.argP(i) for this parameter   (out) */
  dcl  listDescP ptr;                                       /* ptr to our arg_list.descP(i) for this parameter  (out) */
  dcl  areaP ptr;					/* ptr to our translator_temp_ allocation area.	  (out) */
  dcl 1 pl structure aligned like parmSummary;		/* summary structure which counts errors.         (inout) */

  dcl 1 parmDesc aligned like arg_descriptor based(targ.descP);
						/* Create an overlay for the actual target descriptor.    */

  dcl 1 d aligned like target.desc based(dP);		/* Create a short name for target.desc substructure.      */
  dcl  dP ptr;					/*  This substructure changes if -addr is given.	        */

     if src.ad.given then				/* When -addr DECLARATION is given, get storage for that  */
	dP = addr(src.ad.desc);			/*  declaration, rather than for the pointer parameter.   */
     else dP = addr(targ.desc);			/* Otherwise, get storage to hold the parameter defined   */
						/*  by the entrypoint calling sequence.		        */
						/*  (For options(variable) subroutine, get either         */
						/*   character storage, or storage to hold -dcl data type)*/

     if ^supported_by_call_dtype(d.type) then do;		/* Check for structures, non-PL/I types, complex numbers  */
ASSIGN_bad_type:
	if d.type = structure_dtype then 
	     call gripe (call_et_$structure_unsupported, PROC, "dcl 1 ^a ^a;^[ -addr ""^a""^;^s^]", 
	          src.id, substr(targ.dcl,2), src.ad.given, src.dcl);
	else call gripe (call_et_$parameter_type_unsupported, PROC, "^a (^d): dcl ^a ^a;^[ -addr ""^a""^;^s^]", 
	          pl1_dtype_name(d.type), d.type, src.id, targ.dcl, src.ad.given, src.dcl);
	go to ASSIGN_unsupported;
	end;
     if d.dimensionsCount > 0 then do;			/* Check for arrays, which call does not support.         */
	call gripe(call_et_$array_unsupported, PROC,
	     "dcl ^a ^a;^[ -addr ""^a""^;^s^]", src.id, targ.dcl, src.ad.given, src.dcl);
	go to ASSIGN_unsupported;
	end;

     targ.case = argCase(d.type);			/* Place parameter type into one of five parameter cases. */
     if targ.case = 0 then go to ASSIGN_bad_type;

     if d.fcnReturnValue & targ.case = CASEstring & d.size = SizeStar & ^src.ad.given  then do;
						/* Check for a possible sixth case:		        */
	targ.case = CASEreturnsStar;			/*    returns(char(*)... )  or  returns(bit(*)... )       */
	targ.storage.wordCount = 0;			/*  must be handled without pre-allocating storage to hold*/
	targ.storage.P = null;			/*  the returned data.  Instead that data is pushed onto  */
	go to ASSIGN_for(targ.case);			/*  call's stack frame.			        */
	end;

  dcl  octHex bit(1) aligned init(F);			/* For fixed bin or bit arguments, input value may be     */
  dcl  sourceBits bit(200) varying aligned;		/*  given in an octal or hex representation, where last   */
						/*  two digits indicate base (b3=octal, b4=hexadecimal).  */
						/*  For example, decimal 133 is input as:	        */
						/*    octal:  205b3          hexadecimal:  85b4           */
     if (fixed_bin_dtype(d.type) | bit_string_dtype(d.type)) then 
	octHex = T;

						/* Determine actual extent for parameter with star extent.*/
  dcl  desiredSize fixed bin(24);			/* Size in bits, characters, or (area) words.	        */
     desiredSize =  d.size;				/*  - Start out using size from the target descriptor.    */

     if star_extent_dtype(d.type) & d.size = SizeStar then do;
	if src.M ^= Lunset then			/* For strings and areas, map xxx(*) to specific length.  */
	     desiredSize = src.M;			/*  -max_length M				        */
	else if char_string_dtype(d.type) & src.argL > 0 then
	     desiredSize = src.argL;			/*  length(input_arg_value)			        */
	else if bit_string_dtype(d.type)  & src.argL > 0 then do;
	     if octHex & oct_or_hex_source(srcArg, sourceBits) then
		desiredSize = length(sourceBits);
	     else desiredSize = src.argL;
	     end;
	end;
     if star_extent_dtype(d.type) & desiredSize = SizeStar then do;
	call gripe(call_et_$star_extent_unresolved, PROC,
	     "Use -max_length M to give a size: dcl ^a ^a; ^[-addr ""^a""^;^s^]", 
	     src.id, targ.dcl, src.ad.given, src.dcl);
	go to ASSIGN_unsupported;
	end;


  dcl  code fixed bin(35);				/* Get count of storage needed (in words).	        */
     call argStorageWords (d.type, d.aligned, desiredSize, targ.storage.wordCount, code);
     if code ^= 0 then do;				
	call gripe (code, PROC, "Unsupported storage type: ^a (^d): dcl ^a ^a;^[ -addr ""^a""^;^s^]", 
	     pl1_dtype_name(d.type), d.type, src.id, targ.dcl, src.ad.given, src.dcl);
	go to ASSIGN_unsupported;
	end;

     targ.storage.P = allocate(areaP, (targ.storage.wordCount));
						/* Allocate the storage.			        */

  dcl srcArg char(src.argL) based(src.argP);		/* Declare an overlay for the initial value argument.     */

  dcl emptyString char(0) int static options(constant) init("");
						/* An empty string as the initial value:	        */
     if src.dir >= DIRout then do;			/*  - Zeroes (numeric, bit) output arguments.	        */
	src.argP = addr(emptyString);			/*  - Set string output arguments to "".	        */
	src.argL = length(emptyString);
	end;

     go to ASSIGN_for(targ.case);
%page;

ASSIGN_for (CASEpointer):

  dcl cv_ptr_ entry (char(*), fixed bin(35)) returns(ptr);
  dcl convPtr ptr;
  dcl assignPtr       ptr      based(targ.storage.P);
  dcl assignPtrPacked ptr unal based(targ.storage.P);

     if src.argL = 0 then				/* User gave no initialization for pointer?               */
          convPtr = null();                                 /*   Default initial value is a null() pointer.           */
     else do;                                               /* CONVERT                                                */
          convPtr =  cv_ptr_(srcArg, code);                 /*   src (initial arg_value) to an aligned ptr.           */
          if code ^= 0 then go to ASSIGN_failed;
	end;
     if targ.desc.aligned then                              /* ASSIGN					        */
          assignPtr = convPtr;
     else assignPtrPacked = convPtr;
     listDescP = targ.descP;
     go to ASSIGN_ok;
     

ASSIGN_for (CASEentry):

  dcl  cv_entry_ entry (char(*), ptr, fixed bin(35)) returns(entry);
  dcl  cu_$make_entry_value entry (ptr, entry);
  dcl  convEntry entry variable options(variable);
  dcl  assignEntry entry variable options(variable) based(targ.storage.P);

     if src.argL = 0 then				/* STORAGE                                                */
	call cu_$make_entry_value (null(), convEntry);	/* User gave no initialization for entry value?	        */
                                                            /*   Create equivalent of a null entry value.             */
     else do;
          convEntry =  cv_entry_(srcArg, null(), code);	/* CONVERT                                                */
	if code ^= 0 then go to ASSIGN_failed;
	end;
     assignEntry = convEntry;				/* ASSIGN                                                 */
     listDescP = targ.descP;				/*  Entry variables are always aligned.		        */
     go to ASSIGN_ok;
     

ASSIGN_for (CASEnumeric):
     if src.dir <= DIRinout & src.fmt = FMTcode & src.argL > 0 then do;

  dcl  statusCodeE entry variable;
  dcl  statusCodeP ptr;
  dcl  statusCode fixed bin(35) aligned based(statusCodeP);
  dcl  assignCode fixed bin(35) aligned based(targ.storage.P);

	statusCodeE = cv_entry_(srcArg, null(), code);	/* CONVERT input status code name to fixed bin(35) value. */
	if code ^= 0 then go to ASSIGN_failed;
	statusCodeP = codeptr(statusCodeE);
	assignCode = statusCode;			/* ASSIGN					        */
          end;
     
     else if src.dir <= DIRinout & ((src.fmt = FMTdate_time) | (src.fmt = FMTdate) | (src.fmt = FMTtime))  then do;

  dcl  clockN fixed bin(71) aligned based(targ.storage.P);
  dcl  convert_date_to_binary_ entry (char(*), fixed bin(71), fixed bin(35));
	     
	call convert_date_to_binary_(srcArg, clockN, code);
	if code ^= 0 then go to ASSIGN_failed;		/* CONVERT input date/time string to fixed bin(71) value. */
	end;

     else do;					/* CONVERT initial value to numeric form.	        */
	call assign(srcArg, octHex, targ.P, d.type, d.aligned, d.size, d.scale, code);
	if code ^= 0 then go to ASSIGN_failed;
	end;
     listDescP = targ.descP;
     go to ASSIGN_ok;
     

ASSIGN_for (CASEarea):
     
  dcl 1 ai aligned like area_info;
  dcl  assignArea area(desiredSize) based(targ.storage.P);  /* STORAGE				        */
  dcl  define_area_ entry (ptr, fixed bin(35));

     unspec(ai) = ZEROb;				/* CONVERT/ASSIGN				        */
     ai.version = area_info_version_1;			
     ai.control.zero_on_free = T;
     ai.owner = PROC;
     ai.size = desiredSize;
     ai.areap = targ.storage.P;
     call define_area_ (addr(ai), code);
     if code ^= 0 then go to ASSIGN_area_failed;

     if ^src.ad.given & d.size = SizeStar then do;
	targ.modifiedDesc = parmDesc;
	targ.modifiedDesc.size = desiredSize;
	listDescP = addr(targ.modifiedDesc);
	end;
     else if src.ad.given then do;
	listDescP = targ.descP;
	src.ad.desc.size = desiredSize;		/* Created area size not recorded anywhere else.  So      */
	end;					/*  put it in src.ad.desc.			        */
     else listDescP = targ.descP;
     go to ASSIGN_ok;


ASSIGN_for (CASEstring):				/* CONVERT/ASSIGN				        */
     call assign(srcArg, octHex, targ.P, d.type, d.aligned, desiredSize, 0, code);
     if ^src.ad.given & d.size = SizeStar then do;
	targ.modifiedDesc = parmDesc;
	targ.modifiedDesc.size = desiredSize;
	listDescP = addr(targ.modifiedDesc);
	end;
     else listDescP = targ.descP;
     go to ASSIGN_ok;


ASSIGN_for (CASEreturnsStar):				/* For returns(xxx(*)... ) function return value:	        */
     unspec(targ.modifiedDesc) = ZEROb;			/*  - Zero storage in which callee will store descriptor. */
     listDescP = addr(targ.modifiedDesc);		/*  - Make arg_list point to that descriptor.	        */
     targ.storage.P = null;				/*  - Null out pointer to callee-returned storage.        */
     listArgP = addr(targ.storage.P);			/*  - Make arg_list point to that parameter storage ptr.  */
     go to ASSIGN_debug;


ASSIGN_ok:
     if src.ad.given then				/* For -addr DECLARATION, parm is pointer to DECLARATION  */
	listArgP = addr(targ.P);			/*   storage.				        */
     else if varying_string_dtype(d.type) then		/* For varying string, arg_list.parmP(i) points just      */
	listArgP = addrel(targ.P, 1);			/*   after length word of the varying string.	        */
     else listArgP = targ.P;				/* Otherwise, argument list points to allocated parm.     */
ASSIGN_debug:
     if debugI >= 4 then
	call ioa_(" ^va @ ^p   ^2d word^[^;s^]", maxlength(src.id), src.id, listArgP, targ.storage.wordCount,
	     targ.storage.wordCount = 1);
     return;

ASSIGN_failed:
     call gripe(code, PROC, "Converting ""^a"" ^a  to: dcl ^a ^a;^[ -addr ""^a""^;^s^]", 
	srcArg, FMT.name(src.fmt), src.id, targ.dcl, src.ad.given, src.dcl);
     pl.convertFailed = pl.convertFailed + 1;
     return;

ASSIGN_area_failed:
     call gripe(code, PROC, "Emptying area: ^a -id ^a (dcl: ^a)^[ -addr ""^a""^;^s^]", 
	     DIR.name(src.dir), src.id, targ.dcl, src.ad.given, src.dcl);
     pl.convertFailed = pl.convertFailed + 1;
     return;

ASSIGN_unsupported:
     pl.parmsNotSupported = pl.parmsNotSupported + 1;
     return;
     
     end argAssign;


argStorageBits:					/* This routine uses PL/I rules to determine how much     */
     proc (dtype, daligned, dsize) returns(fixed bin(24));	/*  storage is needed.  Count is always returned in bits. */

  dcl  dtype fixed bin;
  dcl  daligned bit(1) aligned;
  dcl  dsize fixed bin(24);

  dcl  code fixed bin(35);
  dcl  count fixed bin(24);				

  dcl  boundary fixed bin(2) unsigned;			

     call storage_for_pl1_dtype(dtype, ^daligned, dsize, boundary, count, code);
     if code = 0 then do;
	if boundary = BOUNDARY.Word then
	     count = count * bits_per_word;
	else if boundary = BOUNDARY.Byte then
	     count = count * bits_per_character;
	end;
     else count = 36;				/* Assert: code should never be non-zero.	        */
						/*  call already restricted dtype's to those supported by */
						/*  the storage_for_pl1_dtype function.		        */
     return (count);
     end argStorageBits;


argStorageWords:					/* This routine uses PL/I rules to determine how much     */
     proc (dtype, daligned, dsize, count, code);		/*  storage is needed.  call always has even-word aligned */
						/*  storage (even for packed scalars), so code below      */
  dcl  dtype fixed bin;				/*  converts bit/byte lengths to word length (just as the */
  dcl  daligned bit(1) aligned;			/*  PL/I size builtin would do).		        */
  dcl  dsize fixed bin(24);
  dcl  count fixed bin(24);				
  dcl  code fixed bin(35);

  dcl  boundary fixed bin(2) unsigned;			

     call storage_for_pl1_dtype(dtype, ^daligned, dsize, boundary, count, code);
     if code = 0 then do;
	if boundary = BOUNDARY.Byte then
	     count = divide(count+characters_per_word-1, characters_per_word, 24, 0);  
	else if boundary = BOUNDARY.Bit then
	     count = divide(count+bits_per_word-1, bits_per_word, 24, 0);
	end;

     end argStorageWords;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name:  argFixedBinValue							        */
	/*									        */
	/* Function: Does a quick conversion of a fixed binary variable to a fixed bin(24) string/area    */
	/* length count.  It is called for two different purposes:				        */
	/*  1) For a ptr parameter declared with:  -addr "char(lengthParmID)", call has found another     */
	/*     source arg_value with -id lengthParmID.  This "reference" arg_value must be an -input      */
	/*     (or -inout) fixed binary arg_value.  Before calling virtualEntry, argFixedBinValue is      */
	/*     called to convert the reference initial value to the length count.  Since this conversion  */
	/*     has not been tested before, a conversion or size condition might occur.		        */
	/*  2) For a string parameter declared with -length lengthParmID, call has found another          */
	/*     source arg_value with -id lengthParmID.  This "reference" arg_value must be a	        */
	/*     fixed binary arg_value, whose output value is used as the length count.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

argFixedBinValue:
     proc (src, targ, argP) returns(fixed bin(24));
     
  dcl 1 src aligned like source;
  dcl 1 targ aligned like target;
  dcl  argP ptr;					/* arg_list.arg_ptr(parmI)			   (in) */
						/*  =null():   purpose 1, use src initial value.	        */
						/*  otherwise: purpose 2, use parm output value.	        */

  dcl  PACKED fixed bin int static options(constant) init(1);

  dcl 1 desc aligned like target.desc;
  dcl  fbSourceP ptr;
  dcl  fbAddressedSource ptr based(argP);
  dcl  value fixed bin(24);
     
  dcl (conversion, size) condition;

     if src.ad.given then do;				/* We have: parmValuePtr -> number		        */
	desc = src.ad.desc; 
	fbSourceP = fbAddressedSource;
	end;
     else do;					/* We have: parmNumber			        */
	desc = targ.desc;
	fbSourceP = argP;
	end;

     on conversion begin;				/* The following calls to assign_ can raise conditions    */
	code = error_table_$bad_conversion;		/* Trap them so we can gracefully report them to user.    */
	go to EXIT_parm_value;
	end;
     on size begin;
	code = error_table_$size_error;
	go to EXIT_parm_value;
	end;

     if argP = null() then				/* Purpose 1: convert call arg_value initial string to a  */
						/*  fixed bin(24) length.			        */
	call assign_ (addr(value), 2*FIXED_BIN, 24, src.argP , 2*char_dtype+PACKED, binary(src.argL,35,0));
     else						/* Purpose 2: convert virtualEntry outout fixed-point     */
						/*  value to a fixed bin(24) length.		        */
	call assign_ (addr(value), 2*FIXED_BIN, 24, fbSourceP, 2*desc.type + binary(^desc.aligned,1,0), binary(desc.size,35,0));
     return(value);

EXIT_parm_value:
     if argP = null() then				/* Purpose 1: SizeStar result diagnoses an error.	        */
	return(SizeStar);
     else do;					/* Purpose 2: report conversion/size error to the user,   */
						/*  and returns an arbitrary length count of 10.	        */
	call gripe(code, PROC, "Converting bin length value; returning 10 instead.");
	return(10);
	end;

     end argFixedBinValue;


parmIsFixedBin:
     proc (src, targ) returns(bit(1) aligned);
     
  dcl 1 src aligned like source;
  dcl 1 targ aligned like target;
     
     if src.ad.given then do;
	if fixed_bin_dtype(src.ad.desc.type) & src.ad.desc.scale = 0  then return(T);
	else return(F);
	end;
     if fixed_bin_dtype(targ.desc.type) & targ.desc.scale = 0  then return(T);
     else return(F);

     end parmIsFixedBin;
%page;

/* ----------------------------------------------------------------- *
 * Internal procedure to handle the details/idiosyncrasies of        *
 * calling the Multics assign_ subroutine, which is the advertised   *
 * subroutine interface to the PL/I any_to_any_ conversion operator. *
 * ----------------------------------------------------------------- */

                                                            /* Clearer names for commonly-used arg descriptor types.  */
  dcl  FIXED_BIN fixed bin aligned int static options(constant) init(real_fix_bin_1_dtype);
  dcl  FIXED_BIN_UNS fixed bin aligned int static options(constant) init(real_fix_bin_1_uns_dtype);

                                                            /* Constants for the targetAligned parameter (below).     */
  dcl  ALIGNED bit(1) aligned int static init("1"b) options (constant);
  dcl  UNALIGNED bit(1) aligned int static init("0"b) options (constant);

assign:
     proc( source, octHex, targetP, targetType, targetAligned, targetPrecision, targetScale, code);

  dcl  source char(*);				/* input arg from call command line.		        */
  dcl  octHex bit(1) aligned;				/* =T: attempt to handle octal/hex input values.          */
  dcl  targetP ptr;					/* ptr to target storage for converted parameter	        */
  dcl  targetType fixed bin;				/* One of std_descriptor_types.incl.pl1 values for target */
  dcl  targetAligned bit(1) aligned;			/* F if target is packed; T if targetP is on	        */
                                                            /*  appropriate storage boundary for targetType.	        */
  dcl  targetPrecision fixed bin(24);			/* Length of non-computational target (in approp. units); */
                                                            /*  or computational precision of target.	        */
  dcl  targetScale fixed bin;				/* Scale of computational target.  0 (ignored) otherwise. */
  dcl  code fixed bin(35);				/* Return code diagnosing bad conversions. (out)	        */

  dcl (conversion, overflow, size, underflow) condition;

  dcl  sourcePacked fixed bin int static options(constant) init(1);
  dcl  targetPacked fixed bin init(1);			/* Assume target is packed when we start.	        */


  dcl  targetL fixed bin(35) init(targetPrecision);	/* In usual case, targetL (passed to assign_) is the same */
						/*   as input targetPrecision value.  For fixed-point     */
						/*   numbers, this is not so.			        */
  dcl 1 encp aligned like encoded_precision;

     if fixed_point_dtype(targetType) then do;		/* For fixed-point types, store scale/precision in targetL*/
	encp.prec  = targetPrecision;
	encp.scale = targetScale;
	unspec(targetL) = unspec(encp);
	end;

     code = 0;                                              /* Initialize output variables.		        */

     if targetAligned then targetPacked = 0;                /* Adjust for an appropriately aligned target.	        */

     on conversion begin;				/* The following calls to assign_ can raise conditions    */
	code = error_table_$bad_conversion;		/* Trap them so we can gracefully report them to user.    */
	go to EXIT_ASSIGN;
	end;
     on overflow begin;				/* Occurs only for floating-point target assignment.      */
	code = call_et_$overflow_error;
	go to EXIT_ASSIGN;
	end;
     on size begin;
	code = error_table_$size_error;
	go to EXIT_ASSIGN;
	end;
     on underflow begin;				/* Occurs only for floating-point target assignment.      */
	code = call_et_$underflow_error;
	go to EXIT_ASSIGN;
	end;
     
     if octHex then 				/* Look for octal and hex character string representations*/
LOOK_FOR_OCTHEX:					/*  of a bit string, to be stored in bit or fixed bin.    */
     do;
  dcl  sourceBits bit(200) var;
	if oct_or_hex_source(source, sourceBits) then     /* Is bit string of form: "3577"b3 (without the quotes)   */
HAVE_OCTHEX_SOURCE:					/*            or of form: "9aBc"b4 (without the quotes)   */
          do;
	     if unsigned_dtype(targetType) then		/* Bits are assigned to storage for numbers right-to-left */
		sourceBits = ltrimZeroes(sourceBits);	/*  so remove leading 0-bits; avoid any size condition.   */
	     else if fixed_bin_dtype(targetType) then	/* Signed fixed bin's require special handling of sign    */
OCTHEX_FIXED_BIN:					/*  bit.  It must be left-filled across storage to left   */
	     do;					/*  of targetPrecision bits.			        */
		if length(sourceBits) > targetPrecision then 
		     sourceBits = ltrimZeroes(sourceBits);
						/*  Remove leading 0-bits; avoid possible size condition. */
		if length(sourceBits) > targetPrecision+1 then do;
		     code = error_table_$size_error;	/* Too many bits given for precision of fixed bin parm.   */
		     go to EXIT_ASSIGN;
		     end;
		if length(sourceBits) = targetPrecision+1 then do;
						/* Negative sign bit given.  Must extend it to left of    */
						/*  precision, if parameter is aligned.		        */
  dcl  signHolder bit(72) aligned;
  dcl  signBits bit(targetL-targetPrecision) aligned based(addr(signHolder));
  dcl  targetBits bit(targetL) aligned based(targetP);

		     targetL = argStorageBits( targetType, targetAligned, targetPrecision);
		     sourceBits = substr(sourceBits,2);
		     signBits = NEG_SIGN_BITS;
		     sourceBits = signBits || sourceBits;
		     targetBits = sourceBits;
		     go to EXIT_ASSIGN;
		     end;
		end OCTHEX_FIXED_BIN;

	     call assign_(targetP, 2*targetType + targetPacked, targetL,
		addr(sourceBits),2*varying_bit_dtype,         length(sourceBits));
	     go to EXIT_ASSIGN;

	     end HAVE_OCTHEX_SOURCE;
	end LOOK_FOR_OCTHEX;

     call assign_(targetP, 2*targetType + targetPacked, targetL,
	addr(source),    2*char_dtype + sourcePacked, length(source));

EXIT_ASSIGN:
     end assign;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Utility routines used by assign.						        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ltrimZeroes:
     proc(s) returns(bit(200) varying aligned);
  dcl  s bit(200) varying aligned;

  dcl  i fixed bin;
  dcl  foundOneI fixed bin;

     do i = 1 to length(s);				/* Search left-to-right for first 1-bit in string.        */
	if substr(s,i,1) = "1"b then do;
	     foundOneI = i;
	     go to LTRIM;
	     end;
	end;
     return(""b);
     
LTRIM:
     return (substr(s,foundOneI));			/* Return bit string starting with first 1-bit.	        */
     end ltrimZeroes;


  dcl  sourceBits bit (200) varying aligned init(""b);	/* Enough to hold 1e59 (max fixed decimal number)	        */

oct_or_hex_source:					/* Look for source initial value in form of octal or hex  */
     proc (s, bv) returns(bit(1) aligned);		/*  PL/I bit string literal (without the quote chars).    */

  dcl  s char(*);
  dcl  bv bit(200) varying aligned;

     if index(reverse(s), "3b") = 1 then do;		/* Bit string of form: "3577"b3 (without the quotes)      */
	if verify(s, "01234567") = length(s)-1 then do;
	     call bitsFromOctal(s, bv);
	     return (T);
	     end;
	return(F);
	end;
     if index(reverse(s), "4b") = 1 then do;		/* Bit string of form: "9abc"b4 (without the quotes)      */
	if verify(s, "0123456789abcdefABCDEF") = 0 then do;
	     call bitsFromHex(s, bv);
	     return (T);
	     end;
	return(F);
	end;
     return (F);

     end oct_or_hex_source;


bitsFromOctal:					/* These conversion routines assume caller has verified   */
     proc(s, bv);					/* input contains only octal or hex chars, followed by    */
						/* the PL/I bit-radix indicator: b3 for octal, b4 for hex */
     
  dcl  s char(*);
  dcl  bv bit(200) varying aligned;

  dcl  i fixed bin;
  dcl  sa (length(s)) char(1) based(addr(s));
  dcl  oct (8) bit(3) int static options(constant) init(
	 "000"b, "001"b, "010"b, "011"b, "100"b, "101"b, "110"b, "111"b);
  
     bv = ""b;
     
     do i = 1 to length(s)-length("b3");
	bv = bv || oct(index("01234567", sa(i)));
	end;
     return;


bitsFromHex:
     entry(s, bv);

  dcl  hex (22) bit(4) int static options(constant) init(
	 "0000"b, "0001"b, "0010"b, "0011"b, "0100"b, "0101"b, "0110"b, "0111"b,
	 "1000"b, "1001"b, "1010"b, "1011"b, "1100"b, "1101"b, "1110"b, "1111"b,
		         "1010"b, "1011"b, "1100"b, "1101"b, "1110"b, "1111"b);
     bv = ""b;
     do i = 1 to length(s)-length("b4");
	bv = bv || hex(index("0123456789abcdefABCDEF", sa(i)));
	end;
     return;

     end bitsFromOctal;

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name: convertOutputArg							        */
	/*									        */
	/* Function:								        */
	/* Routine to convert a return value from its parameter data type back to a string, so it can be  */
	/* displayed/returned to the user.						        */
	/*									        */
	/* Name: debugOutputArg							        */
	/*									        */
	/* Function:								        */
	/* A debug entrypoint is used prior to invoking virtualEntry, to display parameters just after    */
	/* our arg_list is initialized.  It provides information about descriptors in the arg_list, as    */
	/* well.									        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


convertOutputArg:
     proc (i, src, targ, listArgP, listDescP, command, out);    
						/* All parms are (in) except as marked.		        */
  dcl  i fixed bin;					/*  - target parameter number.		        */
  dcl 1 src aligned like source;			/*  - source structure for initial value.	        */
  dcl 1 targ aligned like target;			/*  - target structure for parameter storage info.        */
  dcl  listArgP ptr;				/*  - our arg_list.parmP for this parameter.	        */
  dcl  listDescP ptr;				/*  - our arg_list.descP for this parameter.	        */
  dcl  command bit(1) aligned;			/*  - were we called as command or active function?       */
  dcl  out char(*) varying;				/*  - return parm converted to string, with an	        */
						/*    optional octal dump.                          (out) */
  dcl 1 desc aligned like target.desc;
  dcl  ioaL fixed bin(21);
  dcl  outDump char(1000) varying;
  dcl  packed bit(1) aligned;
  dcl  parmP ptr init(listArgP);

  dcl  debugOutput bit(1) aligned init(T);
 
     debugOutput = F;

debugOutputArg:
     entry (i, src, targ, listArgP, listDescP, command, out, outD);
						/* NB: debugOutputArg is invoked only before calling     */
						/*     the subroutine or function.  It is displaying      */
						/*     how the call command prepared the arg_list, and    */
						/*     initialized the parameters.		        */

  dcl  outD char(*) varying;				/* Debug output describing descriptor.		  (out) */

     out = "";                                              /* Initialize return string.			        */

     if targ.case = CASEreturnsStar then do;		/* Special cases: returns(xxx(*)), returns(xxx(*) var)    */
	if debugOutput then do;			/* BEFORE calling the function:		        */
	     unspec(desc) = "0"b;	
	     desc.type = pointer_dtype;		/*  - parmP points to a pointer which is null, but        */
	     desc.aligned = T;			/*    will point to the actual_return_value string.       */
	     parmP = listArgP;
	     go to CONV(CASEpointer);			/*    So show the null pointer at this stage.	        */
	     end;
	else do;					/* AFTER calling the function:		        */
	     parmP = parmToPtrAligned(parmP, T);	/*  - parmP points to a pointer set by callee to the      */
						/*    actual return value.			        */
	     if parmP ^= null() & varying_string_dtype(targ.desc.type) then
		parmP = addrel(parmP, -1);		/*  - set parmP to point to the actual return value.      */
						/*     We'll use this ptr below.		        */
						/*  - Callee also provided a descriptor, giving actual    */
	     end;					/*    length of return value.  Decode this next.	        */
	end;

     call decode_descriptor(listDescP, desc);		/* Get perhaps modified descriptor, with star extent      */
						/*  replaced by an actual string/area size.	        */

     if  src.ad.given then do;			/* For -addr DECLARATION parameter, use the descriptor    */
	parmP = parmToPtrAligned(parmP, desc.aligned);	/*  created from DECLARATION.  Make parmP point to this   */
	if parmP ^= null  then			/*  declared storage.			        */
	     desc = src.ad.desc;
	else parmP = listArgP;
	end;
     else if targ.case ^= CASEreturnsStar then do;	/* returns(char(*)...) parmP was set above.	        */
	if varying_string_dtype(desc.type) then		/*  - Argument list points just after length word of a    */
	     parmP = addrel(listArgP, -1);		/*    varying string parameter.  Back up to length word.  */
	else parmP = listArgP;
	end;

     go to CONV(argCase(desc.type));			/* Recalculate argCase to account for -addr DECLARATION   */
						/*  desc.type				        */

CONV (CASEnumeric):					
     if (src.fmt = FMTcode) & (^debugOutput | src.dir <= DIRinout)  then do;
						/* Numeric case includes status code: special handling.   */
  dcl  codeN fixed bin(35) aligned based(parmP);
  dcl  shortMsg char(8) aligned;
  dcl  longMsg char(100) aligned;
  dcl  codeName char(128) var;

  dcl  call_status_code_name_ entry (fixed bin(35)) returns(char(128) var);
  dcl  convert_status_code_ entry (fixed bin(35), char(8) aligned, char(100) aligned);

          if codeN ^= 0 then do;
	     codeName = call_status_code_name_(codeN);
               call convert_status_code_(codeN, shortMsg, longMsg);
	     if length(codeName) > 0 then
		out = codeName || "  " || rtrim(longMsg);
	     else out = rtrim(longMsg);
	     end;
          else if command then out = "OK";
          else out = "";
	end;

     else if ((src.fmt = FMTdate_time) | (src.fmt = FMTdate) | (src.fmt = FMTtime)) & 
	   (^debugOutput | src.dir <= DIRinout)  then do;
					          /* Numeric case includes a clock value: special handling. */
  dcl  clockN fixed bin(71) aligned based(parmP);
  dcl  date_time char(250) var;
  dcl  date_time_$format entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
  dcl (process_default_zone, process_default_lang) char(0) init("") int static options(constant);

	date_time = date_time_$format(FMT.kywd(src.fmt), clockN, process_default_zone, process_default_lang);
	out = date_time;
	end;

     else do;					/* Otherwise, let assign convert number to character form */

  dcl 1 encp aligned like encoded_precision;
  dcl  sourceL fixed bin(35);

	if fixed_point_dtype(desc.type) then do;
	     encp.prec = desc.size;
	     encp.scale = desc.scale;
	     unspec(sourceL) = unspec(encp);
	     end;
	else sourceL = desc.size;
	call assign_(addr(out), 2*varying_char_dtype, maxlength(out),
	     parmP, desc.type*2 + binary(^desc.aligned), sourceL);
	out = ltrim(out);
	end;
     go to CONV_return;
     

CONV (CASEstring):					/* For strings, bits and varying strings need special     */
     						/*  handling.				        */
  dcl  bitS bit(sourceL) based(parmP);
  dcl  bitV bit(sourceL) varying based(parmP);
  dcl  varS bit(1) aligned init(F);

     if src.L ^= Lunset then				/* -length L tells us how much data user wants output.    */
          sourceL = src.L;
     else sourceL = desc.size;			/* Otherwise, use the desc.size amount.		        */

     if varying_string_dtype(desc.type) then do;		/* For varying strings, don't exceed cur string length.   */
  dcl  lengthWord fixed bin(24) aligned based(parmP);
	varS = T;
	sourceL = min(sourceL, lengthWord);
	end;

     if sourceL = SizeStar then			/* Somehow, we have a star-extent.  Just note that fact.  */
	out = "[STRING of star extent]";
     else do;					/* For bit strings, let ioa_ do the conversion.	        */
	if bit_string_dtype(desc.type) then do;
	     if mod(sourceL,4) = 0 then do;		/*   - if mod(output_bit_count,4)=0, output hex format.   */
		if varS then
		     call ioa_$rsnnl("""^v.4b""b4", out, ioaL, divide(sourceL,4,35,0), bitV);
		else call ioa_$rsnnl("""^v.4b""b4", out, ioaL, divide(sourceL,4,35,0), bitS);
		end;
	     else if mod(sourceL,3) = 0 then do;	/*   - if mod(output_bit_count,3)=0, output octal format. */
		if varS then
		     call ioa_$rsnnl("""^v.3b""b3", out, ioaL, divide(sourceL,3,35,0), bitV);
		else call ioa_$rsnnl("""^v.3b""b3", out, ioaL, divide(sourceL,3,35,0), bitS);
		end;
	     else do;				/*   - otherwise, output a bit string constant.	        */
		if varS then
		     call ioa_$rsnnl("""^vb""b", out, ioaL, sourceL, bitV);
		else call ioa_$rsnnl("""^vb""b", out, ioaL, sourceL, bitS);
		end;
	     end;
						/* For character strings, let assign copy the string.     */
	else call assign_(addr(out), 2*varying_char_dtype, maxlength(out),
	          parmP, desc.type*2 + binary(^desc.aligned), sourceL);
	end;
     go to CONV_return;


CONV (CASEpointer):					/* For pointers, let ioa_ do the conversion.	        */
  dcl  my_ptr ptr;
     my_ptr = parmToPtrAligned (parmP, desc.aligned);	/* Convert packed ptr parameter to aligned pointer.       */

     call ioa_$rsnnl("^p", out, ioaL, my_ptr);
     go to CONV_return;


CONV (CASEentry):					/* For entry variables, output as a pair of pointers.     */
						/*  probe command uses this same format.	        */
  dcl  my_ent entry variable based(parmP);		/* Entry variables always aligned on even-word boundary.  */
     call ioa_$rsnnl("^p :: ^p", out, ioaL, codeptr(my_ent), environmentptr(my_ent));
     go to CONV_return;


CONV (CASEarea):					/* For area variables, just report area size.	        */
     call ioa_$rsnnl("area(^d)", out, ioaL, desc.size);	/*  NOTE: perhaps could call area_info_ here, and report  */
     go to CONV_return;				/*        on what it finds.  However, this is infrequent  */
						/*        data type as a parameter.		        */

CONV (0):						/* Complain if argCase does not support desc.type.        */
     call gripe(call_et_$dtype_unsupported, PROC,		/*   [Earlier tests of dtype should have ruled this out.] */
	"Output parameter type (^d) for: dcl parm^d ^a;", desc.type, i, descriptorString(listDescP) );
     return;


CONV_return:

  dcl  desc_bv bit(36) aligned based(listDescP);
  dcl  descOut char(200) var;
  dcl  outP char(20) varying;

     if src.ad.given & command then do;			/* For -addr DECLARATION, given indication that the       */
	call ioa_$rsnnl("^p -> ", outP, ioaL, parmP);	/*  output value was pointed to by the parameter.	        */
	out = outP || out;
	end;
     if debugOutput then do;				/* For debug entry, attach octal dump of parameter storage*/
	outDump = dump(parmP, desc);			/*  and set outD to information about parm descriptor.    */
	if length(out) + length(outDump) <= MaxLineLen then    
	     out = out || outDump;
	else out = out || NL || outDump;
	call ioa_$rsnnl("^12.3b  type=^a,^36t packed=^[T^;F^], size/prec=^d^[, scale=^d^;^s^]^[, dimensions=^d^;^s^]", 
	     outD, ioaL, desc_bv,
	     before(pl1_dtype_name(desc.type), "_dtype"), ^desc.aligned, desc.size, 
               desc.scale ^= 0, desc.scale, 
	     desc.dimensionsCount ^= 0, desc.dimensionsCount);
	end;
     else if command & src.xtra = XTRAoctal then do;	/* For non-debug entry, attach octal dump if -octal was   */
	outDump = dump(parmP, desc);			/*  given in arg_value_specification.		        */
	if length(out) + length(outDump) <= MaxLineLen then
	     out = out || outDump;
	else out = out || NL || outDump;
	end;
     if ^debugOutput & command & targ.case = CASEreturnsStar then do;
	call ioa_$rsnnl(				/* For non-debug entry, attach info about parm descriptor */
						/*  for returns(xxx(*)...) parameter.  Callee only set    */
						/*  this descriptor during the call.  We've never seen it */
						/*  until callee returns to call.		        */
	     " ^vx desc @ ^p^42t^12.3b  type=^a,^36t packed=^[T^;F^], size/prec=^d^[, scale=^d^;^s^]^[, dimensions=^d^;^s^]", 
	     descOut, ioaL, maxlength(s(parmI).id)-length("desc "), listDescP, desc_bv,
	     before(pl1_dtype_name(desc.type), "_dtype"), ^desc.aligned, desc.size, 
               desc.scale ^= 0, desc.scale, 
	     desc.dimensionsCount ^= 0, desc.dimensionsCount);
	out = out || NL || descOut;
	end;
     return;


parmToPtrAligned:					/* Convert packed pointer parm to aligned pointer.        */
     proc(P, isAligned) returns(ptr);
     
  dcl  P ptr;
  dcl  isAligned bit(1) aligned;

  dcl  my_ptr ptr;
  dcl  parm_ptr ptr based(P);
  dcl  parm_ptr_packed ptr unaligned based(P);

     if isAligned then
	return(parm_ptr);
     else return(parm_ptr_packed);

     end parmToPtrAligned;
%page;
/* ---------------------------------------- *
 * Internal proc of convertOutputArg that   *
 * creates octal dump of storage holding a  *
 * parameter of a given data type.          *
 * ---------------------------------------- */

dump:     
     proc(storeP, d) returns(char(1000) varying);

  dcl  storeP ptr;					/* ptr to storage to be dumped.		        */
  dcl 1 d aligned like target.desc;			/* decoded descriptor information		        */

  dcl  wordCount fixed bin(24);			/* length to be dumped (in words)		        */
  dcl  dumpRet char(1000) varying;			/* return string				        */

  dcl  ignoreCode fixed bin(35);
  dcl  maxDumpableWords fixed bin int static options(constant) init(76);
  dcl  outPrefix char(5) int static options(constant) init("     ");

  dcl  store (12*wordCount) fixed bin(3) unsigned unaligned based(storeP);
						/* Words to dump, as array of 3-bit nibbles (octal digits)*/
  dcl  i fixed bin;					/* Number digit being dumped.			        */

     call argStorageWords (d.type, d.aligned, d.size, wordCount, ignoreCode);
     wordCount = min(wordCount, maxDumpableWords);	/* Descriptor info determines count of words to dump.     */

     dumpRet = outPrefix;
     do i = lbound(store,1) to hbound(store,1);
	dumpRet = dumpRet || ltrim(char(store(i)));	/* Convert each 3-bit nibble to octal digit.	        */
	if mod(i,48) = 0 then dumpRet = dumpRet || NL || outPrefix;
						/* Start a new line after 4 words of storage.	        */
	else if mod(i,12) = 0 then dumpRet = dumpRet || " ";
						/* Separate each dumped word block.		        */
	end;
     return (dumpRet);
     end dump;

     end convertOutputArg;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Routine to setup argument handling for the main procedure.  It determines:		        */
	/*   invocation type:  command/active function					        */
	/*   gripe routine:    com_err_ or active_fnc_err_				        */
	/*   argument count								        */
	/*   af return arg								        */
	/*									        */
	/* It records argListP and argCount for use by argValue and argsRemain routines.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

argSetup:
     proc( arg_list, command, af_retP, af_retL, gripe);     

  dcl  arg_list ptr;				/* ptr to main procedure's argument list.            (in) */
  dcl  command bit(1) aligned;			/* =T for command, =F for active function	  (out) */
  dcl  af_retP ptr;					/* active function return string info.		  (out) */
  dcl  af_retL fixed bin(21);
  dcl  gripe entry options(variable) variable;		/* error reporting routine suited to command-type.  (out) */

  dcl  code fixed bin(35);				/* status code				        */

  dcl  active_fnc_err_ entry options (variable);
  dcl  com_err_ entry () options (variable);
  dcl  cu_$af_return_arg_rel entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);
  dcl  cu_$arg_count_rel entry (fixed bin, ptr, fixed bin(35));

     argListP = arg_list;				/* Save arg_list pointer for use in other arg-related fcns*/

     call cu_$af_return_arg_rel (argCount, af_retP, af_retL, code, arg_list);
     if code = error_table_$not_act_fnc then do;		/* Get all the data.			        */
          command = T;
          gripe = com_err_;
          call cu_$arg_count_rel (argCount, arg_list, code);
          code = 0;
	end;
     else do;
          command = F;
          gripe = active_fnc_err_;
	end;

     if code ^= 0 then do;
	call gripe (code, PROC, "When getting argument count and invocation method for ^a.", PROC);
	go to EXIT_call;
	end;

     end argSetup;


  dcl  argCount fixed bin;                                  /* Count of arguments in call command line.	        */
  dcl  argI fixed bin init (0);                             /* Index of call argument last examined by code below.    */
  dcl  argListP ptr;                                        /* Ptr to our argument list, needed when non-quick proc   */
                                                            /*  is used to examine the arguments.		        */
  dcl  argValueCount fixed bin init(0);			/* Count of arg_value_specifiers in command line.	        */

argsRemain:					/* Function to report whether any arguments to call       */
     proc () returns (bit (1) aligned);			/*  remain to be processed.			        */
     return (argI < argCount);
     end argsRemain;

argValueGetCount:					/* Subroutine to scan all command line arguments,         */
     proc (debug);					/*  counting the arg_value_specifier arg/option groups.   */

  dcl  debug fixed bin(3) unsigned;

  dcl  argI_saved fixed bin;
  dcl  gripe_saved entry variable;
  dcl 1 s aligned like source;
  dcl 1 o aligned like globalOpt;
  dcl  code fixed bin(35);

     if argsRemain() then do;
	argI_saved = argI;				/* Saved position in arg list.		        */
	gripe_saved = gripe;			/* Scan args silently (no errors).		        */
	gripe = argValueGetCount;

	call argValue (argValueCount+1, s, o, code);	/* Count arg_value_specifiers.		        */
	do while (code ^= error_table_$noarg);
	     argValueCount = argValueCount + 1;
	     call argValue (1, s, o, code);	     
	     end;
	
	argI = argI_saved;				/* Restore saved values.			        */
	gripe = gripe_saved;

	if debug >= 4 then do;			/* Report if user really wants to know.		        */
	     call ioa_ ("argValueCount = ^d", argValueCount);
	     end;
	end;

     end argValueGetCount;

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Routine to access positional arguments to call, one by one as they are needed.  It also        */
	/* handles:								        */
	/*  - per-positional-arg options, if any follow them;				        */
	/*  - global options that impact overall operation of call.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

argValue:
     proc (n, s, gOpt, code);

  dcl  n fixed bin;					/*  positional argument number. (in)		        */
  dcl 1 s aligned like source;			/*  arg_value_specification data (in)		        */
  dcl 1 gOpt aligned like globalOpt;			/*  global options in command line so far. (inout)        */
  dcl  code fixed bin (35);				/*  status code, reporting missing arg, conversion        */
						/*   error, unknown options, etc.		        */

  dcl  arg char(argL) based(argP);			/*  Next argument in call's argument list.  This may      */
  dcl  argFirst char(1) based(argP);			/*   be an option, or initial value for an argument       */
  dcl  argL fixed bin(21);				/*   to pass to virtualEntry, or the string	        */
  dcl  argP ptr;					/*   representation virtualEntry, itself.	        */

  dcl (argDcl,					/*  Operand following -addr is a string.	        */
       argDebug,					/*  Operand following -debug is an integer.	        */
       argID,					/*  Operand following -id is an identifier (ID).          */
       argInitVal,					/*  Operand following -in, -inout is the positional arg.  */
       argLen,					/*  Operand following -length is an integer or an ID.     */
       argMLen   ) bit(1) aligned init(F);		/*  Operand following -max_length is an integer.	        */

  dcl  dirValue fixed bin(3);

  dcl  startedArgValue bit(1) aligned init(F);		/*  Seen -in, -inout, -out, -ignore or non-control yet?   */

     code = 0;

  dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);

     do while (argsRemain());
	call cu_$arg_ptr_rel (argI+1, argP, argL, code, argListP);
						/* Conditionally read next argument to call command/af.   */

	/* process operands of control arguments. */
	if argInitVal then do;			/* Operand following -in or -inout		        */
	     argInitVal = F;
	     s.argP = argP; s.argL = argL;		/* Arg is the next positional arg (an initial value)      */
	     end;

	else if argDcl then do;			/* Operand following -dcl or -addr		        */
	     argDcl = F;
	     if  length(arg) > maxlength(s.dcl) & gripe ^= argValueGetCount  then do;
		call gripe (error_table_$bigarg, PROC, 
		     "Maximum declaration length (^d) exceeded: -addr ^a", maxlength(s.dcl), arg);
		go to ERROR_argValue;
		end;
	     s.dcl = arg;
	     end;
	
	else if argID then do;			/* Operand following -id			        */
	     argID = F;
	     call argNotID_Error(arg);		/*   Report an error for an invalid ID operand.	        */
	     s.id = arg;
	     end;
	
	else if argLen & argIsID(arg) then do;		/* Operand following -length looked like an ID	        */
	     argLen = F;
	     s.L = Lunset;
	     s.L_id = arg;
	     end;

	else if argLen | argMLen then do;		/* Operand for -length or -max_length		        */

  dcl  lengthVar fixed bin(24) aligned based(lengthP);
  dcl  lengthP ptr;
  dcl  option char(11) var;

	     if argLen then do;  argLen  = F;  lengthP = addr(s.L);  option = "-length";      s.L_id = "";  end;
	     else           do;  argMLen = F;  lengthP = addr(s.M);  option = "-max_length";		end;

               call assign(arg, F, lengthP, FIXED_BIN, ALIGNED, 24, 0, code);
               if  code ^= 0 & gripe ^= argValueGetCount  then do;
                    call gripe(error_table_$bad_conversion, PROC, "^a ^a", option, arg);
                    go to ERROR_argValue;
		end;
	     else if  lengthVar < 0 & gripe ^= argValueGetCount  then do;
                    call gripe(error_table_$bad_conversion, PROC, 
		     "Option value must be non-negative: ^a ^a", option, arg);
		go to ERROR_argValue;
		end;
	     end;

	else if argDebug then do;			/* Operand for global option: -debug		        */
               argDebug = F;
               call assign(arg, F, addr(gOpt.debug), FIXED_BIN_UNS, ALIGNED, 3, 0, code);
               if  code ^= 0 & gripe ^= argValueGetCount  then do;
                    call gripe(error_table_$bad_conversion, PROC, "-debug ^a", arg);
                    go to ERROR_argValue;
		end;
	     else if  gOpt.debug > 5 & gripe ^= argValueGetCount  then do;
                    call gripe(error_table_$bad_conversion, PROC, "Option value is an INT in range 0-5: -debug ^a", arg);
		go to ERROR_argValue;
		end;
	     end;

          /* Global options */                              
          else if arg = "-debug" | arg = "-db" then argDebug = T;
	else if arg = "-octal" | arg = "-oc" then s.xtra = XTRAoctal;
	else if arg = "-all"   | arg = "-a"  then s.xtra = XTRAall;

          /* arg_value directions (or direction-related options) */
	else if argValueStarter(arg, dirValue) then do;	
	     if startedArgValue then go to EXIT_argValue; /* Argument starts next argValue; so exit this loop.      */
	     go to ARG_VALUE_DIR(dirValue);
	     
ARG_VALUE_DIR(DIRunset):				/*  Arg is the next positional arg (an initial value)     */
	     s.argP = argP; s.argL = argL;	  go to ARG_VALUE_DIR_end;

ARG_VALUE_DIR(DIRin):
ARG_VALUE_DIR(DIRinout):
	     s.dir = dirValue;   argInitVal = T;  go to ARG_VALUE_DIR_end;

ARG_VALUE_DIR(DIRout):
ARG_VALUE_DIR(DIRignore):
               s.dir = dirValue;                    go to ARG_VALUE_DIR_end;

ARG_VALUE_DIR_end:
	     startedArgValue = T;
	     end;

          /* arg_value options */		
	else if startedArgValue then do;
	          if argIsFMT (arg, s) then;
	     else if arg = "-id"                         then   argID   = T;
               else if arg = "-return"     | arg = "-ret"  then   s.ret   = T;
   	     else if arg = "-length"     | arg = "-ln"   then   argLen  = T;	
	     else if arg = "-max_length" | arg = "-ml"   then   argMLen = T;
	     else if arg = "-declare"    | arg = "-dcl"  then   do;  s.meta  = METAdcl;   argDcl  = T;  end;
	     else if arg = "-addr"                       then   do;  s.meta  = METAaddr;  argDcl  = T;  end;
               else call gripe (error_table_$badopt, PROC, "Ignoring unsupported option: ^a", arg);
	     end;
	else call gripe (error_table_$inconsistent, PROC, "Must start an arg_value before using: ^a", arg);

	argI = argI + 1;				/* Count as processed the arg just examined above.        */
	end;

EXIT_argValue:
     code = error_table_$noarg;			/* Missing arg error, if any condition below is met.      */

     /* Exhausted arg_list without finding operand for one of our control args. */
     if argDebug then 
	call gripe (code, PROC, "-debug operand is an integer between 0 and 5.");
     else if argLen then
	call gripe (code, PROC, "-length operand is a non-negative integer or ID of another argument.");
     else if argMLen then
	call gripe (code, PROC, "-max_length operand is a non-negative integer.");
     else if argID then 
	call gripe (code, PROC, "-id operand is a PL/I identifier.");
     else if argDcl then 
	call gripe (code, PROC, "^a operand is a scalar PL/I declaration.", META.name(s.meta));

     /* Exhausted arg_list without finding an arg_value => error; otherwise, no error */
     else if startedArgValue then 
	code = 0;


ERROR_argValue:
     if gOpt.debug >= 5 then do;			/* Debug code. 				        */

  dcl  src char(s.argL) based(s.argP);

	call ioa_$nnl ("^[-- ^;    ^]^21a^[ ^;^] ^[^;-in ^;-inout ^;-out ^;-ignore ^]^[^a ^;^s^]^[^;-octal ^]", 
	     n=0, s.id || ":", n=0, s.dir+1, length(src)>0, src, s.xtra+1);
	if n = 0 & gOpt.debug > 0 then
	     call ioa_$nnl ("-debug ^d ", gOpt.debug);
	call ioa_ ("^[^s^;-dcl ""^a"" ^;-addr ""^a"" ^]^[^;-code ^;-date ^;-time ^;-date_time ^]^[-max_length ^d ^;^s^]^[-length ^d ^;^s^]^[-return ^;^]",
	     s.meta+1, s.dcl, s.fmt+1, s.M>0, s.M, s.L>0, s.L, s.ret);
	end;
     return;
%page;

argValueStarter:					/* Returns T if argument starts a new arg_value_spec      */
          proc (arg, dirValue) returns (bit(1) aligned);
     
  dcl  arg char(*);
  dcl  dirValue fixed bin(3);

  dcl  argFirst char(1) defined(arg);

  dcl  NUMERIC char(17) int static options(constant) init("+-.0123456789efEF");

	if  length(arg) = 0  then do;			/* Null char string is a valid input value.	        */
STARTER:	     dirValue = DIRunset;  return(T);  end;

	if  argFirst ^= "-" | arg = NULL_POINTER  then  go to STARTER;
						/* Any string not a -control_arg or null() pointer is     */
						/*  a valid input value.			        */
	if  verify(arg,NUMERIC) = 0               then  go to STARTER;
						/* Any negative number is a valid input value.	        */
	if  oct_or_hex_source(arg, ""b)	  then  go to STARTER;
						/* Any octal/hex bit representation starts arg_value      */
          dirValue = isMember (arg, DIR.tiny);		/* Of course, DIR values (-in, -out, ...) start an        */
	if  dirValue > -1  then return(T);		/*  arg_value_specification.			        */

          dirValue = isMember (arg, DIR.abbr);
	if  dirValue > -1  then return(T);

          dirValue = isMember (arg, DIR.name);
	if  dirValue > -1  then return(T);

	return(F);				/* Anything else does not start an arg_value_spec.        */


argIsFMT: entry (arg, s) returns (bit(1) aligned);	/* Returns T if argument is one of the FMT strings        */
	
  dcl 1 s aligned like source;			/*  arg_value_specification data (in)		        */
  dcl  fmtValue fixed bin(3);
	
	if argFirst ^= "-" then return(F);

	fmtValue = isMember (arg, FMT.name);
	if  fmtValue > FMTunset then do;
FMT_yes:	     s.fmt = fmtValue;
	     return(T);
	     end;
	
	fmtValue = isMember (arg, FMT.abbr);	     
	if  fmtValue > FMTunset then go to FMT_yes;
	return(F);
	

argNotID_Error:					/* Complains and exit argValue if -id ID has bad format.  */
	entry (arg);
     
  dcl  IDENTIFIER char(64) int static options(constant) init("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$");
  dcl  IDENTIFIERfirst char(52) int static options(constant) init("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

	if length(arg) < 1 then do;
	     if gripe ^= argValueGetCount then do;
		call gripe (error_table_$smallarg, PROC, "Empty identifier follows: -id");
		go to ERROR_argValue;
		end;
	     else return;
	     end;
	if  length(arg) > maxlength(s.id) & gripe ^= argValueGetCount  then do;
	     call gripe (error_table_$bigarg, PROC, 
		"Maximum identifier length (^d) exceeded: -id ^a", maxlength(s.id), arg);
	     go to ERROR_argValue;
	     end;
	if (verify(argFirst, IDENTIFIERfirst) ^= 0) | (verify(arg, IDENTIFIER) ^= 0) then do;
	     if gripe ^= argValueGetCount then do;
		call gripe (error_table_$badopt, PROC, "-id ^a is not a PL/I identifier.
<identifier> ::= <letter>[<letter>|<digit>|_|$]...", arg);
		go to ERROR_argValue;
		end;
	     end;
	return;
	

argIsID:	entry (arg) returns (bit(1) aligned);		/* Returns T if arg has ID format		        */

	if length(arg) < 1 then return(F);
	if length(arg) > maxlength(s.id) then return(F);
	if (verify(argFirst, IDENTIFIERfirst) ^= 0) | (verify(arg, IDENTIFIER) ^= 0) then return(F);
	return(T);

	end argValueStarter;


isMember: proc (item, array) returns(fixed bin);		/* Returns T if item is a member of string array.	        */

  dcl  item  char(*);
  dcl  array (*) char(*) var;

  dcl  i fixed bin;	
	do i = lbound(array,1) to hbound(array,1);
	     if item = array(i) then return(i);
	     end;
	return(-1);

	end isMember;

     end argValue;
%page;
/* ------------------------------------------------------------------- *
 * Convert argument descriptor to a string of PL/I data attributes.	 *
 * ------------------------------------------------------------------- */

descriptorString:					/* Returns character string declaration corresponding to  */
     proc (descP) returns (char (100) var);		/*  an argument descriptor.			        */

  dcl  descP ptr aligned;

  dcl  desc bit(36) aligned based(descP);

  dcl  code fixed bin(35);
  dcl  ret char(2000) var;

  dcl  get_pl1_parm_desc_string_ entry (ptr, char(*) var, fixed bin(35));

     ret = "";
     call get_pl1_parm_desc_string_ (descP, ret, code);
     if code ^= 0 then
	call gripe (code, PROC, "Error converting descriptor to string: ^.3b", desc);
     if length(ret) > 100 then
	call gripe (code, PROC, "Long descriptor string shortened to 100 chars: ^a", ret);
     return (ret);
     
     end descriptorString;

int2digits:					/* Converts an int to a 2-digit (or longer) string        */
     proc (int) returns(char(8) var);
     
  dcl  int fixed bin;
  dcl  digits char(8) var;
     
     if int < 10 then
	digits = "0";
     else digits = "";
     digits = digits || ltrim(char(int));

     return (digits);

     end int2digits;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Include files used by call.						        */
	/*   NB: A few include files define constants that are used to initialize declared constants.     */
	/*       These include files must appear before those declarations, and are therefore near the    */
	/*       top of call.pl1.  Most of the include files are shown below.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

%page;
%include translator_temp_alloc;
%page;
%include area_info;
%page;
%include arg_list;
%page;
%include arg_descriptor;
%page;
%include call_entry_info_;
%page;
%include encoded_precision;
%page;
%include system;
%page;
%include call_dtype_fcns;
     end call;
