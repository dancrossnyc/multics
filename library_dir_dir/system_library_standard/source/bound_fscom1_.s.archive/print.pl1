/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(68-04-28,Garman), approve(), audit(), install():
     Written by C. Garman.
  2) change(68-10-02,Garman), approve(), audit(), install():
     Modified to call write directly for entire segment or portion
      thereof, give ending-line request.
  3) change(69-07-16,Weaver), approve(), audit(), install():
     Modified by M. Weaver to change smm$initiate and some write_out
      calls.
  4) change(69-08-03,Voydock), approve(), audit(), install():
     Modified by V. Voydock.
  5) change(69-08-06,Weaver), approve(), audit(), install():
     Modified by M. Weaver (August 6 and August 8).
  6) change(69-08-11,Weaver), approve(), audit(), install():
     Modified by M. Weaver (add hcs_$status_minf)
  7) change(70-03-04,Karger), approve(), audit(), install():
     Modified by P. Karger (compiled under PL/I and prints date and time
      in header)
  8) change(70-03-25,Karger), approve(), audit(), install():
     Modified by P. Karger to change calls to tio_ to ios_
  9) change(70-06-19,Stone), approve(), audit(), install():
     Modified by E. Stone.
 10) change(76-10-27,VanVleck), approve(), audit(), install():
     Rewritten by THVV for new arguments, iox, etc.
 11) change(79-08-03,VanVleck), approve(), audit(), install():
     Modified by THVV for archive stuff.  Much help by MND.
 12) change(82-09-13,GDixon), approve(), audit(), install():
     Modified by G. Dixon -- when indenting, properly indent lines preceded
      by NP and VT chars.  Accept -in as short name for -indent (-ind).  Use
      prt_conv_ when -indent I is specified, where mod(I,10) ^= 0.  Fix bug
      which prevents -line_length from being honored.
 13) change(82-11-22,Wallman), approve(), audit(), install():
     Modified by E. Wallman:  Fixed bug that printed extra lines when -for
      was used with -pn.  Reformatted with format_pl1.
 14) change(82-11-24,Wallman), approve(), audit(), install():
     Modified by E. Wallman:  Fixed bug that left the last page short when
      -ppl and -no_vertsp were given.  Renamed many variables for readability.
 15) change(82-11-26,Wallman), approve(), audit(), install():
     Modified by E. Wallman:  Fixed remaining problems in error list thru #10.
 16) change(83-07-11,Texada), approve(), audit(), install():
     Modified by Greg Texada:  added -output_switch, -osw control args.
 17) change(83-09-28,GDixon), approve(), audit(), install():
     Modified by Gary Dixon:  simplify scheme for processing a line.
 18) change(83-12-01,Spitzer), approve(), audit(), install():
     Modified by C. Spitzer:  fix error msg, use pathname_.
 19) change(84-03-08,Spitzer), approve(), audit(), install():
     Modified by C. Spitzer:  use iox_$get_line to pause.
 20) change(84-07-10,Rochlis), approve(), audit(), install():
     Modified by Jon A. Rochlis:  do a reset_more control order before
      printing each file to make video users happy.
 21) change(84-08-21,Falksenj), approve(), audit(), install():
     Modified by J. A. Falksen:  utilize date_time_$format ("date_time",...
 22) change(85-01-10,Lippard), approve(85-01-30,MCR7165),
     audit(85-10-07,Blair), install(85-12-16,MR12.0-1001):
     Modified by Jim Lippard:  force vertsp mode when -vertsp is used, use
      initiate_file_ and terminate_file_, fix bug where -left_col blows up
      on first line of length greater than lc value.
 23) change(86-10-09,TLNguyen), approve(86-10-28,MCR7563),
     audit(86-10-29,Gilcrease), install(86-11-20,MR12.0-1217):
     Modified by Tai Nguyen: make the print command to display exactly
      n lines for a specified segment when the "-for" control argument
      was used.  Fixed an array subscriptrange codition at the run time
      when compiled with the following:
      -table -prefix size, strz, strg, subrg
 24) change(86-11-17,TLNguyen), approve(86-10-28,MCR7563),
     audit(86-11-17,Gilcrease), install(86-11-20,MR12.0-1217):
     Fixed bug which occurs when the line starts with a New Page character
     and the "-from" control argument is entered in the "print" command.
 25) change(86-11-26,TLNguyen), approve(86-11-26,MCR7563),
     audit(86-12-01,Gilcrease), install(86-12-02,MR12.0-1230):
     Fixed error which occurs when the two control arguments -for and -match
     work together in the print command.
 26) change(87-01-02,TLNguyen), approve(87-01-02,MCR7597),
     audit(87-01-09,Lippard), install(87-03-20,MR12.1-1006):
     Make the print command display an appropriative error message and do a
     reset_more control order between archive components for archive case.
 27) change(88-08-02,TLNguyen), approve(88-08-02,MCR7935),
     audit(88-08-30,Parisek), install(88-09-02,MR12.2-1097):
     make the print command with the -from_page P work as documented.
 28) change(89-04-28,Vu), approve(89-04-28,MCR8098), audit(89-05-08,Lee),
     install(89-06-09,MR12.3-1057):
     The print command will not enable the user's terminal mode to "vertsp".
     Delete all references to iox_$modes and sws.reset_modes by vp
     (phx20749 - Commands 514) and (phx20361 - Commands 762).
     Reformatted print.pl1
                                                   END HISTORY COMMENTS */


/* format: style2,ind3,ll80,dclind4,comcol51,linecom */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Name: print, pr						       */
/*							       */
/* print ASCII text file on user console.			       */
/*							       */
/* Note: There is a known bug in this program which is fixable only by an    */
/* unreasonable amount of effort.  The -match, -exclude, -from and -to       */
/* control arguments will not find their target strings if it happens that   */
/* they are split across MSF components. Fixing this bug would require a lot */
/* of hair, incluing a buffer somewhere big enough for the reassembly of the */
/* split line.  For now we ignore it.  Anybody who wants to fix it is        */
/* welcome to.						       */
/*							       */
/*							       */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * *  *  *  * */


print:
pr:
   procedure;

      dcl arg		   char (arg_len) unaligned based (arg_ptr);
      dcl arg_len		   fixed bin (21);
      dcl arg_list_ptr	   ptr;
      dcl arg_ptr		   ptr;
      dcl c		   fixed bin (35);
      dcl error_code	   fixed bin (35);
      dcl exclude_arg_count	   fixed bin;	/* number of -exclude args */
      dcl forcount		   fixed bin;	/* # of input lines to print */
      dcl from_line		   fixed bin;	/* starting line */
      dcl from_page		   fixed bin;	/* lowest page number to print */
      dcl from_regexpr	   char (from_regexpr_len + 2)
			   based (from_regexpr_ptr);
      dcl from_regexpr_len	   fixed bin (21);	/* length of above */
      dcl from_regexpr_ptr	   ptr;		/* starting reg exp */
      dcl iarg		   fixed bin;	/* arg number */
      dcl indentation	   fixed bin (21);	/* indentation */
      dcl input_path_count	   fixed bin;	/* number of pathnames (zero, one, or more) */
      dcl junk		   fixed bin;
      dcl last_count	   fixed bin;
      dcl left_col		   fixed bin;	/* left side of print band */
      dcl match_arg_count	   fixed bin;	/* number of -match args */
      dcl nargs		   fixed bin;	/* arg count */
      dcl output_buffer_size	   fixed bin;	/* size of print buffer */
      dcl out_switch	   ptr;		/* write output on this */
					/* switch; its assumed */
					/* attached & open for */
					/* stream output. */
      dcl right_col		   fixed bin;	/* right side of print band */
      dcl star_sel		   fixed bin (2);	/* branches, or branches+links */
      dcl switch_name	   char (32);	/* plain talk name of -osw */
      dcl to_line		   fixed bin;	/* ending line */
      dcl to_page		   fixed bin;	/* highest */
      dcl to_regexpr_len	   fixed bin (21);
      dcl to_regexpr_ptr	   ptr;		/* ending reg exp */

      dcl 1 sws,				/* switch bits */
	  2 check_lines	   bit (1),	/* TRUE if -match or -ex */
	  2 dont_want_archive  bit (1),	/* TRUE if print archive as big file */
	  2 from_line_given	   bit (1),
	  2 from_page_given	   bit (1),
	  2 had_an_arg	   bit (1),	/* TRUE if any arg */
	  2 last_given	   bit (1),
	  2 no_heading	   bit (1),	/* TRUE if dont want heading */
	  2 no_vertsp	   bit (1),	/* TRUE if simulating NP and VT */
	  2 one_iox_call	   bit (1),	/* TRUE if can do in one call to iox */
	  2 paging	   bit (1),	/* TRUE if paged output is wanted */
	  2 pause_after_page   bit (1),	/* TRUE if pause after page */
	  2 pause_before_print bit (1),	/* TRUE if pause before printing */
	  2 print_quick_way	   bit (1),	/* TRUE if can do without prt_conv */
	  2 print_trailing_nls bit (1),	/* TRUE if print some NLs at end like old print */
	  2 to_line_given	   bit (1),
	  2 to_page_given	   bit (1),
	  2 want_heading	   bit (1),	/* TRUE if print heading */
	  2 want_line_numbers  bit (1);	/* TRUE if print line numbers */

      dcl archive_$next_component_info
			   entry (ptr, fixed bin (24), ptr, ptr,
			   fixed bin (35));
      dcl check_star_name_$entry entry (char (*), fixed bin (35));
      dcl com_err_		   entry options (variable);
      dcl cu_$arg_count	   entry (fixed bin, fixed bin (35));
      dcl cu_$arg_list_ptr	   entry (ptr);
      dcl cu_$arg_ptr	   entry (fixed bin, ptr, fixed bin (21),
			   fixed bin (35));
      dcl cu_$arg_ptr_rel	   entry (fixed bin, ptr, fixed bin (21),
			   fixed bin (35), ptr);
      dcl cv_dec_check_	   entry (char (*), fixed bin (35))
			   returns (fixed bin);
      dcl date_time_$format	   entry (char (*), fixed bin (71), char (*),
			   char (*)) returns (char (250) var);
      dcl expand_pathname_$component
			   entry (char (*), char (*), char (*), char (*),
			   fixed bin (35));
      dcl get_system_free_area_  entry () returns (ptr);
      dcl hcs_$star_	   entry (char (*), char (*), fixed bin (2), ptr,
			   fixed bin, ptr, ptr, fixed bin (35));
      dcl hcs_$status_minf	   entry (char (*), char (*), fixed bin (1),
			   fixed bin (2), fixed bin (24), fixed bin (35));
      dcl initiate_file_	   entry (char (*), char (*), bit (*), ptr,
			   fixed bin (24), fixed bin (35));
      dcl ioa_$ioa_switch	   entry options (variable);
      dcl ioa_$ioa_switch_nnl	   entry options (variable);
      dcl ioa_$rsnp		   entry options (variable);
      dcl iox_$control	   entry (ptr, char (*), ptr, fixed bin (35));
      dcl iox_$get_line	   entry (ptr, ptr, fixed bin (21),
			   fixed bin (21), fixed bin (35));
      dcl iox_$look_iocb	   entry (char (*), ptr, fixed bin (35));
      dcl iox_$put_chars	   entry (ptr, ptr, fixed bin (21),
			   fixed bin (35));
      dcl match_star_name_	   entry (char (*), char (*), fixed bin (35));
      dcl msf_manager_$close	   entry (ptr);
      dcl msf_manager_$get_ptr   entry (ptr, fixed bin, bit (1), ptr,
			   fixed bin (24), fixed bin (35));
      dcl msf_manager_$open	   entry (char (*), char (*), ptr, fixed bin (35))
			   ;
      dcl pathname_		   entry (char (*), char (*))
			   returns (char (168));
      dcl pathname_$component	   entry (char (*), char (*), char (*))
			   returns (char (194));
      dcl print_conv_$print_conv_
			   entry;
      dcl prt_conv_		   entry (ptr, fixed bin (21), ptr,
			   fixed bin (21), ptr);
      dcl search_file_	   entry (ptr, fixed bin (21), fixed bin (21),
			   ptr, fixed bin (21), fixed bin (21),
			   fixed bin (21), fixed bin (21), fixed bin (35))
			   ;
      dcl search_file_$silent	   entry (ptr, fixed bin (21), fixed bin (21),
			   ptr, fixed bin (21), fixed bin (21),
			   fixed bin (21), fixed bin (21), fixed bin (35))
			   ;
      dcl terminate_file_	   entry (ptr, fixed bin (24), bit (*),
			   fixed bin (35));

      dcl (addr, clock, codeptr, divide, index, length, max, min, mod, null,
	reverse, rtrim, search, string, substr, sum, unspec)
			   builtin;
      dcl cleanup		   condition;

      dcl CR		   char (1) int static options (constant)
			   init ("");
      dcl NL		   char (1) int static options (constant) init ("
");
      dcl NLCRVTNP		   char (4) int static options (constant) init ("
");
      dcl NP		   char (1) int static options (constant) init ("");
      dcl NUL		   char (1) int static options (constant)
			   init (" ");
      dcl VT		   char (1) int static options (constant) init ("");
      dcl LONGEST_SEARCH_FILE_REXP
			   fixed bin static options (constant) init (132);
      dcl MAX_BUFFER_LTH	   fixed bin int static options (constant)
			   init (1025);	/* types returned by check_star_name_ */
      dcl 1 type		   static options (constant),
	  2 NOSTAR	   fixed bin (35) init (0),
	  2 STAR		   fixed bin (35) init (1),
	  2 STARSTAR	   fixed bin (35) init (2);
      dcl TERMINATE_SEG	   bit (4) internal static options (constant)
			   init ("0010"b);

      dcl error_table_$bad_conversion
			   fixed bin (35) ext static;
      dcl error_table_$badopt	   fixed bin (35) ext static;
      dcl error_table_$dirseg	   fixed bin (35) ext static;
      dcl error_table_$inconsistent
			   fixed bin (35) ext static;
      dcl error_table_$long_record
			   fixed bin (35) ext static;
      dcl error_table_$noarg	   fixed bin (35) ext static;
      dcl error_table_$no_component
			   fixed bin (35) ext static;
      dcl error_table_$nomatch   fixed bin (35) ext static;
      dcl error_table_$regexp_undefined
			   fixed bin (35) ext static;
      dcl error_table_$zero_length_seg
			   fixed bin (35) ext static;
      dcl iox_$user_input	   ptr ext static;
      dcl iox_$user_output	   ptr ext static;
%page (2);
/* ======================================================== */

/* Set up default values */

      star_sel = star_BRANCHES_ONLY;		/* default is -no_chase */
      from_line, from_page = 1;		/* default is to print whole file */
      to_page = -1;
      match_arg_count, exclude_arg_count, to_line, indentation, forcount,
	 from_regexpr_len, to_regexpr_len, input_path_count = 0;
      string (sws) = "0"b;
      right_col = MAX_BUFFER_LTH;
      last_count, left_col = 1;

      pcip = addr (PCI);
      unspec (PCI) = ""b;
      pci.cv_proc = codeptr (print_conv_$print_conv_);
      pci.line = 1;
      pci.phys_line_length = MAX_BUFFER_LTH;
      pci.ctl_char = "1"b;
      pci.lpi = 6;
      pci.sheets_per_page = 1;
      pci.top_label_line = "";
      pci.bot_label_line = "";
      pci.overflow_off = "1"b;		/* Don't put in NP */
      pci.label_wksp = null;
      pci.label_nelem = 0;
      switch_name = "user_output";		/* default switch */
      out_switch = iox_$user_output;

/* Analyze all the control arguments. */

      call cu_$arg_list_ptr (arg_list_ptr);
      call cu_$arg_count (nargs, error_code);
      if error_code ^= 0
      then
         do;
	  call com_err_ (error_code, "print");	/* can't be AF */
	  return;
         end;

      do iarg = 1 to nargs;			/* preprocess the args */
         call cu_$arg_ptr (iarg, arg_ptr, arg_len, error_code);
         if error_code ^= 0
         then
	  do;
ARG_READ_ERR:
	     call com_err_ (error_code, "print", "Argument ^d.", iarg);
RETURN:
	     return;
	  end;

         if index (arg, "-") ^= 1		/* number or pathname? */
         then
	  do;
	     junk = cv_dec_check_ (arg, error_code);

	     if error_code = 0		/* its a number */
	     then
	        do;
		 if input_path_count = 0	/* make "print 0" work as it used to */
		 then goto its_a_name;

		 if junk = 0		/* 0's are not allowed */
		 then
		    do;
		       error_code = error_table_$bad_conversion;
		       goto ARG_ERR;
		    end;

		 if ^sws.from_line_given
		 then
		    do;
		       from_line = junk;
		       sws.from_line_given = "1"b;
		    end;

		 else if ^sws.to_line_given
		 then
		    do;
		       to_line = junk;
		       sws.to_line_given = "1"b;
		    end;

		 else
		    do;
		       call com_err_ (error_table_$inconsistent, "print",
			  "Only one line range is allowed. ^a", arg);
		       return;
		    end;
		 sws.had_an_arg = "1"b;
	        end;

	     else
	        do;			/* non-numeric */
		 if search (arg, "*?") ^= 0	/* pretend starname matches 2 */
		 then input_path_count = input_path_count + 1;
its_a_name:				/* count file names */
		 input_path_count = input_path_count + 1;
	        end;
	  end;

         else
	  do;
	     sws.had_an_arg = "1"b;

	     if arg = "-name" | arg = "-nm"
	     then
	        do;
		 iarg = iarg + 1;

		 if iarg > nargs
		 then
		    do;
miss_arg:
		       call com_err_ (error_table_$noarg, "print",
			  "After ^a.", arg);
		       return;
		    end;			/* count file names */
		 input_path_count = input_path_count + 1;
	        end;

	     else if arg = "-from" | arg = "-fm"
	     then call GET_FROM_TO (sws.from_line_given, from_regexpr_ptr,
		     from_regexpr_len, from_line);

	     else if arg = "-to"
	     then call GET_FROM_TO (sws.to_line_given, to_regexpr_ptr,
		     to_regexpr_len, to_line);

	     else if arg = "-for"
	     then forcount = GETNUM ();

	     else if arg = "-from_page"
	     then
	        do;
		 sws.from_page_given = "1"b;
		 from_page = GETNUM ();
	        end;

	     else if arg = "-to_page"
	     then
	        do;
		 sws.to_page_given = "1"b;
		 to_page = GETNUM ();
	        end;

	     else if arg = "-indent" | arg = "-ind" | arg = "-in"
	     then indentation = GETNUM ();

	     else if arg = "-last" | arg = "-lt"
	     then
	        do;
		 sws.last_given = "1"b;
		 last_count = GETNUM ();
	        end;

	     else if arg = "-left_col" | arg = "-lc"
	     then left_col = GETNUM ();

	     else if arg = "-right_col" | arg = "-rc"
	     then right_col = GETNUM ();

	     else if arg = "-line_length" | arg = "-ll"
	     then pci.phys_line_length = GETNUM ();

	     else if arg = "-page_length" | arg = "-pl"
	     then
	        do;
		 pci.page_length = GETNUM ();
		 pci.overflow_off = "0"b;	/* Do NP */
	        end;

	     else if arg = "-phys_page_length" | arg = "-ppl"
	     then pci.phys_page_length = GETNUM ();

	     else if arg = "-stop" | arg = "-sp"
	     then
	        do;			/* pause after each page */
		 sws.pause_after_page = "1"b;
		 sws.pause_before_print = "1"b;
	        end;

	     else if arg = "-wait" | arg = "-wt"
	     then sws.pause_before_print = "1"b;

	     else if arg = "-header" | arg = "-he"
	     then
	        do;
		 sws.want_heading = "1"b;
		 sws.no_heading = "0"b;
	        end;

	     else if arg = "-no_header" | arg = "-nhe"
	     then sws.no_heading = "1"b;

	     else if arg = "-no_archive" | arg = "-nac"
	     then sws.dont_want_archive = "1"b;

	     else if arg = "-archive" | arg = "-ac"
	     then sws.dont_want_archive = "0"b;

	     else if arg = "-no_vertsp"
	     then sws.no_vertsp = "1"b;

	     else if arg = "-vertsp"
	     then sws.no_vertsp = "0"b;

	     else if arg = "-match"
	     then
	        do;
		 if iarg >= nargs
		 then goto miss_arg;

		 iarg = iarg + 1;
		 match_arg_count = match_arg_count + 1;
	        end;

	     else if arg = "-ex" | arg = "-exclude"
	     then
	        do;
		 if iarg >= nargs
		 then goto miss_arg;

		 iarg = iarg + 1;
		 exclude_arg_count = exclude_arg_count + 1;
	        end;

	     else if arg = "-number" | arg = "-nb"
	     then sws.want_line_numbers = "1"b;

	     else if arg = "-chase"
	     then star_sel = star_ALL_ENTRIES;

	     else if arg = "-no_chase"
	     then star_sel = star_BRANCHES_ONLY;

	     else if arg = "-output_switch" | arg = "-osw"
	     then
	        do;
		 iarg = iarg + 1;
		 call cu_$arg_ptr (iarg, arg_ptr, arg_len, error_code);
		 if error_code ^= 0
		 then goto ARG_READ_ERR;

		 call iox_$look_iocb (arg, out_switch, error_code);
		 if error_code ^= 0
		 then
		    do;
		       call com_err_ (error_code, "print",
			  "Looking for output switch ^a", arg);
		       goto RETURN;
		    end;
		 switch_name = arg;
	        end;

	     else
	        do;			/* illegal */
		 error_code = error_table_$badopt;
ARG_ERR:
		 call com_err_ (error_code, "print", "^a", arg);
		 return;
	        end;
	  end;
      end;

/* Control arguments are processed */

      if input_path_count = 0
      then
         do;
	  call com_err_ (error_table_$noarg, "print", "No pathname given.");
	  return;
         end;

      if (switch_name ^= "user_output")
	 & (sws.pause_before_print | sws.pause_after_page)
      then				/* Can't give -stop or */
         do;				/* -wait with -osw */
	  call com_err_ (error_table_$inconsistent, "print",
	       "-output_switch cannot be used with ^[-stop^;-wait^].",
	       sws.pause_after_page);
	  return;
         end;

      if (sws.to_page_given | sws.from_page_given)
	 & (sws.from_line_given | sws.to_line_given)
      then
         do;
	  call com_err_ (error_table_$inconsistent, "print",
	       "Page and line specifiers cannot be used together.");
	  return;
         end;

      if sws.from_line_given & sws.last_given
      then
         do;
	  call com_err_ (error_table_$inconsistent, "print",
	       "-from and -last cannot be used together.");
	  return;
         end;

      if sws.to_line_given & sws.from_line_given & to_line < from_line
	 & from_regexpr_len + to_regexpr_len = 0/* but no REs in the range */
      then
         do;
	  call com_err_ (error_table_$inconsistent, "print",
	       "-from ^d > -to ^d", from_line, to_line);
	  return;
         end;

      if sws.from_page_given & sws.to_page_given & to_page < from_page
      then
         do;
	  call com_err_ (error_table_$inconsistent, "print",
	       "-from_page ^d > -to_page ^d", from_page, to_page);
	  return;
         end;

      if right_col < left_col
      then
         do;
	  call com_err_ (error_table_$inconsistent, "print",
	       "-left_col ^d > -right_col ^d", left_col, right_col);
	  return;
         end;

      if pci.phys_line_length < 5		/* prt_conv_ cannot handle length < 5. */
      then				/* It gives fatal process errors when  */
         do;				/* attempting to process HT char. */
	  call com_err_ (0, "print",
	       "Implementation restriction: -line_length must be greater than 4."
	       );
	  return;
         end;

      sws.check_lines = match_arg_count > 0 | exclude_arg_count > 0;

      sws.paging =
	 (pci.page_length ^= 0) | (pci.phys_page_length ^= 0)
	 | sws.from_page_given | sws.to_page_given;

      sws.print_quick_way =
	 (left_col <= 1) & (right_col = MAX_BUFFER_LTH)
	 & (pci.phys_line_length = MAX_BUFFER_LTH) & (^sws.paging)
	 & (mod (indentation, 10) = 0) & (^sws.no_vertsp);

      sws.one_iox_call =
	 (forcount = 0) & ^sws.from_page_given & ^sws.to_page_given
	 & (indentation = 0) & ^sws.pause_after_page & ^sws.no_vertsp
	 & ^sws.from_line_given & ^sws.to_line_given & ^sws.last_given
	 & ^sws.check_lines & ^sws.want_line_numbers;

      output_buffer_size = min (pci.phys_line_length, MAX_BUFFER_LTH);

      if right_col = MAX_BUFFER_LTH
      then right_col = output_buffer_size;

      if pci.phys_line_length = MAX_BUFFER_LTH
      then pci.phys_line_length = output_buffer_size;

      pci.rmarg = output_buffer_size;

      if pci.page_length = 0
      then pci.page_length = 131071;

      if pci.phys_page_length = 0
      then pci.phys_page_length = 66;

      if input_path_count = 1 & ^sws.had_an_arg	/* old way? */
      then sws.want_heading, sws.print_trailing_nls = "1"b;

      else if input_path_count > 1
      then sws.want_heading = "1"b;		/* default to head if many segs */

      if sws.no_heading
      then sws.want_heading = "0"b;		/* .. but may over-ride */

      match_arg_count = max (match_arg_count, 1); /* Illegal PL/I to have match_arg_count = 0 */
      exclude_arg_count = max (exclude_arg_count, 1);
					/* .. anything to make Monte happy */
%page (2);
/* ------------------------------------------------------- */

GET_FROM_TO:
   proc (bv_had, bv_regexpr_ptr, bv_regexpr_len, bv_line);

      dcl bv_had		   bit (1),
	bv_regexpr_ptr	   ptr,
	bv_regexpr_len	   fixed bin (21),
	bv_line		   fixed bin;

      dcl range_arg		   char (6) var;

      if iarg >= nargs			/* nothing to look at? */
      then goto miss_arg;

      range_arg = arg;
      iarg = iarg + 1;

      call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len, error_code, arg_list_ptr);
      if error_code ^= 0
      then goto ARG_READ_ERR;

      junk = cv_dec_check_ (arg, error_code);

      if bv_had				/* if we have already had */
      then
         do;				/* one of these */
	  call com_err_ (error_table_$inconsistent, "print",
	       "Only one line range is allowed. ^a ^[^i^;^s^a^]", range_arg,
	       (error_code ^= 0), junk, arg);
	  goto RETURN;
         end;

      bv_had = "1"b;			/* well, we have one one */

      if arg_len >= 2 &			/* check for /RE/ */
	 index (arg, "/") = 1 & index (reverse (arg), "/") = 1
      then
         do;
	  if arg_len = 2
	  then error_code = error_table_$regexp_undefined;
	  else call search_file_$silent (arg_ptr, 2, arg_len - 2, arg_ptr, 1,
		  arg_len, 0, 0, error_code);
	  if error_code ^= 0 & error_code ^= error_table_$nomatch
	  then
	     do;
	        call com_err_ (error_code, "print", "^a ^a", range_arg, arg);
	        goto RETURN;
	     end;

	  if arg_len > LONGEST_SEARCH_FILE_REXP + 2
	  then				/* too long? */
	     do;
	        call com_err_ (0, "print",
		   "Regular expressions may not be longer than ^d characters. ^/^-^a",
		   LONGEST_SEARCH_FILE_REXP + 2, arg);
	        goto RETURN;
	     end;

	  bv_regexpr_ptr = arg_ptr;
	  bv_regexpr_len = arg_len - 2;
         end;

      else
         do;
	  bv_line = cv_dec_check_ (arg, error_code);
	  if error_code ^= 0 | bv_line < 1
	  then
	     do;
	        error_code = error_table_$bad_conversion;
ARG_OPERAND_ERR:
	        call com_err_ (error_code, "print", "^a ^a", range_arg, arg);
	        go to RETURN;
	     end;
         end;

      return;

/* ------------------------------------------------------- */

GETNUM:
   entry () returns (fixed bin);

      dcl answer		   fixed bin;

      range_arg = arg;
      iarg = iarg + 1;			/* yes */
      call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len, error_code, arg_list_ptr);
      if error_code ^= 0
      then goto ARG_READ_ERR;

      answer = cv_dec_check_ (arg, error_code);
      if error_code ^= 0 | answer < 1
      then
         do;
	  error_code = error_table_$bad_conversion;
	  goto ARG_OPERAND_ERR;
         end;
      return (answer);

   end GET_FROM_TO;
%page;
/* Make a second pass over the arguments and store operands of -match & -exclude */

      begin;				/* needed because of adjustable arrays */

         dcl arg_token	      char (6) var;
         dcl star_area	      area based (star_area_ptr);
         dcl star_area_ptr	      ptr;
         dcl star_entry_array	      (star_entry_count) fixed bin
			      based (star_entry_array_ptr);
         dcl star_entry_array_ptr   ptr;
         dcl match_string_ptr	      (match_arg_count) ptr;
         dcl match_string_len	      (match_arg_count) fixed bin (21);
         dcl match_string_count     fixed bin;
         dcl exclude_string_ptr     (exclude_arg_count) ptr;
         dcl exclude_string_len     (exclude_arg_count) fixed bin (21);
         dcl exclude_string_count   fixed bin;
         dcl ever_printed	      bit (1);	/* global this command */
         dcl ever_had_err	      bit (1);
         dcl ever_found_from	      bit (1);
         dcl ever_found_page	      bit (1);
         dcl seg_ptr	      ptr;	/* -> msf component */
         dcl FCB_ptr	      ptr;	/* -> FCB for msf */
         dcl had_err	      bit (1);
         dcl dir_name	      char (168);	/* directory name */
         dcl entry_name	      char (32);
         dcl archive_element	      char (32);
         dcl entry_star_type	      fixed bin (35);
         dcl archive_element_star_type
			      fixed bin (35);
         dcl archive_elements_found bit (1);
         dcl star_entry_array_index fixed bin;
         dcl star_entry_name	      char (32);

         ever_printed, ever_had_err, ever_found_from, ever_found_page = "0"b;
         match_string_count, exclude_string_count = 0;

         if sws.check_lines
         then
	  do iarg = 1 to nargs;
	     call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len, error_code,
		arg_list_ptr);
	     if error_code ^= 0
	     then goto ARG_READ_ERR;

	     if arg = "-match"
	     then
	        do;
		 iarg = iarg + 1;
		 call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len, error_code,
		      arg_list_ptr);
		 if error_code ^= 0
		 then goto ARG_READ_ERR;

		 if arg_len >= 2 &		/* check for /RE/ */
		      index (arg, "/") = 1 & index (reverse (arg), "/") = 1
		 then
		    do;

		       if arg_len = 2
		       then c = error_table_$regexp_undefined;
		       else call search_file_$silent (arg_ptr, 2,
			       arg_len - 2, arg_ptr, 1, arg_len, 0, 0, c);
		       if c ^= 0 & c ^= error_table_$nomatch
		       then
			do;
			   call com_err_ (c, "print", "-match ^a", arg);
			   goto RETURN;
			end;
		    end;

		 match_string_count = match_string_count + 1;
		 match_string_ptr (match_string_count) = arg_ptr;
		 match_string_len (match_string_count) = arg_len;
	        end;

	     else if arg = "-ex" | arg = "-exclude"
	     then
	        do;
		 arg_token = arg;
		 iarg = iarg + 1;
		 call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len, error_code,
		      arg_list_ptr);
		 if error_code ^= 0
		 then goto ARG_READ_ERR;

		 if arg_len >= 2 &		/* check for RE */
		      index (arg, "/") = 1 & index (reverse (arg), "/") = 1
		 then
		    do;

		       if arg_len = 2
		       then c = error_table_$regexp_undefined;
		       else call search_file_$silent (arg_ptr, 2,
			       arg_len - 2, arg_ptr, 1, arg_len, 0, 0, c);
		       if c ^= 0 & c ^= error_table_$nomatch
		       then
			do;
			   call com_err_ (c, "print", "^a ^a", arg_token,
			        arg);
			   goto RETURN;
			end;
		    end;

		 exclude_string_count = exclude_string_count + 1;
		 exclude_string_ptr (exclude_string_count) = arg_ptr;
		 exclude_string_len (exclude_string_count) = arg_len;
	        end;			/**/

	     else if arg = "-name" | arg = "-nm"/* NAME can also look like a ctlarg */
	     then iarg = iarg + 1;
	  end;

         star_area_ptr = get_system_free_area_ ();
         star_names_ptr, star_entry_ptr, star_entry_array_ptr, seg_ptr,
	    FCB_ptr = null;

         on cleanup call CLEANER;

         input_path_count = 0;

/* Make third pass over arguments to print each file named. */

         do iarg = 1 to nargs;
	  had_err = "0"b;
	  call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len, error_code,
	       arg_list_ptr);
	  if error_code ^= 0
	  then goto ARG_READ_ERR;

	  junk = cv_dec_check_ (arg, error_code);
	  if error_code = 0 & input_path_count > 0
	  then ;				/* ignore numeric args */

	  else if index (arg, "-") = 1
	  then
	     do;				/* skip other ctls */
	        if arg = "-name" | arg = "-nm"
	        then
		 do;
		    iarg = iarg + 1;
		    call cu_$arg_ptr_rel (iarg, arg_ptr, arg_len,
		         error_code, arg_list_ptr);
		    if error_code ^= 0
		    then goto ARG_READ_ERR;

		    goto segname;
		 end;

	        else if arg = "-from" | arg = "-fm" | arg = "-to"
		   | arg = "-for" | arg = "-from_page" | arg = "-to_page"
		   | arg = "-indent" | arg = "-ind" | arg = "-in"
		   | arg = "-left_col" | arg = "-lc" | arg = "-right_col"
		   | arg = "-rc" | arg = "-line_length" | arg = "-ll"
		   | arg = "-page_length" | arg = "-pl"
		   | arg = "-phys_page_length" | arg = "-ppl"
		   | arg = "-match" | arg = "-exclude" | arg = "-ex"
		   | arg = "-output_switch" | arg = "-osw" | arg = "-last"
		   | arg = "-lt"
	        then iarg = iarg + 1;
	     end;

	  else
	     do;				/* non-ctl arg */
segname:
	        call expand_pathname_$component (arg, dir_name, entry_name,
		   archive_element, error_code);
	        if error_code ^= 0
	        then goto ARG_ERR;

	        input_path_count = input_path_count + 1;

	        call check_star_name_$entry (entry_name, entry_star_type);

	        if entry_star_type ^= type.NOSTAR
		   & entry_star_type ^= type.STAR
		   & entry_star_type ^= type.STARSTAR
	        then
		 do;
		    had_err = "1"b;
		    call com_err_ (entry_star_type, "print", "^a",
		         entry_name);
		 end;

	        else
		 do;
		    if archive_element = ""
		    then archive_element_star_type = type.NOSTAR;
		    else call check_star_name_$entry (archive_element,
			    archive_element_star_type);

		    if archive_element_star_type ^= type.NOSTAR
		         & archive_element_star_type ^= type.STAR
		         & archive_element_star_type ^= type.STARSTAR
		    then
		       do;
			had_err = "1"b;
			call com_err_ (archive_element_star_type, "print",
			     "^a", archive_element);
		       end;

		    else
		       do;
			archive_elements_found = "0"b;

			if entry_star_type = type.NOSTAR
			then		/* No stars */
			     call PRINT_ONE_ENTRYNAME (dir_name,
				entry_name, archive_element,
				star_SEGMENT);

			else
			   do;		/* Has stars */
			      call hcs_$star_ (dir_name, entry_name,
				 star_sel, star_area_ptr,
				 star_entry_count, star_entry_ptr,
				 star_names_ptr, error_code);
			      if error_code ^= 0
			      then
			         do;
				  call com_err_ (error_code, "print",
				       "^a",
				       pathname_ (dir_name, entry_name))
				       ;
				  had_err = "1"b;
			         end;

			      else
			         do;	/* Found some */
				  allocate star_entry_array
				       set (star_entry_array_ptr)
				       in (star_area);
					/* print starname segs in alpha order */
				  do star_entry_array_index = 1
				       to star_entry_count;
				     star_entry_array (
					star_entry_array_index) =
					star_entry_array_index;
				  end;

				  call SORT_STAR_ARRAY;

				  do star_entry_array_index = 1
				       to star_entry_count;
				     star_entry_name =
					star_names (
					star_entries (
					star_entry_array (
					star_entry_array_index))
					.nindex);
				     call PRINT_ONE_ENTRYNAME (dir_name,
					star_entry_name,
					archive_element,
					(
					star_entries (
					star_entry_array (
					star_entry_array_index)).type)
					);
				  end;
			         end;

			      call CLEANER; /* Free storage */
			   end;
		       end;
		 end;

	        if ^had_err & archive_element ^= "" & ^archive_elements_found
	        then
		 do;
		    had_err = "1"b;		/* fix bug for TR number 20687 */
		    error_code = error_table_$no_component;
					/* end of fixing bug */
		    call com_err_ (error_code, "print", "^a",
		         pathname_$component (dir_name, entry_name,
		         archive_element));
		 end;
	     end;

	  if had_err
	  then ever_had_err = "1"b;
         end;

         if ^ever_printed & ^ever_had_err
         then
	  do;				/* gotta tell him something for his dime */
	     if sws.from_line_given & ^ever_found_from & ^sws.last_given
	     then if from_regexpr_len > 0
		then call com_err_ (0, "print", "^a not matched.",
			from_regexpr);
		else call com_err_ (0, "print", "Line ^d not found.",
			from_line);

	     else if sws.from_page_given & ^ever_found_page
	     then call com_err_ (0, "print", "Page ^d not found.", from_page);

	     else call com_err_ (0, "print", "No lines selected.");
	  end;

         else if sws.print_trailing_nls & ^ever_had_err
         then call ioa_$ioa_switch (out_switch, "^/");


/*         return;				/* Normal program exit (from inside begin block) */

/* ------------------------------------------------------- */

SORT_STAR_ARRAY:
   proc;

      dcl d		   fixed bin,
	swap		   bit (1),
	t		   fixed bin;

      d = star_entry_count;
      do while (d > 1);
         d = divide (d + 1, 2, 17, 0);
         swap = "1"b;
         do while (swap);
	  swap = "0"b;
	  do star_entry_array_index = 1 to star_entry_count - d;
	     if star_names (
		star_entries (star_entry_array (star_entry_array_index))
		.nindex)
		>
		star_names (
		star_entries (star_entry_array (star_entry_array_index + d))
		.nindex)
	     then
	        do;
		 swap = "1"b;
		 t = star_entry_array (star_entry_array_index);
		 star_entry_array (star_entry_array_index) =
		      star_entry_array (star_entry_array_index + d);
		 star_entry_array (star_entry_array_index + d) = t;
	        end;
	  end;
         end;
      end;

   end SORT_STAR_ARRAY;
%page;
CLEANER:
   proc;

      if star_names_ptr ^= null
      then free star_names in (star_area);

      if star_entry_ptr ^= null
      then free star_entries in (star_area);

      if star_entry_array_ptr ^= null
      then free star_entry_array in (star_area);

      if FCB_ptr ^= null
      then call msf_manager_$close (FCB_ptr);

      else if seg_ptr ^= null
      then call terminate_file_ (seg_ptr, (0), TERMINATE_SEG, (0));

      star_names_ptr, star_entry_ptr, star_entry_array_ptr, seg_ptr, FCB_ptr =
	 null;

   end CLEANER;
%page (2);
/* ------------------------------------------------------- */

/* This subroutine handles the file system stuff.
   It knows how to handle MSFs and archives. */

PRINT_ONE_ENTRYNAME:
   proc (dirname, ename, arch_elem_wanted, en_type);

      dcl dirname		   char (168);	/* (arg) directory */
      dcl ename		   char (32);	/* (arg) entry */
      dcl arch_elem_wanted	   char (32);	/* (arg) element */
      dcl en_type		   fixed bin (2) uns;
					/* (arg) whether to bitch */

      dcl 1 sws1,				/* switch bits */
	  2 doing_archive	   bit (1),	/* TRUE if doing an archive */
	  2 found_first	   bit (1),	/* flags for line select */
	  2 found_last	   bit (1),
	  2 found_to	   bit (1),
	  2 last_msf_component bit (1),	/* TRUE for last MSF component, */
					/* and all segs & archive elements */
	  2 more_in_archive	   bit (1),	/* TRUE if archive scanning */
	  2 print_heading_first
			   bit (1),	/* TRUE if printing heading */
	  2 stop_after_first_elem
			   bit (1),	/* TRUE if doing nonstar archive elem */
	  2 paused	   bit (1);	/* TRUE if we paused at the beginning of this entry */

      dcl 1 ACI		   like archive_component_info aligned;
      dcl (
	ARCH_COMP		   init (3),
	MSF_COMP		   init (2),
	SEG		   init (1)
	)		   fixed bin int static options (constant);
      dcl bitc		   fixed bin (24);	/* bit count */
      dcl comp_ptr		   ptr;		/* if print archive */
					/* MSF part or archive element */
      dcl component		   char (seg_charct) based (comp_ptr);
      dcl ec1		   fixed bin (35);	/* err code */
      dcl entry_type	   fixed bin (2);	/* arg to status */
      dcl error_code	   fixed bin (35);	/* err code */
      dcl indent_string	   char (indentation) init ("");
      dcl last_line_number	   fixed bin;	/* number of input line last output. */
      dcl line_count	   fixed bin;
      dcl last_slew		   char (1);
      dcl line_length	   fixed bin (21);	/* length of one line */
      dcl line_number	   fixed bin;	/* line number to print */
      dcl msf_component	   fixed bin;	/* component number */
      dcl msf_component_count	   fixed bin (24);	/* highest component */
      dcl output_buffer	   char (MAX_BUFFER_LTH);
      dcl output_buffer_ch	   (MAX_BUFFER_LTH) char (1)
			   defined output_buffer;
      dcl output_buffer_length   fixed bin (21);	/* amount currently used */
      dcl page_number	   fixed bin;	/* current page number */
      dcl seg_charct	   fixed bin (21);	/* char count of current seg */
      dcl seg_type		   fixed bin;	/* type of entry passed to PRINT_ONE_SEG */
					/*   can be: SEG, MSF_COMP, ARCH_COMP */
      dcl segment		   char (seg_charct) based (seg_ptr);
      dcl slew		   char (1);	/* vertical motion char */
      dcl vt_length		   fixed bin (21);	/* length of line up to next VT */
      dcl wanted_elem	   char (32);

      call iox_$control (out_switch, "reset_more", null (), (0));
					/* for video system users ... */

      last_line_number = 0;
      last_slew = NUL;
      sws1.doing_archive, sws1.found_to, sws1.paused = "0"b;
      sws1.last_msf_component = "1"b;

      call initiate_file_ (dirname, ename, R_ACCESS, seg_ptr, bitc, error_code);

      if seg_ptr = null
      then
         do;				/* Can't initiate: missing? or directory/msf? */
	  call hcs_$status_minf (dirname, ename, 1, entry_type,
	       msf_component_count, ec1);
	  if ec1 ^= 0
	  then
	     do;
	        if en_type = star_LINK
	        then return;		/* don't complain about missing link target if * convention */

	        else
		 do;
		    error_code = ec1;
abort:
		    call com_err_ (error_code, "print", "^a",
		         pathname_ (dirname, ename));
		    had_err = "1"b;
		    return;
		 end;
	     end;

	  if entry_type ^= star_DIRECTORY
	  then goto abort;			/* A seg we can't initiate */

/* Directory */

	  if msf_component_count < 1
	  then
	     do;				/* really dir */
	        if en_type ^= star_SEGMENT
	        then return;		/* quiet if star convention */
	        error_code = error_table_$dirseg;
					/* don't print dirs */
	        goto abort;			/* .. just fuss */
	     end;

/* Multisegment file case */

	  else
	     do;
	        seg_type = MSF_COMP;
	        call msf_manager_$open (dirname, ename, FCB_ptr, error_code);
	        if error_code ^= 0
	        then goto abort;

	        call RESET;

	        if sws.last_given		/* for -last */
	        then
		 do;
		    from_line = 0;

		    if sws.to_line_given & to_regexpr_len = 0
		    then from_line = max (to_line - last_count + 1, 1);
					/* count lines in the MSF */
		    else
		       do;
			do msf_component = 0
			     to msf_component_count - 1
			     while (^sws1.found_to);
			   call msf_manager_$get_ptr (FCB_ptr,
			        msf_component, "0"b, comp_ptr, bitc,
			        error_code);
			   if error_code ^= 0
			   then goto MSF_err;

			   seg_charct = divide (bitc + 8, 9, 21, 0);

			   if seg_charct > 0
			   then
			      do;
			         call COUNT_LINES (component,
				    msf_component
				    = msf_component_count - 1,
				    line_count, sws1.found_to);
			         from_line = from_line + line_count;
			      end;
			end;
			from_line = max (from_line - last_count + 1, 1);
		       end;
		 end;

	        line_number = 1;
	        sws1.paused = "0"b;

	        do msf_component = 0 to msf_component_count - 1
		   while (^sws1.found_last);

		 call msf_manager_$get_ptr (FCB_ptr, msf_component, "0"b,
		      comp_ptr, bitc, error_code);
		 if error_code ^= 0
		 then goto MSF_err;

		 sws1.last_msf_component =
		      (msf_component = msf_component_count - 1);
		 seg_charct = divide (bitc + 8, 9, 21, 0);
		 if seg_charct = 0
		 then error_code = error_table_$zero_length_seg;
					/* Actually print component */
		 else call PRINT_ONE_SEG (component);
					/* dont count nnl lines twice */
		 if ^sws1.last_msf_component
		 then if substr (component, seg_charct, 1) ^= NL
		      then line_number = line_number - 1;
	        end;

MSF_err:
	        if error_code ^= 0
	        then
		 do;
		    had_err = "1"b;
		    call com_err_ (error_code, "print",
		         "Component ^d of multisegment file ^a.",
		         msf_component, pathname_ (dirname, ename));
		 end;

	        call msf_manager_$close (FCB_ptr);
	     end;				/* of MSF */
	  return;				/* exit from MSF case */
         end;				/* seg_ptr = null */

/* Segment case */

      error_code = 0;
      sws1.doing_archive =
	 arch_elem_wanted ^= ""
	 | (^sws.dont_want_archive
	 & index (reverse (rtrim (ename)), reverse (".archive")) = 1);

/* Archive case */

      if sws1.doing_archive
      then
         do;
	  seg_type = ARCH_COMP;
	  stop_after_first_elem = (archive_element_star_type = type.NOSTAR);

	  if arch_elem_wanted = ""
	  then
	     do;
	        wanted_elem = "**";		/* print whole archive? */
	        stop_after_first_elem = "0"b;
	     end;
	  else wanted_elem = arch_elem_wanted;

	  comp_ptr = null;
	  ACI.version = ARCHIVE_COMPONENT_INFO_VERSION_1;
	  sws1.more_in_archive = "1"b;

	  do while (sws1.more_in_archive & error_code = 0);
	     call archive_$next_component_info (seg_ptr, bitc, comp_ptr,
		addr (ACI), error_code);
	     if error_code = 0
	     then
	        do;
		 if comp_ptr = null
		 then sws1.more_in_archive = "0"b;

		 else
		    do;
		       call match_star_name_ (ACI.name, wanted_elem,
			  error_code);
		       if error_code ^= 0
		       then error_code = 0;
		       else
			do;
			   call RESET;

			   seg_charct =
			        divide (ACI.comp_bc + 8, 9, 21, 0);
			   if seg_charct = 0
			   then
			      do;		/* archive wont let this happen, but ... */
			         call com_err_ (
				    error_table_$zero_length_seg,
				    "print", "^a",
				    pathname_$component (dirname, ename,
				    ACI.name));
			         had_err = "1"b;
			      end;

			   else
			      do;
			         archive_elements_found = "1"b;

			         if sws.last_given
					/* for -last */
			         then
				  do;
				     if sws.to_line_given
					& to_regexpr_len = 0
				     then from_line =
					     max (to_line
					     - last_count + 1, 1);
				     else
				        do;
					 call COUNT_LINES (component,
					      "1"b, from_line,
					      sws1.found_to);
					 from_line =
					      max (from_line
					      - last_count + 1, 1);
				        end;
				  end;

			         line_number = 1;
			         sws1.paused = "0"b;
					/* fixed bug for TR number 18887 */
			         call iox_$control (out_switch,
				    "reset_more", null (), (0));
					/* for video system users ... */
					/* end of fixing bug */

			         call PRINT_ONE_SEG (component);
					/* Terminate loop */
			         if stop_after_first_elem
			         then sws1.more_in_archive = "0"b;
			      end;
			end;
		    end;
	        end;			/* error_code =  0 */
	  end;				/* loop */
         end;				/* of archive case */

/* Single segment file case. */

      else
         do;
	  seg_type = SEG;
	  call RESET;

	  seg_charct = divide (bitc + 8, 9, 21, 0);
	  if seg_charct ^= 0
	  then
	     do;
	        if sws.last_given		/* for -last */
	        then
		 do;
		    if sws.to_line_given & to_regexpr_len = 0
		    then from_line = max (to_line - last_count + 1, 1);
		    else
		       do;
			call COUNT_LINES (segment, "1"b, from_line,
			     sws1.found_to);
			from_line = max (from_line - last_count + 1, 1);
		       end;
		 end;

	        line_number = 1;
	        sws1.paused = "0"b;

	        call PRINT_ONE_SEG (segment);
	     end;

	  else error_code = error_table_$zero_length_seg;
         end;				/* of ssf case */

      call terminate_file_ (seg_ptr, (0), TERMINATE_SEG, (0));
					/* done with segment */
      seg_ptr = null;
      if error_code ^= 0
      then
         do;
	  had_err = "1"b;
	  call com_err_ (error_code, "print", "^a",
	       pathname_ (dirname, ename));
         end;

      return;				/* Normal exit from PRINT_ONE_ENTRYNAME */
%page;
/* ------------------------------------------------------- */

RESET:
   proc;

      sws1.print_heading_first = sws.want_heading;/* treat archive elements as single files */
					/* clear items not to be carried from one file to next */
      pci.level, pci.pos, pci.slew_residue, pci.sav_pos, pci.esc_state,
	 pci.esc_num = 0;
      pci.temp, sws1.found_first, sws1.found_last = "0"b;
      page_number, pci.line = 1;
      line_count = 0;
      slew = NL;
   end RESET;
%page;
/* ------------------------------------------------------- */

COUNT_LINES:				/* count lines in a segment */
   proc (seg, last_seg, lines, found_to);

/* PARAMETERS */

      dcl seg		   char (*);
      dcl last_seg		   bit (1);
      dcl lines		   fixed bin;
      dcl found_to		   bit (1);

/* LOCAL */

      dcl c		   fixed bin (35),
	char_index	   fixed bin (21);

      char_index = 0;
      lines = 0;

      do while (char_index < seg_charct);
         line_length = index (substr (seg, char_index + 1), NL);
         if line_length > 0
         then lines = lines + 1;
         else
	  do;				/* Last line of seg does   */
	     if last_seg
	     then				/* NOT end with NL.  Count */
		lines = lines + 1;		/* it if no more MSF comps.*/
	     line_length = length (substr (seg, char_index + 1));
	  end;

         if to_regexpr_len > 0		/* using regexpr for to? */
         then
	  do;
	     call search_file_ (to_regexpr_ptr, 2, to_regexpr_len, addr (seg),
		char_index + 1, char_index + line_length, 0, 0, c);
	     if c = 0
	     then
	        do;
		 found_to = "1"b;
		 if substr (seg, char_index + line_length, length (NL))
		      ^= NL
		 then			/* if last line of segment */
		      lines = lines + 1;	/* matches /RE/, but does  */
		 return;			/* not end with NL, count  */
	        end;			/* this line.	       */
	  end;
         char_index = char_index + line_length;
      end;

   end COUNT_LINES;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* This subroutine does the actual printing.
   It deals with one segment at a time, which may be either an SSF,
   one component of a MSF, or an archive element. */

PRINT_ONE_SEG:
   proc (segment);

      dcl segment		   char (*);	/* seg to be printed */

      dcl char_index	   fixed bin (21);	/* index of last char used */
      dcl line_count_this_page   fixed bin;	/* lines per page, for paging */
      dcl line_length	   fixed bin (21);	/* length of one line */
      dcl print_this_line	   bit (1);
      dcl region_begin	   fixed bin (21);	/* char_index at sws1.found_first */
      dcl seg_ptr		   ptr;		/* -> seg to be printed */
      dcl segarray		   (seg_charct) char (1) based (seg_ptr);

      seg_ptr = addr (segment);

      char_index, line_count_this_page = 0;

      if (sws.print_quick_way & sws.one_iox_call) /* Print whole segment */
      then				/* without from/to */
PRINT_QUICK_WAY:				/* tests, etc */
         do;
	  if sws.pause_before_print
	  then call PAUSE;

	  call PRINT_HEAD;
	  call PRINT_STRING (seg_ptr, seg_charct);
	  ever_printed = "1"b;
	  return;				/* Normal exit, easy case */
         end PRINT_QUICK_WAY;

PRINT_SEG:				/* loop through lines of */
      do while (char_index < seg_charct & ^sws1.found_last);
					/* segment, printing those*/
					/* that pass tests. */
         line_length = index (substr (segment, char_index + 1), NL);
         if line_length = 0			/* no EOL, take the rest */
         then line_length = length (substr (segment, char_index + 1));

         call PRINT_ONE_LINE ();
         line_number = line_number + 1;

      end PRINT_SEG;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* If file doesn't end with a NP character as its very last character, then we must	*/
/* output final NP when paging.  This is ONLY done for last component of MSF, not for	*/
/* earlier components.							*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

      if (seg_type ^= MSF_COMP | sws1.last_msf_component)
	 &
	 ^(pci.line = 1 & pci.pos = 0 & pci.level = 0 & pci.slew_residue = 0)
      then				/* This tests for file not */
         do;				/* ending with NP. */

	  if pci.pos > 0 | pci.slew_residue = -1
	  then				/* If file doesn't end */
	     do;				/* with a NL, NP or VT, */
	        slew = NL;			/* force NL to be present. */
	        call SLEW ();
	     end;

	  if sws.paging			/* When paging, end file */
	  then				/* with a NP char. */
	     do;
	        slew = NP;
	        call SLEW ();
	     end;
         end;

      return;				/* Normal exit, medium and hard cases */
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* This routine is used if we are printing one line at a time.
   It knows how to mess with the insides of the line */

PRINT_ONE_LINE:
   proc;

      print_this_line = "1"b;

      call CHECK_FROM_LINE ();		/* Check -from/-to line. */
      if print_this_line
      then call CHECK_TO_LINE ();
      if print_this_line
      then print_this_line = MATCH_EXCLUDE ();

      if print_this_line
      then				/* check page boundaries. */
	 if sws.to_page_given
	 then if page_number > to_page
	      then
	         do;
		  sws1.found_last = "1"b;
		  return;
	         end;

      if print_this_line & (page_number >= from_page)
      then
         do;
	  if sws.pause_before_print & ^sws1.paused
	  then
	     do;
	        call PAUSE;
	        sws1.paused = "1"b;
	     end;

	  call PRINT_HEAD;			/* Print heading before 1st line of file. */
	  ever_found_page = "1"b;
	  ever_printed = "1"b;
         end;
      else print_this_line = "0"b;

      if sws.print_quick_way
      then
         do;
	  if print_this_line
	  then call PROCESS_LINE_VIA_IOX (addr (segarray (char_index + 1)),
		  line_length);

         end;
      else
         do;
	  if ^sws.no_vertsp			/* prt_conv_ converts VT  */
	  then				/* to some number of NLs. */
	     do;				/* In vertsp mode, we     */
	        vt_length =			/* want VT itself to be   */
		   index (substr (segment, char_index + 1, line_length), VT)
		   ;
	        do while (vt_length > 0);	/* output. Special-case VT*/
		 call			/* in this code.          */
		      PROCESS_LINE_VIA_PRT_CONV (
		      addr (segarray (char_index + 1)), vt_length,
		      print_this_line, "0"b, "1"b);
		 char_index = char_index + vt_length;
		 line_length = line_length - vt_length;
		 vt_length =
		      index (substr (segment, char_index + 1, line_length),
		      VT);
	        end;			/* do while (vt_length) */
	     end;				/* if ^sws.no_vertsp */

	  call				/* Call prt_conv_ on line */
	       PROCESS_LINE_VIA_PRT_CONV (addr (segarray (char_index + 1)),
	       line_length, print_this_line, "0"b, "0"b);
         end;				/* else do */

      char_index = char_index + line_length;

      if forcount > 0
      then
         do;				/* forcount and line_count */
	  if line_count >= forcount
	  then
	     do;				/* must be check here after */
	        sws1.found_last = "1"b;	/* printing each line.     */
	        seg_charct = char_index + line_length;
	     end;
         end;

   end PRINT_ONE_LINE;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

CHECK_FROM_LINE:
   proc;

      dcl c		   fixed bin (35);

      region_begin = char_index;
      if sws1.found_first
      then return;

      if from_regexpr_len > 0
      then
         do;
	  call search_file_ (from_regexpr_ptr, 2, from_regexpr_len,
	       addr (segment), char_index + 1, char_index + line_length, 0, 0,
	       c);
	  if c = 0
	  then
	     do;
	        ever_found_from, sws1.found_first = "1"b;
	        from_line = line_number;
	     end;
	  else print_this_line = "0"b;
         end;
      else if line_number >= from_line
      then ever_found_from, sws1.found_first = "1"b;
      else print_this_line = "0"b;

   end CHECK_FROM_LINE;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

CHECK_TO_LINE:
   proc;

      dcl c		   fixed bin (35);

      if ^sws.to_line_given & (forcount = 0)
      then return;

      if to_regexpr_len > 0			/* need regexpr for to? */
      then
         do;
	  call search_file_ (to_regexpr_ptr, 2, to_regexpr_len,
	       addr (segment), char_index + 1, char_index + line_length, 0, 0,
	       c);
	  if c = 0
	  then
	     do;
	        sws1.found_last = "1"b;
	        seg_charct = char_index + line_length;
	     end;
         end;

      else if to_line > 0
      then
         do;
	  if line_number >= to_line
	  then
	     do;
	        if substr (segment, char_index + line_length, 1) = NL
	        then
		 do;
		    sws1.found_last = "1"b;
		    seg_charct = char_index + line_length;
		 end;
	     end;
         end;

   end CHECK_TO_LINE;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

LINENO_AND_INDENT:
   proc (strike_level, chars_for_line);

      dcl strike_level	   fixed bin,
	chars_for_line	   fixed bin (21);

      if last_slew = ""
      then
         do;
	  last_line_number = line_number;
	  last_slew = slew;
	  return;
         end;

      if sws.want_line_numbers
      then if strike_level = 0 & last_slew ^= CR
	 then if line_number ^= last_line_number
	      then call ioa_$ioa_switch_nnl (out_switch, "^8i  ", line_number)
		      ;
	      else call ioa_$ioa_switch_nnl (out_switch, "^8i+ ", line_number)
		      ;
	 else call ioa_$ioa_switch_nnl (out_switch, "^-");
      last_line_number = line_number;
      last_slew = slew;

      if indentation > 0 & chars_for_line > 0	/* Indent? */
      then call PRINT_STRING (addr (indent_string), indentation);

   end LINENO_AND_INDENT;
%page (2);
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/*  This subroutine checks if the current line is printable in the presence
   of the control args -match and -exclude */

MATCH_EXCLUDE:
   proc returns (bit (1));

      dcl jj		   fixed bin;
      dcl c		   fixed bin (35);
      dcl srchp		   ptr,
	srchl		   fixed bin (21);
      dcl srch		   char (srchl) based (srchp);
      dcl (matched, excluded)	   bit (1);

      if ^sws.check_lines
      then return ("1"b);

      matched = "0"b;
      do jj = 1 to match_string_count while (^matched);
         srchp = match_string_ptr (jj);
         srchl = match_string_len (jj);

         if srchl > 2 & index (srch, "/") = 1 & index (reverse (srch), "/") = 1
         then
	  do;
	     call search_file_ (srchp, 2, srchl - 2, addr (segment),
		char_index + 1, char_index + line_length, 0, 0, c);
	     if c = 0
	     then matched = "1"b;
	  end;

         else if index (substr (segment, char_index + 1, line_length), srch)
	    ^= 0
         then matched = "1"b;
      end;

      if match_string_count > 0 & ^matched
      then return ("0"b);

      excluded = "0"b;
      do jj = 1 to exclude_string_count;
         srchp = exclude_string_ptr (jj);
         srchl = exclude_string_len (jj);

         if srchl > 2 & index (srch, "/") = 1 & index (reverse (srch), "/") = 1
         then
	  do;
	     call search_file_ (srchp, 2, srchl - 2, addr (segment),
		char_index + 1, char_index + line_length, 0, 0, c);
	     if c = 0
	     then excluded = "1"b;
	  end;

         else if index (substr (segment, char_index + 1, line_length), srch)
	    ^= 0
         then excluded = "1"b;
      end;

      return (^excluded);

   end MATCH_EXCLUDE;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

PAUSE:
   proc;

      dcl buffer		   char (256);

      error_code = error_table_$long_record;
      do while (error_code = error_table_$long_record);
					/* This call skips one input line: i.e. pauses */
         call iox_$get_line (iox_$user_input, addr (buffer), 256, (0),
	    error_code);
      end;

      call iox_$control (iox_$user_input, "resetread", null, (0));

   end PAUSE;

%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* Print the heading. Uglinesses of this output format are for compatibility
   with the old print. I don't like them either. */

PRINT_HEAD:
   proc;

      dcl date		   char (64) var,
	head_line		   char (250),
	head_line_len	   fixed bin (21);

      if ^sws1.print_heading_first
      then return;

      if sws1.doing_archive
      then
         do;				/* New format */
	  date = date_time_$format ("date_time", ACI.time_modified, "", "");
	  call ioa_$rsnp ("^/^2-^a::^a^-^a^/", head_line, head_line_len,
	       ename, ACI.name, date);
         end;

      else
         do;
	  date = date_time_$format ("date_time", clock (), "", "");
	  call ioa_$rsnp ("^/^2-^a^-^a^2/", head_line, head_line_len, ename,
	       date);
         end;
      if sws.print_quick_way | sws.one_iox_call
      then call PRINT_STRING (addr (head_line), head_line_len);
      else
         do;
	  call PROCESS_LINE_VIA_PRT_CONV (addr (head_line), head_line_len,
	       "1"b, "1"b, "0"b);
	  line_count = line_count - 1;	/* After printed the heading,  */
         end;				/* "line_count" must not be    */
      sws1.print_heading_first = "0"b;		/* incremented by one. Avoid   */
					/* errors error when enters    */
   end PRINT_HEAD;				/* print foo -for N -he -ind N */
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

PRINT_STRING:
   proc (ptr, len);

      dcl ptr		   ptr,
	len		   fixed bin (21);

      call iox_$put_chars (out_switch, ptr, len, error_code);
      if error_code ^= 0
      then
         do;
	  call com_err_ (error_code, "print", "Writing to switch ^a.",
	       switch_name);
	  go to RETURN;
         end;

   end PRINT_STRING;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* This routine processes line fragments where each       */
/* fragment ends with a NL, VT, NP or CR.  These are the  */
/* slew characters needed to drive proper slew processing.*/

PROCESS_LINE_VIA_IOX:
   proc (line_ptr_parm, line_len_parm);

      dcl line_ptr_parm	   ptr,		/* ptr to output line. */
	line_len_parm	   fixed bin (21);	/* length of output line. */

      dcl end_of_output_line	   fixed bin (21);	/* location in line of */
					/* VT, NL, or NP char. */

      dcl line_len		   fixed bin (21),
	line_ptr		   ptr,
	line		   char (line_len) based (line_ptr),
	line_array	   (line_len) char (1) based (line_ptr);

      line_ptr = line_ptr_parm;		/* copy, because we change */
      line_len = line_len_parm;		/* these values.	       */

      do while (line_len > 0);
         end_of_output_line = search (line, NLCRVTNP);
         if end_of_output_line > 0
         then
	  do;
	     slew = line_array (end_of_output_line);
	     end_of_output_line = end_of_output_line - 1;
	  end;				/* remove slew char from */
					/* end of output line.   */
         else
	  do;
	     slew = "";
	     end_of_output_line = length (line);
	  end;

         ever_found_page = "1"b;
         call LINENO_AND_INDENT (0, end_of_output_line);

         if end_of_output_line ^= 0
         then call PRINT_STRING (addr (line), end_of_output_line);

         call SLEW ();

         if (end_of_output_line + 1) < line_len	/* not at the end of the line*/
         then line_ptr = addr (line_array (end_of_output_line + 2));
         line_len = line_len - (end_of_output_line + 1);

      end;

      line_count = line_count + 1;

   end PROCESS_LINE_VIA_IOX;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* This routine calls prt_conv_ to process a single line.  It may be called */
/* many times for lines which are overlength or contain overstrikes.        */
/* HTs are converted to SP chars, VT to NLs (unless vertical_tab = "1"b),   */
/* and NP to NLs.  Overstriking is handling by using CR to overlay line     */
/* images atop one another.					      */

PROCESS_LINE_VIA_PRT_CONV:
   proc (line_ptr_parm, line_len_parm, print_this_line, header, vertical_tab);

      dcl line_ptr_parm	   ptr,		/* ptr to output line. */
	line_len_parm	   fixed bin (21),	/* length of output line. */
	print_this_line	   bit (1),	/* on if line passed all */
					/* tests for printing      */
					/* except -from_page.  We  */
					/* do -from_page test here */
					/* since line may span     */
					/* pages		       */
	header		   bit (1),	/* on when printing header */
	vertical_tab	   bit (1);	/* on when line fragment  */
					/* ends with VT, not NL   */

      dcl chars_done	   fixed bin (21);	/* number of chars processed from line. */
      dcl chars_for_line	   fixed bin (21);	/* amount of output buffer to actually print */
      dcl chars_to_do	   fixed bin (21);	/* number of chars left on page */
      dcl (saved_line_length, saved_rmarg)
			   fixed bin;

      dcl line_len		   fixed bin (21),
	line_ptr		   ptr,
	line		   char (line_len) based (line_ptr),
	line_array	   (line_len) char (1) based (line_ptr);

      if header				/* When printing header, */
      then				/* don't honor	     */
         do;				/* -line_length	     */
	  saved_line_length = pci.phys_line_length;
	  pci.phys_line_length = length (output_buffer);
	  saved_rmarg = pci.rmarg;
	  pci.rmarg = length (output_buffer);
         end;

      line_ptr = line_ptr_parm;		/* copy, because we change */
      line_len = line_len_parm;		/* these values.	       */

      chars_to_do = length (line);		/* loop, calling prt_conv_ */
      do while (chars_to_do > 0 | pci.slew_residue > 0);
         line_count_this_page = pci.line;	/* remember line count     */
					/* before output. SLEW uses*/
					/* this.		       */
         call prt_conv_ (addr (line), chars_to_do, addr (output_buffer),
	    output_buffer_length, addr (pci));
         chars_done = length (line) - chars_to_do;

         if chars_done > 0			/* prevent subcriptrange  */
					/* (underflow) condition  */
					/* when a line contains   */
					/* BACK SPACES characters.*/
         then line_ptr = addr (line_array (chars_done));

         slew = output_buffer_ch (output_buffer_length);

         output_buffer_length = output_buffer_length - 1;
					/* remove slew char from */
					/* end of output line.   */

         if vertical_tab & slew = NL		/* For VT mapped in NL   */
         then				/* (rather than NP),     */
	  do;				/* change slew to VT and */
	     slew = VT;			/* ignore prt_conv_ NLs. */
	     pci.slew_residue = 0;		/* SLEW proc outputs VT. */
	  end;

         if header				/* Ignore -left_col and    */
					/* -right_col for header.  */
         then chars_for_line = output_buffer_length;
         else chars_for_line =
	         min (right_col, output_buffer_length) - left_col + 1;

/* watch for negative character counts */
         if chars_for_line < 0
         then chars_for_line = 0;

         if print_this_line & (page_number >= from_page)
         then				/* Do -from_page test, and */
	  do;				/* print line if it passes */
	     ever_found_page = "1"b;
	     if ^header
	     then call LINENO_AND_INDENT (pci.level, chars_for_line);
	     call PRINT_STRING (addr (output_buffer_ch (left_col)),
		chars_for_line);
	     call SLEW ();
	  end;				/* if have not done yet    */
         if chars_done < line_len		/* then always moves the   */
         then line_ptr = addr (line_array (2));	/* pointer to the NEXT     */
         line_len = line_len - chars_done;	/* character in the line.  */
					/* Then update line_len by */
					/* starting from the char  */
					/* pointed by the pointer  */
					/* to the remaining line.  */

         if slew = NP			/* After NP, redo the   */
         then				/* -to_page test.	    */
	  do;
	     page_number = page_number + 1;
	     if sws.to_page_given
	     then
	        do;
		 if page_number > to_page
		 then
		    do;
		       sws1.found_last = "1"b;
		       return;
		    end;
	        end;
	  end;
      end;

      if header				/* After header, restore */
      then				/* -line_length info.    */
         do;
	  pci.phys_line_length = saved_line_length;
	  pci.rmarg = saved_rmarg;
         end;

      line_count = line_count + 1;

   end PROCESS_LINE_VIA_PRT_CONV;
%page;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

SLEW:
   proc;

      dcl needct		   fixed bin;

      if slew = ""				/* no slew */
      then return;

      if slew = CR
      then go to real_slew;

      if slew = NP				/* ejecting a page? */
      then
         do;
	  if sws.pause_after_page
	  then
	     do;
	        call PRINT_STRING (addr (NL), 1);
	        call PAUSE;
	     end;
	  else if ^sws.no_vertsp
	  then goto real_slew;

	  else				/* Compute lines needed */
	     do;
	        needct = pci.phys_page_length - line_count_this_page + 1;
	        call ioa_$ioa_switch_nnl (out_switch, "^v/", needct);
	        line_count_this_page = 0;
	     end;
         end;

      else if slew = VT			/* VT is never simulated */
      then go to real_slew;			/* by us. prt_conv_ does */
					/* the simulation.	     */

      else				/* NL slew.	     */
         do;
	  line_count_this_page = line_count_this_page + 1;
real_slew:
	  call PRINT_STRING (addr (slew), 1);
         end;

   end SLEW;

   end PRINT_ONE_SEG;

   end PRINT_ONE_ENTRYNAME;

      end;				/* of begin block */

%include prt_conv_info;

      dcl 1 PCI		   like pci aligned;
%page;
%include star_structures;
%page;
%include archive_component_info;
%page;
%include access_mode_values;

   end print;
