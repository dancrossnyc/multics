/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(87-06-16,LJAdams), approve(87-06-16,MCR7584),
     audit(87-07-23,Gilcrease), install(87-08-04,MR12.1-1055):
     Changed editing_chars_version_2 to editing_chars_version_3 which
     includes the redisplay character (for DSA only).
     editing_chars_version_2 will still be accepted.
  2) change(87-07-10,LJAdams), approve(87-07-10,MCR7742),
     audit(87-07-23,Gilcrease), install(87-08-04,MR12.1-1055):
     Changed to accept either scroll or line_count as a valid value for
     mv.char_value.
  3) change(88-02-08,Brunelle), approve(88-02-08,MCR7813),
     audit(88-10-12,Blair), install(88-10-17,MR12.2-1171):
     Change to use SPECIAL_VERSION_2 instead of SPECIAL_VERSION of special
     chars structure.  Change set/get_special control orders to automatically
     handle old(3)/new(15) lengths of special_chars.
  4) change(88-10-20,Brunelle), approve(88-10-20,PBF7813),
     audit(88-10-20,Farley), install(88-10-20,MR12.2-1175):
     Correct "ptr being referenced but never set" problem.  Also altered method
     used to copy old-version special chars structures from/to new version to
     use a more efficient manner.
  5) change(89-02-27,Lee), approve(89-03-14,MCR8075), audit(89-04-20,Flegel),
     install(89-05-10,MR12.3-1041):
     phx19510 (Video 91) - fixed to handle problem with setting of editing
     chars when the erase and kill characters are being interchanged.
                                                   END HISTORY COMMENTS */


/* wioctl_ -- control orders and modes for window_io_ */
/* Benson I. Margulies, sometime in 1981 */
/* Modified 11 December 1981 by Chris Jones to add more_mode=fold */
/* Modified 15 December 1981 by Chris Jones to add set_editing_chars */
/* Modified 11 January 1982 by Chris Jones to clear break table entries
   on ^erkl and ^esc modes */
/* Modified 26 January 1982 by William York to implement user-settable
   more handlers. */
/* Modified 3 February 1982 by Chris Jones to fix set_window_info so cursor
   always lands in the window */
/* Modified 28 April 1982 by WMY to return the current more handler routine
   (if any) in a set_more_handler call. version 2 of more_handler_info. */
/* Modified 26 August 1982 by WMY to add the send_buffered_output order, and
   pass any unrecognized order on to tc_ level. */
/* Modified 20 September 1982 by WMY to remove the send_buffered_output
   control order, since window_$sync is a better mechanism. */
/* Modified 18 October 1982 by WMY to re-allocate the window image when the
   size of a window is changed via set_window_info. */
/* Modified October 1982 by WMY to add set_ and get_token_characters and
   set_ and get_more_prompt. */
/* Modified January 1983 by WMY to add io_call support. */
/* Modified February 1983 by WMY to add set_editor_key_bindings. */
/* Modified 8 May 1983 by WMY to add io_call support for set and
   get_window_status and set and get_token_characters. */
/* Modified 7 June 1983 by WMY to make set_window_info check the elements
   of the window_position_info structure for reasonable values and
   actually set the width of the window instead of ignoring the width
   specified by the caller. */
/* Modified 14 June 1983 by WMY to use version 2 line_editor_key_binding_info
   structure, and interpret a 0 width specification in a set_window_info
   order as a full-screen-width window. */
/* Modified 15 June 1983 by WMY to change set_editing_chars to use the
   set_editor_key_bindings order, and unbind the old editing chars. */
/* Modified 2 August 1983 by Jon A. Rochlis to make get_window_status zero
   attach_data.status, not just attach_data.status_pending, and to
   add io_call support for set_window_status */
/* Modified 6 August 1983 by JR to add io_call support for get_more_responses,
   get_more_prompt, and (set get)_editing_chars.  Also to improve error
   reporting in io_call processing, and to elimitate duplicate error messages
   by zeroing code before returning if we report the error.  Also to remove
   the special casing of the terminal_info control, since we pass anything
   unrecognized to tc_ anyway. */
/* Modified 7 August 1983 by JR to add get_more_handler and io_call support
   for it. */
/* Modified 7-8 August 1983 by JR for better io_call support for
   set_editor_key_bindings, added -builtin and -numarg control args */
/* Modified 2 September 1983 by JR for case insensitive comparisons of
   builtin requests and numarg actions for set_editor_key_bindings */
/* Modified 8 October 1983 by JR for partial screen width support.  Made
   set_window_info set the new fields in tc_desk_info, and default column
   origin to 1 if we get passed 0 (it used to be a mbz). */
/* Modified December 1983 by JR to make get_capabilites set the various
   flags correctly for partial width windows, and to make get_window_info
   set window_position.origin.column */
/* Modified 23 December 1983 by JR to support the (set get)_output_conversion
   and (set get)_special control orders.  Merry Christmas!! */
/* Modified 8 January 1983 by JR to explicitly do a get_capabilities to
   determine if more_mode=SCROLL rather than relying on
   attach_data.capabilities which is going away. */
/* Modified 1 February 1984 by JR to support the removal of window_io_video_
   by adding the get_window_iocb_ptr for window_, and adding support for
   read_status here, since all roads lead to wioctl_ for control orders. */
/* Modified 29 February 1984 by Barmar to add get_editor_key_bindings
   control order, and make set_key_binding free dispatch tables that become
   garbage */
/* Modified 1 March 1984 by Barmar to change "goto error_return" into
   "call error_exit", and to upgrade set_editor_key_bindings to support
   the new set_editor_key_bindings info structure. */
/* Modified 9 March 1984 by Barmar - Fixed lots of invalid code, add
   io_call support for setting name, description, and info_path,
   implemented io_call get_editor_key_bindings */
/* Modified 22 March 1984 by Barmar - Added (set get)_audit_iocb_ptr control
   orders. */
/* Modified 28 March 1984 by JR to add support for window_iocb_ptr in
   tc_desk_info, and to add support to get_window_status for
   W_STATUS_TTP_CHANGE and W_STATUS_RECONNECTION. */
/* Modified 01 September 1984 by JR to add edited mode. */

/* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
wioctl_:
     procedure;

declare  (
         (Old_modes, New_modes, Order)
			  character (*),
         Code		  fixed bin (35),
         Iocb_ptr		  pointer,
         Info_ptr		  pointer
         )		  parameter;

declare  temp_ptr		  pointer;


declare  mode_string_$parse	  entry (character (*), pointer, pointer, fixed binary (35));

declare  ioa_$rsnnl		  entry () options (variable);
declare  pathname_		  entry (char (*), char (*)) returns (char (168));
declare  requote_string_	  entry (char (*)) returns (char (*));
declare  window_io_iox_$reset_more_entry
			  entry (pointer);

declare  target_iocbp	  pointer;
declare  modex		  fixed bin;
declare  force_mode		  bit (1) aligned;
declare  binding_index	  fixed bin;

declare  1 auto_capabilities_info
			  aligned like capabilities_info;

declare  1 desk_info	  aligned like tc_desk_window_info;

declare  (
         video_et_$bad_window_id,
         video_et_$overlapping_more_responses,
         video_et_$window_too_big,
         video_et_$no_more_handler_in_use,
         error_table_$bad_subr_arg,
         error_table_$bad_mode_value,
         error_table_$inconsistent,
         error_table_$null_info_ptr,
         error_table_$invalid_array_size
         )		  external static fixed bin (35);
declare  error_table_$bad_mode  fixed bin (35) ext static;
declare  error_table_$unimplemented_version
			  fixed bin (35) ext static;

declare  (addr, bin, byte, clock, codeptr, copy, hbound, index, lbound, length, max, null, rank, rtrim, search, string,
         substr, translate, unspec)
			  builtin;
dcl      cleanup		  condition;
dcl      SPACE		  char (1) static options (constant) init (" ");
dcl      DEL		  char (1) static options (constant) init ("");
dcl      WHITE_SPACE	  char (5) int static options (constant) initial
						/* CR, NL, HT, VT, FF */
			  ("
	");

/* special chars structures to support old/new versions */
dcl      1 special_chars_old	  aligned based,		/* table of special character sequences */
	 2 nl_seq		  aligned like c_chars_old,	/* new-line sequence */
	 2 cr_seq		  aligned like c_chars_old,	/* carriage-return sequence */
	 2 bs_seq		  aligned like c_chars_old,	/* backspace sequence */
	 2 tab_seq	  aligned like c_chars_old,	/* horizontal tab sequence */
	 2 vt_seq		  aligned like c_chars_old,	/* vertical tab sequence */
	 2 ff_seq		  aligned like c_chars_old,	/* form-feed sequence */
	 2 printer_on	  aligned like c_chars_old,	/* printer-on sequence */
	 2 printer_off	  aligned like c_chars_old,	/* printer_off sequence */
	 2 red_ribbon_shift	  aligned like c_chars_old,	/* red ribbon shift sequence */
	 2 black_ribbon_shift aligned like c_chars_old,	/* black ribbon shift sequence */
	 2 end_of_page	  aligned like c_chars_old,	/* end-of-page warning sequence */
	 2 escape_length	  fixed bin,		/* number of escape sequences */
	 2 not_edited_escapes (sc_escape_len refer (special_chars_old.escape_length)) like c_chars_old,
						/* use in ^edited mode */
	 2 edited_escapes	  (sc_escape_len refer (special_chars_old.escape_length)) like c_chars_old,
						/* use in edited mode */
	 2 input_escapes	  aligned,
	   3 len		  fixed bin (8) unaligned,	/* length of string */
	   3 str		  char (sc_input_escape_len refer (special_chars_old.input_escapes.len)) unaligned,
						/* escape sequence characters */
	 2 input_results	  aligned,
	   3 pad		  bit (9) unaligned,	/* so that strings will look the same */
	   3 str		  char (sc_input_escape_len refer (special_chars_old.input_escapes.len)) unaligned;
						/* results of escape sequences */


dcl      1 c_chars_old	  based (c_chars_ptr) aligned,
	 2 count		  fixed bin (8) unaligned,
	 2 chars		  (3) char (1) unaligned;

dcl      1 special_chars_struc_old
			  aligned based,
	 2 version	  fixed bin,
	 2 default	  fixed bin,		/* non-zero indicates use default */
	 2 special_chars,				/* same as level-1 above */
						/* has to be spelled out instead of using like */
						/* because of refer options */
	   3 nl_seq	  aligned like c_chars_old,	/* new-line sequence */
	   3 cr_seq	  aligned like c_chars_old,	/* carriage-return sequence */
	   3 bs_seq	  aligned like c_chars_old,	/* backspace sequence */
	   3 tab_seq	  aligned like c_chars_old,	/* horizontal tab sequence */
	   3 vt_seq	  aligned like c_chars_old,	/* vertical tab sequence */
	   3 ff_seq	  aligned like c_chars_old,	/* form-feed sequence */
	   3 printer_on	  aligned like c_chars_old,	/* printer-on sequence */
	   3 printer_off	  aligned like c_chars_old,	/* printer_off sequence */
	   3 red_ribbon_shift aligned like c_chars_old,	/* red ribbon shift sequence */
	   3 black_ribbon_shift
			  aligned like c_chars_old,	/* black ribbon shift sequence */
	   3 end_of_page	  aligned like c_chars_old,	/* end-of-page warning sequence */
	   3 escape_length	  fixed bin,		/* number of escape sequences */
	   3 not_edited_escapes
			  (sc_escape_len refer (special_chars_struc_old.escape_length)) like c_chars_old,
						/* use in ^edited mode */
	   3 edited_escapes	  (sc_escape_len refer (special_chars_struc_old.escape_length)) like c_chars_old,
						/* use in edited mode */
	   3 input_escapes	  aligned,
	     4 len	  fixed bin (8) unaligned,	/* length of string */
	     4 str	  char (sc_input_escape_len refer (special_chars_struc_old.input_escapes.len)) unaligned,
						/* escape sequence characters */
	   3 input_results	  aligned,
	     4 pad	  bit (9) unaligned,	/* so that strings will look the same */
	     4 str	  char (sc_input_escape_len refer (special_chars_struc_old.input_escapes.len)) unaligned;
						/* results of escape sequences */
%page;

modes:
     entry (Iocb_ptr, New_modes, Old_modes, Code);

	call setup;

	Old_modes = "";
	call ioa_$rsnnl (
	     "more_mode=^[scroll^;clear^;wrap^;fold^],^[^^^]more,ll=^d,pl=^d,^[^^^]vertsp,^[^^^]can,^[^^^]erkl,^[^^^]esc,^[^^^]rawo,^[^^^]red,^[^^^]ctl_char,^[^^^]edited",
	     Old_modes, (0), attach_data.more_mode, ^attach_data.more_processing, attach_data.current.columns,
	     attach_data.current.rows, ^attach_data.flags.vertsp, ^attach_data.flags.can, ^attach_data.flags.erkl,
	     ^attach_data.flags.esc, ^attach_data.flags.rawo, ^attach_data.flags.red, ^attach_data.flags.ctl_char,
	     ^attach_data.flags.edited);

	if New_modes = "" then
	     return;
	call mode_string_$parse (New_modes, get_system_free_area_ (), mode_string_info_ptr, Code);
	if Code ^= 0 then
	     return;

	force_mode = "0"b;
	do modex = 1 to hbound (mode_string_info.modes, 1);
	     call set_mode (mode_string_info.modes (modex));
	end;

mode_error_return:
	free mode_string_info;

	return;

/* This procedure analyzes a single mode */
set_mode:
     procedure (mv);
dcl      1 mv		  aligned like mode_value;

	if mv.mode_name = "force" then
	     force_mode = mode_value_boolean ();

	else if mv.mode_name = "more_mode" then do;
	     if ^mv.char_valuep then
		goto BAD_TYPE;

	     if mv.char_value = "scroll" | mv.char_value = "line_count" then do;
		auto_capabilities_info.version = capabilities_info_version_1;
		call iox_$control (Iocb_ptr, "get_capabilities", addr (auto_capabilities_info), Code);
		if Code ^= 0 then
		     return;
		if ^auto_capabilities_info.scroll_region then
		     go to BAD_VALUE;
		attach_data.more_mode = MORE_MODE_SCROLL;
	     end;
	     else if mv.char_value = "wrap" then
		attach_data.more_mode = MORE_MODE_WRAP;
	     else if mv.char_value = "clear" then
		attach_data.more_mode = MORE_MODE_CLEAR;
	     else if mv.char_value = "fold" then
		attach_data.more_mode = MORE_MODE_FOLD;
	     else goto BAD_TYPE;
	end;					/* more_mode */
	else if mv.mode_name = "more" then
	     attach_data.more_processing = mode_value_boolean ();
	else if mv.mode_name = "debug" then
	     attach_data.debug = mode_value_boolean ();

	else if mv.mode_name = "ll" then
	     if mv.numeric_value ^= attach_data.current.columns then
		go to BAD_VALUE;
	     else ;				/* read only, but accept truth */

	else if mv.mode_name = "pl" then
	     if mv.numeric_value ^= attach_data.current.rows then
		go to BAD_VALUE;
	     else ;

	else if mv.mode_name = "vertsp" then
	     attach_data.flags.vertsp = mode_value_boolean ();
	else if mv.mode_name = "can" then
	     attach_data.can = mode_value_boolean ();

/* These two require break tbl changes as well */
	else if mv.mode_name = "erkl" then do;
	     attach_data.erkl = mode_value_boolean ();
	     call set_break_table (attach_data.erase_char, attach_data.erkl);
	     call set_break_table (attach_data.kill_char, attach_data.erkl);
	end;					/* erkl mode */

	else if mv.mode_name = "esc" then do;
	     attach_data.esc = mode_value_boolean ();
	     call set_break_table (attach_data.input_escape_char, attach_data.esc);
	end;					/* esc mode */

	else if mv.mode_name = "rawo" then
	     begin;
declare  saved_r		  bit (1);
	     saved_r = attach_data.rawo;
	     attach_data.rawo = mode_value_boolean ();
	     if ^saved_r & attach_data.rawo & attach_data.cursor_valid then do;
		attach_data.row_at_rawo = attach_data.line;
		attach_data.col_at_rawo = attach_data.col;
	     end;
	     else if saved_r & ^attach_data.rawo then do;
		attach_data.line = attach_data.row_at_rawo;
		attach_data.col = attach_data.col_at_rawo;
		attach_data.cursor_valid = "1"b;
	     end;
	end;

	else if mv.mode_name = "red" then
	     attach_data.red = mode_value_boolean ();
	else if mv.mode_name = "ctl_char" then
	     attach_data.ctl_char = mode_value_boolean ();
	else if mv.mode_name = "edited" then
	     attach_data.edited = mode_value_boolean ();

/* support modes we've never heard of */
	else if ^force_mode then do;
	     Code = error_table_$bad_mode;		/*	     Old_modes = mv.mode_name; */
						/* this should contain the invalid mode for good error messages */
						/*	     if mv.char_valuep then Old_modes = rtrim(Old_modes) || "=" || mv.char_value; */
	     go to mode_error_return;
	end;

	return;

/* check type and return mode value */

mode_value_boolean:
	procedure returns (bit (1) aligned);		/* global mv */
	     if ^mv.boolean_valuep then
		goto BAD_TYPE;
	     return (mv.boolean_value);

mode_value_char:
	entry returns (char (32) varying);
	     if ^mv.char_valuep then
		goto BAD_TYPE;
	     return (rtrim (mv.char_value));

mode_value_numeric:
	entry returns (fixed bin (35));
	     if ^mv.numeric_valuep then
		goto BAD_TYPE;
	     return (mv.numeric_value);

	end;
BAD_TYPE:
BAD_VALUE:
	Code = error_table_$bad_mode_value;
	goto mode_error_return;
     end set_mode;

control:
     entry (Iocb_ptr, Order, Info_ptr, Code);
	call setup;

	if Order = "reset_more" then
	     call window_io_iox_$reset_more_entry (Iocb_ptr);

	else if Order = "send_buffered_output" then
	     call window_$sync (Iocb_ptr, Code);

	else if Order = "printer_off" then
	     attach_data.suppress_echo = "1"b;
	else if Order = "printer_on" then
	     attach_data.suppress_echo = "0"b;

	else if Order = "get_terminal_iocb_ptr" then
	     Info_ptr = target_iocbp;			/* This is really very un-iox-like */

	else if Order = "get_window_iocb_ptr" then
	     Info_ptr = Iocb_ptr -> actual_iocb_ptr;	/* If terminal control can do it, then window_ can do it also ... */

	else if Order = "get_capabilities" then do;
	     call check_null ();
	     call iox_$control (target_iocbp, Order, Info_ptr, Code);
	     if Code ^= 0 then
		return;

/* Now map the terminal capabilities into the window capabilities */
	     if Info_ptr -> capabilities_info.columns ^= attach_data.current.columns then do;
						/* Illegal operations for non full width windows */
		Info_ptr -> capabilities_info.scroll_region = "0"b;
		Info_ptr -> capabilities_info.insert_chars = "1"b;
						/* we simulate these if they aren't available */
		Info_ptr -> capabilities_info.insert_mode = "1"b;
						/* ? */
		Info_ptr -> capabilities_info.delete_chars = "1"b;
	     end;

	     Info_ptr -> capabilities_info.columns = attach_data.current.columns;
	     Info_ptr -> capabilities_info.rows = attach_data.current.rows;
	     return;
	end;

	else if Order = "get_window_info" then do;
	     call check_null ();
	     window_position_info_ptr = Info_ptr;
	     call require_version (window_position_info.version, window_position_info_version_1);
	     window_position_info.height = attach_data.current.rows;
	     window_position_info.width = attach_data.current.columns;
	     window_position_info.origin.column = attach_data.column_origin;
	     window_position_info.origin.line = attach_data.line_origin;
	end;

	else if Order = "set_window_info" then do;
	     call check_null ();
	     window_position_info_ptr = Info_ptr;
	     call require_version (window_position_info.version, window_position_info_version_1);

	     auto_capabilities_info.version = capabilities_info_version_1;
	     call iox_$control (target_iocbp, "get_capabilities", addr (auto_capabilities_info), Code);
	     if Code ^= 0 then
		return;

/* Verify that the new window position and bounds are within
   the screen bounds */
/* tc_ will verify that start+length-1 is within bounds ...
   perhaps this should all be done in one place */

	     Code = video_et_$window_too_big;

	     if (window_position_info.origin.line > auto_capabilities_info.screensize.rows)
		| (window_position_info.origin.line < 1) then
		return;

	     if window_position_info.extent.height < 1 then
		return;

	     if (window_position_info.origin.line + window_position_info.extent.height - 1)
		> auto_capabilities_info.screensize.rows then
		return;

	     if window_position_info.origin.column = 0 then
		window_position_info.origin.column = 1;

	     if window_position_info.origin.column < 1
		| window_position_info.origin.column > auto_capabilities_info.screensize.columns then
		return;

	     if window_position_info.extent.width > auto_capabilities_info.screensize.columns then
		return;

	     if window_position_info.extent.width = 0 then
		window_position_info.extent.width = auto_capabilities_info.screensize.columns;

	     Code = 0;

	     desk_info.window_id = attach_data.window_id;
	     desk_info.first_row = window_position_info.origin.line;
	     desk_info.n_rows = window_position_info.extent.height;
	     desk_info.first_column = window_position_info.origin.column;
	     desk_info.n_columns = window_position_info.extent.width;

	     call iox_$control (target_iocbp, "resize_window", addr (desk_info), Code);

	     if Code = video_et_$bad_window_id then do;
		call iox_$control (target_iocbp, "check_out_window", addr (desk_info), (0));
		desk_info.window_iocb_ptr = Iocb_ptr -> iocb.actual_iocb_ptr;
		call iox_$control (target_iocbp, "check_in_window", addr (desk_info), Code);
		if Code = 0 then
		     attach_data.window_id = desk_info.window_id;
	     end;
	     if Code ^= 0 then
		return;

/* Free the old-size window image. */
	     if attach_data.window_image_ptr ^= null () then
		free window_image in (attach_data_area);

rearrange_window:
	     begin;
declare  origin_change	  fixed bin;
declare  bottom_line_change	  fixed bin;
declare  old_origin		  fixed bin;
declare  old_bottom_line	  fixed bin;
declare  new_bottom_line	  fixed bin;

declare  saved_ignore_status	  bit (1) aligned;

declare  cleanup		  condition;

		saved_ignore_status = attach_data.ignore_status;

		on cleanup attach_data.ignore_status = saved_ignore_status;
		attach_data.ignore_status = "1"b;

		string (attach_data.status) = ""b;
		attach_data.status_pending = "0"b;

		origin_change = attach_data.current.line_origin - window_position_info.line;
						/* + if it went up, got new turf */
		old_origin = attach_data.current.line_origin;

		new_bottom_line = window_position_info.line + window_position_info.height - 1;
		old_bottom_line = old_origin + attach_data.current.rows - 1;

		bottom_line_change = new_bottom_line - old_bottom_line;

		attach_data.current.rows = window_position_info.height;
		attach_data.line_origin = window_position_info.line;

		attach_data.current.columns = window_position_info.width;
		attach_data.column_origin = window_position_info.column;

		if ^(((attach_data.current.line_origin >= old_origin)
						/** **/
		     & (attach_data.current.line_origin <= new_bottom_line))
						/* top is within old space */
		     | ((new_bottom_line >= old_origin) /** **/
		     & (new_bottom_line <= old_bottom_line)))
						/* no overlap */
		then do;
		     call window_$position_cursor (Iocb_ptr, (1), (1), (0));
		     call window_io_iox_$reset_more_entry (Iocb_ptr);
		end;

		else do;				/* There is some overlap, clear the new turf */

		     if attach_data.line > attach_data.current.rows then
			call window_$position_cursor (Iocb_ptr, attach_data.current.rows, (1), (0));
		     else if origin_change > 0 then
			call window_$change_line (Iocb_ptr, attach_data.line + origin_change, (0));
						/* same place on screen */

		end;

		attach_data.ignore_status = saved_ignore_status;
	     end rearrange_window;

	     call ioa_$rsnnl ("window_io_ ^a -first_line ^i -n_lines ^i -first_column ^i -n_columns ^i",
		attach_data.attach_description, (0), attach_data.target_iocb_ptr -> iocb.name,
		attach_data.line_origin, attach_data.current.rows, attach_data.column_origin,
		attach_data.current.columns);

	     attach_data.status_pending = "0"b;
	     string (attach_data.status) = ""b;

	     if attach_data.async_count > 0 then do;
		attach_data.status_pending = "1"b;
		attach_data.status.screen_invalid = "1"b;
	     end;

/* Now that all re-sizing is done, allocate new window image. */
	     allocate window_image in (attach_data_area);

	     if ^(attach_data.more_mode = MORE_MODE_SCROLL) then
		return;

	     auto_capabilities_info.version = capabilities_info_version_1;
	     call iox_$control (Iocb_ptr, "get_capabilities", addr (auto_capabilities_info), Code);
						/* window capabilities */
	     if Code ^= 0 then
		return;				/* at least we tried */
	     if ^auto_capabilities_info.scroll_region then
		attach_data.more_mode = MORE_MODE_WRAP;

	     return;
	end;

	else if Order = "get_editing_chars" then do;
	     call check_null ();
	     editing_chars_ptr = Info_ptr;
	     call require_version (editing_chars.version, editing_chars_version_3);
	     editing_chars.erase = attach_data.erase_char;
	     editing_chars.kill = attach_data.kill_char;
	end;

	else if Order = "set_editing_chars" then do;
	     call check_null ();
	     editing_chars_ptr = Info_ptr;
	     call require_version (editing_chars.version, editing_chars_version_3);
	     if index (WHITE_SPACE, editing_chars.erase) ^= 0 | index (WHITE_SPACE, editing_chars.kill) ^= 0
		| editing_chars.erase = editing_chars.kill then
		Code = error_table_$inconsistent;

	     else do;

		begin;
dcl      1 lekbi		  aligned like line_editor_key_binding_info based (sekbi.key_binding_info_ptr);
dcl      1 sekbi		  aligned like set_editor_key_bindings_info;

		     sekbi.version = set_editor_key_bindings_info_version_1;
		     sekbi.update = "1"b;
		     sekbi.replace = "0"b;
		     sekbi.mbz = (34)"0"b;
		     sekbi.key_binding_info_ptr = null ();
		     line_editor_binding_count = 4;
		     line_editor_longest_sequence = 1;

		     on cleanup
			begin;
			if sekbi.key_binding_info_ptr ^= null () then
			     free lekbi in (attach_data_area);
		     end;
		     allocate lekbi in (attach_data_area);

		     lekbi.version = line_editor_key_binding_info_version_3;

/* We may end up setting either character or both */
		     lekbi.binding_count = 0;

/* SPACE means don't change that character */

/* RL: phx19510 - handle case where both erase and kill are specified and */
/*       possibly being interchanged  */
		     if editing_chars.erase ^= SPACE & editing_chars.kill ^= SPACE then do;
			lekbi.binding_count = lekbi.binding_count + 4;

/* First unbind the previous erase char, to
   SELF_INSERT if it is a printing graphic or
   UNDEFINED if it is not. */

			if (attach_data.erase_char >= SPACE) & (attach_data.erase_char < DEL) then
			     lekbi.bindings (lekbi.binding_count - 3).action = SELF_INSERT;
			else lekbi.bindings (lekbi.binding_count - 3).action = UNDEFINED;
			lekbi.bindings (lekbi.binding_count - 3).sequence = attach_data.erase_char;

			lekbi.bindings (lekbi.binding_count - 1).action = BACKWARD_DELETE_CHARACTER;
			lekbi.bindings (lekbi.binding_count - 1).sequence = editing_chars.erase;

			attach_data.erase_char = editing_chars.erase;

			if (attach_data.kill_char >= SPACE) & (attach_data.kill_char < DEL) then
			     lekbi.bindings (lekbi.binding_count - 2).action = SELF_INSERT;
			else lekbi.bindings (lekbi.binding_count - 2).action = UNDEFINED;
			lekbi.bindings (lekbi.binding_count - 2).sequence = attach_data.kill_char;

			lekbi.bindings (lekbi.binding_count).action = KILL_TO_BEGINNING_OF_LINE;
			lekbi.bindings (lekbi.binding_count).sequence = editing_chars.kill;

			attach_data.kill_char = editing_chars.kill;



		     end;

		     else if editing_chars.erase ^= SPACE then do;
			lekbi.binding_count = lekbi.binding_count + 2;

/* First unbind the previous erase char, to
   SELF_INSERT if it is a printing graphic or
   UNDEFINED if it is not. */

			if (attach_data.erase_char >= SPACE) & (attach_data.erase_char < DEL) then
			     lekbi.bindings (lekbi.binding_count - 1).action = SELF_INSERT;
			else lekbi.bindings (lekbi.binding_count - 1).action = UNDEFINED;
			lekbi.bindings (lekbi.binding_count - 1).sequence = attach_data.erase_char;

			lekbi.bindings (lekbi.binding_count).action = BACKWARD_DELETE_CHARACTER;
			lekbi.bindings (lekbi.binding_count).sequence = editing_chars.erase;

			attach_data.erase_char = editing_chars.erase;
		     end;

		     else if editing_chars.kill ^= SPACE then do;
			lekbi.binding_count = lekbi.binding_count + 2;

/* First unbind the previous kill char, to
   SELF_INSERT if it is a printing graphic or
   UNDEFINED if it is not. */

			if (attach_data.kill_char >= SPACE) & (attach_data.kill_char < DEL) then
			     lekbi.bindings (lekbi.binding_count - 1).action = SELF_INSERT;
			else lekbi.bindings (lekbi.binding_count - 1).action = UNDEFINED;
			lekbi.bindings (lekbi.binding_count - 1).sequence = attach_data.kill_char;

			lekbi.bindings (lekbi.binding_count).action = KILL_TO_BEGINNING_OF_LINE;
			lekbi.bindings (lekbi.binding_count).sequence = editing_chars.kill;

			attach_data.kill_char = editing_chars.kill;
		     end;

		     /*** Use default strings for these */
		     lekbi.name (*), lekbi.description (*), lekbi.info_dir (*), lekbi.info_entry (*) = "";

		     call iox_$control (Iocb_ptr, "set_editor_key_bindings", addr (sekbi), Code);

		     temp_ptr = sekbi.key_binding_info_ptr;
		     sekbi.key_binding_info_ptr = null ();
		     free temp_ptr -> lekbi;
		end;
	     end;
	end;

	else if Order = "get_more_responses" then do;
	     call check_null ();
	     more_responses_info_ptr = Info_ptr;
	     call require_version (more_responses_info.version, more_responses_info_version_1);
	     more_responses_info.n_yeses = attach_data.n_yeses;
	     more_responses_info.n_noes = attach_data.n_noes;
	     more_responses_info.yeses = attach_data.more_yeses;
	     more_responses_info.noes = attach_data.more_noes;
	end;

	else if Order = "set_more_responses" then do;
	     call check_null ();
	     more_responses_info_ptr = Info_ptr;
	     call require_version (more_responses_info.version, more_responses_info_version_1);
	     if search (substr (more_responses_info.yeses, 1, more_responses_info.n_yeses),
		substr (more_responses_info.noes, 1, more_responses_info.n_noes)) > 0 then
		Code = video_et_$overlapping_more_responses;
	     else do;
		attach_data.n_yeses = more_responses_info.n_yeses;
		attach_data.n_noes = more_responses_info.n_noes;
		attach_data.more_yeses = more_responses_info.yeses;
		attach_data.more_noes = more_responses_info.noes;
	     end;
	end;					/* set_more_responses */

	else if Order = "get_window_status" then do;	/* destructive read */
	     call check_null ();
	     window_status_info_ptr = Info_ptr;
	     call require_version (window_status_info.version, window_status_version_1);
	     string (window_status_info.status_string) = string (attach_data.status);
	     string (attach_data.status) = "0"b;
	     attach_data.status_pending = "0"b;
	     return;
	end;

	else if Order = "set_window_status"		/* Interrupt */
	then do;					/* return codes from now Until doomsday */
	     call check_null ();
	     window_status_info_ptr = Info_ptr;
	     call require_version (window_status_info.version, window_status_version_1);
	     string (attach_data.status) = string (attach_data.status) | string (window_status_info.status_string);
	     attach_data.status_pending = "1"b;
	end;

	else if Order = "start" then
	     call iox_$control (target_iocbp, "start", null (), (0));

	else if Order = "set_break_table" then do;
	     call check_null ();
	     break_table_ptr = Info_ptr;
	     call require_version (break_table_info.version, break_table_info_version_1);
	     attach_data.breaks = string (break_table_info.breaks);
	end;
	else if Order = "get_break_table" then do;
	     call check_null ();
	     break_table_ptr = Info_ptr;
	     call require_version (break_table_info.version, break_table_info_version_1);
	     string (break_table_info.breaks) = attach_data.breaks;
	end;

	else if Order = "set_more_handler" then do;
	     call check_null ();
	     more_handler_info_ptr = Info_ptr;
	     call require_version (more_handler_info.version, more_handler_info_version_3);

/* return the old entry value if there was one */
	     if attach_data.more_handler_in_use then do;
		more_handler_info.old_more_handler = attach_data.more_handler;
		more_handler_info.old_handler_valid = "1"b;
	     end;
	     else more_handler_info.old_handler_valid = "0"b;

/* should the entry variable be verified in some way? */
	     attach_data.more_handler = more_handler_info.more_handler;
	     attach_data.more_handler_in_use = "1"b;
	end;

	else if Order = "get_more_handler" then do;
	     call check_null ();
	     more_handler_info_ptr = Info_ptr;
	     call require_version (more_handler_info.version, more_handler_info_version_3);
	     if ^attach_data.more_handler_in_use then do;
		Code = video_et_$no_more_handler_in_use;
		return;
	     end;
	     more_handler_info.more_handler = attach_data.more_handler;
	     more_handler_info.old_handler_valid = "0"b;
	     return;
	end;

	else if Order = "reset_more_handler" then
	     attach_data.more_handler_in_use = "0"b;

	else if Order = "set_token_characters" then do;
	     call check_null ();
	     token_characters_info_ptr = Info_ptr;
	     call require_version_str (token_characters_info.version, token_characters_info_version_1);
	     attach_data.token_characters = token_characters_info.token_characters;
	     attach_data.token_character_count = token_characters_info.token_character_count;
	end;

	else if Order = "get_token_characters" then do;
	     call check_null ();
	     token_characters_info_ptr = Info_ptr;
	     call require_version_str (token_characters_info.version, token_characters_info_version_1);
	     token_characters_info.token_characters = attach_data.token_characters;
	     token_characters_info.token_character_count = attach_data.token_character_count;
	end;

	else if Order = "set_more_prompt" then do;
	     call check_null ();
	     more_prompt_info_ptr = Info_ptr;
	     call require_version_str (more_prompt_info.version, more_prompt_info_version_1);
	     attach_data.more_prompt = more_prompt_info.more_prompt;
	end;

	else if Order = "get_more_prompt" then do;
	     call check_null ();
	     more_prompt_info_ptr = Info_ptr;
	     call require_version_str (more_prompt_info.version, more_prompt_info_version_1);
	     more_prompt_info.more_prompt = attach_data.more_prompt;
	end;

	else if Order = "set_editor_key_bindings" then do;
	     call check_null ();
	     set_editor_key_bindings_info_ptr = Info_ptr;

dcl      line_editor_key_binding_info_version_2
			  char (8) int static options (constant) init ("lekbi002");
						/* archaic version */
	     if set_editor_key_bindings_info.version = line_editor_key_binding_info_version_2
		| set_editor_key_bindings_info.version = line_editor_key_binding_info_version_3 then
		call update_key_bindings (set_editor_key_bindings_info_ptr);
	     else if set_editor_key_bindings_info.version ^= set_editor_key_bindings_info_version_1 then
		call error_exit (error_table_$unimplemented_version);
	     else if set_editor_key_bindings_info.replace = set_editor_key_bindings_info.update
						/* exactly one may be set */
		then
		call error_exit (error_table_$bad_subr_arg);
	     else if set_editor_key_bindings_info.update then
		call update_key_bindings (set_editor_key_bindings_info.key_binding_info_ptr);
	     else					/* if set_editor_key_bindings_info.replace */
		do;
		temp_ptr = attach_data.dispatch_table_ptr;
		attach_data.dispatch_table_ptr = set_editor_key_bindings_info.key_binding_info_ptr;
		free temp_ptr -> dispatch_table in (attach_data_area);
	     end;
	end;

	else if Order = "get_editor_key_bindings" then do;
	     call check_null ();
	     get_editor_key_bindings_info_ptr = Info_ptr;

	     call require_version_str (get_editor_key_bindings_info.version, get_editor_key_bindings_info_version_1);
	     call require_mbz (get_editor_key_bindings_info.flags.mbz);

	     if get_editor_key_bindings_info.entire_state then
		call make_key_bindings_copy (get_editor_key_bindings_info.entire_state_ptr);

	     else do;
		line_editor_key_binding_info_ptr = get_editor_key_bindings_info.key_binding_info_ptr;
		if line_editor_key_binding_info_ptr = null () then do;
		     call error_exit (error_table_$null_info_ptr);
		end;
		call require_version_str (line_editor_key_binding_info.version,
		     line_editor_key_binding_info_version_3);

dcl      bad_prefix		  condition;
		on bad_prefix			/* Signaled if he asks for the binding of a sequence */
		     call error_exit (error_table_$bad_subr_arg);
						/* with an invalid prefix sequence */

		do binding_index = 1 to line_editor_key_binding_info.binding_count;
		     call get_key_binding (line_editor_key_binding_info.sequence (binding_index),
			line_editor_key_binding_info.action (binding_index),
			line_editor_key_binding_info.numarg_action (binding_index),
			line_editor_key_binding_info.editor_routine (binding_index),
			line_editor_key_binding_info.name (binding_index),
			line_editor_key_binding_info.description (binding_index),
			line_editor_key_binding_info.info_path (binding_index));
		end;
	     end;

	     return;
	end;

	else if Order = "get_output_conversion" then do;
dcl      1 cts		  aligned like cv_trans_struc based (cts_ptr);
dcl      cts_ptr		  ptr;
	     call check_null ();
	     cts_ptr = Info_ptr;
	     if ^(cts.version = 1 | cts.version = CV_TRANS_VERSION)
						/* support both versions */
	     then do;
		Code = error_table_$unimplemented_version;
		return;
	     end;
	     begin;
dcl      index		  fixed bin;
		do index = 0 to CV_TRANS_SIZE (cts.version);
		     cts.cv_trans.value (index) = attach_data.output_cv_ptr -> cv_trans.value (index);
		end;				/* do */
	     end;					/* begin */
	end;

	else if Order = "set_output_conversion" then do;
	     call check_null ();
	     cts_ptr = Info_ptr;
	     if ^(cts.version = 1 | cts.version = CV_TRANS_VERSION)
						/* support both versions */
	     then do;
		Code = error_table_$unimplemented_version;
		return;
	     end;
	     if cts.default = 1 then			/* default to what we get from terminal control */
		do;
		call iox_$control (target_iocbp, "get_output_conversion", cts_ptr, Code);
		if Code ^= 0 then
		     return;
	     end;
	     attach_data.output_cv_ptr -> cv_trans.value (*) = OUTPUT_CONVERT_OCTAL;
						/* anything but garbage will do */
	     begin;
dcl      index		  fixed bin;
		do index = 0 to CV_TRANS_SIZE (cts.version);
		     attach_data.output_cv_ptr -> cv_trans.value (index) = cts.cv_trans.value (index);
		end;				/* do */
	     end;					/* begin */
						/* Set up tct table for quick conversion scan. */
	     begin;
dcl      cv_trans_idx	  fixed bin;
dcl      conversion_type	  fixed bin;

/* Fill in first 128 entries in string from regular table. */
		do cv_trans_idx = 0 to 127;
		     substr (attach_data.conversion_tct_table, cv_trans_idx + 1, 1) =
			byte (attach_data.output_cv_ptr -> cv_trans.value (cv_trans_idx));
		end;

/* Now handle next 128, giving defaults if necessary. */
		do cv_trans_idx = 128 to 255;
		     conversion_type = attach_data.output_cv_ptr -> cv_trans.value (cv_trans_idx);
		     if conversion_type = OUTPUT_CONVERT_ORDINARY
						/* bull */
			then
			substr (attach_data.conversion_tct_table, cv_trans_idx + 1, 1) =
			     byte (OUTPUT_CONVERT_OCTAL);
		     else substr (attach_data.conversion_tct_table, cv_trans_idx + 1, 1) = byte (conversion_type);
		end;

/* Now take care of things beyond limits of conversion table. */
		substr (attach_data.conversion_tct_table, 257, 256) = copy (byte (OUTPUT_CONVERT_OCTAL), 256);
	     end;					/* begin */

	end;

	else if Order = "get_special" then do;
dcl      1 gsi		  aligned like get_special_info_struc based (Info_ptr);
dcl      gsi_area		  area based (gsi.area_ptr);

dcl      1 gsi_old		  aligned based (Info_ptr),
	 2 area_ptr	  pointer,
	 2 table_ptr	  pointer;
dcl      gsi_area_old	  area based (gsi_old.area_ptr);

	     call check_null ();
	     sc_escape_len = attach_data.special_ptr -> special_chars.escape_length;
	     sc_input_escape_len = attach_data.special_ptr -> special_chars.input_escapes.len;
	     if gsi.version = SPECIAL_INFO_STRUCT_VERSION_1 then do;
		allocate special_chars_struc set (gsi.table_ptr) in (gsi_area);
		gsi.table_ptr -> special_chars_struc.version = SPECIAL_VERSION_2;
		addr (gsi.table_ptr -> special_chars_struc.special_chars) -> special_chars =
		     attach_data.special_ptr -> special_chars;
	     end;
	     else do;
		allocate special_chars_struc_old set (gsi_old.table_ptr) in (gsi_area_old);
		gsi_old.table_ptr -> special_chars_struc_old.version = SPECIAL_VERSION;
		call copy_new_to_old_special_table;
		if Code ^= 0 then do;
		     free gsi_old.table_ptr -> special_chars_struc_old;
		     gsi_old.table_ptr = null;
		end;
	     end;
	end;

	else if Order = "set_special" then do;
dcl      1 scs		  aligned like special_chars_struc based (scs_ptr);
dcl      scs_ptr		  ptr;
	     call check_null ();
	     scs_ptr = Info_ptr;

/* this used to be a call to require_version but since we need to allow two
   version numbers, it won't work any more.  We will check it inline for now */
	     if scs.version ^= SPECIAL_VERSION & scs.version ^= SPECIAL_VERSION_2
		& scs.version ^= editing_chars_version_2 then do;
		call error_exit (error_table_$unimplemented_version);
	     end;
	     on cleanup goto FREE_SCS;
	     if scs.default = 1 then do;		/* default to what we get from terminal control */
		begin;
dcl      1 auto_gsi		  like get_special_info_struc;
		     auto_gsi.version = SPECIAL_INFO_STRUCT_VERSION_1;
		     auto_gsi.area_ptr = get_system_free_area_ ();
		     call iox_$control (target_iocbp, "get_special", addr (auto_gsi), Code);
		     if Code ^= 0 then
			return;
		     scs_ptr = auto_gsi.table_ptr;
		end;				/* begin */
	     end;					/* then do */
	     sc_escape_len = scs.special_chars.escape_length;
	     sc_input_escape_len = scs.special_chars.input_escapes.len;
	     allocate special_chars set (temp_ptr);
	     if scs.version = SPECIAL_VERSION_2 then
		temp_ptr -> special_chars = addr (scs.special_chars) -> special_chars;
	     else call copy_old_to_new_special_table;
	     free attach_data.special_ptr -> special_chars;
	     attach_data.special_ptr = temp_ptr;
FREE_SCS:
	     if scs_ptr ^= Info_ptr			/* scs is what we got from terminal control, not what the user gave us */
		then
		free scs;
	end;

	else if Order = "read_status" then
	     call read_status ();

	else if (Order = "io_call") | (Order = "io_call_af") then
	     call process_io_call (Iocb_ptr, Order, Info_ptr, Code);

	else if Order = "set_audit_iocb_ptr" then
	     attach_data.auditor_iocb_ptr = Info_ptr;

	else if Order = "get_audit_iocb_ptr" then
	     Info_ptr = attach_data.auditor_iocb_ptr;

/* Unrecognized at window level, try passing on to tc_. */
	else call iox_$control (target_iocbp, Order, Info_ptr, Code);

	return;

update_key_bindings:
     proc (a_info_ptr);

dcl      a_info_ptr		  ptr parameter;

	line_editor_key_binding_info_ptr = a_info_ptr;

	if line_editor_key_binding_info.version = line_editor_key_binding_info_version_3 then do;

/* Verify that all actions are within the allowed values */
	     do binding_index = 1 to line_editor_key_binding_info.binding_count;
		if length (line_editor_key_binding_info.sequence (binding_index)) = 0 then do;
		     call error_exit (error_table_$bad_subr_arg);
		end;

		if (line_editor_key_binding_info.action (binding_index) < EXTERNAL_ROUTINE)
		     | (line_editor_key_binding_info.action (binding_index) > HIGHEST_BUILTIN_ROUTINE_VALUE) then do;
		     call error_exit (error_table_$bad_subr_arg);
		end;

		if (line_editor_key_binding_info.numarg_action (binding_index) < 0
		     | line_editor_key_binding_info.numarg_action (binding_index) > HIGHEST_NUMARG_ACTION_VALUE)
		     & ^(line_editor_key_binding_info.action (binding_index) = EXTERNAL_ROUTINE) then do;
		     call error_exit (error_table_$bad_subr_arg);
		end;

	     end;

/* set individual key bindings from structure */
	     do binding_index = 1 to line_editor_key_binding_info.binding_count;
		call set_key_binding (line_editor_key_binding_info.sequence (binding_index),
		     line_editor_key_binding_info.action (binding_index),
		     line_editor_key_binding_info.numarg_action (binding_index),
		     line_editor_key_binding_info.editor_routine (binding_index),
		     line_editor_key_binding_info.name (binding_index),
		     line_editor_key_binding_info.description (binding_index),
		     line_editor_key_binding_info.info_path (binding_index));
	     end;
	end;

	else if line_editor_key_binding_info.version = line_editor_key_binding_info_version_2 then do;
dcl      1 v2lekbi		  aligned based (line_editor_key_binding_info_ptr),
	 2 version	  char (8),
	 2 binding_count	  fixed bin,
	 2 longest_sequence	  fixed bin,
	 2 bindings	  (line_editor_binding_count refer (v2lekbi.binding_count)),
	   3 sequence	  char (line_editor_longest_sequence refer (v2lekbi.longest_sequence)) varying,
	   3 action	  fixed bin,
	   3 numarg_action	  fixed binary,
	   3 editor_routine	  entry (pointer, fixed bin (35));
dcl      1 blank_info_path	  like line_editor_key_binding_info.info_path;

	     do binding_index = 1 to v2lekbi.binding_count;
		if length (v2lekbi.sequence (binding_index)) = 0 then do;
		     call error_exit (error_table_$bad_subr_arg);
		end;

		if (v2lekbi.action (binding_index) < EXTERNAL_ROUTINE)
		     | (v2lekbi.action (binding_index) > HIGHEST_BUILTIN_ROUTINE_VALUE) then do;
		     call error_exit (error_table_$bad_subr_arg);
		end;

		if (v2lekbi.numarg_action (binding_index) < 0
		     | v2lekbi.numarg_action (binding_index) > HIGHEST_NUMARG_ACTION_VALUE)
		     & ^(v2lekbi.action (binding_index) = EXTERNAL_ROUTINE) then do;
		     call error_exit (error_table_$bad_subr_arg);
		end;

	     end;

	     blank_info_path.info_dir, blank_info_path.info_entry = "";

/* set individual key bindings from structure */
	     do binding_index = 1 to v2lekbi.binding_count;
		call set_key_binding (v2lekbi.sequence (binding_index), v2lekbi.action (binding_index),
		     v2lekbi.numarg_action (binding_index), v2lekbi.editor_routine (binding_index), "", "",
		     blank_info_path);
	     end;
	end;

	else call error_exit (error_table_$unimplemented_version);

	return;
     end update_key_bindings;

set_key_binding:
     procedure (sequence, action, numarg_action, editor_routine, name, description, info_path);

dcl      sequence		  char (*) varying;
dcl      action		  fixed bin;
dcl      numarg_action	  fixed bin;
dcl      editor_routine	  entry (ptr, fixed bin (35));
dcl      (name, description)	  char (*) varying aligned parameter;
dcl      1 info_path	  like line_editor_key_binding_info.info_path parameter;

dcl      char		  char (1) aligned;
dcl      char_fix		  fixed bin (9);
dcl      char_index		  fixed bin;
dcl      old_ptr		  pointer;
dcl      new_ptr		  pointer;

dcl      window_io_iox_$free_dispatch_tables
			  entry (ptr);

dcl      PREFIX		  fixed bin static options (constant) init (-1);

	char = substr (sequence, 1, 1);

/* If we are setting a single self-insert character, make sure that
   it can be echo negotiated */
	if (action = SELF_INSERT) & (length (sequence) = 1) & (char >= SPACE) & (char < DEL) then
	     call set_break_table (char, "0"b);
	else call set_break_table (char, "1"b);

	old_ptr = attach_data.dispatch_table_ptr;

/* loop through first characters setting up prefix tables. */
	do char_index = 1 to length (sequence) - 1;
	     char_fix = rank (substr (sequence, char_index, 1));

/* If char is not already a prefix, allocate new table. */
	     if old_ptr -> dispatch_table.key (char_fix).type >= 0 then do;
		allocate dispatch_table set (new_ptr);
		new_ptr -> dispatch_table.key (*).type = UNDEFINED;
						/* chain it in to current table */
		old_ptr -> dispatch_table.key (char_fix).next_table = new_ptr;
		old_ptr -> dispatch_table.key (char_fix).type = PREFIX;
	     end;
	     old_ptr = old_ptr -> dispatch_table.key (char_fix).next_table;
	end;

	char_fix = rank (substr (sequence, length (sequence), 1));

/* If a prefix turns into a leaf, free the old dispatch table */
	if old_ptr -> dispatch_table.key (char_fix).type = PREFIX then
	     call window_io_iox_$free_dispatch_tables (old_ptr -> dispatch_table.key (char_fix).next_table);

/* Set the specified dispatch table entry. */
	old_ptr -> dispatch_table.key (char_fix).type = action;

	if action = EXTERNAL_ROUTINE then do;
	     old_ptr -> dispatch_table.key (char_fix).routine = editor_routine;
	     old_ptr -> dispatch_table.key (char_fix).numarg_action = numarg_action;
	end;
	old_ptr -> dispatch_table.key (char_fix).name = name;
	old_ptr -> dispatch_table.key (char_fix).description = description;
	old_ptr -> dispatch_table.key (char_fix).info_path = info_path;

	return;

get_key_binding:
     entry (sequence, action, numarg_action, editor_routine, name, description, info_path);

	old_ptr = attach_data.dispatch_table_ptr;

	do char_index = 1 to length (sequence) - 1;
	     char_fix = rank (substr (sequence, char_index, 1));

/* If char is not a prefix then complain */
	     if old_ptr -> dispatch_table.key (char_fix).type >= 0 then
		signal bad_prefix;

	     old_ptr = old_ptr -> dispatch_table.key (char_fix).next_table;
	end;

	char_fix = rank (substr (sequence, length (sequence), 1));
	action = old_ptr -> dispatch_table.key (char_fix).type;

	if action = EXTERNAL_ROUTINE then do;
	     editor_routine = old_ptr -> dispatch_table.key (char_fix).routine;
	     numarg_action = old_ptr -> dispatch_table.key (char_fix).numarg_action;
	end;
	if length (old_ptr -> dispatch_table.key (char_fix).name) = 0 then
	     name = builtin_routine_names (max (action, lbound (builtin_routine_names, 1)));
	else name = old_ptr -> dispatch_table.key (char_fix).name;
	if length (old_ptr -> dispatch_table.key (char_fix).description) = 0 then
	     description = builtin_descriptions (max (action, lbound (builtin_descriptions, 1)));
	else description = old_ptr -> dispatch_table.key (char_fix).description;
	if old_ptr -> dispatch_table.key (char_fix).info_entry = "" then do;
	     if action = EXTERNAL_ROUTINE then do;
		info_path.info_entry = "";
		info_path.info_dir = "";
	     end;
	     else do;
		info_path.info_entry = BUILTIN_INFO_ENTRY;
		info_path.info_dir = BUILTIN_INFO_DIR;
	     end;
	end;
	else info_path = old_ptr -> dispatch_table.key (char_fix).info_path;

	return;

     end set_key_binding;

make_key_bindings_copy:
     procedure (new_ptr);

dcl      new_ptr		  ptr;			/* (output) points to a copy of the dispatch table hierarchy */

	call copy_dispatch_table (attach_data.dispatch_table_ptr, new_ptr);
	return;

copy_dispatch_table:
	procedure (old_ptr, new_ptr);

dcl      (old_ptr, new_ptr)	  ptr;

dcl      key_num		  fixed bin;

	     allocate dispatch_table in (attach_data_area) set (new_ptr);
	     new_ptr -> dispatch_table = old_ptr -> dispatch_table;
	     do key_num = lbound (old_ptr -> dispatch_table.key, 1) to hbound (old_ptr -> dispatch_table.key, 1);
		if old_ptr -> dispatch_table.key (key_num).type < 0 then
		     call copy_dispatch_table (old_ptr -> dispatch_table.key (key_num).next_table,
			new_ptr -> dispatch_table.key (key_num).next_table);
	     end;

	     return;

	end copy_dispatch_table;

     end make_key_bindings_copy;

process_io_call:
     procedure (io_call_iocb, io_call_order, io_call_infop, code);

dcl      io_call_iocb	  pointer parameter;
dcl      io_call_order	  char (*) parameter;
dcl      code		  fixed bin (35) parameter;

%include io_call_info;

dcl      iocb_ptr		  pointer;
dcl      order		  char (32);
dcl      caller		  char (32);
dcl      called_as_af	  bit (1);
dcl      i		  fixed bin;
dcl      arg_index		  fixed bin;
dcl      entry_name		  char (65);		/* 32 + 1 + 32 */

dcl      1 MHI		  aligned like more_handler_info;
dcl      1 MRI		  aligned like more_responses_info;
dcl      1 MPI		  aligned like more_prompt_info;
dcl      1 TCI		  aligned like token_characters_info;
dcl      1 WSI		  aligned like window_status_info;
dcl      1 EC		  aligned like editing_chars;

dcl      error_table_$wrong_no_of_args
			  fixed bin (35) external;
dcl      error_table_$undefined_order_request
			  fixed bin (35) external;
dcl      error_table_$noarg	  fixed bin (35) external;
dcl      error_table_$bad_arg	  fixed bin (35) external;
dcl      error_table_$badopt	  fixed bin (35) external;

dcl      cv_entry_		  entry (char (*), ptr, fixed bin (35)) returns (entry);

	code = 0;

	iocb_ptr = io_call_iocb -> iocb.actual_iocb_ptr;

	if io_call_order = "io_call" then
	     called_as_af = "0"b;
	else do;
	     called_as_af = "1"b;
	     io_call_af_ret = "";
	end;

	order = io_call_info.order_name;
	caller = io_call_info.caller_name;

	if order = "set_more_handler" then do;
	     if io_call_info.nargs = 0 then do;
		call io_call_info.error (0, "", "usage: io_call control window_switch set_more_handler more_handler");
		return;
	     end;
	     if io_call_info.nargs > 1 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller, "Only one more handler name may be specified. ^a",
		     order);
		return;
	     end;

	     MHI.version = more_handler_info_version_3;
	     MHI.more_handler = cv_entry_ ((io_call_info.args (1)), codeptr (process_io_call), code);
	     if code ^= 0 then do;
		call io_call_info
		     .
		     error (code, caller, "Could not covert ""^a"" to an entry value. ^a", io_call_info.args (1),
		     order);
		code = 0;
		return;
	     end;
	     call iox_$control (iocb_ptr, order, addr (MHI), code);
	     if code ^= 0 then
		call io_call_info.error (code, caller, "While setting more handler. ^a", order);
	     code = 0;
	     return;
	end;

	else if order = "get_more_handler" then do;
	     call io_call_require_no_args ();
	     MHI.version = more_handler_info_version_3;
	     call iox_$control (iocb_ptr, order, addr (MHI), code);
	     if code ^= 0 & code ^= video_et_$no_more_handler_in_use then do;
		call io_call_info.error (code, caller, "While getting more handler. ^a", order);
		code = 0;
		return;
	     end;
	     if code = video_et_$no_more_handler_in_use then do;
		if called_as_af then
		     call ioa_$rsnnl ("NONE", io_call_af_ret, (0));
		else call io_call_info.report ("No more handler in use.");
		code = 0;
		return;
	     end;
	     call entry_var_to_string (MHI.more_handler, entry_name, code);
	     if code ^= 0 then do;
		call io_call_info.error (code, caller, "While getting name of more handler. ^a", order);
		code = 0;
		return;
	     end;
	     if called_as_af then
		call ioa_$rsnnl ("^a", io_call_af_ret, (0), rtrim (entry_name));
	     else call io_call_info.report ("More handler: ^a", rtrim (entry_name));
	     return;
	end;

	else if order = "set_more_responses" then do;
	     if io_call_info.nargs = 0 then do;
		call io_call_info
		     .
		     error (0, "",
		     "usage: io_call control window_switch set_more_responses yes_responses no_responses");
		return;
	     end;
	     if io_call_info.nargs < 2 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller, "Both yes and no responses must be specified. ^a",
		     order);
		return;
	     end;
	     if io_call_info.nargs > 2 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller,
		     "Only one yes response string and one no response string may be specified. ^a", order);
		return;
	     end;
	     MRI.version = more_responses_info_version_1;
	     MRI.n_yeses = length (io_call_info.args (1));
	     MRI.yeses = io_call_info.args (1);
	     MRI.n_noes = length (io_call_info.args (2));
	     MRI.noes = io_call_info.args (2);		/* rely on real control order to validate responses */
	     call iox_$control (iocb_ptr, order, addr (MRI), code);
	     if code ^= 0 then
		call io_call_info.error (code, caller, "While setting more responses. ^a", order);
	     code = 0;
	     return;
	end;

	else if order = "get_more_responses" then do;
	     call io_call_require_no_args ();
	     MRI.version = more_responses_info_version_1;
	     call iox_$control (iocb_ptr, order, addr (MRI), code);
	     if code ^= 0 then do;
		call io_call_info.error (code, caller, "While getting more repsonses. ^a", order);
		code = 0;
		return;
	     end;
	     if called_as_af then
		call ioa_$rsnnl ("^a ^a", io_call_af_ret, (0), substr (MRI.yeses, 1, MRI.n_yeses),
		     substr (MRI.noes, 1, MRI.n_noes));
	     else do;
dcl      (yeses, noes)	  char (255) varying init ("");
		do i = 1 to max (MRI.n_yeses, MRI.n_noes);
		     if i <= MRI.n_yeses then
			yeses = yeses || flat_rep (substr (MRI.yeses, i, i + 1)) || " ";
		     if i <= MRI.n_noes then
			noes = noes || flat_rep (substr (MRI.noes, i, i + 1)) || " ";
		end;				/* do loop */
		call io_call_info
		     .
		     report ("Yes Response^[s^]: ""^a""  No Response^[s^]: ""^a""", MRI.n_yeses > 1, yeses,
		     MRI.n_noes > 1, noes);
	     end;
	     return;
	end;

	else if order = "set_more_prompt" then do;
	     if io_call_info.nargs = 0 then do;
		call io_call_info.error (0, "", "usage: io_call control window_switch set_more_prompt prompt_string");
		return;
	     end;
	     if io_call_info.nargs > 1 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller, "Only one more prompt string may be specified. ^a",
		     order);
		return;
	     end;
	     MPI.version = more_prompt_info_version_1;
	     MPI.more_prompt = io_call_info.args (1);
	     call iox_$control (iocb_ptr, order, addr (MPI), code);
	     if code ^= 0 then
		call io_call_info.error (code, caller, "While setting more prompt. ^a", order);
	     code = 0;
	     return;
	end;

	else if order = "get_more_prompt" then do;
	     call io_call_require_no_args ();
	     MPI.version = more_prompt_info_version_1;
	     call iox_$control (iocb_ptr, order, addr (MPI), code);
	     if code ^= 0 then do;
		call io_call_info.error (code, caller, "While getting more prompt. ^a", order);
		code = 0;
		return;
	     end;
	     if called_as_af then
		call ioa_$rsnnl ("^a", io_call_af_ret, (0), MPI.more_prompt);
	     else call io_call_info.report ("More prompt: ""^a""", MPI.more_prompt);
	     return;
	end;


	else if order = "set_editor_key_bindings" then do;
	     if io_call_info.nargs = 0 then do;
binding_usage:
		call io_call_info
		     .
		     error (0, "",
		     "usage: io_call control window_switch set_editor_key_bindings character_sequence1 {editor_routine1} {control_args_1} ... {character_sequenceN {editor_routineN} {control_argsN}}"
		     );
		return;
	     end;

/* Prepare to build args structure. */
/* Pass one, count number bindings and get max length,
   don't validate args at all */

	     line_editor_binding_count = 0;
	     line_editor_longest_sequence = 0;

	     call count_key_binding_args (1 /* arg_index */, line_editor_binding_count, line_editor_longest_sequence);

	     if line_editor_binding_count = 0 | line_editor_longest_sequence = 0 then
		goto binding_usage;			/* must not know what's going on */

	     allocate line_editor_key_binding_info set (line_editor_key_binding_info_ptr);
	     on cleanup free line_editor_key_binding_info;

	     line_editor_key_binding_info.version = line_editor_key_binding_info_version_3;

/* Fill in the individual bindings. */
/* now check the control arg validity */

	     call process_key_bindings (1 /* arg_index */, 1 /* binding_index */);

	     call iox_$control (iocb_ptr, order, line_editor_key_binding_info_ptr, code);
	     revert cleanup;
	     free line_editor_key_binding_info;
	     if code ^= 0 then
		call io_call_info.error (code, caller, "While setting key bindings. ^a", order);
	     code = 0;
	     return;
	end;

	else if order = "get_editor_key_bindings" then do;
	     if io_call_info.nargs ^= 1 then do;
		call io_call_info
		     .
		     error (0, "", "usage: io_call control window_switch get_editor_key_bindings character_sequence");
		call error_exit (Code);
	     end;
	     begin;
dcl      1 gekbi		  aligned like get_editor_key_bindings_info;
dcl      1 lekbi		  aligned like line_editor_key_binding_info based (gekbi.key_binding_info_ptr);

		gekbi.version = get_editor_key_bindings_info_version_1;
		string (gekbi.flags) = ""b;
		gekbi.key_binding_info_ptr = null ();
		line_editor_binding_count = 1;
		line_editor_longest_sequence = length (io_call_info.args (1));
		on cleanup
		     begin;
		     if gekbi.key_binding_info_ptr = null () then
			free line_editor_key_binding_info in (attach_data_area);
		end;
		allocate lekbi in (attach_data_area);

		lekbi.version = line_editor_key_binding_info_version_3;
		lekbi.sequence (1) = io_call_info.args (1);

		call iox_$control (iocb_ptr, order, addr (gekbi), code);
		if code ^= 0 then do;
		     call io_call_info
			.
			error (code, caller, "Getting the binding of ^a. ^a",
			requote_string_ ((io_call_info.args (1))), order);
		     return;
		end;

dcl      routine_pathname	  char (256);
		if lekbi.action (1) = EXTERNAL_ROUTINE then do;
		     call entry_var_to_string (lekbi.editor_routine (1), routine_pathname, code);
		     if code ^= 0 then
			return;
		end;

/* Note, numarg actions for builtins are only defined in window_io_iox_,
   so we don't return them here.  There should be a way to get at them. */

		if called_as_af then do;		/* it is easier to get right this way, rather than to have one really hairy ioa_$rsnnl ... */
		     if lekbi.action (1) = EXTERNAL_ROUTINE then
			call ioa_$rsnnl ("^a ^a -numarg_action ^a -name ^a -description ^a ^[-info_pathname ^a]",
			     io_call_af_ret, (0), requote_string_ ((lekbi.sequence (1))),
			     requote_string_ (rtrim (routine_pathname)),
			     numarg_action_names (lekbi.numarg_action (1)),
			     requote_string_ (rtrim (lekbi.name (1))),
			     requote_string_ (rtrim (lekbi.description (1))),
			     (lekbi.info_entry (1) ^= "") /* empty path? */,
			     requote_string_ (rtrim (pathname_ (lekbi.info_dir (1), lekbi.info_entry (1)))));
		     else if lekbi.action (1) > EXTERNAL_ROUTINE then
						/* a builtin */
			call ioa_$rsnnl ("^a -builtin ^a -description ^a^[ -info_pathname ^a^]", io_call_af_ret,
			     (0), lekbi.sequence (1), builtin_routine_names (lekbi.action (1)),
			     requote_string_ (rtrim (lekbi.description (1))),
			     (lekbi.info_entry (1) ^= "") /* empty path? */,
			     requote_string_ (rtrim (pathname_ (lekbi.info_dir (1), lekbi.info_entry (1)))));
		     else				/* a prefix key, for sure */
			call ioa_$rsnnl ("^a -name PREFIX -description ^a", io_call_af_ret, (0),
			     requote_string_ ((lekbi.sequence (1))),
			     requote_string_ (rtrim (lekbi.description (1))));
		end;				/* case for AF */

		else call io_call_info
			.
			report (
			"Sequence: ^a^/    ^[Num-arg action: ^a^/    Procedure: ^a^/    ^;^2s^]Name: ^a^/    Description: ^a^[^/    Info path: ^a^]",
			flat_rep_string (lekbi.sequence (1)), (lekbi.action (1) = EXTERNAL_ROUTINE),
			numarg_action_names (lekbi.numarg_action (1)), routine_pathname, lekbi.name (1),
			lekbi.description (1), (lekbi.info_entry (1) ^= "") /* no path supplied */,
			pathname_ (lekbi.info_dir (1), lekbi.info_entry (1)));

		revert cleanup;
		free lekbi in (attach_data_area);
	     end;
	     code = 0;
	     return;
	end;

	else if order = "set_token_characters" then do;
	     if io_call_info.nargs = 0 then do;
		call io_call_info
		     .
		     error (0, "", "usage: io_call control window_switch set_token_characters token_character_string")
		     ;
		return;
	     end;
	     if io_call_info.nargs > 1 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller,
		     "Only one string of token characters may be specified. ^a", order);
		return;
	     end;

	     TCI.version = token_characters_info_version_1;
	     TCI.token_character_count = length (io_call_info.args (1));
	     TCI.token_characters = io_call_info.args (1);

	     call iox_$control (iocb_ptr, order, addr (TCI), code);
	     if code ^= 0 then
		call io_call_info.error (code, caller, "While setting token characters. ^a", order);
	     code = 0;
	     return;
	end;

	else if order = "get_token_characters" then do;
	     call io_call_require_no_args ();
	     TCI.version = token_characters_info_version_1;
	     call iox_$control (iocb_ptr, order, addr (TCI), code);
	     if code ^= 0 then do;
		call io_call_info.error (code, caller, "While getting token characters. ^a", order);
		code = 0;
		return;
	     end;
	     if called_as_af then
		io_call_af_ret = substr (TCI.token_characters, 1, TCI.token_character_count);
	     else call io_call_info.report ("^a", substr (TCI.token_characters, 1, TCI.token_character_count));
	     return;
	end;

	else if order = "get_window_status" then do;
	     call io_call_require_no_args ();
	     WSI.version = window_status_version_1;
	     call iox_$control (iocb_ptr, order, addr (WSI), code);
	     if code ^= 0 then do;
		call io_call_info.error (code, caller, "While getting window status. ^a", order);
		code = 0;
		return;
	     end;
	     if called_as_af then do;
		if (WSI.status_string = ""b) then
		     io_call_af_ret = "NONE";
		else call ioa_$rsnnl ("^[SCREEN_INVALID ^]^[ASYNC_CHANGE ^]^[TTP_CHANGE ^]^[RECONNECTION^]",
			io_call_af_ret, (0), (WSI.status_string & W_STATUS_SCREEN_INVALID),
			(WSI.status_string & W_STATUS_ASYNC_EVENT), (WSI.status_string & W_STATUS_TTP_CHANGE),
			(WSI.status_string & W_STATUS_RECONNECTION));
	     end;
	     else call io_call_info
		     .
		     report (
		     "There was ^[no ^]^[screen_invalid ^]^[async_change ^]^[ttp_change ^]^[reconnection ^]status pending for the window.",
		     (WSI.status_string = ""b), (WSI.status_string & W_STATUS_SCREEN_INVALID),
		     (WSI.status_string & W_STATUS_ASYNC_EVENT), (WSI.status_string & W_STATUS_TTP_CHANGE),
		     (WSI.status_string & W_STATUS_RECONNECTION));
	     return;
	end;

	else if order = "set_window_status" then do;
	     if io_call_info.nargs = 0 then do;
		call io_call_info
		     .error (0, "", "usage: io control window_switch set_window_status status_key_1 {status_key_2}");
		return;
	     end;
	     WSI.version = window_status_version_1;
	     do arg_index = 1 to io_call_info.nargs;
		if io_call_info.args (arg_index) = "screen_invalid" then
		     WSI.status_string = WSI.status_string | W_STATUS_SCREEN_INVALID;
		else if io_call_info.args (arg_index) = "asynchronous_change"
		     | io_call_info.args (arg_index) = "async_change" then
		     WSI.status_string = WSI.status_string | W_STATUS_ASYNC_EVENT;
		else if io_call_info.args (arg_index) = "terminal_type_change"
		     | io_call_info.args (arg_index) = "ttp_change" then
		     WSI.status_string = WSI.status_string | W_STATUS_TTP_CHANGE;
		else if io_call_info.args (arg_index) = "reconnection" then
		     WSI.status_string = WSI.status_string | W_STATUS_RECONNECTION;
		else do;
		     call io_call_info
			.
			error (error_table_$bad_arg, caller,
			"Only screen_invalid or asynchronous_change is allowed, not ""^a."" ^a",
			io_call_info.args (arg_index), order);
		     return;
		end;
	     end;					/* do loop */
	     call iox_$control (iocb_ptr, order, addr (WSI), code);
	     return;
	end;

/* this is a bit much for a pretty worthless control order (after all
   there is stty -edit), but if we're going to do it, let's do it right */

	else if order = "set_editing_chars" then do;
	     if io_call_info.nargs = 0 then do;
		call io_call_info
		     .error (0, "", "usage: io_call control window_switch set_editing_chars erase_kill_characters");
		return;
	     end;
	     if io_call_info.nargs > 1 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller,
		     "Only one set of editing characters may be specified. ^a", order);
		return;
	     end;
	     if length (io_call_info.args (1)) < 2 then do;
		call io_call_info
		     .
		     error (error_table_$bad_arg, caller, "Both erase and kill characters must be specified. ^a",
		     order);
		return;
	     end;
	     if length (io_call_info.args (1)) > 3 then do;
		call io_call_info
		     .
		     error (error_table_$bad_arg, caller,
		     "Only one erase character, one kill character and one redisplay character may be specified. ^a",
		     order);
		return;
	     end;
	     EC.erase = substr (io_call_info.args (1), 1, 1);
	     EC.kill = substr (io_call_info.args (1), 2, 1);
	     if length (io_call_info.args (1)) = 3 then do;
		EC.version = editing_chars_version_3;
		EC.redisplay = substr (io_call_info.args (1), 3, 1);
	     end;
	     else do;
		EC.version = editing_chars_version_2;
		EC.redisplay = "";
	     end;

	     call iox_$control (iocb_ptr, order, addr (EC), code);
	     if code ^= 0 then
		call io_call_info.error (code, caller, "While setting editing characters. ^a", order);
	     return;
	end;

	else if order = "get_editing_chars" then do;
	     call io_call_require_no_args ();
	     EC.version = editing_chars_version_3;
	     call iox_$control (iocb_ptr, order, addr (EC), code);
	     if code ^= 0 then
		return;
	     if called_as_af then
		call ioa_$rsnnl ("^a^a^a", io_call_af_ret, (0), EC.erase, EC.kill, EC.redisplay);
	     else call io_call_info
		     .
		     report ("Erase: ^a, Kill: ^a, Redisplay: ^a", flat_rep (EC.erase), flat_rep (EC.kill),
		     flat_rep (EC.redisplay));
	     return;
	end;

	code = error_table_$undefined_order_request;
	return;

io_call_require_no_args:
	procedure;

	     if io_call_info.nargs ^= 0 then do;
		call io_call_info
		     .
		     error (error_table_$wrong_no_of_args, caller, "No arguments are allowed for the ^a order.",
		     order);
		call error_exit (Code);
	     end;
	end io_call_require_no_args;

/* Count the number of args (and longest key sequence) for
   set_editor_key_bindings, so we can allocate the
   line_editor_key_binding_structure (refer extents).
   The only validity checking done here is to ensure that a reasonable
   number of arguments were given (i.e. we catch "\033 foo \034", here
   and complain about now editor routine for \034), but all other
   checking is done later. */

/* We get called once for each key binding to be set, thus we know that
   arg_index will always start pointing at the key sequence */

count_key_binding_args:
	procedure (arg_index, binding_count, longest_key_sequence);

dcl      arg_index		  fixed bin,
         binding_count	  fixed bin,
         longest_key_sequence	  fixed bin;

dcl      ctl_arg_flag	  bit (1);

	     do while (arg_index <= io_call_info.nargs);

		if arg_index = io_call_info.nargs then do;
		     if index (io_call_info.args (arg_index), "-") = 1 then
			return;
		     call io_call_info
			.
			error (error_table_$noarg, caller,
			"Editor routine for character sequence ""^a"" must be specified.",
			io_call_info.args (arg_index));
		     call error_exit (Code);
		end;

		longest_key_sequence = max (length (io_call_info.args (arg_index)), longest_key_sequence);
		binding_count = binding_count + 1;

		arg_index = arg_index + 1;

		if index (io_call_info.args (arg_index), "-") ^= 1 then
		     arg_index = arg_index + 1;	/* skip over external routine name */

/* skip over any control args (-control_arg arg), -control_arg -control_arg
   will squeak by here but will be caught later */

		if arg_index <= io_call_info.nargs then
		     if index (io_call_info.args (arg_index), "-") = 1 then do;
			ctl_arg_flag = "1"b;
			do while (ctl_arg_flag);
			     arg_index = arg_index + 2;
			     if arg_index < io_call_info.nargs then
				ctl_arg_flag = (index (io_call_info.args (arg_index), "-") = 1);
			     else ctl_arg_flag = "0"b;
			end;			/* do while */
		     end;

	     end;					/* main do while loop */

	     return;

	end count_key_binding_args;

/* fill in line_editor_key_binding_info */

process_key_bindings:
	procedure (arg_index, binding_index);

dcl      arg_index		  fixed bin;
dcl      binding_index	  fixed bin;

dcl      1 flags		  aligned,
	 2 builtin_given	  unaligned bit (1),
	 2 external_given	  unaligned bit (1),
	 2 numarg_action_given
			  unaligned bit (1);

	     do while (arg_index <= io_call_info.nargs);

		unspec (flags) = ""b;

/* copy the sequence directly from the command line */
		line_editor_key_binding_info.sequence (binding_index) = io_call_info.args (arg_index);

		/*** Initialize the strings to blanks ***/
		line_editor_key_binding_info.name, line_editor_key_binding_info.description,
		     line_editor_key_binding_info.info_dir, line_editor_key_binding_info.info_entry = "";

		arg_index = arg_index + 1;

		if index (io_call_info.args (arg_index), "-") ^= 1 then do;
		     line_editor_key_binding_info.action (binding_index) = EXTERNAL_ROUTINE;
						/* convert the companion arg to an entry */
		     line_editor_key_binding_info.editor_routine (binding_index) =
			cv_entry_ ((io_call_info.args (arg_index)), codeptr (process_io_call), code);
		     if code ^= 0 then do;
			call io_call_info
			     .
			     error (code, caller, "Could not convert ""^a"" to an entry value. ^a",
			     io_call_info.args (arg_index), order);
			code = 0;
			call error_exit (Code);
		     end;
		     external_given = "1"b;
		     builtin_given = "0"b;
		     arg_index = arg_index + 1;	/* fall through to check for control args for this external editor request */
		end;

		if arg_index <= io_call_info.nargs then
		     if index (io_call_info.args (arg_index), "-") = 1 then
						/* a control arg */
			call process_control_args (arg_index, binding_index);

		if ^(builtin_given | external_given) then do;
		     call io_call_info
			.
			error (error_table_$noarg, caller,
			"Editor routine for character sequence ""^a"" must be specified. ^a",
			line_editor_key_binding_info.sequence (binding_index), order);
		     call error_exit (Code);
		end;

		if builtin_given & numarg_action_given then do;
		     call io_call_info
			.
			error (error_table_$inconsistent, caller,
			"Numarg action may not be specified for builtin routines. ^a", order);
		     call error_exit (Code);
		end;

		if ^numarg_action_given & external_given then
		     line_editor_key_binding_info.numarg_action (binding_index) = PASS;

		binding_index = binding_index + 1;

	     end;					/* do while */

	     return;

/* Process control args for set_editor_key_bindings.
   arg_index will be left set to the next non-control arg */

process_control_args:
	     procedure (arg_index, binding_index);

dcl      arg_index		  fixed bin;
dcl      binding_index	  fixed bin;
dcl      builtin_index	  fixed bin;
dcl      numarg_index	  fixed bin;
dcl      arg		  char (arg_len) varying based (arg_ptr);
dcl      next_arg		  char (next_arg_len) varying based (next_arg_ptr);
dcl      (arg_len, next_arg_len)
			  fixed bin (21);
dcl      (arg_ptr, next_arg_ptr)
			  ptr;
dcl      found		  bit (1);

dcl      uppercase		  char (26) static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl      lowercase		  char (26) static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
dcl      expand_pathname_$add_suffix
			  entry (char (*), char (*), char (*), char (*), fixed bin (35));

		do while (arg_index <= io_call_info.nargs);

		     arg_ptr = addr (io_call_info.args (arg_index));
		     arg_len = length (io_call_info.args (arg_index));

		     if index (arg, "-") ^= 1 then
			return;			/* done with control args for this key binding */

		     if ^(arg = "-builtin" | arg = "-external" | arg = "-numarg_action" | arg = "-name"
			| arg = "-description" | arg = "-info_pathname") then do;
			call io_call_info.error (error_table_$badopt, caller, "^a. ^a", arg, order);
			call error_exit (Code);
		     end;

		     if arg_index = io_call_info.nargs then do;
			call io_call_info
			     .error (error_table_$noarg, caller, """^a"" requires an argument. ^a", arg, order);
			call error_exit (Code);
		     end;

		     next_arg_ptr = addr (io_call_info.args (arg_index + 1));
		     next_arg_len = length (io_call_info.args (arg_index + 1));

		     if arg = "-external" then do;
			line_editor_key_binding_info.action (binding_index) = EXTERNAL_ROUTINE;
						/* convert the companion arg to an entry */
			line_editor_key_binding_info.editor_routine (binding_index) =
			     cv_entry_ ((next_arg), codeptr (process_io_call), code);
			if code ^= 0 then do;
			     call io_call_info
				.
				error (code, caller, "Could not convert ""^a"" to an entry value. ^a", next_arg,
				order);
			     code = 0;
			     call error_exit (Code);
			end;
			external_given = "1"b;
			builtin_given = "0"b;
		     end;

/* We assume that builtin names are all uppercase, and we uppercase the user
   supplied name before doing the comparision, so that everything is
   case insensitive.  Same goes for numarg_action. */

		     if arg = "-builtin" then do;	/* skip EXTERNAL_ROUTINE */
			begin;
dcl      next_arg_uppercase	  char (next_arg_len);
			     found = "0"b;
			     next_arg_uppercase = translate (next_arg, uppercase, lowercase);
			     do builtin_index = 1 to HIGHEST_BUILTIN_ROUTINE_VALUE while (^found);
				if builtin_routine_names (builtin_index) = next_arg_uppercase then
				     found = "1"b;
			     end;			/* do while */
			end;			/* begin */
			if ^found then do;
			     call io_call_info
				.
				error (error_table_$bad_arg, caller,
				"""^a"" is not a builtin editor function. ^a", next_arg, order);
			     call error_exit (Code);
			end;
			line_editor_key_binding_info.action (binding_index) = builtin_index - 1;
						/* do loop adds one */
			builtin_given = "1"b;
			external_given = "0"b;
		     end;

		     else if arg = "-numarg_action" then do;
			begin;
dcl      next_arg_uppercase	  char (next_arg_len);
			     found = "0"b;
			     next_arg_uppercase = translate (next_arg, uppercase, lowercase);
			     do numarg_index = 0 to HIGHEST_NUMARG_ACTION_VALUE while (^found);
				if numarg_action_names (numarg_index) = next_arg_uppercase then
				     found = "1"b;
			     end;			/* do while */
			end;			/* begin */
			if ^found then do;
			     call io_call_info
				.
				error (error_table_$bad_arg, caller, """^a"" is not a valid numarg action. ^a",
				next_arg, order);
			     call error_exit (Code);
			end;
			line_editor_key_binding_info.numarg_action (binding_index) = numarg_index - 1;
						/* do loop adds one */
			numarg_action_given = "1"b;
		     end;

		     else if arg = "-name" then
			line_editor_key_binding_info.name (binding_index) = next_arg;
		     else if arg = "-description" then
			line_editor_key_binding_info.description (binding_index) = next_arg;
		     else if arg = "-info_pathname" then do;
			call expand_pathname_$add_suffix ((next_arg), "info",
			     line_editor_key_binding_info.info_dir (binding_index),
			     line_editor_key_binding_info.info_entry (binding_index), code);
			if code ^= 0 then do;
			     call io_call_info.error (code, caller, "The pathname ""^a"". ^a", next_arg, order);
			     call error_exit (Code);
			end;
		     end;

		     arg_index = arg_index + 2;	/* make sure we call by reference */


		end;				/* do while */

		return;

	     end process_control_args;

	end process_key_bindings;

     end process_io_call;

require_version:
     proc (version_found, latest);

dcl      version_found	  fixed bin parameter;
dcl      latest		  fixed bin parameter;

	if version_found ^= latest & version_found ^= editing_chars_version_2 then do;
	     call error_exit (error_table_$unimplemented_version);
	end;

     end require_version;

require_version_str:
     proc (version_found, latest);

dcl      version_found	  char (8) aligned;
dcl      latest		  char (8);

	if version_found ^= latest then do;
	     call error_exit (error_table_$unimplemented_version);
	end;

     end require_version_str;

check_null:
     procedure;
	if Info_ptr = null () then do;
	     call error_exit (error_table_$null_info_ptr);
	end;
     end check_null;

require_mbz:
     proc (bit_string);

dcl      bit_string		  bit (*);

	if bit_string ^= ""b then do;
	     call error_exit (error_table_$bad_subr_arg);
	end;
     end require_mbz;

setup:
     procedure;
	attach_data_ptr = Iocb_ptr -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
	Code = 0;
	target_iocbp = attach_data.target_iocb_ptr;
     end setup;

always_breaks:
     procedure (c) returns (bit (1) aligned) reducible;
dcl      c		  char (1) aligned parameter;
	return (rank (c) <= 31 | c = byte (bin ("177"b3)) /* DEL */);
     end always_breaks;

set_break_table:
     proc (c, flag);

dcl      c		  char (1) aligned;
dcl      flag		  bit (1) unaligned;

	if (rank (c) >= lbound (line_editor_breaks_array, 1)) & (rank (c) <= hbound (line_editor_breaks_array, 1)) then
	     line_editor_breaks_array (rank (c)) = always_breaks (c) | flag;

     end set_break_table;

/* Stolen from window_io_iox_ for get_more_responses, get_editing_chars,
   and now get_editor_keybindings */

flat_rep:
     procedure (c) returns (char (32) varying) reducible;

dcl      c		  character (1);

	if c = byte (bin ("015"b3)) then
	     return ("RETURN");
	if c = byte (bin ("033"b3)) then
	     return ("ESC");
	if c < " " then
	     return ("^" || byte (rank (c) + rank ("@")));
	if c = " " then
	     return ("SPACE");
	if c = byte (bin ("177"b3)) then
	     return ("DEL");
	return (c);

     end flat_rep;

flat_rep_string:
     proc (P_string) returns (char (*)) reducible;

dcl      P_string		  char (*) varying;

dcl      char_idx		  fixed bin (21);

	if length (P_string) = 0 then
	     return ("");				/* prevent stringrange below */

	begin;
dcl      flat_string	  char (7 * length (P_string)) varying init ("");

	     do char_idx = 1 to length (P_string) - 1;
		flat_string = flat_string || flat_rep (substr (P_string, char_idx, 1)) || " ";
	     end;
	     flat_string = flat_string || flat_rep (substr (P_string, length (P_string), 1));
	     return ((flat_string));
	end;

     end flat_rep_string;

/* This is for get_more_handler and for get_editor_key_bindings.
   It takes an entry variable and turns it into a segname$entry string,
   leaving out the full pathname.  JR 8/7/83 */

entry_var_to_string:
     procedure (routine, entry_string, code);

dcl      routine		  entry;
dcl      entry_string	  char (*);
dcl      code		  fixed bin (35);

dcl      seg_name		  char (32);		/* only the entryname, not the directory */
dcl      entry_point_name	  char (32);		/* entry point within the segment */

dcl      hcs_$fs_get_path_name  entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl      get_entry_name_	  entry (ptr, char (*), fixed bin (18), char (8) aligned, fixed bin (35));

dcl      1 entry_variable	  aligned based,
	 2 code_ptr	  ptr,
	 2 env_ptr	  ptr;

	call hcs_$fs_get_path_name (addr (routine) -> entry_variable.code_ptr, "", (0), seg_name, code);
	if code ^= 0 then
	     return;

	call get_entry_name_ (addr (routine) -> entry_variable.code_ptr, entry_point_name, (0), "", code);
	if code ^= 0 then
	     return;

	entry_string = rtrim (seg_name) || "$" || rtrim (entry_point_name);

	return;

     end entry_var_to_string;

/* This really doesn't belong here.  It causes this module to have the
   knowledge of how to call tc_.  It fit much better in window_io_video_.
   It also really doesn't work well from tc_ either, otherwise I would
   just pass the order through and deal with it there.  Perhaps the
   read_status proc in tc_input should be an entry, and we (or tc_) could
   just call it.  But for now ...  -- JR 2/1/84 */

read_status:
     proc ();

%include tc_operations_;
/* ugh ... this shouldn't be here */
%include tty_read_status_info;

dcl      1 rqrs		  aligned like request_read_status;
						/* let's pretend to be window_/window_io_video_ */

	rqrs.sentinel = REQUEST_SENTINEL;
	rqrs.window_id = attach_data.window_id;
	rqrs.request_id = clock ();
	rqrs.operation = OP_READ_STATUS;
	rqrs.row = attach_data.current.line_origin;	/* 1,1 is as good as any ... this prevents out_of_bounds faults way down at tc_ */
	rqrs.col = attach_data.current.column_origin;	/* note, these are terminal coords not window coords */
	string (rqrs.flags) = ""b;

	call iox_$control (target_iocbp, "window_operation", addr (rqrs), Code);
	if Code ^= 0 then
	     return;				/* This should deal with window_status_pending, at least for the reconnection case (or until then the check_in window kludge), but not now. */

	Info_ptr -> tty_read_status_info.event_channel = rqrs.event_channel;
	Info_ptr -> tty_read_status_info.input_pending = rqrs.returned_length > 0;

	return;

     end read_status;

error_exit:
     proc (a_code);

dcl      a_code		  fixed bin (35) parameter;

	Code = a_code;
	go to error_return;

     end error_exit;

error_return:
	return;
%page;
copy_new_to_old_special_table:
     proc;

/* special procedure to copy a version 2 special chars structure (15 char
   sequences) to a version 1 special chars structure (3 char sequences).
   If any of the sequences are too long, it will return non-zero error code */

dcl      i		  fixed bin;
dcl      old_max_length	  fixed bin;

	Code = 0;
	old_max_length = hbound (gsi_old.table_ptr -> special_chars_struc_old.nl_seq.chars, 1);

	if attach_data.special_ptr -> special_chars.nl_seq.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.nl_seq) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.nl_seq) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.cr_seq.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.cr_seq) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.cr_seq) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.bs_seq.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.bs_seq) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.bs_seq) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.tab_seq.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.tab_seq) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.tab_seq) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.vt_seq.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.vt_seq) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.vt_seq) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.ff_seq.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.ff_seq) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.ff_seq) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.printer_on.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.printer_on) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.printer_on) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.printer_off.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.printer_off) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.printer_off) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.red_ribbon_shift.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.red_ribbon_shift) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.red_ribbon_shift) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.black_ribbon_shift.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.black_ribbon_shift) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.black_ribbon_shift) -> c_chars_old;
	if attach_data.special_ptr -> special_chars.end_of_page.count > old_max_length then
	     go to bad_special;
	addr (gsi_old.table_ptr -> special_chars_struc_old.end_of_page) -> c_chars_old =
	     addr (attach_data.special_ptr -> special_chars.end_of_page) -> c_chars_old;
	gsi_old.table_ptr -> special_chars_struc_old.escape_length =
	     attach_data.special_ptr -> special_chars.escape_length;
	do i = 1 to attach_data.special_ptr -> special_chars.escape_length;
	     if attach_data.special_ptr -> special_chars.not_edited_escapes (i).count > old_max_length then
		go to bad_special;
	     addr (gsi_old.table_ptr -> special_chars_struc_old.not_edited_escapes (i)) -> c_chars_old =
		addr (attach_data.special_ptr -> special_chars.not_edited_escapes (i)) -> c_chars_old;
	     if attach_data.special_ptr -> special_chars.edited_escapes (i).count > old_max_length then
		go to bad_special;
	     addr (gsi_old.table_ptr -> special_chars_struc_old.edited_escapes (i)) -> c_chars_old =
		addr (attach_data.special_ptr -> special_chars.edited_escapes (i)) -> c_chars_old;
	end;
	gsi_old.table_ptr -> special_chars_struc_old.input_escapes =
	     attach_data.special_ptr -> special_chars.input_escapes;
	gsi_old.table_ptr -> special_chars_struc_old.input_results =
	     attach_data.special_ptr -> special_chars.input_results;

	return;

bad_special:
	Code = error_table_$invalid_array_size;
	return;

     end copy_new_to_old_special_table;
%page;
copy_old_to_new_special_table:
     proc;

/* special procedure to copy a version 1 special chars structure (3 char
   sequences) to a version 2 special chars structure (15 char sequences). */

dcl      i		  fixed bin;

	addr (temp_ptr -> special_chars.nl_seq) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.nl_seq) -> c_chars_old;
	addr (temp_ptr -> special_chars.cr_seq) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.cr_seq) -> c_chars_old;
	addr (temp_ptr -> special_chars.bs_seq) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.bs_seq) -> c_chars_old;
	addr (temp_ptr -> special_chars.tab_seq) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.tab_seq) -> c_chars_old;
	addr (temp_ptr -> special_chars.vt_seq) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.vt_seq) -> c_chars_old;
	addr (temp_ptr -> special_chars.ff_seq) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.ff_seq) -> c_chars_old;
	addr (temp_ptr -> special_chars.printer_on) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.printer_on) -> c_chars_old;
	addr (temp_ptr -> special_chars.printer_off) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.printer_off) -> c_chars_old;
	addr (temp_ptr -> special_chars.red_ribbon_shift) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.red_ribbon_shift) -> c_chars_old;
	addr (temp_ptr -> special_chars.black_ribbon_shift) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.black_ribbon_shift) -> c_chars_old;
	addr (temp_ptr -> special_chars.end_of_page) -> c_chars_old =
	     addr (addr (scs.special_chars) -> special_chars_old.end_of_page) -> c_chars_old;
	temp_ptr -> special_chars.escape_length = addr (scs.special_chars) -> special_chars_old.escape_length;
	do i = 1 to attach_data.special_ptr -> special_chars.escape_length;
	     addr (temp_ptr -> special_chars.not_edited_escapes (i)) -> c_chars_old =
		addr (addr (scs.special_chars) -> special_chars_old.not_edited_escapes (i)) -> c_chars_old;
	     addr (temp_ptr -> special_chars.edited_escapes (i)) -> c_chars_old =
		addr (addr (scs.special_chars) -> special_chars_old.edited_escapes (i)) -> c_chars_old;
	end;
	temp_ptr -> special_chars.input_escapes = addr (scs.special_chars) -> special_chars_struc_old.input_escapes;
	temp_ptr -> special_chars.input_results = addr (scs.special_chars) -> special_chars_struc_old.input_results;

	return;

     end copy_old_to_new_special_table;
%page;
%include window_io_attach_data_;
%include window_control_info;
%page;
%include iocb;
%page;
%include tc_desk_info_;
%page;
%include tty_editing_chars;
%page;
%include tty_convert;
%page;
%include iox_dcls;
%page;
%include mode_string_info;
%page;
%include window_dcls;
%page;
%include terminal_type_data;
%page;
%include terminal_info;

     end wioctl_;

