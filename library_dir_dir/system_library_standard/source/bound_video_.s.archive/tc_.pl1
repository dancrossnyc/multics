/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-05-30,LJAdams), approve(86-11-11,MCR7485),
     audit(86-12-19,Margolin), install(87-01-06,MR12.0-1255):
     Modified to support MOWSE.
  2) change(86-11-26,LJAdams), approve(86-11-26,MCR7584),
     audit(86-12-19,Margolin), install(87-01-06,MR12.0-1255):
     Initial DSA coding has been maintained in an non-executable form.
  3) change(87-01-16,LJAdams), approve(87-01-16,PBF7485),
     audit(87-01-16,Gilcrease), install(87-01-19,MR12.0-1287):
     Do not perform cleanup_init for control order initialize_mowse_terminal.
     This will be handled when error code is fed back to video_utils_.
  4) change(87-02-03,LJAdams), approve(87-02-03,MCR7642),
     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
     The initial terminal modes were not being properly propagated.
  5) change(87-02-13,LJAdams), approve(87-02-13,MCR7642),
     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
     Do not support a MOWSE terminal type unless the line type is MOWSE.
  6) change(87-03-11,LJAdams), approve(87-03-11,MCR7646),
     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
     Use terminal_type_data to get the information for the existance of a
     protocol (dependency).  Changed ttd_version to ttd_version_3.
  7) change(87-05-20,LJAdams), approve(87-05-20,MCR7699),
     audit(87-06-30,RBarstad), install(87-08-04,MR12.1-1055):
     Provided support for MOWSE_FANSI protocol.
     Changed name of include file terminal_type_protocols.incl.pl1 which
     was to long to term_type_protocols.incl.pl1.
  8) change(87-06-03,LJAdams), approve(87-06-03,MCR7584),
     audit(87-06-30,RBarstad), install(87-08-04,MR12.1-1055):
     Added initial break table for DSA.
  9) change(87-09-04,LJAdams), approve(87-09-04,PBF7485),
     audit(87-09-04,RBarstad), install(87-09-09,MR12.1-1102):
     Moved placement of call to ws_tty_$abort to avoid data transmission
     before ws_tty_ was ready to receive data.
                                                   END HISTORY COMMENTS */


/* tc_.pl1 Terminal Control utilities --
   init, shutdown, reconnect/reinit, primitive desk management.

   This program is called from the I/O Module interface */

/* format: style4,delnl,insnl,indattr,ifthen,dclind9 */

/* */
/* Written by Benson Margulies, sometime in 1981 */
/* Modified 21 January 1982 by Chris Jones to add ^tabecho to initial modes */
/* Modified 11 April 1982 by Richard Lamson to add get_foreign_terminal_data
   order call for user SUPDUP support. */
/* Modified 14 July 1982 to fix bug in above change in which important tc_data
   values were not initialized for non-SUPDUP users of STYs. */
/* Modified 10 September 1982 by William M. York to add the
   send_buffered_output control order. */
/* Modified 20 September 1982 by WMY to remove the send_buffered_output
   control order, since window_$sync is a better mechanism. */
/* Modified January 1983 by WMY to stop validating the cursor position for
   calls that don't modify the screen (e.g. unechoed input). */
/* Modified 1 August 1983 by Jon A. Rochlis to remove special casing
   the terminal_info control order, since ring0 appears to handle it
   correctly and we don't (i.e. answerback). */
/* Modified 9 September 1983 by JR to map error_table_$no_table into the new
   error_table_$unsupported terminal.  It must be an error_table_ code as
   opposed a video_et_ code because it will be used at reconnection time. */
/* Modified 1 October 1983 by JR to add support for partial screen width
   windows and to really delete the terminal_info code. */
/* Modified 6 January 1983 by JR to add the randomize_redisplay control order
   to make Barmar happy. */
/* Modified 18 March 1984 by JR to add support for the set_term_type
   order. Init and shut have been modified (mostly init). They have been
   split into two parts, the terminal type dependent part (video info, etc.)
   and the general tc_data part. */
/* Modified 7 September 1984 by C. Marker to add set_line_speed order. */
/* Modified 31 October 1984 by BIM for fix to uninitialized variable.  */
/* Modified 7 February 1985 by JR to make get_capabilities fill in the
   overprint flag. */
/* Modified June 1985 by Roger Negaret to support DSA networks. */

tc_:
     procedure;
	return;

declare  tc_disconnect$check	  entry (pointer, fixed binary (35));
declare  tc_request$init	  entry (pointer);
declare  tc_request$shut	  entry (pointer, fixed bin (35));

declare  tc_screen$init	  entry (pointer, fixed binary, fixed binary);
declare  tc_screen$shut	  entry (pointer);
declare  tc_input$init	  entry (pointer);
declare  tc_input$shut	  entry (pointer);
declare  tc_request		  entry (pointer, pointer, fixed bin, fixed binary (35));

declare  tc_$init_ttp_info	  entry (ptr, char (*), fixed bin (35));
declare  tc_$shut_ttp_info	  entry (ptr);

declare  ttt_info_$initial_string
			  entry (character (*), character (*) var, fixed binary (35));
declare  ttt_info_$video_info	  entry (character (*), fixed binary, pointer, pointer, fixed binary (35));
declare  ttt_info_$terminal_data
			  entry (character (*), fixed binary, fixed binary, pointer, fixed binary (35));

declare  hcs_$tty_attach	  entry (character (*), fixed bin (71), fixed bin, fixed bin, fixed bin (35));
declare  hcs_$tty_detach	  entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
declare  hcs_$tty_abort	  entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
declare  hcs_$tty_order	  entry (fixed bin, character (*), pointer, fixed bin, fixed bin (35));
declare  dsa_tty_$attach	  entry (character (*), fixed bin (71), fixed bin (35), fixed bin, fixed bin (35));
declare  dsa_tty_$detach	  entry (fixed bin (35), fixed bin, fixed bin, fixed bin (35));
declare  dsa_tty_$abort	  entry (fixed bin (35), fixed bin, fixed bin, fixed bin (35));
declare  dsa_tty_$order	  entry (fixed bin (35), character (*), pointer, fixed bin, fixed bin (35));
declare  ws_tty_$attach	  entry (ptr, char (*), fixed bin (71), fixed bin, fixed bin (35));
declare  ws_tty_$detach	  entry (ptr, fixed bin, fixed bin, fixed bin (35));
declare  ws_tty_$abort	  entry (ptr, fixed bin, fixed bin, fixed bin (35));
declare  ws_tty_$order	  entry (ptr, char (*), ptr, fixed bin, fixed bin (35));
declare  continue_to_signal_	  entry (fixed binary (35));


declare  (
         hcs_$set_ips_mask,
         hcs_$reset_ips_mask
         )		  entry (bit (36) aligned, bit (36) aligned);
declare  (
         ipc_$mask_ev_calls,
         ipc_$unmask_ev_calls
         )		  entry (fixed bin (35));

declare  get_system_free_area_  entry () returns (ptr);

declare  dsa_error_table_$try_again
			  external static fixed bin (35);

declare  (
         error_table_$unimplemented_version,
         error_table_$smallarg,
         error_table_$no_table,
         error_table_$null_info_ptr,
         error_table_$unsupported_terminal,
         error_table_$incompatible_term_type,
         video_et_$window_too_big,
         video_et_$bad_window_id,
         video_et_$capability_lacking,
         video_et_$no_video_info,
         video_et_$terminal_cannot_position,
         video_et_$out_of_window_bounds
         )		  external static fixed bin (35);

declare  tty_state		  fixed bin;
declare  X_code		  fixed bin (35);

declare  iox_$control	  entry (ptr, char (*), ptr, fixed bin (35));

declare  (
         TC_data_ptr	  pointer,
         Code		  fixed bin (35),
         Request_ptr	  pointer,
         Terminal_type	  character (*),
         Channel		  character (*),
         Event		  fixed bin (71),
         Window_id		  bit (36) aligned,
         Reconnection_flag	  bit (1),
         MOWSE_ptr		  ptr
         )		  parameter;

declare  1 windows		  (100) based (tc_data.desk_ptr),
	 2 flags		  aligned,
	   3 in_use	  bit (1) unaligned,
	   3 status_pending	  bit (1) unaligned,
	   3 pad		  bit (34) unaligned,
	 2 location	  aligned,
	   3 top_row	  fixed bin,
	   3 n_rows	  fixed bin,
	   3 first_column	  fixed bin,
	   3 n_columns	  fixed bin,
	 2 window_id	  bit (36) aligned,		/* for now, bit (index in this table) */
	 2 window_iocb_ptr	  ptr,			/* so we can do set_window_status orders */
	 2 pending_status	  bit (36) aligned;		/* may be longer someday */

/* first bit is PIATTY (ITS hangup signal) */

declare  1 ttd		  aligned like terminal_type_data automatic;

declare  1 mowse_info	  static,
	 2 tc_data_ptr	  ptr,
	 2 ttd		  aligned like terminal_type_data;

declare  wx		  fixed bin;
declare  ips_mask		  bit (36) aligned;

declare  cleanup		  condition;
declare  terminal_control_disconnection_
			  condition;

declare  (addr, after, bin, bit, clock, hbound, index, lbound, length, max, null, reverse, rtrim, substr, unspec)
			  builtin;

/* CONSTANTS */

declare  UNMASK_ALL		  bit (36) aligned initial (""b) internal static options (constant);
dcl      INITIAL_BREAKTEST	  bit (128) unaligned internal static options (constant) init (""b);
						/* noone in their right mind would use that for a breaktable, so it will compare unequal, and get set in hardcore */

dcl      INITIAL_MODES	  char (128) internal static options (constant)
			  init (
			  "force,rawo,rawi,fulldpx,^echoplex,^prefixnl,breakall,^hndlquit,^crecho,^lfecho,^replay,^polite,^tabecho"
			  );
dcl      MOWSE_DEVICE	  char (9) internal static options (constant) init ("mowse_i/o");

dcl      MOWSE_INITIAL_MODES	  char (128) internal static options (constant) init ("force,ll79,pl23");

dcl      iox_$modes		  entry (ptr, char (*), char (*), fixed bin (35));

init:
     entry (TC_data_ptr, Channel, Event, Terminal_type, Reconnection_flag, MOWSE_ptr, Code);

	if ^Reconnection_flag then do;
	     allocate tc_data set (tc_data_ptr);
	     tc_data.screen_data_ptr = null ();		/* for cleanup handler */
	     tc_data.input_buffer_ptr = null ();
	     tc_data.desk_ptr = null ();
	end;
	else tc_data_ptr = TC_data_ptr;

	if substr (Channel, 1, 4) = "dsa." then do;	/* DSA */
	     tc_data.network_type = DSA_NETWORK_TYPE;
	     call dsa_tty_$attach (Channel, Event, tc_data.tty_handle, tty_state, Code);
	end;
	else if index (Channel, MOWSE_DEVICE) = 1 then do;/* MOWSE */
	     tc_data.network_type = MOWSE_NETWORK_TYPE;
	     tc_data.mowse_terminal_iocb_ptr = MOWSE_ptr;
	end;
	else do;					/* MCS */
	     tc_data.network_type = MCS_NETWORK_TYPE;
	     call hcs_$tty_attach (Channel, Event, tc_data.devx, tty_state, Code);
	end;

	if Code ^= 0 then do;
	     free tc_data;
	     return;
	end;

	on cleanup call cleanup_init;

	tc_data.event = Event;

	tc_data.state.pending.have_sent_protocol = ""b;
	tc_data.state.pending.async_same_window = ""b;
	tc_data.state.pending.protocol_evs (*) = 0;
	tc_data.state.pending.blocked_windows (*) = ""b;

	call init_ttp_info_1 (Code);
	if Code ^= 0 then do;
	     free tc_data;
	     return;
	end;

	tc_data.breaktest = INITIAL_BREAKTEST;

	call init_ttp_info_2 (Code);
	if Code ^= 0 then do;
	     call cleanup_init;
	     return;
	end;

	if tc_data.network_type ^= MOWSE_NETWORK_TYPE then do;
	     call init_ttp_info_3 (Code);
	     if Code ^= 0 then do;
		call cleanup_init;
		return;
	     end;
	end;
	else do;					/* mowse terminal type data is set after video 	*/
						/* has been attached			*/
	     mowse_info.ttd = ttd;
	     mowse_info.tc_data_ptr = tc_data_ptr;
	end;


	if ^Reconnection_flag then do;
	     allocate windows;			/* set the desk ptr */
	     unspec (windows) = ""b;
	     windows (*).in_use = "0"b;
	end;

	if Code ^= 0 then
	     return;

	TC_data_ptr = tc_data_ptr;

	return;

/* Initialize only the terminal dependant info in tc_data */

init_ttp_info:
     entry (TC_data_ptr, Terminal_type, Code);

	call init_ttp_info_1 (Code);
	if Code ^= 0 then
	     return;
	call init_ttp_info_2 (Code);
	if tc_data.network_type ^= MOWSE_NETWORK_TYPE then
	     call init_ttp_info_3 (Code);		/* we should not get here if were MOWSE		*/
	return;

/* Split into two operations, so init can tell the difference, if we fail. */

init_ttp_info_1:
     proc (Code);

dcl      Code		  fixed bin (35);

	call get_video_data (Code);
	if Code ^= 0 then
	     return;

	call verify_capabilities (tc_data.ttt_video_ptr, Code);
	if Code ^= 0 then
	     return;

	return;

     end init_ttp_info_1;

init_ttp_info_2:
     proc (Code);

dcl      Code		  fixed bin (35);

/* Now initialize the folks down below. If that all works,
   which it can only not by signalling, then we massage the
   terminal */

	call tc_request$init (tc_data_ptr);
	call tc_input$init (tc_data_ptr);
	call tc_screen$init (tc_data.screen_data_ptr, tc_data.rows, tc_data.columns);
	return;

     end init_ttp_info_2;

init_ttp_info_3:
     proc (Code);

dcl      Code		  fixed bin (35);

	call setup_terminal (Code);

/* Now place terminal in known state */

	call clear_screen_proc;
	return;

     end init_ttp_info_3;

request:
     entry (TC_data_ptr, Request_ptr, Code);

	tc_data_ptr = TC_data_ptr;
	Code = 0;
	call request_proc (Request_ptr, Code);
	return;

request_proc:
     procedure (R_ptr, Code);
declare  R_ptr		  pointer;
declare  Code		  fixed bin (35);
	request_ptr = R_ptr;

	if request_header.window_id ^= (36)"1"b then do;
	     wx = find_window (request_header.window_id, Code);
						/* it best be there */
	     if Code ^= 0 then
		return;

	     call check_bounds (Code);
	     if Code ^= 0 then
		return;

	     call tc_request (tc_data_ptr, request_ptr,
		windows (wx).first_column + windows (wx).n_columns - 1 /* last column in the window */, Code);
	end;

	else call tc_request (tc_data_ptr, request_ptr, tc_data.columns, Code);
						/* better not be I/D chars */

     end request_proc;


check_in_window:
     entry (TC_data_ptr, Row, N_rows, Col, N_cols, Window_id, Window_iocb_ptr, Code);
declare  (Row, N_rows)	  fixed bin;
declare  (Col, N_cols)	  fixed bin;
declare  Window_iocb_ptr	  ptr;

	tc_data_ptr = TC_data_ptr;
	Code = 0;

	call check_in_window_proc (Row, N_rows, Col, N_cols, Window_id, Window_iocb_ptr);
	return;

check_in_window_proc:
     procedure (Row, N_rows, Col, N_cols, Window_id, Window_iocb_ptr);

declare  (Row, N_rows)	  fixed bin;
declare  (Col, N_cols)	  fixed bin;
declare  Window_id		  bit (36) aligned;
declare  Window_iocb_ptr	  ptr;

	if Row < 1				/* no hyperspace */
	     | N_rows < 1				/* or degenerates */
	     | Row + N_rows - 1 > tc_data.rows		/* too big */
	     | Col < 1				/* check the other dimension also */
	     | N_cols < 1 | Col + N_cols - 1 > tc_data.columns then do;
	     Code = video_et_$window_too_big;
	     return;
	end;

	wx = find_free_slot ();			/* uninterruptable, no windows (uggh) */
	Window_id = windows (wx).window_id;
	windows (wx).top_row = Row;
	windows (wx).n_rows = N_rows;
	windows (wx).first_column = Col;
	windows (wx).n_columns = N_cols;
	windows (wx).window_iocb_ptr = Window_iocb_ptr;
	return;
     end check_in_window_proc;

check_out_window:
     entry (TC_data_ptr, Window_id, Code);
	Code = 0;

	tc_data_ptr = TC_data_ptr;
	call check_out_window_proc (Window_id);
	return;

check_out_window_proc:
     procedure (Window_id);
declare  Window_id		  bit (36) aligned;

	wx = find_window (Window_id, Code);
	if Code ^= 0 then
	     return;
	windows (wx).in_use = "0"b;
	return;
     end check_out_window_proc;

resize_window:
     entry (TC_data_ptr, Window_id, Row, N_rows, Col, N_cols, Code);

	tc_data_ptr = TC_data_ptr;
	Code = 0;

	call resize_window_proc (Window_id, Row, N_rows, Col, N_cols);
	return;

resize_window_proc:
     procedure (Window_id, Row, N_rows, Col, N_cols);
declare  Window_id		  bit (36) aligned;
declare  Row		  fixed bin;
declare  N_rows		  fixed bin;
declare  Col		  fixed bin;
declare  N_cols		  fixed bin;

	if Row < 1				/* no hyperspace */
	     | N_rows < 1				/* or degenerates */
	     | Row + N_rows - 1 > tc_data.rows		/* too big */
	     | Col < 1				/* check the other dimension also */
	     | N_cols < 1 | Col + N_cols - 1 > tc_data.columns then do;
	     Code = video_et_$window_too_big;
	     return;
	end;

	wx = find_window (Window_id, Code);
	if Code ^= 0 then
	     return;

	windows (wx).top_row = Row;
	windows (wx).n_rows = N_rows;
	windows (wx).first_column = Col;
	windows (wx).n_columns = N_cols;

	return;
     end resize_window_proc;

get_capabilities:
     entry (TC_data_ptr, C_ptr, Code);
declare  C_ptr		  pointer;

	tc_data_ptr = TC_data_ptr;
	Code = 0;
	call get_capabilities_proc (C_ptr);
	return;

get_capabilities_proc:
     procedure (C_ptr);
declare  C_ptr		  pointer;

	capabilities_info_ptr = C_ptr;
	if capabilities_info.version ^= capabilities_info_version then do;
	     Code = error_table_$unimplemented_version;
	     return;
	end;

/* These are physical capabilities -- window_io_ is expected
   to know which we will simulate. */

	capabilities_info.screensize.columns = tc_data.terminal.columns;
	capabilities_info.screensize.rows = tc_data.terminal.rows;
	ttyvtblp = tc_data.ttt_video_ptr;

	capabilities_info.scroll_region =
	     tty_video_table.sequences (INSERT_LINES).present & tty_video_table.sequences (DELETE_LINES).present;
	capabilities_info.insert_chars = tty_video_table.sequences (INSERT_CHARS).present;
	capabilities_info.insert_mode = tty_video_table.sequences (END_INSERT_CHARS).present;
	capabilities_info.delete_chars = tty_video_table.sequences (DELETE_CHARS).present;
	capabilities_info.overprint = tty_video_table.overstrike_available;
	capabilities_info.line_speed = tc_data.terminal.line_speed;
	return;
     end get_capabilities_proc;

/* Caller of this better be damned sure order is innocuous */

random_order:
     entry (TC_data_ptr, Order, Info_ptr, Code);
declare  Order		  character (*);
declare  Info_ptr		  pointer;

	tc_data_ptr = TC_data_ptr;
	call call_order (Order, Info_ptr, Code);
	return;


get_terminal_info:
     procedure (ttp, baud_rate, code);

declare  ttp                   char (*);       /* in  */
declare  baud_rate             fixed bin;       /* out */
declare  code                  fixed bin (35);  /* out */

declare  1 ti                  aligned like terminal_info automatic;
     
          baud_rate = 0;
          code = 0;

/* First, pick up the terminal type from ring 0, if our caller
   did not give us one */

	ti.version = 1;
	call call_order ("terminal_info", addr (ti), (0));

          if ttp ^= "" then
	   ti.term_type = ttp;
	tc_data.ttp = ti.term_type;
	ttd.version = ttd_version_3;
	call ttt_info_$terminal_data (ti.term_type, (0), ti.baud_rate, addr (ttd), code);
          if code ^= 0 then
             return;

          baud_rate = ti.baud_rate;

end get_terminal_info;



get_video_data:
     procedure (code);

/* This should not do anything to the terminal */

declare  baud_rate		  fixed bin;                 /* in */
declare  code		  fixed bin (35);            /* in */

	if Terminal_type ^= "" then			/* use caller supplied type */
	   call get_terminal_info (Terminal_type, baud_rate, code);
          else call get_terminal_info ("", baud_rate, code);
	if code ^= 0 then
             return;

          call check_protocol (ttd.protocol, code);
	if code ^= 0 then do;
	   call cleanup_init; 
	   return;
	   end;

	call get_video_info_ptr (ttp, baud_rate, tc_data.ttt_video_ptr, code);
	if code ^= 0 then
	     return;

	if tc_data.ttt_video_ptr = null () then
	     code = video_et_$no_video_info;
	ttyvtblp = tc_data.ttt_video_ptr;

/* fill in important values in tc_data */
	tc_data.rows = tty_video_table.screen_height;
	tc_data.columns = tty_video_table.screen_line_length;
	tc_data.line_speed = baud_rate;

/* user may be coming in via SUPDUP, so issue a
   get_foreign_terminal_data order to get screen dimensions, etc.
   This order call will also succeed on STY connections, but
   the modes returned will not be what the following code looks for,
   so no tc_data values will get changed. */

	my_ftd.version = FOREIGN_TERMINAL_DATA_VERSION_1;
	my_ftd.area_ptr = get_system_free_area_ ();
	call call_order ("get_foreign_terminal_data", addr (my_ftd), X_code);
	if X_code = 0 then do;
	     mode_string_info_ptr = my_ftd.mode_string_info_ptr;
	     do i = 1 to mode_string_info.number;
		mode_value_ptr = addr (mode_string_info.modes (i));
		if /* case */ mode_value.mode_name = "line_length" then
		     tc_data.columns = mode_value.numeric_value;
		else if mode_value.mode_name = "page_length" then
		     tc_data.rows = mode_value.numeric_value;
		else if mode_value.mode_name = "ospeed" then
		     tc_data.line_speed = mode_value.numeric_value;
		else if mode_value.mode_name = "insert_delete_lines" | mode_value.mode_name = "idel_lines" then
		     if ^mode_value.boolean_value then do;
			call delete_sequence (INSERT_LINES);
			call delete_sequence (DELETE_LINES);
		     end;
		     else ;
		else if mode_value.mode_name = "insert_delete_chars" | mode_value.mode_name = "idel_chars" then
		     if ^mode_value.boolean_value then do;
			call delete_sequence (INSERT_CHARS);
			call delete_sequence (DELETE_CHARS);
		     end;
		     else ;
	     end;
	end;

	return;

delete_sequence:
	procedure (sequence_number);

	     if sequence_number <= tty_video_table.nseq then
		tty_video_table.sequences (sequence_number).present = "0"b;
	     return;

declare  sequence_number	  fixed binary;

	end delete_sequence;

%include foreign_terminal_data;
%include mode_string_info;
declare  1 my_ftd		  auto like foreign_terminal_data;
declare  i		  fixed binary;

     end get_video_data;

get_video_info_ptr:
     procedure (ttp, baud_rate, video_info_ptr, code);

dcl      ttp		  char (*);
dcl      baud_rate		  fixed bin;
dcl      video_info_ptr	  ptr;
dcl      code		  fixed bin (35);

	call ttt_info_$video_info (ttp, baud_rate, null (), video_info_ptr, code);

	if code = error_table_$no_table then
	     code = error_table_$unsupported_terminal;

	return;

     end get_video_info_ptr;

verify_capabilities:
     procedure (video_table_ptr, code);

dcl      video_table_ptr	  ptr;

/* Make sure she flies */
/* Must have one of abs poistioning, up/down/right/left, or home/right/down */

declare  code		  fixed bin (35);

	code = 0;

	ttyvtblp = video_table_ptr;
	if ^((tty_video_table.sequences (ABS_POS).present
	     | (tty_video_table.sequences (CURSOR_UP).present & tty_video_table.sequences (CURSOR_DOWN).present
	     & tty_video_table.sequences (CURSOR_RIGHT).present & tty_video_table.sequences (CURSOR_LEFT).present)
	     | (tty_video_table.sequences (HOME).present & tty_video_table.sequences (CURSOR_DOWN).present
	     & tty_video_table.sequences (CURSOR_RIGHT).present))) then
	     code = video_et_$terminal_cannot_position;

     end verify_capabilities;

setup_terminal:
     procedure (code);
declare  code		  fixed bin (35);

/* Type */
          if tc_data.network_type = DSA_NETWORK_TYPE then do;

						/* For DSA, we always initialize a break table */
dcl  1 dsa_break_table like echo_neg_data aligned;	/* Here, because used only once */

	     dsa_break_table.version = echo_neg_data_version_2;
	     dsa_break_table.break(*) = "1"b;		/* All chars sets. Why not */
						/* The remainder is ignored by dsa_tty_index_ */
	     
	     call call_order ("set_echo_break_table", addr (dsa_break_table), code);
	     if code ^= 0 then
		return;
	     end;

	if tc_data.network_type = MOWSE_NETWORK_TYPE then do;
	     call ws_tty_$abort (tc_data.mowse_terminal_iocb_ptr, (1) /* resetread */, tty_state, (0));
	     call call_order ("set_terminal_data", addr (mowse_info.ttd), code);
	     end;
	else call call_order ("set_terminal_data", addr (ttd), code);
	if code ^= 0 then
	     return;

/* Modes */

	if tc_data.network_type = MOWSE_NETWORK_TYPE then
	     call iox_$modes (tc_data.mowse_terminal_iocb_ptr, MOWSE_INITIAL_MODES, tc_data.old_mode_string, code);
	else call set_modes (INITIAL_MODES, tc_data.old_mode_string, code);
	if code = error_table_$smallarg then
	     code = 0;
	if code ^= 0 then
	     return;

	call send_initial_string (code);		/* depends on our presence in rawo */
	if code ^= 0 then
	     return;

	if tc_data.network_type = DSA_NETWORK_TYPE then	/* DSA */
	     call dsa_tty_$abort (tc_data.tty_handle, (1) /* resetread */, tty_state, (0));
	else					/* MCS */
	     call hcs_$tty_abort (tc_data.devx, (1) /* resetread */, tty_state, (0));

	call call_order ("printer_off", null (), (0));
     end setup_terminal;


send_initial_string:
     procedure (code);
declare  code		  fixed bin (35);
declare  initial_string	  character (512) varying;
declare  1 tct		  aligned like request_text;

	code = 0;
	call ttt_info_$initial_string (tc_data.ttp, initial_string, code);
	if code ^= 0 then
	     return;

	if length (initial_string) = 0 then
	     return;

	tct.operation = OP_WRITE_RAW;
	tct.row = 1;
	tct.col = 1;

	begin;
declare  i_s_non_varying	  char (length (initial_string));
	     i_s_non_varying = initial_string;
	     tct.text_ptr = addr (i_s_non_varying);
	     tct.text_length = length (initial_string);
	     call tc_request (tc_data_ptr, addr (tct), tc_data.columns /* why not? */, (0));
	end;

     end send_initial_string;



call_order:
     procedure (order, info, code);

declare  order		  character (*);
declare  info		  pointer;
declare  code		  fixed bin (35);
declare  tty_state		  fixed bin;
declare  tc_block		  entry (pointer, pointer, bit (36) aligned);

	code = 0;

	if tc_data.network_type = DSA_NETWORK_TYPE then do;
						/* DSA */
try_again:
	     call dsa_tty_$order (tc_data.tty_handle, order, info, tty_state, code);
	     if code = dsa_error_table_$try_again then do;
		call tc_block (tc_data_ptr, request_ptr, UNMASK_ALL);
		code = 0;
		goto try_again;
	     end;
	end;
	else if tc_data.network_type = MOWSE_NETWORK_TYPE then
						/* MOWSE */
	     call ws_tty_$order (tc_data.mowse_terminal_iocb_ptr, order, info, tty_state, code);
	else					/* MCS */
	     call hcs_$tty_order (tc_data.devx, order, info, tty_state, code);

	call tc_disconnect$check (tc_data_ptr, code);
     end call_order;


check_protocol:
      procedure (op, code);

dcl       op             fixed bin;
dcl       code           fixed bin(35);

      if (op > hbound(protocol_names,1)) | (op < lbound(protocol_names,1)) then
         op = -1;
      goto PROTOCOL (op);

PROTOCOL (-1):					/* ERROR */
      code = error_table_$incompatible_term_type;
      return;

PROTOCOL (0):					/* NO_PROTOCOL */
      if tc_data.network_type = MOWSE_NETWORK_TYPE then
         goto PROTOCOL (-1);
      return;

PROTOCOL (1):					/* MOWSE */
      if tc_data.network_type ^= MOWSE_NETWORK_TYPE then
         goto PROTOCOL (-1);
      return;

PROTOCOL (2):                                              /* MOWSE_FANSI */
       return;                                             /* valid with all network types */
            
end check_protocol;

set_modes:
     procedure (new_modes, old_modes, code);

dcl      (new_modes, old_modes) char (*);
dcl      code		  fixed bin (35);

mode_block:
	begin;					/* size is unknown till here */

declare  modes_ptr		  pointer;
declare  1 t_modes_info	  aligned,
	 2 mode_length	  fixed bin (21),
	 2 modes		  char (max (length (new_modes), length (old_modes)));

	     modes_ptr = addr (t_modes_info);
	     t_modes_info.mode_length = length (t_modes_info.modes);
	     t_modes_info.modes = new_modes;

	     call call_order ("modes", modes_ptr, code);

	     if code ^= 0 & code ^= error_table_$smallarg then do;
		old_modes = t_modes_info.modes;	/* the mode(s) in error are in here */
		return;
	     end;

	     if length (old_modes) = 0 then
		return;

	     if t_modes_info.mode_length = 0 then do;
		old_modes = "";
		return;
	     end;
	     if code = 0 then do;
		old_modes = t_modes_info.modes;
		return;
	     end;

/* from this point on we have a smallarg */

	     code = 0;				/* but we do not admit it. */
	     if substr (reverse (rtrim (old_modes)), 1, 1) = "."
						/* the hardcore returned an even mode, which it should */
		then
		return;

/* from this point the hardcore returned a fragment of a mode */

	     old_modes = reverse (after (reverse (t_modes_info.modes), ","));
	     if length (rtrim (old_modes)) = length (old_modes) then
		old_modes = reverse (after (reverse (old_modes), ","));
						/* leave room for a "." */
	     substr (old_modes, length (rtrim (old_modes)) + 1, 1) = ".";

	end mode_block;
     end set_modes;

shut:
     entry (TC_data_ptr);

	tc_data_ptr = TC_data_ptr;
	if tc_data_ptr = null () then
	     return;

/* turn off hairy features that we do not want to go off */

	ips_mask = ""b;
	on cleanup
	     begin;
	     if ips_mask ^= ""b then do;
		call hcs_$reset_ips_mask (ips_mask, ""b);
		call ipc_$unmask_ev_calls (0);
	     end;
	end;

	call hcs_$set_ips_mask (""b, ips_mask);
	call ipc_$mask_ev_calls (0);
	tc_data.state.pending.count = 0;

	on terminal_control_disconnection_ go to give_up_shut;
	call clear_screen_proc;
	call send_initial_string (0);
	call set_modes (tc_data.old_mode_string, "", (0));

give_up_shut:
	call cleanup_init;
	if tc_data.ttt_video_ptr ^= null then
	     free tc_data.ttt_video_ptr -> tty_video_table;

	free tc_data;
	TC_data_ptr = null ();
	call ipc_$unmask_ev_calls (0);
	call hcs_$reset_ips_mask (ips_mask, ""b);

	return;

/* This entry is called when changing the terminal type.  It cleans up
   terminal type dependent info from tc_data but leaves all else alone. */

shut_ttp_info:
     entry (TC_data_ptr);

	tc_data_ptr = TC_data_ptr;
	if tc_data.ttt_video_ptr ^= null () then
	     free tc_data.ttt_video_ptr -> tty_video_table;

	if tc_data.screen_data_ptr ^= null () then
	     call tc_screen$shut (tc_data.screen_data_ptr);

	call tc_request$shut (tc_data_ptr, (0));

	return;

cleanup_init:
     procedure;

	if tc_data.screen_data_ptr ^= null () then
	     call tc_screen$shut (tc_data.screen_data_ptr);

	if tc_data.input_buffer_ptr ^= null () then
	     call tc_input$shut (tc_data_ptr);

	if tc_data.desk_ptr ^= null () then
	     free windows;

	call tc_request$shut (tc_data_ptr, (0));

	if tc_data.network_type = DSA_NETWORK_TYPE then	/* DSA */
	     call dsa_tty_$detach (tc_data.tty_handle, (0), (0), (0));
	else if tc_data.network_type = MOWSE_NETWORK_TYPE then
						/* MOWSE */
	     call ws_tty_$detach (tc_data.mowse_terminal_iocb_ptr, (0), (0), (0));
	else					/* MCS */
	     call hcs_$tty_detach (tc_data.devx, (0), (0), (0));

     end cleanup_init;



find_free_slot:
     procedure returns (fixed bin);
declare  w		  fixed bin;

	do w = 1 to hbound (windows, 1);
	     if ^windows (w).in_use then do;		/* this should mask, or stacq, or something */
		windows (w).in_use = "1"b;
		windows (w).status_pending = "0"b;
		windows (w).pad = ""b;
		windows (w).window_id = substr (reverse (bit (clock (), 72)), 1, 19) || bit (w, 17);
		return (w);
	     end;
	end;
	signal tc_too_many_windows_;
declare  tc_too_many_windows_	  condition;
     end find_free_slot;

find_window:
     procedure (window_id, code) returns (fixed bin);

declare  window_id		  bit (36) aligned;
declare  code		  fixed bin (35);
declare  wx		  fixed bin;

	wx = bin (substr (window_id, 20), 17);

	if windows (wx).window_id ^= window_id then do;
	     code = video_et_$bad_window_id;
	     return (0);
	end;
	return (wx);
     end find_window;

check_bounds:
     procedure (code);
declare  code		  fixed bin (35);

/* The screen is assumed to have one "phantom" position beyond its
   specified width, where the cursor may be positioned, but text may
   (possible) not be displayed. The cursor may be positioned anyplace
   including the phantom column, but text may not be placed there, for
   after putting out the text the cursor would have noplace to go.
   This may be nondelux, but it works. Also, characters may not be solicted
   from that column, for we could not echo. */

	if request_header.row < 1			/* not in the sky */
	     | request_header.col < 1			/* or in china */
	     | request_header.row < windows (wx).top_row	/* or not in */
	     | request_header.row > windows (wx).top_row + windows (wx).n_rows - 1
	     | request_header.col < windows (wx).first_column
	     | request_header.col > windows (wx).first_column + windows (wx).n_columns then
	     go to OUT_OF_BOUNDS;

	go to OP (request_header.operation);

OP (0):						/* OP_ERROR */
	return;

OP (1):						/* OP_POSITION_CURSOR */
	call check_bounds_within_phantom;
	return;


OP (2):						/* OP_CLEAR_REGION */
	call check_bounds_within_phantom;

	if request_clear_region.rows >		/* extent requested */
	     (windows (wx).n_rows - (request_header.row - windows (wx).top_row)) then
	     go to OUT_OF_BOUNDS;

	if (request_clear_region.columns - request_header.col - 1) > windows (wx).n_columns then
	     go to OUT_OF_BOUNDS;			/* this will permit zero width regions in phantom col */

	return;

OP (14):						/* OP_OVERWRITE_TEXT */
OP (3):						/* OP_INSERT_TEXT */
	call check_bounds_within_phantom;		/* allow starting in phantom col */
						/* make sure final column isn't beyond phantom col */
	if (request_header.col + request_text.text_length) > windows (wx).first_column + windows (wx).n_columns + 1 then
	     go to OUT_OF_BOUNDS;
	return;

OP (6):						/* OP_DELETE_CHARS */
	call check_bounds_within_window;
	if (request_header.col + request_delete_chars.count) > windows (wx).first_column + windows (wx).n_columns + 1
	     then
	     go to OUT_OF_BOUNDS;

	return;

OP (7):						/* OP_SCROLL_REGION */
						/* coords are not payed attention to */
	if windows (wx).n_columns ^= tc_data.columns then /* naughty, naughty, a partial width window! */
	     do;					/* no i-del lines for these windows. tc_request should do this check, but it doesn't know about windows ... sigh */
	     Code = video_et_$capability_lacking;
	     return;
	end;

	if request_scroll_region.start_line < windows (wx).top_row
						/* */
	     | request_scroll_region.start_line > windows (wx).top_row + windows (wx).n_rows - 1
						/* */
	     | request_scroll_region.n_lines < 1
	     | request_scroll_region.start_line + request_scroll_region.n_lines
	     > windows (wx).top_row + windows (wx).n_rows then
	     go to OUT_OF_BOUNDS;

	return;

OP (9):						/* OP_GET_CHARS_ECHO */
	call check_bounds_within_window;
	if request_read.buffer_length + request_read.col > windows (wx).first_column + windows (wx).n_columns + 1 then
	     go to OUT_OF_BOUNDS;
	return;

OP (11):						/* OP_WRITE_SYNC_GET_CHARS_NO_ECHO */
	call check_bounds_within_window;
	if request_read.prompt_length + request_read.col > windows (wx).first_column + windows (wx).n_columns + 1 then
	     go to OUT_OF_BOUNDS;

	return;

/* we don't check bounds for unechoed input, raw output and things
   that don't change the screen. */

OP (10):						/* OP_GET_CHARS_NO_ECHO */
OP (16):						/* OP_READ_ONE */
OP (13):						/* OP_READ_STATUS */
OP (12):						/* OP_GET_CURSOR_POSITION */
OP (15):						/* OP_WRITE_RAW */
OP (8):						/* OP_BELL */
	return;

OUT_OF_BOUNDS:
	Code = video_et_$out_of_window_bounds;
	return;

check_bounds_within_phantom:
	procedure;

	     if request_header.col < windows (wx).first_column
						/* left */
		| request_header.col > windows (wx).first_column + windows (wx).n_columns + 1
						/* right */
		then
		go to OUT_OF_BOUNDS;

	     return;

check_bounds_within_window:
	entry;

	     if request_header.col < windows (wx).first_column
		| request_header.col > windows (wx).first_column + windows (wx).n_columns - 1 then
		go to OUT_OF_BOUNDS;

	end check_bounds_within_phantom;
     end check_bounds;


/**** The code that follows logically belongs in tc_io_. It has been
      transplanted here to avoid having the tc_io_ stack frame pushed
      for every video operation. ****/

set_up:
     procedure;

	Code = 0;
	actual_iocbp = Iocbp -> iocb.actual_iocb_ptr;
	attach_data_ptr = actual_iocbp -> iocb.attach_data_ptr;
	mask = ""b;
	return;

     end set_up;

declare  Iocbp		  pointer;
declare  actual_iocbp	  pointer;
declare  mask		  bit (36) aligned;

%page;
%include tc_io_attach_data_;
%include tc_desk_info_;
%include iocb;
%page;

tc_io_control:
     entry (Iocbp, Order, Info_ptr, Code);
	call set_up;
	tc_data_ptr = attach_data.tc_info_ptr;

declare  line_speed_ptr	  pointer;
declare  line_speed		  fixed bin based (line_speed_ptr);

declare  sub_error_		  condition;

dcl      1 fsc_info		  like mowse_io_flush_subchannel_info;

	attach_data.operation_hlock = attach_data.operation_hlock + 1;
	on terminal_control_disconnection_ call disconnect_handler;
	on cleanup attach_data.operation_hlock = attach_data.operation_hlock - 1;

	on sub_error_ call perhaps_internal_error;

	if /* case */ Order = "window_operation" then
	     call request_proc (Info_ptr, Code);

	else if Order = "clear_screen" then
	     call clear_screen_proc;

	else if Order = "get_screen_image_ptr" then
	     call get_screen_image_proc (Info_ptr);	/* POINTER IS OUTPUT ! */

	else if Order = "get_capabilities" then
	     call get_capabilities_proc (Info_ptr);

	else if Order = "check_in_window" then do;
	     tc_desk_info_ptr = Info_ptr;
	     call check_in_window_proc (tc_desk_window_info.first_row, tc_desk_window_info.n_rows,
		tc_desk_window_info.first_column, tc_desk_window_info.n_columns, tc_desk_window_info.window_id,
		tc_desk_window_info.window_iocb_ptr);
	end;
	else if Order = "check_out_window" then do;
	     tc_desk_info_ptr = Info_ptr;
	     call check_out_window_proc (tc_desk_window_info.window_id);
	end;
	else if Order = "resize_window" then do;

	     tc_desk_info_ptr = Info_ptr;
	     call resize_window_proc (tc_desk_window_info.window_id, tc_desk_window_info.first_row,
		tc_desk_window_info.n_rows, tc_desk_window_info.first_column, tc_desk_window_info.n_columns);
	end;
	else if Order = "set_line_speed" then do;
	     line_speed_ptr = Info_ptr;
	     tc_data.line_speed = line_speed;
	end;
	else if Order = "debug_on" then
	     attach_data.debug = "1"b;
	else if Order = "debug_off" then
	     attach_data.debug = "0"b;

	else if Order = "set_term_type" then do;
	     begin;
		sttip = Info_ptr;
		if sttip = null () then do;
		     Code = error_table_$null_info_ptr;
		     return;
		end;
		if set_term_type_info.version ^= stti_version_1 then do;
		     Code = error_table_$unimplemented_version;
		     return;
		end;
		call set_term_type_proc (set_term_type_info.name, Code);
		return;
	     end;					/* begin */
	end;					/* case do */

	else if Order = "reconnection" then
	     call reconnection_proc (Code);

	else if Order = "randomize_redisplay" then	/* to prevent position_cursor from optimizing */
	     tc_data.state.cursor_valid = "0"b;
	else if Order = "initialize_mowse_terminal" then do;
	     fsc_info.subchannel = FG;
	     fsc_info.version = mowse_io_info_version_1;
	     call iox_$control (tc_data.mowse_terminal_iocb_ptr, "flush_subchannel", addr (fsc_info), Code);
	     call init_ttp_info_3 (Code);
	     if Code ^= 0 then
		return;
	     call ws_tty_$attach (tc_data.mowse_terminal_iocb_ptr, Channel, Event, tty_state, Code);
	end;
	else call call_order (Order, Info_ptr, Code);	/* Trust our caller */

reconnection_proc:
     proc (Code);

dcl      new_ttp		  char (32);
dcl      video_info_ptr	  ptr;
dcl      Code		  fixed bin (35);

dcl      user_info_$terminal_data
			  entry (char (*), char (*), char (*), fixed bin, char (*));
dcl      tc_io_$reconnection	  entry (ptr, fixed bin (35));
dcl      video_utils_$turn_off_login_channel
			  entry (fixed bin (35));

	call user_info_$terminal_data ("", new_ttp, "", (0), "");
						/* get new terminal type */

/* see if the new terminal will fly before trying to tweak tc_io_ */

	call get_video_info_ptr (new_ttp, 0, video_info_ptr, Code);
	if Code ^= 0 then do;
REVOKE_VIDEO:
	     call video_utils_$turn_off_login_channel (Code);
	     return;
	end;

	call verify_capabilities (video_info_ptr, Code);
	if video_info_ptr ^= null ()			/* let's play it safe */
	     then
	     free video_info_ptr -> tty_video_table;
	if Code ^= 0 then
	     goto REVOKE_VIDEO;

/* looks good ... let's tell tc_ */

	call tc_io_$reconnection (attach_data_ptr, Code);
	if Code ^= 0 then
	     goto REVOKE_VIDEO;

/* Now inform window (and therefore applications) of the change */

dcl      1 WSI		  aligned like window_status_info;
dcl      iox_$control	  entry (ptr, char (*), ptr, fixed bin (35));

	WSI.version = window_status_version_1;
	WSI.status_string = W_STATUS_TTP_CHANGE | W_STATUS_SCREEN_INVALID | W_STATUS_RECONNECTION;

	do wx = 1 to hbound (windows, 1);
	     if windows (wx).in_use then
		call iox_$control (windows (wx).window_iocb_ptr, "set_window_status", addr (WSI), (0));
	end;					/* do */

	return;

     end reconnection_proc;

set_term_type_proc:
     proc (new_ttp, Code);

dcl      new_ttp		  char (*);
dcl      Code		  fixed bin (35);
dcl      video_info_ptr	  ptr;

/* First a dry run to make sure the new ttp will fly */

	call get_terminal_info(new_ttp, (0), Code);
	if Code ^= 0 then
	     return;

          call check_protocol (ttd.protocol, Code);
	if Code ^= 0 then
              return;
          
	call get_video_info_ptr (new_ttp, 0, video_info_ptr, Code);
	if Code ^= 0 then
	     return;

	call verify_capabilities (video_info_ptr, Code);
	if video_info_ptr ^= null ()			/* play it safe */
	     then
	     free video_info_ptr -> tty_video_table;
	if Code ^= 0 then
	     return;

/* Update tc_'s idea of the terminal type */

	call tc_$shut_ttp_info (tc_data_ptr);
	call tc_$init_ttp_info (tc_data_ptr, set_term_type_info.name, Code);
	if Code ^= 0 then
	     return;				/* Boy are we in trouble if this doesn't work */

/* Now inform window (and therefore applications) of the change */

dcl      1 WSI		  aligned like window_status_info;
dcl      iox_$control	  entry (ptr, char (*), ptr, fixed bin (35));
	WSI.version = window_status_version_1;
	WSI.status_string = W_STATUS_TTP_CHANGE | W_STATUS_SCREEN_INVALID;

	do wx = 1 to hbound (windows, 1);
	     if windows (wx).in_use then
		call iox_$control (windows (wx).window_iocb_ptr, "set_window_status", addr (WSI), (0));
	end;					/* do */

	return;

     end set_term_type_proc;



clear_screen_proc:
     procedure;

declare  1 rcr		  aligned like request_clear_region;

	rcr.sentinel = REQUEST_SENTINEL;
	rcr.request_id = clock ();
	rcr.window_id = (36)"1"b;			/* Special internal op */
	rcr.coords = 1;				/* will set both values */
	rcr.operation = OP_CLEAR_SCREEN_NO_OPT;

	rcr.extent.rows = tc_data.terminal.rows;
	rcr.extent.columns = tc_data.terminal.columns;

	call request_proc (addr (rcr), (0));
	return;
     end clear_screen_proc;


get_screen_image_proc:
     procedure (si_ptr);
declare  si_ptr		  pointer;
	si_ptr = tc_data.screen_data_ptr;		/* violate modularization, but its cheaper */
	return;
     end get_screen_image_proc;

reinit_return:
	if tc_data.state.pending.count < 0 then
	     tc_data.state.pending.count = 0;
	if attach_data.operation_hlock ^= 0 then
	     attach_data.operation_hlock = attach_data.operation_hlock - 1;
	return;

hangup_return:
	attach_data.operation_hlock = attach_data.operation_hlock - 1;

	return;

disconnect_handler:
     procedure;

/* The disconnection strategy is different from that of tty_ */
/* If we are a login_channel, and a disconnection occurs, we
   wait for the reconnection, but we want applications to know
   that something is wrong. also, none of the checked-in windows
   will be valid after a detach/reattach.
   So when window_io_ gets an invalid-window-id fom us/tc_,
   it must attempt to re-check-in, and consider that evidence that
   it can trust no screen state. Thus "completing the operation"
   on disconnections is not neccessary ... we wait for the reconnection,
   and then return invalid_window_id. We cannot return a more mnemotic
   code because the disconnect, detach, attach could have happened
   while we were not even on the stack to notice.

   If we are not a login channel, then the disconnection is just
   a hungup channel, which we translate back into io_no_permission
   and return it to the caller.
*/

declare  video_et_$bad_window_id
			  fixed bin (35) ext static;
declare  find_condition_info_	  entry (pointer, pointer, fixed binary (35));
declare  video_utils_$turn_off_for_debug
			  entry;
declare  timer_manager_$sleep	  entry (fixed binary (71), bit (2));
declare  video_data_$error_name external static character (32);
%include condition_info;
%include condition_info_header;
%include tc_disconnect_info;
%include sub_error_info;
declare  1 ci		  aligned like condition_info;
declare  error_table_$io_no_permission
			  external static fixed bin (35);


	ci.version = condition_info_version_1;
	call find_condition_info_ (null (), addr (ci), (0));
	tcdi_ptr = ci.info_ptr;
	if tc_data.network_type = DSA_NETWORK_TYPE then do;
	     if tc_disconnect_info.tty_handle ^= attach_data.tty_handle then do;
		call continue_to_signal_ (0);
		return;
	     end;
	end;
	else if tc_data.network_type = MOWSE_NETWORK_TYPE then do;
	     if tc_disconnect_info.mowse_terminal_iocb_ptr ^= attach_data.mowse_terminal_iocb_ptr then do;
		call continue_to_signal_ (0);
		return;
	     end;
	end;
	else if tc_disconnect_info.devx ^= attach_data.tty_index then do;
	     call continue_to_signal_ (0);
	     return;
	end;

	if ^attach_data.login_channel then do;
	     Code = error_table_$io_no_permission;
	     call force_unmask;
	     go to hangup_return;
	end;

/* We are a login channel */

	call force_unmask;

	do while ("1"b);				/* wait one minute for AS to take care of us */
	     if attach_data.async_detach then
		goto reconnected;
	     call timer_manager_$sleep (2, "11"b /* rel secs */);
	end;

reconnected:
	Code = video_et_$bad_window_id;
	go to hangup_return;

perhaps_internal_error:
     entry;

	ci.version = 1;
	call find_condition_info_ (null (), addr (ci), (0));
	sub_error_info_ptr = ci.info_ptr;
	if sub_error_info.name ^= video_data_$error_name then do;
	     call continue_to_signal_ (0);
	     return;
	end;					/* Its ours, and noone elses */

	if attach_data.login_channel then do;
	     if attach_data.debug then do;
		call video_utils_$turn_off_for_debug;
		call continue_to_signal_ (0);
		ci.info_ptr -> condition_info_header.cant_restart = "1"b;
		return;
	     end;
	     call shut (attach_data.tc_info_ptr);
	     call init (attach_data.tc_info_ptr, attach_data.device_used, attach_data.event_wait.channel_id (1), "",
		"0"b /* not reconnection */, attach_data.mowse_terminal_iocb_ptr, Code);
	     if Code = 0 then
		Code = video_et_$bad_window_id;
	     go to reinit_return;
	end;					/* login channel case */
	call continue_to_signal_ (0);			/* emit the error msg */
	return;
     end disconnect_handler;



force_unmask:
     procedure;
declare  hcs_$reset_ips_mask	  entry (bit (36) aligned, bit (36) aligned);

	call hcs_$reset_ips_mask ((36)"1"b, ""b);

     end force_unmask;
%page;
%include net_event_message;
%include tty_video_tables;
%page;
%include tc_data_;
%page;
%include tc_operations_;
%page;
%include terminal_type_data;
%include term_type_protocols;
%include terminal_info;
%page;
%include set_term_type_info;
%page;
/* So we can do a set_window_status at reconnection and ttp change time */
%include window_control_info;
%page;
%include window_status;
%page;
%include sub_err_flags;
%page;
%include terminal_capabilities;
%page;
%include mowse_messages;
%page;
%include mowse_io_control_info;
%page;
%include mowse;
%include mcs_echo_neg;
     end tc_;
