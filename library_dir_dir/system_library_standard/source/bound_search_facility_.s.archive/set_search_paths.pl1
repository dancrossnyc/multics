/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(87-10-15,Lippard), approve(87-10-26,MCR7788),
     audit(88-01-13,GWMay), install(88-01-19,MR12.2-1016):
     Added -inhibit_error (-ihe) and -no_inhibit_error (-nihe) to
     where_search_paths.
  2) change(87-10-29,Lippard), approve(87-11-23,MCR7797),
     audit(88-01-13,GWMay), install(88-01-19,MR12.2-1016):
     Added -force (-fc), -inhibit_error (-ihe), and -no_inhibit_error (-nihe)
     to add_search_paths.
  3) change(87-11-17,Lippard), approve(87-12-21,MCR7822),
     audit(88-02-11,Blair), install(88-02-16,MR12.2-1023):
     Added -initiated_segments (-is).
  4) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
     audit(88-02-11,Blair), install(88-02-16,MR12.2-1023):
     Changed to use UIDs in pathname comparisons.
  5) change(87-11-23,Lippard), approve(87-12-21,MCR7822),
     audit(88-02-11,Blair), install(88-02-16,MR12.2-1023):
     Modified to requote pathnames returned by psp and wsp AFs, reject null
     pathnames, and correct error message given when asp modifiers are given
     out of position.
  6) change(88-02-25,Lippard), approve(87-12-21,PBF7822),
     audit(88-02-25,Farley), install(88-03-01,MR12.2-1031):
     Modified to consider matching UIDs on segments with different entry
     names to be a non-match, so that peculiar uses of search paths
     (e.g. azm's "structure" search list) will continue to work.
                                                   END HISTORY COMMENTS */


/* format: off */

/*	Search Facility Command Interface

	Rewritten 06-Sep-78 by Monte Davidoff.
	ssp -default added 07/01/80 S. Herbst
*/
set_search_paths:
ssp:
     procedure;

/* automatic */

	declare af_return_string_length
				 fixed binary (21);
	declare af_return_string_ptr	 pointer;
	declare af_sw		 bit (1);		/* on for active function, off for command */
	declare af_usage		 char (44);	/* active function usage message */
	declare arg_list_ptr	 pointer;		/* pointer to command's argument list */
	declare args_arg_count	 fixed binary;
	declare args_ptr		 pointer;
	declare cleanup_new_sl_info_ptr
				 pointer;		/* pointers for cleanup_ */
	declare cleanup_sl_info_ptr	 pointer;
	declare cleanup_sl_list_ptr	 pointer;
	declare command		 char (32);	/* what command this is */
	declare sys_err_		 entry options (variable) variable;
	declare usage		 char (44);	/* command usage message */

/* based */

	declare af_return_string	 char (af_return_string_length) varying based (af_return_string_ptr);

	declare 1 args		 based (args_ptr),
		2 arg_count	 fixed binary,	/* how many arguments the command has */
		2 first_arg	 fixed binary,	/* index of first non-control-arg argument */
		2 arg		 (args_arg_count refer (args.arg_count)),
		  3 ptr		 pointer,		/* pointer to argument */
		  3 len		 fixed binary (21), /* length of argument */
		  3 next_arg	 fixed binary,	/* index of next parsed argument */
		  3 pathx		 fixed binary;	/* if used, index of this argument in sl_info */

/* builtin */

	declare addr		 builtin;
	declare hbound		 builtin;
	declare lbound		 builtin;
	declare length		 builtin;
	declare ltrim		 builtin;
	declare null		 builtin;
	declare rtrim		 builtin;
	declare search		 builtin;
	declare substr		 builtin;

/* condition */

	declare cleanup		 condition;

/* internal static */

	declare CHASE		 fixed bin (1) internal static options (constant) initial (1);

	declare HT		 char (1) internal static options (constant) initial ("	");
	declare SP		 char (1) internal static options (constant) initial (" ");

/* external static */

	declare error_table_$action_not_performed
				 fixed binary (35) external static;
	declare error_table_$badarg	 fixed binary (35) external static;
	declare error_table_$badopt	 fixed binary (35) external static;
	declare error_table_$new_search_list
				 fixed binary (35) external static;
	declare error_table_$not_act_fnc
				 fixed binary (35) external static;

/* external entry */

	declare absolute_pathname_	 entry (char (*), char (*), fixed binary (35));
	declare active_fnc_err_	 entry options (variable);
	declare active_fnc_err_$af_suppress_name
				 entry options (variable);
	declare com_err_		 entry options (variable);
	declare com_err_$suppress_name entry options (variable);
	declare cu_$af_arg_count_rel	 entry (fixed binary, fixed binary (35), pointer);
	declare cu_$af_return_arg_rel	 entry (fixed binary, pointer, fixed binary (21), fixed binary (35), pointer);
	declare cu_$arg_list_ptr	 entry (pointer);
	declare cu_$arg_ptr_rel	 entry (fixed binary, pointer, fixed binary (21), fixed binary (35), pointer);
	declare expand_pathname_	 entry (char (*), char (*), char (*), fixed binary (35));
	declare get_pdir_		 entry returns(char(168));
	declare get_system_free_area_	 entry () returns (pointer);
	declare hcs_$get_uid_file	 entry (char (*), char (*), bit (36) aligned, fixed binary (35));
	declare hcs_$status_minf	 entry (char (*), char (*), fixed binary (1), fixed binary (2), fixed binary (24),
				 fixed binary (35));
	declare ioa_		 entry options (variable);
	declare ioa_$rsnnl		 entry options (variable);
	declare search_paths_$delete_list
				 entry (char (*), pointer, fixed binary (35));
	declare search_paths_$find_all entry (char (*), pointer, char (*), char (*), pointer, fixed binary, pointer,
				 fixed binary (35));
	declare search_paths_$find_dir entry (char (*), pointer, char (*), char (*), char (*), fixed binary (35));
	declare search_paths_$get	 entry (char (*), bit (36), char (*), pointer, pointer, fixed binary, pointer,
				 fixed binary (35));
	declare search_paths_$list	 entry (pointer, pointer, fixed binary, pointer, fixed binary (35));
	declare search_paths_$set	 entry (char (*), pointer, pointer, fixed binary (35));
	declare user_info_$homedir	 entry (char(*));

%include sl_info;
%include sl_control_s;
%include sl_list;
%include status_structures;

/* set_search_paths */

	call initialize ("set_search_paths", "search_list {search_paths} {-control_args}", "");
	call cu_$arg_list_ptr (arg_list_ptr);
	on cleanup
	     call cleanup_;
	call set_search_paths_;
	call cleanup_;
	return;

add_search_paths:
asp:
     entry;

	call initialize ("add_search_paths", "search_list search_paths", "");
	call cu_$arg_list_ptr (arg_list_ptr);
	on cleanup
	     call cleanup_;
	call add_search_paths_;
	call cleanup_;
	return;

delete_search_paths:
dsp:
     entry;

	call initialize ("delete_search_paths", "search_list {search_paths} {-control_args}", "");
	call cu_$arg_list_ptr (arg_list_ptr);
	on cleanup
	     call cleanup_;
	call delete_search_paths_;
	call cleanup_;
	return;

print_search_paths:
psp:
     entry;

	call initialize ("print_search_paths", "{search_lists} {-control_args}", "search_list {-control_args}");
	call cu_$arg_list_ptr (arg_list_ptr);
	on cleanup
	     call cleanup_;
	call print_search_paths_;
	call cleanup_;
	return;

where_search_paths:
wsp:
     entry;

	call initialize ("where_search_paths", "search_list entryname {-control_args}", "");
	call cu_$arg_list_ptr (arg_list_ptr);
	on cleanup
	     call cleanup_;
	call where_search_paths_;
	call cleanup_;
	return;

set_search_paths_:
     procedure;

	declare argx		 fixed binary;
	declare code		 fixed binary (35);
	declare control_arg_sws	 (2) bit (1);
	declare old_argx		 fixed binary;
	declare parsed_arg_count	 fixed binary;
	declare pathx		 fixed binary;
	declare sl_name		 char (32);

	declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);

	declare 1 ssp_args		 aligned internal static options (constant),
		2 keywords	 (10) char (20)
				 initial ("-home_dir", "-hd", "-process_dir", "-pd", "-referencing_dir", "-rd",
				 "-working_dir", "-wd", "-initiated_segments", "-is"),
		2 modifiers,
		  3 name		 (1) char (1) initial (""),
		  3 has_arg	 (1) bit (1) initial ("0"b),
		2 control_args,
		  3 name		 (4) char (8) initial ("-brief", "-bf", "-default", "-df"),
		  3 switch	 (4) fixed binary initial (1, 1, 2, 2),
		  3 value		 (4) bit (1) initial ("1"b, "1"b, "1"b, "1"b);
	declare BRIEF_SW		 fixed binary internal static options (constant) initial (1);
	declare DEFAULT_SW		 fixed binary internal static options (constant) initial (2);

	call get_args (arg_list_ptr, ssp_args, control_arg_sws, parsed_arg_count, code);
	if code ^= 0
	then return;

	if parsed_arg_count = 0
	then do;
		call usage_err_;
		return;
	     end;

	if parsed_arg_count > 1 & control_arg_sws (DEFAULT_SW)
	then do;
		call sys_err_ (0, command, "Search paths cannot be specified with -default.");
		return;
	     end;

	argx = args.first_arg;
	call check_search_list_name (argx_string, sl_name, code);
	if code ^= 0
	then return;

/* -initiated_segments may only be used with linker search paths. */
	old_argx = argx;
	do argx = args.arg (argx).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
	     if (argx_string = "-initiated_segments" | argx_string = "-is") & sl_name ^= "linker"
	     then do;
		     code = error_table_$badopt;
		     call sys_err_ ((0), command, "The ""^a"" keyword may only be used with the linker search list.", argx_string);
		     return;
		end;
	end;
	argx = old_argx;

	call create_sl_info (parsed_arg_count - 1, cleanup_sl_info_ptr);

	args.arg (*).pathx = 0;
	if cleanup_sl_info_ptr ^= null
	then do pathx = 1 to cleanup_sl_info_ptr -> sl_info.num_paths;
		argx = args.arg (argx).next_arg;

		if args.arg (argx).len = 0
		then do;
			code = error_table_$badarg;
			call sys_err_ (code, command, """""");
			return;
		     end;

		call get_path_type (argx_string, cleanup_sl_info_ptr -> sl_info.paths (pathx).type,
		     cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname, code);
		if code ^= 0
		then return;

		if path_index (cleanup_sl_info_ptr, cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname) < pathx
		then do;
			call sys_err_ (0, command, "Search path specified twice. ^a",
			     cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname);
			return;
		     end;

		args.arg (argx).pathx = pathx;
	     end;

	call set_the_search_paths_of_a_search_list (sl_name, control_arg_sws (BRIEF_SW), cleanup_sl_info_ptr, code);
	if code ^= 0 & code ^= error_table_$new_search_list
	then return;

	call check_paths_for_warnings (sl_name, cleanup_sl_info_ptr);
     end set_search_paths_;

add_search_paths_:
     procedure;

	declare argx		 fixed binary;
	declare code		 fixed binary (35);
	declare control_arg_sws	 (2) bit (1);
	declare ignore_current_list	 bit (1);
	declare old_argx		 fixed binary;
	declare parsed_arg_count	 fixed binary;
	declare path_count		 fixed binary;
	declare pathx		 fixed binary;
	declare sl_name		 char (32);

	declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);

	declare 1 asp_args		 aligned internal static options (constant),
		2 keywords	 (10) char (20)
				 initial ("-home_dir", "-hd", "-process_dir", "-pd", "-referencing_dir", "-rd",
				 "-working_dir", "-wd", "-initiated_segments", "-is"),
		2 modifiers,
		  3 name		 (8) char (8)
				 initial ("-first", "-ft", "-last", "-lt", "-before", "-be", "-after", "-af"),
		  3 has_arg	 (8) bit (1) initial ("0"b, "0"b, "0"b, "0"b, "1"b, "1"b, "1"b, "1"b),
		2 control_args,
		  3 name		 (8) char (17) initial ("-force", "-fc", "-no_force", "-nfc", "-inhibit_error", "-ihe", "-no_inhibit_error", "-nihe"),
		  3 switch	 (8) fixed binary initial (1, 1, 1, 1, 2, 2, 2, 2),
		  3 value		 (8) bit (1) initial ("1"b, "1"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b);
	declare FORCE_SW		 fixed binary internal static options (constant) initial (1);
	declare INHIBIT_ERR_SW	 fixed binary internal static options (constant) initial (2);

	call get_args (arg_list_ptr, asp_args, control_arg_sws, parsed_arg_count, code);
	if code ^= 0
	then return;

	if parsed_arg_count < 2
	then do;
		call usage_err_;
		return;
	     end;

	argx = args.first_arg;
	call check_search_list_name (argx_string, sl_name, code);
	if code ^= 0
	then return;

/* -initiated_segments may only be used with linker search paths. */
	old_argx = argx;
	do argx = args.arg (argx).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
	     if (argx_string = "-initiated_segments" | argx_string = "-is") & sl_name ^= "linker"
	     then do;
		     code = error_table_$badopt;
		     call sys_err_ ((0), command, "The ""^a"" keyword may only be used with the linker search list.", argx_string);
		     return;
		end;
	end;
	argx = old_argx;

	call search_paths_$get (sl_name, ""b, "", null, get_system_free_area_ (), sl_info_version_1, cleanup_sl_info_ptr,
	     code);
	if code ^= 0
	then do;
		call sys_err_ (code, command, "^a", sl_name);
		return;
	     end;

	ignore_current_list = "0"b;

/* Begin block with local variables for compatibility with the style of
   the rest of program (and because this block contains local variables
   having the same names as others outside the block). */
	if control_arg_sws (FORCE_SW)
	then begin;
		declare delete_count	 fixed binary;
		declare new_pathx		 fixed binary;
		declare pathname		 character (168);
		declare pathx		 fixed binary;

/* See which paths are duplicates, and delete them. */
		delete_count = 0;
		do argx = args.arg (argx).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
		     call get_path_type (argx_string, (0), pathname, code);
		     if code ^= 0
		     then return;
		     pathx = path_index (cleanup_sl_info_ptr, pathname);
		     if pathx ^= 0
		     then do;
			     cleanup_sl_info_ptr -> sl_info.paths (pathx).type = 0;
			     cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname = "";
			     delete_count = delete_count + 1;
			end;
		end;

/* They're all duplicates. */
		if delete_count = cleanup_sl_info_ptr -> sl_info.num_paths
		then do;
			ignore_current_list = "1"b;
			path_count = 0;
		end;

/* Delete the duplicates. */
		else if delete_count ^= 0
		then do;
			call create_sl_info (cleanup_sl_info_ptr -> sl_info.num_paths - delete_count, cleanup_new_sl_info_ptr);

			new_pathx = 1;
			do pathx = 1 to cleanup_sl_info_ptr -> sl_info.num_paths
			     while (new_pathx <= cleanup_new_sl_info_ptr -> sl_info.num_paths);
			     if cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname ^= ""
			     then do;
				     cleanup_new_sl_info_ptr -> sl_info.paths (new_pathx).type =
					cleanup_sl_info_ptr -> sl_info.paths (pathx).type;
				     cleanup_new_sl_info_ptr -> sl_info.paths (new_pathx).pathname =
					cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname;
				     cleanup_new_sl_info_ptr -> sl_info.paths (new_pathx).uid =
					cleanup_sl_info_ptr -> sl_info.paths (pathx).uid;
				     new_pathx = new_pathx + 1;
				end;
			end;

			free cleanup_sl_info_ptr -> sl_info;
			cleanup_sl_info_ptr = cleanup_new_sl_info_ptr;
			cleanup_new_sl_info_ptr = null ();
		     end;
	     end;

/* If they're all duplicates, just create a whole new search list. */
	if ignore_current_list
	then do;
		call create_sl_info (parsed_arg_count - 1, cleanup_new_sl_info_ptr);
		cleanup_new_sl_info_ptr -> sl_info.paths (*).type = 0;
		cleanup_new_sl_info_ptr -> sl_info.paths (*).pathname = "";
		cleanup_new_sl_info_ptr -> sl_info.paths (*).uid = ""b;
	     end;

/* Otherwise, just add the new and duplicate paths. */
	else do;
		path_count = cleanup_sl_info_ptr -> sl_info.num_paths;
		call create_sl_info (path_count + parsed_arg_count - 1, cleanup_new_sl_info_ptr);
		cleanup_new_sl_info_ptr -> sl_info.paths (*).type = 0;
		cleanup_new_sl_info_ptr -> sl_info.paths (*).pathname = "";
		cleanup_new_sl_info_ptr -> sl_info.paths (*).uid = ""b;

		do pathx = 1 to path_count;
		     cleanup_new_sl_info_ptr -> sl_info.paths (pathx).type =
			cleanup_sl_info_ptr -> sl_info.paths (pathx).type;
		     cleanup_new_sl_info_ptr -> sl_info.paths (pathx).pathname =
			cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname;
		     cleanup_new_sl_info_ptr -> sl_info.paths (pathx).uid =
			cleanup_sl_info_ptr -> sl_info.paths (pathx).uid;
		end;
	     end;

	free cleanup_sl_info_ptr -> sl_info;
	cleanup_sl_info_ptr = null;

	call add_search_paths_to_sl_info (sl_name, cleanup_new_sl_info_ptr, control_arg_sws (INHIBIT_ERR_SW), path_count, code);
	if code ^= 0
	then return;

	call create_sl_info (path_count, cleanup_sl_info_ptr);
	do pathx = 1 to path_count;
	     cleanup_sl_info_ptr -> sl_info.paths (pathx).type = cleanup_new_sl_info_ptr -> sl_info.paths (pathx).type;
	     cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname =
		cleanup_new_sl_info_ptr -> sl_info.paths (pathx).pathname;
	     cleanup_sl_info_ptr -> sl_info.paths (pathx).uid =
		cleanup_new_sl_info_ptr -> sl_info.paths (pathx).uid;
	end;

	free cleanup_new_sl_info_ptr -> sl_info;
	cleanup_new_sl_info_ptr = null;

	call set_the_search_paths_of_a_search_list (sl_name, "0"b, cleanup_sl_info_ptr, code);
	if code ^= 0
	then return;

	if ^control_arg_sws (INHIBIT_ERR_SW)
	then call check_paths_for_warnings (sl_name, cleanup_sl_info_ptr);
     end add_search_paths_;

delete_search_paths_:
     procedure;

	declare argx		 fixed binary;
	declare code		 fixed binary (35);
	declare control_arg_sws	 (1) bit (1);
	declare old_argx		 fixed binary;
	declare parsed_arg_count	 fixed binary;
	declare sl_name		 char (32);

	declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);

	declare 1 dsp_args		 aligned internal static options (constant),
		2 keywords	 (10) char (20)
				 initial ("-home_dir", "-hd", "-process_dir", "-pd", "-referencing_dir", "-rd", "-working_dir", "-wd", "-initiated_segments", "-is"),
		2 modifiers,
		  3 name		 (1) char (1) initial (""),
		  3 has_arg	 (1) bit (1) initial ("0"b),
		2 control_args,
		  3 name		 (2) char (4) initial ("-all", "-a"),
		  3 switch	 (2) fixed binary initial (1, 1),
		  3 value		 (2) bit (1) initial ("1"b, "1"b);
	declare ALL_SW		 fixed binary internal static options (constant) initial (1);

	call get_args (arg_list_ptr, dsp_args, control_arg_sws, parsed_arg_count, code);
	if code ^= 0
	then return;

	if parsed_arg_count = 0
	then do;
		call usage_err_;
		return;
	     end;

	argx = args.first_arg;
	call check_search_list_name (argx_string, sl_name, code);
	if code ^= 0
	then return;

/* -initiated_segments may only be used with linker search paths. */
	old_argx = argx;
	do argx = args.arg (argx).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
	     if (argx_string = "-initiated_segments" | argx_string = "-is") & sl_name ^= "linker"
	     then do;
		     code = error_table_$badopt;
		     call sys_err_ ((0), command, "The ""^a"" keyword may only be used with the linker search list.", argx_string);
		     return;
		end;
	end;
	argx = old_argx;

	if control_arg_sws (ALL_SW)
	then do;
		call search_paths_$delete_list (sl_name, null, code);
		if code ^= 0
		then do;
			call sys_err_ (code, command, "^a", sl_name);
			return;
		     end;
	     end;
	else begin;
		declare delete_count	 fixed binary;
		declare new_pathx		 fixed binary;
		declare pathname		 character (168);
		declare pathx		 fixed binary;

		call search_paths_$get (sl_name, ""b, "", null, get_system_free_area_ (), sl_info_version_1,
		     cleanup_sl_info_ptr, code);
		if code ^= 0
		then do;
			call sys_err_ (code, command, "^a", sl_name);
			return;
		     end;

		delete_count = 0;
		do argx = args.arg (argx).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
		     if args.arg (argx).len = 0
		     then do;
			     code = error_table_$badarg;
			     call sys_err_ (code, command, """""");
			     return;
			end;
		     call get_path_type (argx_string, (0), pathname, code);
		     if code ^= 0
		     then return;
		     pathx = path_index (cleanup_sl_info_ptr, pathname);
		     if pathx = 0
		     then call sys_err_ (0, command, "Search path ^a is not in the ^a search list.", argx_string, sl_name)
			     ;
		     else do;
			     cleanup_sl_info_ptr -> sl_info.paths (pathx).type = 0;
			     cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname = "";
			     cleanup_sl_info_ptr -> sl_info.paths (pathx).uid = ""b;
			     delete_count = delete_count + 1;
			end;
		end;

		if delete_count = cleanup_sl_info_ptr -> sl_info.num_paths
		then do;
			call sys_err_ (error_table_$action_not_performed, command, "The search list would be empty.");
			return;
		     end;

		if delete_count = 0
		then do;
			call sys_err_ (0, command, "No search paths deleted.");
			return;
		     end;

		call create_sl_info (cleanup_sl_info_ptr -> sl_info.num_paths - delete_count, cleanup_new_sl_info_ptr);

		new_pathx = 1;
		do pathx = 1 to cleanup_sl_info_ptr -> sl_info.num_paths
		     while (new_pathx <= cleanup_new_sl_info_ptr -> sl_info.num_paths);
		     if cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname ^= ""
		     then do;
			     cleanup_new_sl_info_ptr -> sl_info.paths (new_pathx).type =
				cleanup_sl_info_ptr -> sl_info.paths (pathx).type;
			     cleanup_new_sl_info_ptr -> sl_info.paths (new_pathx).pathname =
				cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname;
			     cleanup_new_sl_info_ptr -> sl_info.paths (new_pathx).uid =
				cleanup_sl_info_ptr -> sl_info.paths (pathx).uid;
			     new_pathx = new_pathx + 1;
			end;
		end;

		call set_the_search_paths_of_a_search_list (sl_name, "0"b, cleanup_new_sl_info_ptr, code);
	     end;
     end delete_search_paths_;

print_search_paths_:
     procedure;

	declare code		 fixed binary (35);
	declare control_arg_sws	 (1) bit (1);
	declare parsed_arg_count	 fixed binary;

	declare 1 psp_args		 aligned internal static options (constant),
		2 keywords	 (1) char (1) initial (""),
		2 modifiers,
		  3 name		 (1) char (1) initial (""),
		  3 has_arg	 (1) bit (1) initial ("0"b),
		2 control_args,
		  3 name		 (2) char (12) initial ("-expanded", "-exp"),
		  3 switch	 (2) fixed binary initial (1, 1),
		  3 value		 (2) bit (1) initial ("1"b, "1"b);
	declare EXPAND_SW		 fixed binary internal static options (constant) initial (1);

	call check_for_active_function (arg_list_ptr, code);
	if code ^= 0
	then return;

	call get_args (arg_list_ptr, psp_args, control_arg_sws, parsed_arg_count, code);
	if code ^= 0
	then return;

	if af_sw & parsed_arg_count ^= 1
	then do;
		call usage_err_;
		return;
	     end;

	if parsed_arg_count = 0
	then do;
		call search_paths_$list (null, get_system_free_area_ (), sl_list_version_2, cleanup_sl_list_ptr, code);
		if code ^= 0
		then do;
			call sys_err_ (code, command);
			return;
		     end;

		if cleanup_sl_list_ptr = null
		then call sys_err_ (0, command, "Search segment is empty.");
		else begin;
			declare namex		 fixed binary;
			declare sl_list_ptr		 pointer;

			do sl_list_ptr = cleanup_sl_list_ptr repeat sl_list_ptr -> sl_list.link
			     while (sl_list_ptr ^= null);
			     do namex = 1 to sl_list_ptr -> sl_list.name_count;
				call output_one_line (sl_list_ptr -> sl_list.names (namex));
			     end;
			     call print_search_list (sl_list_ptr -> sl_list.names (1), "0"b,
				control_arg_sws (EXPAND_SW), cleanup_sl_info_ptr);
			end;
		     end;
	     end;
	else begin;
		declare argx		 fixed binary;
		declare sl_name		 char (32);

		declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);

		do argx = args.first_arg repeat args.arg (argx).next_arg while (argx ^= 0);
		     call check_search_list_name (argx_string, sl_name, code);
		     if code = 0
		     then call print_search_list (sl_name, ^af_sw, control_arg_sws (EXPAND_SW), cleanup_sl_info_ptr);
		end;
	     end;
     end print_search_paths_;

where_search_paths_:
     procedure;

	declare argx		 fixed binary;
	declare code		 fixed binary (35);
	declare control_arg_sws	 (2) bit (1);
	declare old_argx		 fixed binary;
	declare parsed_arg_count	 fixed binary;
	declare sl_name		 char (32);

	declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);

	declare 1 wsp_args		 aligned internal static options (constant),
		2 keywords	 (1) char (1) initial (""),
		2 modifiers,
		  3 name		 (1) char (1) initial (""),
		  3 has_arg	 (1) bit (1) initial ("0"b),
		2 control_args,
		  3 name		 (6) char (17) initial ("-all", "-a", "-inhibit_error", "-ihe", "-no_inhibit_error", "-nihe"),
		  3 switch	 (6) fixed binary initial (1, 1, 2, 2, 2, 2),
		  3 value		 (6) bit (1) initial ("1"b, "1"b, "1"b, "1"b, "0"b, "0"b);
	declare ALL_SW		 fixed binary internal static options (constant) initial (1);
	declare INHIBIT_ERR_SW	 fixed binary internal static options (constant) initial (2);

	call check_for_active_function (arg_list_ptr, code);
	if code ^= 0
	then return;

	call get_args (arg_list_ptr, wsp_args, control_arg_sws, parsed_arg_count, code);
	if code ^= 0
	then return;

	if parsed_arg_count ^= 2
	then do;
		call usage_err_;
		return;
	     end;

	argx = args.first_arg;
	call check_search_list_name (argx_string, sl_name, code);
	if code ^= 0
	then return;

/* -initiated_segments may only be used with linker search paths. */
	old_argx = argx;
	do argx = args.arg (argx).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
	     if (argx_string = "-initiated_segments" | argx_string = "-is") & sl_name ^= "linker"
	     then do;
		     code = error_table_$badopt;
		     call sys_err_ (code, command, "^a", argx_string);
		     return;
		end;
	end;
	argx = old_argx;

	argx = args.arg (argx).next_arg;
	if args.arg (argx).len = 0
	then do;
		code = error_table_$badarg;
		call sys_err_ (code, command, """""");
		return;
	     end;
	if control_arg_sws (ALL_SW)
	then begin;
		declare pathx		 fixed binary;

		call search_paths_$find_all (sl_name, null, argx_string, "", get_system_free_area_ (), sl_info_version_1,
		     cleanup_sl_info_ptr, code);
		if code ^= 0
		then do;
			if control_arg_sws (INHIBIT_ERR_SW) & af_sw then af_return_string = "";
			else call sys_err_ (code, command, "^a in ^a search list.", argx_string, sl_name);
			return;
		     end;

		do pathx = 1 to cleanup_sl_info_ptr -> sl_info.num_paths;
		     call output_pathname (cleanup_sl_info_ptr -> sl_info.paths (pathx).pathname, argx_string);
		end;
	     end;
	else begin;
		declare dir_name		 char (168);

		call search_paths_$find_dir (sl_name, null, argx_string, "", dir_name, code);
		if code ^= 0
		then do;
			if control_arg_sws (INHIBIT_ERR_SW) & af_sw then af_return_string = "";
			else call sys_err_ (code, command, "^a in ^a search list.", argx_string, sl_name);
			return;
		     end;
		call output_pathname (dir_name, argx_string);
	     end;
     end where_search_paths_;

/*	Add the search path arguments of add_search_paths to an sl_info structure.

	The sl_info structure must have enough room for all the possible
	search paths in the argument list.
*/
add_search_paths_to_sl_info:
     procedure (sl_name, sl_info_ptr, inhibit_err, path_count, code);

	declare sl_name		 char (*);	/* (Input) search list name */
	declare sl_info_ptr		 pointer;		/* (Input) pointer to a "large enough" sl_info */
	declare inhibit_err		 bit (1);		/* (Input) if warnings shouldn't be printed */
	declare path_count		 fixed binary;	/* (Updated) number of paths in sl_info */
	declare code		 fixed binary (35); /* (Output) standard status code */

	declare argx		 fixed binary;
	declare dname		 char (168);
	declare ename		 char (32);
	declare error		 bit (1);
	declare insert_index	 fixed binary;
	declare pathname		 char (168);
	declare type		 fixed binary;
	declare uid		 bit (36) aligned;

	code = 0;

	args.arg (*).pathx = 0;
	do argx = args.arg (args.first_arg).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
	     if args.arg (argx).len = 0
	     then do;
		     code = error_table_$badarg;
		     call sys_err_ (code, command, """""");
		     return;
		end;
	     call get_search_path_and_position (sl_info_ptr, path_count, argx, inhibit_err, type, pathname, insert_index, error, code);
	     if code ^= 0
	     then return;

	     if ^error
	     then begin;
		     declare pathx		      fixed binary;

		     do pathx = path_count to insert_index by -1;
			sl_info_ptr -> sl_info.paths (pathx + 1).type = sl_info_ptr -> sl_info.paths (pathx).type;
			sl_info_ptr -> sl_info.paths (pathx + 1).pathname =
			     sl_info_ptr -> sl_info.paths (pathx).pathname;
			sl_info_ptr -> sl_info.paths (pathx + 1).uid =
			     sl_info_ptr -> sl_info.paths (pathx).uid;
		     end;

		     path_count = path_count + 1;
		     sl_info_ptr -> sl_info.paths (insert_index).type = type;
		     sl_info_ptr -> sl_info.paths (insert_index).pathname = pathname;

/* The following two expansions need to be done for the linker search
   list in order to set the UID correctly. */
		     if type = PROCESS_DIR
		     then pathname = get_pdir_ ();

		     else if type = HOME_DIR
		     then call user_info_$homedir (pathname);

		     uid = ""b;
		     if type = ABSOLUTE_PATH | type = HOME_DIR | type = PROCESS_DIR
		     then do;
			call expand_pathname_ (pathname, dname, ename, code);
			if code = 0
			then call hcs_$get_uid_file (dname, ename, uid, (0));
			end;
		     sl_info_ptr -> sl_info.paths (insert_index).uid = uid;

		     do pathx = 1 to argx - 1;
			if args.arg (pathx).pathx >= insert_index
			then args.arg (pathx).pathx = args.arg (pathx).pathx + 1;
		     end;

		     args.arg (argx).pathx = insert_index;
		end;
	end;
	return;

/*	Convert an argument of add_search_paths to a search path and figure
	out where to put it in the sl_info structure.

	This looks at modifiers that may follow an argument.
*/
get_search_path_and_position:
     procedure (sl_info_ptr, path_count, argx, inhibit_err, type, pathname, insert_index, error, code);

	declare sl_info_ptr		 pointer;		/* (Input) pointer to a "large enough" sl_info */
	declare path_count		 fixed binary;	/* (Input) number of paths in sl_info */
	declare argx		 fixed binary;	/* (Input) current argument number */
	declare inhibit_err		 bit (1);		/* (Input) if warnings shouldn't be printed */
	declare type		 fixed binary;	/* (Output) type of the new search path */
	declare pathname		 char (*);	/* (Output) new search pathname */
	declare insert_index	 fixed binary;	/* (Output) where to insert search path in sl_info */
	declare error		 bit (1);		/* (Output) on means there was a non-fatal error */
	declare code		 fixed binary (35); /* (Output) standard status code */

	declare next_arg		 fixed binary;
	declare old_pathname	 char (168);
	declare old_type		 fixed binary;
	declare pathx		 fixed binary;

	declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);
	declare next_arg_string	 char (args.arg (next_arg).len) based (args.arg (next_arg).ptr);

	type = 0;
	pathname = "";
	insert_index = path_count + 1;
	error = "0"b;
	code = 0;

	call get_path_type (argx_string, type, pathname, code);
	if code ^= 0
	then return;

	if path_index (sl_info_ptr, pathname) > 0 & ^inhibit_err
	then do;
		error = "1"b;
		call sys_err_ (0, command, "Warning. ^a is already in the ^a search list.", pathname, sl_name);
	     end;

	if argx >= args.arg_count
	then return;				/* no modifiers */

	next_arg = argx + 1;
	if next_arg_string = "-first" | next_arg_string = "-ft"
	then do;
		insert_index = 1;
		return;
	     end;

	if next_arg_string = "-last" | next_arg_string = "-lt"
	then do;
		insert_index = path_count + 1;
		return;
	     end;

	if next_arg_string = "-before" | next_arg_string = "-be"
	then insert_index = 0;
	else if next_arg_string = "-after" | next_arg_string = "-af"
	then insert_index = 1;
	else return;

	next_arg = next_arg + 1;
	if next_arg > args.arg_count
	then do;
		code = error_table_$badopt;
		call sys_err_ (0, command, "A search path must follow ^[-before^;-after^].", insert_index = 0);
		return;
	     end;

	call get_path_type (next_arg_string, old_type, old_pathname, code);
	if code ^= 0
	then return;

	pathx = path_index (sl_info_ptr, old_pathname);
	if pathx = 0
	then do;
		error = "1"b;
		call sys_err_ (0, command, "Search path ^a was not in the ^a search list.", old_pathname, sl_name);
	     end;

	insert_index = pathx + insert_index;
     end get_search_path_and_position;

     end add_search_paths_to_sl_info;

/*	Initialize global variables

	If af_usage_msg is null, then usage_msg is used.
*/
initialize:
     procedure (command_name, usage_msg, af_usage_msg);

	declare command_name	 char (*);	/* (Input) what command this is */
	declare usage_msg		 char (*);	/* (Input) command usage message */
	declare af_usage_msg	 char (*);	/* (Input) active function usage message */

	command = command_name;
	usage = usage_msg;
	if af_usage_msg = ""
	then af_usage = usage_msg;
	else af_usage = af_usage_msg;

	af_sw = "0"b;
	sys_err_ = com_err_;

	args_ptr = null;
	cleanup_new_sl_info_ptr = null;
	cleanup_sl_info_ptr = null;
	cleanup_sl_list_ptr = null;
     end initialize;

/* Find out if this command was called as an active function */

check_for_active_function:
     procedure (arg_list_ptr, code);

	declare arg_list_ptr	 pointer;		/* (Input) pointer to argument list */
	declare code		 fixed binary (35); /* (Output) standard status code */

	declare arg_count		 fixed binary;

	call cu_$af_return_arg_rel (arg_count, af_return_string_ptr, af_return_string_length, code, arg_list_ptr);
	if code = 0
	then do;
		af_sw = "1"b;
		sys_err_ = active_fnc_err_;
		af_return_string = "";
	     end;
	else if code = error_table_$not_act_fnc
	then code = 0;
	else call sys_err_ (code, command);
     end check_for_active_function;

/*	Parse the command's arguments.

	Pointers to the arguments are placed in a structure.
	Control-arguments are checked, and a switch is set when one is
	found.  A parsed_arg_count is returned which gives the number of
	arguments not including control-arguments and modifiers.  The
	parsed arguments are linked together so it is possible to loop
	through them and ignore control-arguments and modifiers.

Note:	The first argument cannot have a modifier.  (add_search_paths is the
	only command which allows modifiers and the first argument of
	add_search_paths is a search list, not a search path).
*/
get_args:
     procedure (arg_list_ptr, command_args, control_arg_sws, parsed_arg_count, code);

	declare arg_list_ptr	 pointer;		/* (Input) pointer to argument list */
	declare 1 command_args	 aligned,		/* (Input) expected arguments description */
		2 keywords	 (*) char (*),	/* control-arg-like keywords that aren't control args */
		2 modifiers,			/* positional control-args that can follow an argument */
		  3 name		 (*) char (*),	/* modifier's name */
		  3 has_arg	 (*) bit (1),	/* on if the modifier takes an argument */
		2 control_args,			/* what control-arguments there are */
		  3 name		 (*) char (*),	/* control-arguments name */
		  3 switch	 (*) fixed binary,	/* what switch to set if found */
		  3 value		 (*) bit (1);	/* what value to set the switch */
	declare control_arg_sws	 (*) bit (1);	/* (Output) what control arguments were found */
	declare parsed_arg_count	 fixed binary;	/* (Output) how many args excluding control-args and modifiers */
	declare code		 fixed binary (35); /* (Output) standard status code */

	declare argx		 fixed binary;
	declare namex		 fixed binary;
	declare last_parsed_arg	 fixed binary;

	declare argx_string		 char (args.arg (argx).len) based (args.arg (argx).ptr);

	control_arg_sws (*) = "0"b;
	parsed_arg_count = 0;
	code = 0;

	call cu_$af_arg_count_rel (args_arg_count, code, arg_list_ptr);
	if code = error_table_$not_act_fnc
	then code = 0;
	if code ^= 0
	then do;
		call sys_err_ (code, command);
		return;
	     end;

	if args_arg_count = 0
	then return;
	allocate args;

	args.first_arg = 0;
	args.arg (*).next_arg = 0;

	do argx = 1 to args.arg_count;
	     call cu_$arg_ptr_rel (argx, args.arg (argx).ptr, args.arg (argx).len, code, arg_list_ptr);
	     if code ^= 0
	     then do;
		     call sys_err_ (code, command, "Argument ^d.", argx);
		     return;
		end;
	end;

	last_parsed_arg = -1;
	argx = 1;
	do while (argx <= args.arg_count);
	     if ^is_control_arg (argx_string) | string_array_index (command_args.keywords (*), argx_string) > 0
	     then do;
		     parsed_arg_count = parsed_arg_count + 1;
		     if last_parsed_arg < 0
		     then args.first_arg = argx;
		     else args.arg (last_parsed_arg).next_arg = argx;
		     last_parsed_arg = argx;
		end;
	     else do;
		     namex = string_array_index (command_args.control_args.name (*), argx_string);
		     if namex > 0
		     then control_arg_sws (command_args.control_args.switch (namex)) = command_args.control_args.value (namex);
		     else do;
			     namex = string_array_index (command_args.modifiers.name (*), argx_string);
			     if last_parsed_arg = argx - 1 & last_parsed_arg > 1 & namex > 0
			     then if command_args.modifiers.has_arg (namex)
				then argx = argx + 1;
				else ;
			     else do;
				     code = error_table_$badopt;
				     if namex > 0
				     then call sys_err_ ((0), command, "The modifier ""^a"" may only follow a path or keyword.", argx_string);
				     else call sys_err_ (code, command, "^a", argx_string);
				     return;
				end;
			end;
		end;

	     argx = argx + 1;
	end;
     end get_args;

/* Make sure the search list name is valid */

check_search_list_name:
     procedure (given_search_list_name, sl_name, code);

	declare given_search_list_name char (*);	/* (Input) supplied search list name */
	declare sl_name		 char (*);	/* (Output) search list name */
	declare code		 fixed binary (35); /* (Output) non-standard status code */

	declare pos		 fixed binary;

	sl_name = "";
	code = 0;

	if is_control_arg (given_search_list_name)
	then do;
		code = -1;
		call usage_err_;
		return;
	     end;

	if length (given_search_list_name) > length (sl_name)
	then do;
		code = -1;
		call sys_err_ (0, command, "Search list name too long. ^a", given_search_list_name);
		return;
	     end;

	pos = search (given_search_list_name, "<>");
	if pos ^= 0
	then do;
		code = -1;
		call sys_err_ (0, command, "Invalid character ""^a"" in search list name. ^a",
		     substr (given_search_list_name, pos, 1), given_search_list_name);
		return;
	     end;

	if given_search_list_name = ""
	then do;
		code = -1;
		call sys_err_ (0, command, "Null search list name.");
		return;
	     end;

	sl_name = given_search_list_name;
     end check_search_list_name;

/* Allocate and initialize an sl_info structure */

create_sl_info:
     procedure (path_count, sl_info_ptr);

	declare path_count		 fixed binary;	/* (Input) number of search paths in sl_info */
	declare sl_info_ptr		 pointer;		/* (Output) pointer to sl_info */

	sl_info_ptr = null;
	if path_count ^= 0
	then do;
		sl_info_num_paths = path_count;
		allocate sl_info set (sl_info_ptr);

		sl_info_ptr -> sl_info.version = sl_info_version_1;
		sl_info_ptr -> sl_info.change_index_p = null;
		sl_info_ptr -> sl_info.change_index = 0;
		sl_info_ptr -> sl_info.pad1 (*) = ""b;
		sl_info_ptr -> sl_info.paths (*).code = 0;
		sl_info_ptr -> sl_info.paths (*).uid = ""b;
	     end;
     end create_sl_info;

/* Convert an argument into a search path type and pathname */

get_path_type:
     procedure (search_path, type, pathname, code);

	declare search_path		 char (*);	/* (Input) search path to convert */
	declare type		 fixed binary;	/* (Output) search path type */
	declare pathname		 char (*);	/* (Output) search pathname */
	declare code		 fixed binary (35); /* (Output) standard status code */

	type = 0;
	pathname = search_path;
	code = 0;
	if is_control_arg (search_path)
	then if search_path = "-home_dir" | search_path = "-hd"
	     then do;
		     type = HOME_DIR;
		     pathname = "-home_dir";
		end;
	     else if search_path = "-process_dir" | search_path = "-pd"
	     then do;
		     type = PROCESS_DIR;
		     pathname = "-process_dir";
		end;
	     else if search_path = "-referencing_dir" | search_path = "-rd"
	     then do;
		     type = REFERENCING_DIR;
		     pathname = "-referencing_dir";
		end;
	     else if search_path = "-working_dir" | search_path = "-wd"
	     then do;
		     type = WORKING_DIR;
		     pathname = "-working_dir";
		end;
	     else if search_path = "-initiated_segments" | search_path = "-is"
	     then do;
		     type = INITIATED_SEGS;
		     pathname = "-initiated_segments";
		end;
	     else do;
		     code = error_table_$badopt;
		     call sys_err_ (code, command, "^a", search_path);
		end;
	else do;
		if search (search_path, "[]") = 0
		then type = ABSOLUTE_PATH;
		else type = UNEXPANDED_PATH;

		call absolute_pathname_ (search_path, pathname, code);
		if code ^= 0
		then call sys_err_ (code, command, "^a", search_path);
	     end;
     end get_path_type;

/*	Check if an argument is a control-argument.

	A control-argument is defined for this procedure to be anything starting with a hyphen.
*/
is_control_arg:
     procedure (arg) returns (bit (1));

	declare arg		 char (*);	/* (Input) a command argument */

	if arg = ""
	then return ("0"b);
	else return (substr (arg, 1, 1) = "-");
     end is_control_arg;

/* Find the index of a search path in sl_info */

path_index:
     procedure (sl_info_ptr, pathname) returns (fixed binary);

	declare sl_info_ptr		 pointer;		/* (Input) pointer to sl_info */
	declare pathname		 char (*);	/* (Input) pathname to look for */

	declare code		 fixed binary (35);

	declare dname		 char (168);
	declare ename		 char (32);

	declare entry_type		 fixed binary (2);

	declare pathx		 fixed binary;

	declare uid		 bit (36) aligned;

	entry_type = 0;
	uid = ""b;
	call expand_pathname_ (pathname, dname, ename, code);
	if code = 0
	then do;
		call hcs_$status_minf (dname, ename, CHASE, entry_type, (0), code);
	     	if code = 0
		then call hcs_$get_uid_file (dname, ename, uid, (0));
	     end;
	do pathx = 1 to sl_info_ptr -> sl_info.num_paths while (unique_pathname ());
	end;
	if pathx > sl_info_ptr -> sl_info.num_paths
	then return (0);
	else return (pathx);

unique_pathname: procedure () returns (bit (1) aligned);
dcl  sl_dname char (168);
dcl  sl_ename char (32);

	     if pathname = sl_info_ptr -> sl_info.paths (pathx).pathname
	     then return ("0"b);

	     if (uid ^= sl_info_ptr -> sl_info.paths (pathx).uid
	     | uid = ""b | sl_info_ptr -> sl_info.paths (pathx).uid = ""b)
	     then return ("1"b);			/* unique */

/* In the case of search lists of segment pathnames, we want to consider
   different names on the same entry to be different.  So if UIDs match
   but the entry names are different, we consider it not to be a match. */

	     if entry_type ^= Segment
	     then return ("0"b);
	     call expand_pathname_ (sl_info_ptr -> sl_info.paths (pathx).pathname, sl_dname, sl_ename, code);
	     if code ^= 0
	     then return ("0"b);
	     if ename ^= sl_ename
	     then return ("1"b);			/* unique */
	     else return ("0"b);
	end unique_pathname;
     end path_index;

/* Find the index of a character string in a character string array */

string_array_index:
     procedure (array, string) returns (fixed binary);

	declare array		 (*) char (*) aligned;
						/* (Input) array of character strings */
	declare string		 char (*);	/* (Input) string to look for */

	declare arrayx		 fixed binary;

	do arrayx = lbound (array, 1) to hbound (array, 1) while (string ^= array (arrayx));
	end;
	if arrayx > hbound (array, 1)
	then return (0);
	else return (arrayx);
     end string_array_index;

/*	Change a search list.

	Appropriate error and warning messages are printed.
*/
set_the_search_paths_of_a_search_list:
     procedure (sl_name, brief_sw, sl_info_ptr, code);

	declare sl_name		 char (*);	/* (Input) search list name */
	declare brief_sw		 bit (1);		/* (Input) on to suppress new search list warning message */
	declare sl_info_ptr		 pointer;		/* (Updated) pointer to sl_info with the new search list */
	declare code		 fixed binary (35); /* (Output) standard status code */

	call search_paths_$set (sl_name, null, sl_info_ptr, code);
	if code ^= 0
	then do;
		if code = error_table_$action_not_performed
		then begin;
			declare pathx		 fixed binary;

			do pathx = 1 to sl_info_ptr -> sl_info.num_paths;
			     if sl_info_ptr -> sl_info.paths (pathx).code ^= 0
			     then call sys_err_ (sl_info_ptr -> sl_info.paths (pathx).code, command, "^a",
				     sl_info_ptr -> sl_info.paths (pathx).pathname);
			end;
		     end;

		else if code ^= error_table_$new_search_list | ^brief_sw
		then call sys_err_ (code, command, "^a", sl_name);
	     end;

	if sl_info_ptr ^= null
	then do;
		free sl_info_ptr -> sl_info;
		sl_info_ptr = null;
	     end;
     end set_the_search_paths_of_a_search_list;

/* Warn the user if directories being added to the search list don't exist */

check_paths_for_warnings:
     procedure (sl_name, sl_info_ptr);

	declare sl_name		 char (*);	/* (Input) search list name */
	declare sl_info_ptr		 pointer;		/* (Output) pointer to allocate sl_info in */

	declare code		 fixed binary (35);

	call search_paths_$get (sl_name, "1"b, "", null, get_system_free_area_ (), sl_info_version_1, sl_info_ptr, code);
	if sl_info_ptr ^= null
	then begin;
		declare argx		 fixed binary;
		declare pathx		 fixed binary;

		do argx = args.arg (args.first_arg).next_arg repeat args.arg (argx).next_arg while (argx ^= 0);
		     pathx = args.arg (argx).pathx;
		     if pathx > 0
		     then if sl_info_ptr -> sl_info.paths (pathx).type = ABSOLUTE_PATH
			     | sl_info_ptr -> sl_info.paths (pathx).type = UNEXPANDED_PATH
			then begin;
				declare bit_count		 fixed binary (24);
				declare dir_name		 char (168);
				declare entry_type		 fixed binary (2);
				declare entryname		 char (32);

				call expand_pathname_ (sl_info_ptr -> sl_info.paths (pathx).pathname, dir_name,
				     entryname, code);
				call hcs_$status_minf (dir_name, entryname, 0, entry_type, bit_count, code);
				if code ^= 0
				then call sys_err_ (code, command, "Warning. ^a",
					sl_info_ptr -> sl_info.paths (pathx).pathname);
			     end;
		end;

		free sl_info_ptr -> sl_info;
		sl_info_ptr = null;
	     end;
     end check_paths_for_warnings;

/* Output the contents of a search list */

print_search_list:
     procedure (sl_name, print_name_sw, expand_sw, sl_info_ptr);

	declare sl_name		 char (*);	/* (Input) search list to print */
	declare print_name_sw	 bit (1);		/* (Input) on to print the search list name */
	declare expand_sw		 bit (1);		/* (Input) on to expand keywords */
	declare sl_info_ptr		 pointer;		/* (Output) pointer to allocate sl_info in */

	declare code		 fixed binary (35);
	declare pathx		 fixed binary;

	if expand_sw
	then do;
		sl_control_s.af_pathname = "1"b;
		sl_control_s.pad1 = "0"b;
		sl_control_s.key_ref_dir = "0"b;
		sl_control_s.key_work_dir = "1"b;
		sl_control_s.key_proc_dir = "1"b;
		sl_control_s.key_home_dir = "1"b;
		sl_control_s.pad2 = ""b;
	     end;
	else sl_control = ""b;
	call search_paths_$get (sl_name, sl_control, "", null, get_system_free_area_ (), sl_info_version_1, sl_info_ptr,
	     code);
	if code = 0
	then do;
		if print_name_sw
		then call output_one_line (sl_name);
		do pathx = 1 to sl_info_ptr -> sl_info.num_paths;
		     call output_one_line (HT || sl_info_ptr -> sl_info.paths (pathx).pathname);
		end;
		call output_one_line ("");
	     end;
	else call sys_err_ (code, command, "^a", sl_name);

	if sl_info_ptr ^= null
	then do;
		free sl_info_ptr -> sl_info;
		sl_info_ptr = null;
	     end;
     end print_search_list;

/*	Output a pathname.

	Handle the Root correctly.
*/
output_pathname:
     procedure (dir_name, entryname);

	declare dir_name		 char (*);	/* (Input) directory name */
	declare entryname		 char (*);	/* (Input) entry in the directory */

	declare length		 fixed binary (21);
	declare pathname		 char (168);

	call ioa_$rsnnl ("^a^[>^]^a", pathname, length, dir_name, dir_name ^= ">", entryname);
	call output_one_line (pathname);
     end output_pathname;

/*	Output a line.

	The line is printed if this is a command, and appended to the
	active function return string, if this is an active function.
*/
output_one_line:
     procedure (line);

	declare line		 char (*);	/* (Input) the line to output */
	declare requote_string_	 entry (char (*)) returns (char (*));

	if af_sw
	then do;
		if ltrim (rtrim (line, HT || SP), HT || SP) = ""
		then return;

		if af_return_string = ""
		then af_return_string =
		     requote_string_ (ltrim (rtrim (line, HT || SP), HT || SP));
		else af_return_string = af_return_string || SP ||
		     requote_string_ (ltrim (rtrim (line, HT || SP), HT || SP));
	     end;
	else call ioa_ ("^a", line);
     end output_one_line;

/*	Print the usage error message.

	Different messages are printed for commands and active functions.
*/
usage_err_:
     procedure;

	if af_sw
	then call active_fnc_err_$af_suppress_name (0, command, "Usage: [^a ^a]", command, af_usage);
	else call com_err_$suppress_name (0, command, "Usage: ^a ^a", command, usage);
     end usage_err_;

cleanup_:
     procedure;

	if args_ptr ^= null
	then do;
		free args;
		args_ptr = null;
	     end;
	if cleanup_sl_info_ptr ^= null
	then do;
		free cleanup_sl_info_ptr -> sl_info;
		cleanup_sl_info_ptr = null;
	     end;
	if cleanup_new_sl_info_ptr ^= null
	then do;
		free cleanup_new_sl_info_ptr -> sl_info;
		cleanup_new_sl_info_ptr = null;
	     end;
	if cleanup_sl_list_ptr ^= null
	then begin;
		declare next_sl_list_ptr	 pointer;

		do while (cleanup_sl_list_ptr ^= null);
		     next_sl_list_ptr = cleanup_sl_list_ptr -> sl_list.link;
		     free cleanup_sl_list_ptr -> sl_list;
		     cleanup_sl_list_ptr = next_sl_list_ptr;
		end;
	     end;
     end cleanup_;

     end set_search_paths;
