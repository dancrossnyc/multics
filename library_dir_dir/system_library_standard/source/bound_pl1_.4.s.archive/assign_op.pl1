/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-21,RWaters), approve(89-04-21,MCR8101), audit(89-04-27,Huen),
     install(89-06-16,MR12.3-1059):
     Reset the indicators after a call to size_check_fx1/size_check_uns_fx1.
  2) change(89-07-10,RWaters), approve(89-07-10,MCR8121), audit(89-08-09,Vu),
     install(89-09-22,MR12.3-1073):
     Print warning when constants occure on LHS of assignment stmt.
                                                   END HISTORY COMMENTS */


/* format: style2,^indattr,ifthendo,ifthen,^indnoniterdo,^elsestmt,dclind9 */
/* This procedure is called to process the assign operator
%page;
   Initial Version: 15 September 1971 by BLW
          Modified: 12 February 1973 by BLW
          Modified: 16 February 1973 by RAB
          Modified: 18 June 1973 by RAB for EIS
          Modified: 26 November 1974 by RAB for opt of const bit assmt
          Modified: 26 May 1975 by RAB for assign_round
          Modified: 21 August 1975 by RAB to fix 1399
          Modified: 16 October 1976 by RAB to improve vs = vs || char1;
          Modified: 10 November 1976 by RAB to fix 1549
          Modified: 25 February 1977 by RAB to fix 1585
          Modified: 9 March 1977 by RAB to fix 1593
          Modified: 19 March 1977 by RAB for aq_man$left_shift
                    and aq_man$right_shift
          Modified: 6 May 1977 by RAB to fix 1617 and use load for A(5)'s all_zeros case
          Modified: 15 May 1977 by RAB to fix 1621
          Modified: 1 September 1977 by RAB to fix 1664 by calling state_man$flush_sym
          Modified: 14 September 1977 by RAB to fix 1653
          Modified: 10 November 1977 by RAB to make minor string assignment improvement
          Modified: 2 December 1977 by RAB to fix 1692
          Modified: 16 July 1978 by PCK for unsigned binary
          Modified: 11 August 1978 by RAB to fix 1729 & 1754
          Modified: 30 November 1978 by RAB to fix 1799 (vs = substr(a,length(vs),b))
          Modified: 18 Dec 1978 by RAB to fix 1805 (vs = vs ||vsfun(); for stack frames > 16k)
          Modified: 79/04/23 by PCK to implement fixed decimal
          Modified: 28 May 1979 by RAB to fix 1827 (vs = substr(a,length(vs)+1))
          Modified: 30 March 1980 by RAB for reference.(padded aligned)_for_store_ref.
                    See prepare_operand for details.
          Modified 830118 BIM to copy_temp ptr temps on the LHS. See
                   pointer_builtins for more explanation. 
	Modified 890304 by RWaters to reset the indicators after a call
		to size_check_fx1, and size_check_uns_fx1.
          Modified 890715 by RWaters reformatted; print a warning message when
                    an options(constant) occures on the LHS of an assignment.
*/
%page;
assign_op:
     proc (pt);

/* parameters */
	dcl      pt ptr parameter;			/* points at operator node */

/* automatic */
	dcl      (p, p1, p2, s1, s2, b2, q, q1, q2) ptr;
	dcl      exp_pt ptr;
	dcl      arg (3) ptr;
	dcl      top ptr;
	dcl      (a, b, i, type1, type2, k, size1, size2) fixed bin;
	dcl      (length1, length2, aq_used, scale1, scale2) fixed bin;
	dcl      (prec1, prec2, ds, d, dt, cfo, orig_count, units_per_wrd) fixed bin;
	dcl      (atomic, all_blanks, all_ones, all_zeros, all_same) bit (1) aligned;
	dcl      (loaded, last_macro, hard1, hard2, here_before) bit (1) aligned;
	dcl      (load_it, right_constant, check_size, no_store) bit (1) aligned;
	dcl      (pack_char_pic, always_round, refs_are_same) bit (1) aligned;
	dcl      base bit (3) aligned;
	dcl      tag bit (4) aligned;
	dcl      op_code bit (9) aligned;
	dcl      full_word bit (36) aligned;
	dcl      c_length fixed bin (24);
	dcl      word bit (36) aligned based;
	dcl      double_string bit (72) aligned;
	dcl      (m1, m2, macro, bump_mac, size_ck_macro) fixed bin (15);

/* external */
	dcl      cg_stat$cur_level fixed bin external;
	dcl      cg_stat$cur_statement ptr external;
	dcl      cg_stat$cur_tree ptr ext;
	dcl      cg_stat$null_value bit (72) aligned external;
	dcl      cg_stat$packed_null_value fixed bin external;
	dcl      cg_stat$save_exp_called bit (1) external;
	dcl      cg_stat$temp_ref ptr external;
	dcl      cg_stat$text_base ptr external;
	dcl      cg_stat$text_pos fixed bin external;

/* entries */
	dcl      adjust_ref_count entry (ptr, fixed bin);

	dcl      aq_man$check_strings entry (fixed bin);
	dcl      aq_man$left_shift entry (fixed bin (8), bit (1) aligned);
	dcl      aq_man$lock entry (ptr, fixed bin);
	dcl      aq_man$right_shift entry (fixed bin (8), bit (1) aligned);
	dcl      aq_man$trim_aq entry (fixed bin);

	dcl      base_to_core entry (fixed bin, ptr);
	dcl      base_man$load_any_var entry (fixed bin, ptr) returns (bit (3) aligned);
	dcl      base_man$load_packed entry (ptr, fixed bin);
	dcl      base_man$load_var entry (fixed bin, ptr, fixed bin);
	dcl      base_man$store_ptr_to entry (ptr, ptr);
	dcl      base_man$update_base entry (fixed bin, ptr, fixed bin);

	dcl      compile_exp entry (ptr);
	dcl      compile_exp$save entry (ptr) returns (ptr);
	dcl      compile_exp$save_exp entry (ptr) returns (ptr);
	dcl      copy_temp entry (ptr) returns (ptr);
	dcl      compare_expression entry (ptr, ptr) reducible returns (bit (1) aligned);
	dcl      convert_chars entry (ptr, ptr, bit (1) aligned, bit (1) aligned);
	dcl      convert_arithmetic entry (ptr, ptr, bit (1) aligned, bit (1) aligned);
	dcl      c_a entry (fixed bin, fixed bin) returns (ptr);
	dcl      decimal_op$get_float_temp entry (fixed bin (24), bit (1) aligned) returns (ptr);
	dcl      error entry (fixed bin, ptr, ptr);
	dcl      expmac entry (fixed bin (15), ptr);
	dcl      expmac$one entry (fixed bin (15), ptr, fixed bin);
	dcl      expmac$zero entry (fixed bin (15));
	dcl      expmac$many entry (fixed bin (15), ptr, fixed bin);
	dcl      expmac$many_eis entry (fixed bin (15), ptr, fixed bin);
	dcl      expmac$one_eis entry (fixed bin (15), ptr);
	dcl      expmac$two_eis entry (fixed bin (15), ptr, ptr);

	dcl      fixed_to_float entry (ptr);
	dcl      float_to_fixed entry (ptr);
	dcl      generate_constant entry (bit (*) aligned, fixed bin) returns (ptr);
	dcl      generate_constant$real_fix_bin_1 entry (fixed bin) returns (ptr);
	dcl      generate_constant$bit_string entry (bit (*) aligned, fixed bin) returns (ptr);
	dcl      generate_constant$char_string entry (char (*) aligned, fixed bin) returns (ptr);
	dcl      get_imaginary entry (ptr) returns (ptr);
	dcl      get_single_ref entry (ptr) returns (ptr);
	dcl      load entry (ptr, fixed bin);
	dcl      load$for_store entry (ptr, fixed bin);
	dcl      load$long_string entry (ptr);
	dcl      load$short_string entry (ptr, fixed bin);
	dcl      load_prog entry (ptr, fixed bin) variable;
	dcl      load_size entry (ptr);
	dcl      load_size$xr_or_aq entry (ptr, bit (4) aligned);
	dcl      long_op$one_eis entry (ptr, fixed bin, fixed bin (15));
	dcl      long_op$extend_stack entry (ptr, fixed bin (15));
	dcl      make_n_addressable entry (ptr, fixed bin);
	dcl      m_a entry (ptr, bit (2) aligned);
	dcl      make_both_addressable entry (ptr, ptr, bit (1) aligned);
	dcl      need_temp entry (ptr, bit (2) aligned);
	dcl      move_data$move_block entry (ptr, ptr, fixed bin);
	dcl      picture_op entry (ptr);
	dcl      prepare_operand entry (ptr, fixed bin, bit (1) aligned) returns (ptr);
	dcl      stack_temp$assign_temp entry (ptr);
	dcl      state_man$erase_reg entry (bit (19) aligned);
	dcl      state_man$flush_ref entry (ptr);
	dcl      state_man$flush_sym entry (ptr);
	dcl      store entry (ptr);
	dcl      store$all_ones entry (ptr);
	dcl      store$force entry (ptr);
	dcl      store$save_string_temp entry (ptr);
	dcl      xr_man$load_const entry (fixed bin, fixed bin);

/* builtins */
	dcl      (abs, addr, addrel, bit, divide, fixed, max, min, mod, null, string, substr, verify) builtin;

/* other stuff */
	dcl      assign_info$assign_info (14, 14) fixed bin ext,
	         1 assign_info aligned based,		/* image of ext structure */
		 2 act_a unal bit (6),
		 2 act_b unal bit (6),
		 2 macro_1 unal bit (12),
		 2 macro_2 unal bit (12);

	dcl      (
	         assign_label_to_int init (379),
	         rflb1_to_cflb1 init (390),
	         set_label_const (2) init (315, 285),
	         ldfl1 init (9),
	         alloc_char_temp init (89),
	         chars_move init (420),
	         chars_move_vt init (444),
	         cat_move_chars init (218),
	         sbfx1 init (22),
	         aos_mac init (309),
	         incr_mac init (310),
	         lda init (1),
	         ansa init (43),
	         longbs_to_fx2 init (132),
	         cpfx1 init (136),
	         lrl init (62),
	         lrs init (492),
	         lls init (63),
	         move_chars init (98),
	         oraq init (48),
	         stfx1 init (15),
	         sta init (4),
	         fx1_to_bs init (293),
	         blank_cs init (472),
	         zero_bs init (468),
	         one_bs init (469),
	         zero_cs init (419),
	         one_cs init (484),
	         zero_cs_q init (479),
	         b2c_mac init (108),
	         size_check_fx1 init (553),
	         chars_move_ck init (555),
	         signal_stringsize init (563),
	         size_ck_varying init (566),
	         size_ck_suffix init (567),
	         size_ck_decimal init (582),
	         cmp_suffix_1 init (220),
	         size_ck_suffix_1 init (698),
	         left_shift (2) init (515, 63),
	         truncate (2) init (520, 521),
	         min_fx1 init (247),
	         zero_mac init (308),
	         zero_mac_p_1 init (307),
	         move_decimal init (438),
	         multiply_decimal init (450),
	         make_lv init (173),
	         store_lv init (174),
	         size_check_uns_fx1 init (731),
	         uns_fx1_to_bs init (733)
	         ) fixed bin (15) int static options (constant);

	dcl      ptr_convert (23:24, 23:24) fixed bin (15) int static init (0, 407, 408, 0);

	dcl      based_bs bit (size2) aligned based,
	         based_cs char (length2) aligned based;

	dcl      1 instruction based aligned,		/* layout of first word of EIS instruction */
		 2 fill char (1) unal,		/* fill character -- can be set by assign_op */
		 2 enablefault bit (1) unal,
		 2 pad1 bit (1) unal,
		 2 mf2 bit (7) unal,
		 2 opcode bit (10) unal,
		 2 inhibit bit (1) unal,
		 2 mf1 bit (7) unal;

	dcl      1 exponent aligned,			/* layout of floating decimal exponent character */
		 2 pad bit (1) unal,
		 2 value fixed bin (7) unal;

	dcl      exponent_char char (1) based (addr (exponent)) aligned;

/* CONSTANTS */

	dcl      TRUE bit (1) aligned int static options (constant) init ("1"b);
	dcl      FALSE bit (1) aligned int static options (constant) init ("0"b);

%page;
%include cgsystem;
%page;
%include statement;
%page;
%include operator;
%page;
%include reference;
%page;
%include symbol;
%page;
%include block;
%page;
%include nodes;
%page;
%include bases;
%page;
%include data_types;
%page;
%include machine_state;
%page;
%include op_codes;
%page;
%include boundary;
%page;
/* program */

	load_prog = load$for_store;

	all_blanks, all_ones, all_zeros, all_same, loaded, here_before, full_word, no_store, pack_char_pic, last_macro =
	     FALSE;

	p = pt;
	op_code = p -> operator.op_code;
	check_size = (op_code = assign_size_ck);
	always_round = (op_code = assign_round);

	p1 = prepare_operand ((p -> operand (1)), 1, atomic);
	orig_count = p1 -> reference.ref_count;

	exp_pt, p2 = p -> operand (2);
	if p2 -> node.type = operator_node | p2 -> node.type = label_node | ^p2 -> reference.temp_ref then
	     p2 = prepare_operand (p2, 1, atomic);
	else
	     atomic = TRUE;

gt:
	s1 = p1 -> reference.symbol;
	s2 = p2 -> reference.symbol;

	scale1 = s1 -> symbol.scale;
	prec1 = s1 -> symbol.c_dcl_size;

	right_constant = FALSE;

	type2 = p2 -> reference.data_type;

	if s2 -> node.type = label_node then do;
	     type1 = p1 -> reference.data_type;
	     goto lab_or_ent;
	end;

	scale2 = s2 -> symbol.scale;
	prec2 = s2 -> symbol.c_dcl_size;

	if s1 -> symbol.storage_block & ^here_before then do;
	     type1, p1 -> reference.data_type = type2;
	     p1 -> reference.c_length = p2 -> reference.c_length;
	     if type1 = char_string | type2 = bit_string then
		p1 -> reference.long_ref = p1 -> reference.c_length * convert_size (type1) > bits_per_two_words;
	end;
	else
	     type1 = p1 -> reference.data_type;

	here_before = TRUE;

	dt = type1 - char_string;

	if type2 ^= bit_string then
	     if type2 ^= char_string then
		goto chk_temp;

	length2 = p2 -> reference.c_length;
	size2 = length2 * convert_size (type2);

	if op_code = pack then
	     if type2 = char_string then
		if substr (cg_stat$cur_statement -> statement.prefix, 5, 1) then
		     pack_char_pic = TRUE;

	if atomic then do;
	     if ^s2 -> symbol.constant then
		goto chk_temp;
	     if s2 -> symbol.varying then
		goto chk_temp;
	     if s2 -> symbol.dimensioned then
		goto chk_temp;
	     if p2 -> reference.offset ^= null then
		goto chk_temp;
	     if p2 -> reference.length ^= null then
		goto chk_temp;
	     if p2 -> reference.c_offset ^= 0 then
		goto chk_temp;
	     if p2 -> reference.temp_ref then
		goto chk_temp;

	     right_constant = TRUE;

	     q = s2 -> symbol.initial;

	     if type2 = char_string then do;
		if length2 > 0 then do;
		     all_same = verify (q -> based_cs, substr (q -> based_cs, 1, 1)) = 0;
		     if all_same then
			all_blanks = substr (q -> based_cs, 1, 1) = " ";
		end;
		else
		     all_same, all_blanks = TRUE;
	     end;
	     else do;
		all_ones = (^q -> based_bs = FALSE);
		all_zeros = (q -> based_bs = FALSE);
	     end;
	end;

chk_temp:
	if ^p1 -> reference.temp_ref then
	     goto get_info;
	if p1 -> reference.defined_ref then
	     goto get_info;
	if p1 -> reference.aggregate then
	     goto get_info;

/* have temporary on left of assignment */

	if p1 -> reference.length = null then do;

	     load_prog = load;

	     if p1 -> reference.allocate then do;
		if ^p1 -> reference.allocated then
		     call stack_temp$assign_temp (p1);
		if p1 -> reference.ref_count = 1 then
		     p1 -> reference.ref_count = 2;
		goto get_info;
	     end;

	     if ^p1 -> reference.long_ref then do;
		no_store = TRUE;
		goto get_info;
	     end;

	end;

/* have long (string) temp = something */

	if type1 ^= type2 then do;
	     p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
	     call long_op$extend_stack (p1, alloc_char_temp + dt);
	     call store$save_string_temp (p1);
	     goto get_info;
	end;

	if ^atomic then
	     p2 = compile_exp$save (exp_pt);

	call long_op$extend_stack (p1, alloc_char_temp + dt);
	if cg_stat$save_exp_called then
	     call store$save_string_temp (p1);
	call expmac$two_eis (move_chars + dt, p1, p2);

	goto done;

get_info:
	if atomic then
	     goto gi;

	if type2 <= real_flt_bin_2 then
	     k = 1;
	else do;
	     if type2 ^= type1 then
		goto gi;
	     if type2 < char_string then
		goto gi;
	     if type2 > bit_string then
		goto gi;

	     if pack_char_pic then
		goto gi;
	     if p1 -> reference.varying_ref then
		goto gi;
	     if p1 -> reference.length ^= null then
		goto gi;

	     k = 0;
	end;

/* if the right hand side is another assign operator which only changes the
 * precision of its operand(2) (case k = 1) or another assignment to a
 * string temporary (case k = 0) we'll try to eliminate the extra assign
 */

	if exp_pt -> node.type ^= operator_node then
	     goto gi;
	if exp_pt -> operator.op_code ^= assign then
	     goto gi;
	if exp_pt -> operator.operand (1) -> reference.ref_count > 1 then
	     goto gi;

	if k = 0 then do;
	     if p2 -> reference.varying_ref then
		goto gi;
	     if p2 -> reference.length ^= null then
		goto gi;

/* we can eliminate assignment if length of right side temporary
 * is equal to length of left side temp
 */
	     if p1 -> reference.c_length = p2 -> reference.c_length then
		goto elim;
	end;

/* we have to restore the original value of the data type field
 * of operand(2) if it is a reference because if we dont, prepare_operand
 * will get confused and not evaluate the offset expression (if any)
 */

	q2 = exp_pt -> operand (2);
	if q2 -> node.type = operator_node then
	     q2 = q2 -> operand (1);

	m1 = q2 -> reference.data_type;

	q2 = prepare_operand (q2, 0, atomic);

	m2 = q2 -> reference.data_type;
	q2 -> reference.data_type = m1;

	if k = 0 then do;
	     if p1 -> reference.c_length < p2 -> reference.c_length then
		if type2 ^= m2 then
		     goto repair;
		else
		     goto elim;

/* must have p1 -> c_length > p2 -> c_length */

/* q2 -> reference.c_length won't be in the same units as for p2,
 * but it still gives a reasonable indication of safety unless q2
 * is decimal.  This fixes 1653
 */
	     if type2 ^= m2 then
		if m2 >= real_fix_dec & m2 <= complex_flt_dec then
		     goto repair;

	     if q2 -> reference.varying_ref then
		goto repair;
	     if q2 -> reference.length ^= null then
		goto repair;

	     if p2 -> reference.c_length < q2 -> reference.c_length then
		goto repair;

/* eliminate the assignment */

elim:
	     p2, exp_pt = exp_pt -> operand (2);
	     if k = 0 then do;
		p2 = prepare_operand (p2, 1, atomic);
		goto gt;
	     end;
	     p2 = prepare_operand (p2, 1, atomic);
	     goto gi;
	end;

/* k = 1 at this point */

	if type2 = m2 then
	     goto elim;

repair:
	atomic = FALSE;

gi:
	if type2 > bit_string then
	     goto LABEL_ENTRY_OR_PTR;

	q = addr (assign_info$assign_info (type1, type2));
	a = fixed (q -> assign_info.act_a, 6);
	b = fixed (q -> assign_info.act_b, 6);
	m1 = fixed (q -> assign_info.macro_1, 12);
	m2 = fixed (q -> assign_info.macro_2, 12);

	if pack_char_pic then do;
	     a = 2;
	     b = 2;
	end;

/* MR12.3: print a sev 2 warning about assignments to an
 * options(constant) variable
 */
	if p1 -> reference.symbol -> symbol.alloc_in_text then
	     call error (134, cg_stat$cur_statement, null);

	goto A (a);
%page;
/* unimplemented conversion */

A (0):
	call error (331, cg_stat$cur_statement, null);
	goto done;
%page;
/* ordinary arithmetic assignment */

A (1):
	if p1 -> reference.aligned_for_store_ref then do;
A1a:
	     if atomic then
		call load_prog (p2, 0);
	     else
		call compile_exp (exp_pt);
	     goto B (b);
	end;

/* have assignment to packed arithmetic value */

	if type1 ^= type2 then
	     goto A1a;

	if ^atomic then
	     if exp_pt -> node.type = operator_node then
		goto A1a;

	if p2 -> reference.ref_count > 1 then
	     goto A1a;

	if check_size then
	     if type1 = real_fix_bin_1 then
		if prec1 < prec2 then
		     goto A1a;

/* have atom on right */

	size1 = p1 -> reference.c_length;

	if type1 = real_fix_bin_1 then do;

	     if s2 -> symbol.constant then do;

		if s2 -> symbol.packed & ^p2 -> reference.aligned_ref then
		     goto fake_bit;

		if p2 -> reference.offset ^= null then
		     goto A1b;
		if p2 -> reference.c_offset ^= 0 then
		     goto A1b;

		p2 = generate_constant$bit_string (
		     substr (s2 -> symbol.initial -> word, bits_per_word - size1 + 1, size1), size1);

/* now treat assignment as if we were assigning bit strings */

fake_bit:
		check_size = FALSE;

		if prec1 = prec2 then
		     if s1 -> symbol.unsigned = s2 -> symbol.unsigned then
			if p1 -> reference.hard_to_load | p2 -> reference.hard_to_load then do;
			     dt = 1;
			     goto short_eis;
			end;

		call load$for_store (p2, 0);

		aq_used = a_reg.offset + a_reg.size;

		k = size1 - a_reg.size;
		if k < 0 then do;			/* right side is larger than we need */
		     call aq_man$check_strings (aq_used + k);
		     a_reg.offset = a_reg.offset - k;
		end;
		else if k > 0 then do;		/* right side has less precision than we need */
		     if a_reg.offset > 0 then
			call aq_man$left_shift (a_reg.offset, "0"b);

		     if s2 -> symbol.unsigned then
			macro = lrl;
		     else
			macro = lrs;

		     call expmac (macro, c_a (k, 1));

		end;

		a_reg.size = size1;
		p1 -> reference.data_type = bit_string;
		goto l1;
	     end;

A1b:
	     if p2 -> reference.aligned_ref then
		goto A1a;
	     if p2 -> reference.value_in.q then
		goto A1a;

	     if scale1 ^= scale2 then
		goto A1a;

/* have packed fixed single on right, too */

	     p2 -> reference.data_type = bit_string;
	     goto fake_bit;
	end;

	if p2 -> reference.value_in.q then
	     goto A1a;

	if type1 = real_flt_bin_1 | type1 = real_flt_bin_2 then do;
	     type1, p1 -> reference.data_type, p2 -> reference.data_type = bit_string;

	     call load_prog (p2, type2 - real_flt_bin_1);

	     size2 = p2 -> reference.c_length;
	     goto string_store_check;
	end;

	goto A1a;
%page;
/* char string and decimal conversion */

A (2):
	if ^atomic then
	     p2 = compile_exp$save_exp (exp_pt);
	goto B (b);
%page;
/* left side is complex */

A (3):
	if atomic then do;
	     call expmac (m2, p2);
	     goto l1;
	end;

	call compile_exp (exp_pt);
	m2 = 0;
	goto B (b);
%page;
/* right side is complex float single binary */

A (4):
	if ^atomic then do;
	     p2 = compile_exp$save_exp (exp_pt);
	     if exp_pt -> node.type ^= operator_node then
		goto B (4);
	end;

	if type1 = complex_flt_bin_1 then do;
	     call load_prog (p2, 0);
	     goto l1;
	end;

	call expmac ((ldfl1), p2);
	loaded = TRUE;
	if scale1 ^= 0 then
	     b = 7;
	goto B (b);
%page;
/* have string = string */

A (5):
	length1 = p1 -> reference.c_length;
	size1 = length1 * convert_size (type1);
	d = fixed (size1 > bits_per_word, 1);

	all_same = all_same & ((length1 = length2 & p1 -> reference.length = null) | all_blanks);
	all_ones = all_ones & (length1 = length2 & p1 -> reference.length = null);

	hard1 = p1 -> reference.hard_to_load;
	hard2 = p2 -> reference.hard_to_load;
	if ^hard2 then
	     if p2 -> reference.long_ref then
		if p2 -> reference.units < word_ then
		     hard2 = size1 > bits_per_word;

	if ^check_size then
	     goto A5a;
	if p1 -> reference.length ^= null then
	     goto A5a;
	if p2 -> reference.length ^= null then
	     goto A5a;

	call check_stringsize;

/* the following code tries to improve string assignments by using
 * an MLR or ldaq-staq seq
 */

A5a:
	if p1 -> reference.varying_ref then
	     goto A5c;
	if p1 -> reference.length ^= null then
	     goto A5c;
	if ^p1 -> reference.aligned_for_store_ref then
	     goto A5c;

	if no_store then
	     goto A5c;

	if ^p2 -> reference.aligned_ref then
	     goto A5c;
	if p2 -> reference.varying_ref then
	     goto A5c;
	if p2 -> reference.length ^= null then
	     goto A5c;
	if ^p2 -> reference.long_ref then
	     goto A5c;

	if all_same | all_ones | all_zeros then
	     if size1 > break_even_bits then
		goto A5c;

	if length1 > length2 then
	     goto A5c;

	if ^(mod (size1, bits_per_word) = 0 | p1 -> reference.long_ref) then
	     goto A5c;

	if mod (size1, bits_per_word) = 0 | p1 -> reference.padded_for_store_ref then do;

	     if ^atomic then
		call compile_exp (exp_pt);

	     call move_data$move_block (p1, p2, divide (size1 + bits_per_word - 1, bits_per_word, 17, 0));
	     goto done;
	end;

A5c:
	if atomic then do;

A5ca:
	     if ^p1 -> reference.varying_ref then
		goto chk;

/* have varying string on left */

	     if p2 -> reference.length ^= null then
		goto l9;
	     if p2 -> reference.varying_ref then
		goto l9;

	     if length2 = 0 then do;
		p1 -> reference.c_offset = p1 -> reference.c_offset - 1;
		call expmac ((zero_mac), p1);
		p1 -> reference.c_offset = p1 -> reference.c_offset + 1;
		call state_man$flush_ref (p1);	/* p1 might have been in indicators */
		goto done;
	     end;

	     if p1 -> reference.length ^= null then
		goto l9;

	     load_prog = load;

	     if ^hard2 then do;
		if ^p2 -> reference.long_ref then do;
		     call load_prog (p2, d);
		     goto string_store_work;
		end;

		if ^p1 -> reference.long_ref then do;
		     call load$short_string (p2, d);
		     goto string_store_work;
		end;
	     end;

	     goto l9;

chk:
	     if p1 -> reference.long_ref then do;

l9:
lg:
		if ^p1 -> reference.varying_ref then do;
		     call state_man$flush_sym ((p1 -> reference.symbol));
		     call eis_move;
		     goto done;
		end;

/* have varying string on left, must set cur length */

		if p1 -> reference.length ^= p2 -> reference.length then
		     arg (1) = get_length_in_storage (p1);
		else
		     arg (1) = get_length (p1);

		if p2 -> reference.varying_ref then do;

		     call load_size (p2);

		     if arg (1) = null then
			if s2 -> symbol.c_dcl_size <= length1 & s2 -> symbol.dcl_size = null then
			     goto l11;
			else
			     arg (1) = generate_constant$real_fix_bin_1 (length1);

		     goto l10;
		end;

		arg (2) = get_length (p2);

		if arg (1) = null then
		     if arg (2) = null then do;
			call load (generate_constant$real_fix_bin_1 (min (length1, length2)), 0);
			goto l11;
		     end;
		     else
			arg (1) = generate_constant$real_fix_bin_1 (length1);
		else if arg (2) = null then
		     arg (2) = generate_constant$real_fix_bin_1 (length2);

		call load (arg (2), 0);

		if arg (1) = arg (2) then do;
		     if ^arg (1) -> reference.shared then
			arg (1) -> reference.ref_count = arg (1) -> reference.ref_count - 1;
		     goto l11;
		end;

l10:
		if p2 -> reference.ref_count = 1 then
		     call need_temp (p2, "01"b);
		if check_size then
		     macro = size_ck_varying;
		else
		     macro = min_fx1;
		if arg (1) -> reference.data_type = real_fix_bin_2 then
		     arg (1) = get_single_ref (arg (1));
		call expmac (macro, arg (1));

l11:
		refs_are_same = compare_refs (p1, p2);

		if ^refs_are_same & p2 -> reference.offset ^= null then do;

/* the offset of p2 may be length(p1) (either as a
 * reference node or as an operator node), so we
 * should be careful to see that it is loaded before
 * the length(p1) is changed.  We use aq_man$lock
 * and make_n_addressable to ensure that registers
 * stay locked.  Fixes 1799 and 1827.
 */

		     call aq_man$lock (null, 2);
		     arg (1) = p2;
		     call make_n_addressable (addr (arg), 1);
		end;

		call expmac_length_of_varying (stfx1, p1);

		if ^refs_are_same then
		     call expmac$two_eis (chars_move_vt + dt, p1, p2);
		else do;
		     if ^p2 -> reference.shared then
			call adjust_ref_count (p2, -1);
		     if ^p1 -> reference.shared then
			call adjust_ref_count (p1, -1);
		end;

		goto done;
	     end;

/* string on left is short */

	     if p2 -> reference.varying_ref then
		goto short_eis;

	     if hard1 | hard2 then
		goto short_eis;

	     if p2 -> reference.long_ref then
		if p2 -> reference.length = null then
		     call load$short_string (p2, d);
		else do;
short_eis:
		     if no_store then
			p1 = copy_temp (p1);

		     if p1 -> reference.aligned_for_store_ref then
			if mod (size1, bits_per_word) ^= 0 then do;
			     if size1 < bits_per_word then
				macro = zero_mac;
			     else
				macro = zero_mac_p_1;
			     if ^p1 -> reference.shared then
				p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
			     call expmac (macro, p1);
			end;

		     call state_man$flush_sym ((p1 -> reference.symbol));

		     call eis_move;

		     if p1 -> reference.temp_ref then
			if cg_stat$save_exp_called then
			     call adjust_ref_count (p1, -1);
			else if cg_stat$cur_tree ^= p then do;
			     if ^no_store then
				p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
			     call load (p1, d);
			end;

		     goto done;
		end;
	     else if all_zeros then do;

		if p1 -> reference.temp_ref then do;
		     call load_prog (p2, d);
		     goto string_store_work;
		end;

		if p1 -> reference.aligned_for_store_ref then
		     if size1 <= bits_per_word then
			goto zm;
		     else do;
			call load_prog (p2, d);
			goto string_store_work;
		     end;

/* we'll zero the string by generating an and to storage
 * macro using a mask with 0's in the field occupied
 * by the string
 */

		call state_man$flush_ref (p1);
		double_string = (72)"1"b;
		cfo = mod (p1 -> reference.c_offset * convert_offset (p1 -> reference.units), bits_per_word);
		substr (double_string, cfo + 1, size1) = "0"b;

		d = fixed (cfo + size1 > bits_per_word, 1);
		p2 = generate_constant (double_string, d + 1);
		call load (p2, d);
		call expmac$one ((ansa), p1, d);
		goto done;
	     end;
	     else if right_constant then do;
		if p1 -> reference.aligned_for_store_ref then do;
		     call load_prog (p2, d);
		     goto string_store_work;
		end;

/* we have a string constant being assigned to a variable
 * with a non-zero offset, we'll generate another constant
 * which is already shifted
 */

		cfo = mod (p1 -> reference.c_offset * convert_offset (p1 -> reference.units), bits_per_word);
		if cfo + size1 > bits_per_two_words then do;
		     call load_prog (p2, d);
		     goto string_store_work;
		end;

		double_string = (72)"0"b;
		substr (double_string, cfo + 1, size1) = s2 -> symbol.initial -> based_bs;
		d = fixed (cfo + size1 > bits_per_word, 1);
		p2 = generate_constant (double_string, d + 1);

		call expmac$one ((lda), p2, d);
		a_reg.offset = cfo;
		a_reg.size = size2;
		a_reg.length = bits_per_word * (d + 1);
		goto string_store_work;
	     end;
	     else do;
		call load_prog (p2, d);
		goto string_store_work;
	     end;

	     goto string_store_work;
	end;

	if exp_pt -> node.type ^= operator_node then
	     goto A5ca;

/* string on right is not atomic */

	if ^p1 -> reference.varying_ref then
	     goto l4;

/* following code looks for the case
 *	 vs = vs || something
 * where vs is a varying string.  note that we can't use
 * compare_expression directly because ref node for
 * vs on LHS has a length field and ref node on RHS has
 * 0 length field
 */

	if exp_pt -> operator.op_code ^= cat_string then
	     goto l4;

	q = exp_pt -> operand (2);
	if q -> reference.c_length ^= 0 then
	     goto l4;
	if q -> reference.length ^= null then
	     goto l4;

	if ^compare_refs (p1, q) then
	     goto l4;

/* We have the case
 *	     vs = vs || something;
 * so we can move something to the end of vs
 */

	q = prepare_operand (q, -1, atomic);

	q1 = prepare_operand ((exp_pt -> operand (3)), 1, atomic);
	if ^atomic then
	     if q1 -> reference.long_ref then
		call compile_exp ((exp_pt -> operand (3)));
	     else
		q1 = compile_exp$save_exp ((exp_pt -> operand (3)));

/* We should bump down some reference counts for unneeded temps
 * associated with result of cat_string operator
 */

	call adjust_suff_temp ((exp_pt -> operand (1)));

/* get a ptr to the operand to be used in the subsequent compare.
 * We make the call now because this operand may need to be unpacked
 * which would emit code.  This fixes 1754
 */

	if q1 -> reference.c_length ^= 1 then
	     q2 = get_suffix_length (q1);
	else
	     q2 = get_suffix_length (p1);

/* make the varying string addressable without a tag */

	call m_a (p1, "10"b);

	if p1 -> address.tag then do;
	     if ^p1 -> reference.shared then
		p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
	     base = base_man$load_any_var (2, p1);
	     if p1 -> reference.ref_count = 1 then
		call need_temp (p1, "10"b);
	end;

/* erase and lock the q register and force both operands to be addressable,
 * erase and locking the involved registers
 */

	call state_man$erase_reg ("01"b);
	call aq_man$lock (null, 2);
	arg (1) = p1;
	arg (2) = q1;
	p1 -> reference.perm_address = TRUE;
	call make_n_addressable (addr (arg), 2);
	p1 -> reference.perm_address = FALSE;

	if q1 -> reference.c_length ^= 1 then do;	/* get the room left in the varying string for the move */
	     call load_size (p1);
	     call expmac_length_of_varying ((sbfx1), p1);

/* compare the 2 lengths to decide how much we will move in ( result in q reg ) */

	     if check_size then
		macro = size_ck_suffix;
	     else
		macro = min_fx1;
	     if q1 -> reference.varying_ref then
		call expmac_length_of_varying (macro, q1);
	     else
		call expmac (macro, q2);

/* load present size of varying string into a register other than q */

	     call load_size$xr_or_aq (q, tag);

	     bump_mac = incr_mac;
	     macro = chars_move_vt + dt;
	end;
	else do;					/* compare present size with max length of target */

	     call load_size (q);

	     if check_size then
		macro = size_ck_suffix_1;
	     else
		macro = cmp_suffix_1;

	     call expmac (macro, q2);

	     tag = "0110"b;				/* ql */

	     bump_mac = aos_mac;
	     macro = cat_move_chars + dt;
	end;

	if ^q -> reference.shared then
	     call adjust_ref_count (q, -1);

/* update length field of varying string */

	call expmac_length_of_varying (bump_mac, p1);

/* Use old size of varying string as the offset in the string for the target of the move */

	p1 -> address.tag = "00"b || tag;
	p1 -> reference.perm_address = TRUE;
	q1 -> reference.perm_address = TRUE;
	call expmac$two_eis (macro, p1, q1);

	if dt > 0 then
	     machine_state.indicators = ind_invalid;
	goto done;
%page;
/* Have expression, will compile */

l4:
	if ^p2 -> reference.long_ref & ^(p1 -> reference.varying_ref & p1 -> reference.length = null)
	     & (p1 -> reference.long_ref | hard1) then
	     p2 = compile_exp$save (exp_pt);
	else
	     call compile_exp (exp_pt);

	if p1 -> reference.varying_ref then do;
	     if p1 -> reference.length ^= null then
		goto lg;

	     if p2 -> reference.length = null then do;
		if ^p2 -> reference.long_ref then
		     goto string_store_work;
	     end;
	     else
		goto lg;
	end;

	if p1 -> reference.long_ref then
	     goto lg;

/* string on left is short */

	if hard1 then
	     goto short_eis;

	if p2 -> reference.long_ref then do;

	     if check_size then
		goto short_eis;

	     if p2 -> reference.length ^= null | size2 < bits_per_two_words then
		goto short_eis;

	     p2 -> reference.value_in.storage = TRUE;

	     call load$short_string (p2, d);
	     size2 = bits_per_word * (d + 1);
	end;

/* we have size2 <= a_reg.size */

string_store_work:
	if p1 -> reference.varying_ref then do;

	     if ^p1 -> reference.shared then
		p1 -> reference.ref_count = p1 -> reference.ref_count + 1;

	     call expmac$one ((sta), p1, fixed (min (size1, size2) > bits_per_word, 1));
	     p2 = generate_constant$real_fix_bin_1 (min (length1, length2));

	     if p1 -> address.tag = "000110"b then do;	/* ql */
		call expmac ((lda), p2);
		m2 = sta;
	     end;
	     else do;
		call load (p2, 0);
		m2 = stfx1;
	     end;

	     last_macro = TRUE;
	     call expmac_length_of_varying (m2, p1);

	     goto done;
	end;

string_store_check:
	if size1 = a_reg.size then
	     goto st;

	if size1 < a_reg.size then do;
	     if no_store then
		call aq_man$trim_aq (size1);
	     goto st;
	end;

/* have size2 <= a_reg.size < size1 */

	aq_used = a_reg.size + a_reg.offset;

	if type1 = bit_string then
	     if a_reg.length = bits_per_two_words | a_reg.length - a_reg.offset >= size1 then
		goto st;
	     else
		goto pad;

/* we must pad the char string, check to see if new length
 * will fit with current offset
 */

	if size1 > bits_per_two_words - a_reg.offset then do;

/* we can't extend far enough without shifting string
 * back to left end of aq
 */
	     call aq_man$left_shift (a_reg.offset, "1"b);
	     aq_used = a_reg.size;
	end;

	if size1 <= bits_per_word then
	     k = size1 + a_reg.offset;
	else
	     k = bits_per_two_words;

	if a_reg.length < k then do;
pad:
	     call aq_man$trim_aq (aq_used);
	     a_reg.length = 72;
	end;

	if type1 = bit_string then
	     goto st;

	call expmac ((oraq), c_a (aq_used, 6));

	if mod (k, bits_per_word) ^= 0 then do;
	     call aq_man$trim_aq (k);
	     a_reg.length = bits_per_two_words;
	end;

	a_reg.size = k - a_reg.offset;

st:
	if (size1 = size2) & all_ones then
	     call store$all_ones (p1);
	else
	     call store (p1);

	if a_reg.size + a_reg.offset > bits_per_two_words then
	     a_reg.size = bits_per_two_words - a_reg.offset;

	goto done;
%page;
/* something (not char string) = bit string */

A (6):
	if p2 -> reference.long_ref | p2 -> reference.varying_ref then do;

	     if ^atomic then
		call compile_exp (exp_pt);
	     call load$long_string (p2);

	     call expmac$zero ((longbs_to_fx2));

/* now have real_fix_bin_2 in aq register */

now_fx2:
	     type2 = real_fix_bin_2;

	     q = addr (assign_info$assign_info (type1, type2));
	     m1 = fixed (q -> assign_info.macro_1, 12);
	     m2 = fixed (q -> assign_info.macro_2, 12);
	     goto B (fixed (q -> assign_info.act_b, 6));
	end;

	if all_zeros then
	     if type1 = real_fix_bin_1 & ^p1 -> reference.temp_ref & p1 -> reference.aligned_for_store_ref then do;
zm:
		call state_man$flush_ref (p1);
		call expmac ((zero_mac), p1);
		goto done;
	     end;

	if atomic then
	     call load (p2, 1);
	else
	     call compile_exp (exp_pt);

	dt = a_reg.offset;
	if a_reg.number ^= 0 then do;
	     q = a_reg.variable (1);
	     if q -> reference.temp_ref & q -> reference.ref_count > 0 then
		call state_man$erase_reg ("1"b);
	end;

	if size2 < bits_per_two_words then do;
	     k = bits_per_two_words - size2;
	     if k > dt then
		call aq_man$right_shift (k - dt, "1"b);
	end;

	if scale1 ^= 0 then
	     call state_man$erase_reg ("1"b);

	goto now_fx2;
%page;
/* bit_string = arithmetic */

A (7):
	if ^atomic then do;
	     call compile_exp (exp_pt);

	     loaded = TRUE;
	end;

	goto B (b);
%page;
/* ordinary arithmetic assignment */

B (1):
	if m1 ^= 0 then
	     call expmac$zero (m1);

l0:
	if m2 ^= 0 then
	     call expmac$zero (m2);

l1:
	if check_size & s1 -> symbol.fixed then do;
	     if type1 > real_fix_bin_1 then
		dt = 1;
	     else if type2 > real_fix_bin_1 then
		dt = 1;
	     else
		dt = 0;
	     call xr_man$load_const (-s1 -> symbol.c_dcl_size * (dt + 1), 7);

	     if s1 -> symbol.unsigned then
		size_ck_macro = size_check_uns_fx1 + dt;
	     else
		size_ck_macro = size_check_fx1 + dt;

	     call expmac$zero (size_ck_macro);

/* RW 89
 * The above load_const destroyed the indicators we needed.
 */
	     machine_state.indicators = ind_invalid;

	end;

	call store (p1);

done:
	cg_stat$temp_ref = p1;

	if p1 -> reference.temp_ref then
	     p1 -> reference.ref_count = min (p1 -> reference.ref_count, orig_count);

	if ^p1 -> reference.shared then
	     p1 -> reference.evaluated = TRUE;

	return;
%page;
/* have conversion to or from char string */

B (2):
	if p1 -> reference.temp_ref & p1 -> reference.shared & p1 -> reference.length = null then do;
	     p1, p -> operand (1) = copy_temp (p1);
	     orig_count = 1;
	end;

	load_it =
	     p1 -> reference.temp_ref & ^cg_stat$save_exp_called & cg_stat$cur_tree ^= p & ^p1 -> reference.long_ref
	     & ^s1 -> symbol.decimal;

	if op_code = pack | op_code = unpack then
	     call picture_op (p);
	else do;
	     call convert_chars (p1, p2, check_size, always_round);

	     if p2 ^= null then do;			/* conversion was done into temp which we must still assign */
		atomic = TRUE;
		length2 = p2 -> reference.c_length;
		size2 = bits_per_char * length2;
		type2 = char_string;
		goto A (5);
	     end;
	end;

B2b:
	if type1 = bit_string then
	     machine_state.indicators = ind_invalid;

	if load_it then do;
	     p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
	     call load (p1, fixed (type1 >= char_string, 1));
	end;
	goto done;
%page;
/* have bit string = arithmetic */

B (3):
	size1, length1 = p1 -> reference.c_length;

	if type2 <= real_fix_bin_2 & scale2 ^= 0 then do;
	     if ^loaded then
		call load (p2, 0);

	     call scaler (-scale2, type2);

	     prec2 = max (prec2 - scale2, 0);
	     goto B3b;
	end;

	if ^loaded then
	     if type2 > real_fix_bin_2 | ^p2 -> reference.aligned_ref then
		call load (p2, 0);
	     else do;
		d = type2 - real_fix_bin_1;
		k = bits_per_word * (d + 1);

		arg (1) = p2;
		arg (2) = c_a (k - prec2, 1);

		if s2 -> symbol.unsigned then
		     macro = uns_fx1_to_bs;
		else
		     macro = fx1_to_bs;

		call expmac$many (macro + d, addr (arg), 2);

		a_reg.length = k;
		goto B3a;
	     end;

B3b:
	if ^s2 -> symbol.unsigned then do;
	     if machine_state.indicators ^= ind_arithmetic then do;
		call expmac (cpfx1 - real_fix_bin_1 + type2, c_a (0, 5));
		machine_state.indicators = ind_arithmetic;
	     end;

	     if m1 ^= 0 then
		call expmac$zero (m1);
	     if m2 ^= 0 then
		call expmac$zero (m2);
	end;

	call expmac ((lls), c_a (bits_per_two_words - prec2, 1));

	a_reg.length = bits_per_two_words;

B3a:
	a_reg.size, size2, length2 = prec2;
	a_reg.offset = 0;

	if p1 -> reference.long_ref & ^(p1 -> reference.varying_ref & p1 -> reference.length = null) then do;
	     p2 = c_a (46, 4);			/* store in double_temp */
	     p2 -> reference.c_length = length2;
	     p2 -> reference.temp_ref = TRUE;
	     p2 -> reference.data_type = bit_string;
	     p2 -> reference.ref_count = 2;
	     p2 -> reference.value_in.storage = TRUE;
	     call expmac$one ((sta), p2, fixed (length2 > bits_per_word, 1));
	     goto lg;
	end;
	else do;
	     if check_size then
		call check_stringsize;
	     goto string_store_work;
	end;

LABEL_ENTRY_OR_PTR:
	orig_count = p1 -> reference.ref_count;
	if type2 < unpacked_ptr then
	     goto lab_or_ent;

/* following check allows for initialization of file constants */

	if type1 = local_label_variable then
	     type1, p1 -> reference.data_type = unpacked_ptr;

	if type2 = unpacked_ptr then do;

/* NOTE:  All assignments of unpacked ptrs must be done through the pointer
 *        registers in order to validate the pointers' ring numbers
 */

	     if ^atomic then do;
		if type1 = unpacked_ptr then
		     if ^p2 -> reference.allocate then do;
						/* slide the LHS in as the target of the operator */
			exp_pt -> operand (1) = p1;
			call compile_exp (exp_pt);	/* and compile */
			goto done;
		     end;


		call compile_exp (exp_pt);		/* leave the temp in the machine state */
		p2 = exp_pt -> operator.operand (1);	/* and use it */
		goto CONVERT_UNPACKED_PTR_TO_SOMETHING;
	     end;

	     if s2 -> symbol.constant then do;

/* right side of assignment is a constant, it must be null ptr.
 * if left side is packed ptr, use packed representation of null
 */
		if type1 = packed_ptr then do;
		     p2, p -> operand (2) = generate_constant$real_fix_bin_1 (cg_stat$packed_null_value);
		     type2, p2 -> reference.data_type = packed_ptr;
		end;
	     end;
	end;

	if p2 -> reference.temp_ref then
	     if ^p1 -> reference.temp_ref then
		do i = 1 to 6;
		     if p2 -> reference.value_in.b (i) then do;
			if p1 -> reference.aligned_for_store_ref then
			     if ^p2 -> reference.shared then
				call adjust_ref_count (p2, -1);

			call base_to_core (i, p1);

/* have to decrement count after base_to_core rather
 * than before for unaligned refs so that temp can
 * be used for intermediate saving by base_to_core
 */

			if ^p1 -> reference.aligned_for_store_ref then
			     if ^p2 -> reference.shared then
				call adjust_ref_count (p2, -1);
			goto done;
		     end;
		end;

CONVERT_UNPACKED_PTR_TO_SOMETHING:
	if type1 < type2 | (type2 = packed_ptr & p1 -> reference.temp_ref) then do;
	     call base_man$load_packed (p, i);
	     if ^p1 -> reference.temp_ref | p1 -> reference.aggregate | cg_stat$save_exp_called then
		call base_to_core (i, p1);
	     goto done;
	end;
	else if type2 = unpacked_ptr then
	     if p1 -> reference.temp_ref | ^s2 -> symbol.constant then
		if p1 -> reference.aligned_for_store_ref | p1 -> reference.hard_to_load then do;
		     if ^p2 -> reference.shared & p2 -> reference.temp_ref then
			call adjust_ref_count (p2, +1);
						/* base man will hit ref count even though the reference is evaluated already, potentially */
		     base = base_man$load_any_var (1, p2);
		     i = which_base (fixed (base, 3));
		     if ^p1 -> reference.temp_ref | p1 -> reference.aggregate | cg_stat$save_exp_called then
			call base_to_core (i, p1);
		     else
			call base_man$update_base (1, p1, i);
		     goto done;
		end;

	call load (p2, 0);

	m2 = ptr_convert (type2, type1);
	goto l0;
%page;
/* have conversion to or from decimal or complex */

B (4):
	if s1 -> symbol.complex ^= s2 -> symbol.complex then
	     goto B4b;
	if type1 ^= type2 then
	     goto B4a;
	if scale1 ^= scale2 then
	     goto B4a;
	if p1 -> reference.c_length ^= p2 -> reference.c_length then
	     goto B4a;

	if p1 -> reference.aligned_for_store_ref & p2 -> reference.aligned_ref
	     & s1 -> symbol.unaligned = s2 -> symbol.unaligned then do;
	     if s2 -> symbol.decimal then
		if s2 -> symbol.unaligned then do;
		     units_per_wrd = packed_digits_per_word;
		     if s2 -> symbol.complex then
			c_length =
			     p2 -> reference.c_length + 2 * mod (divide (p2 -> reference.c_length, 2, 24, 0), 2);
		     else
			c_length = p2 -> reference.c_length;
		end;
		else do;
		     units_per_wrd = chars_per_word;
		     c_length = p2 -> reference.c_length;
		end;
	     else do;
		units_per_wrd = bits_per_word;
		c_length = p2 -> reference.c_length;
	     end;

	     call move_data$move_block (p1, p2, divide (c_length + units_per_wrd - 1, units_per_wrd, 17, 0));
	     goto done;
	end;

B4a:
	if s1 -> symbol.decimal then
	     if s2 -> symbol.decimal then do;
		macro = move_decimal;

		if max (scale1, scale2) <= max_dec_scale & min (scale1, scale2) >= min_dec_scale then
		     call assign_decimal;

		else if type1 = type2 then do;
		     if abs (scale1 - scale2) <= max_dec_scale - min_dec_scale then do;
			if scale1 > scale2 then
			     i = min_dec_scale;
			else
			     i = max_dec_scale;
			s1 -> symbol.scale = i + (scale1 - scale2);
			s2 -> symbol.scale = i;
		     end;
		     else do;
			macro = multiply_decimal;
			exponent.pad = "0"b;
			exponent.value = scale1 - scale2;
			s1 -> symbol.scale = 0;
			s2 -> symbol.scale = 0;
		     end;

		     call assign_decimal;

		     s1 -> symbol.scale = scale1;
		     s2 -> symbol.scale = scale2;
		end;
		else do;
		     macro = multiply_decimal;
		     exponent.pad = "0"b;

		     if scale1 > max_dec_scale | scale1 < min_dec_scale then
			exponent.value = scale1;
		     else
			exponent.value = -scale2;

		     call assign_decimal;
		end;

		goto done;
	     end;

B4b:
	if p1 -> reference.temp_ref & p1 -> reference.shared then do;
	     p1, p -> operand (1) = copy_temp (p1);
	     orig_count = 1;
	end;

	load_it =
	     p1 -> reference.temp_ref & ^cg_stat$save_exp_called & cg_stat$cur_tree ^= p
	     & ^(s1 -> symbol.decimal | s1 -> symbol.complex);

	call convert_arithmetic (p1, p2, check_size, always_round);

	goto B2b;
%page;
/* have fixed binary = fixed binary */

B (5):
	if m1 ^= 0 then
	     call expmac$zero (m1);

	ds = scale1 - scale2;

	if ds ^= 0 then do;
	     k = max (type1, type2);
	     call scaler (ds, k);
	end;

	goto l1;
%page;
/* have float binary = fixed binary */

B (6):
	if scale2 = 0 then
	     goto B (1);

	call fixed_to_float (p2);
	if type1 = complex_flt_bin_1 then
	     call expmac$zero (rflb1_to_cflb1);
	goto l1;
%page;
/* have fixed binary = float binary */

B (7):
	if scale1 = 0 then
	     goto B (1);

	call float_to_fixed (p1);
	goto l1;
%page;
lab_or_ent:
	if p1 -> reference.temp_ref & ^cg_stat$save_exp_called then
	     p1 -> reference.ref_count = p1 -> reference.ref_count + 1;

	if type1 = real_fix_bin_1 then do;
	     arg (1) = p1;
	     arg (2) = p2;
	     call expmac$many ((assign_label_to_int), addr (arg), 2);
	     goto done;
	end;

	if type1 = unpacked_ptr then do;
	     call base_man$store_ptr_to (p2, p1);
	     goto done;
	end;

	if type2 = ext_entry_in | type2 = ext_entry_out then do;
	     call base_man$load_var (2, p2, 1);

	     if ^p1 -> reference.shared then
		p1 -> reference.ref_count = p1 -> reference.ref_count + 1;

	     p1 -> reference.data_type = unpacked_ptr;
	     call base_to_core (1, p1);

	     p2 = generate_constant$bit_string (cg_stat$null_value, (bits_per_two_words));
	     p2 -> reference.data_type = unpacked_ptr;
	     call load (p2, 0);
	     call m_a (p1, "1"b);			/* can't have indirection in address */
	     p1 -> reference.perm_address = TRUE;

	     p1 -> address.offset = bit (fixed (fixed (p1 -> address.offset, 15) + 2, 15), 15);
	     call store$force (p1);
	     p1 -> reference.perm_address = FALSE;
	     p1 -> reference.data_type = type1;
	     goto done;
	end;

	b2 = s2 -> symbol.block_node;

	if type2 ^= label_constant then
	     if type2 ^= int_entry then
		goto le_1;

	if b2 -> block.level ^= cg_stat$cur_level then
	     goto le_2;

	call m_a (p1, "1"b);
	p1 -> reference.perm_address = TRUE;
	k = 1 + fixed (p1 -> address.base = bp, 1);
	call base_man$load_var (2, p2, k);
	call expmac ((set_label_const (k)), p1);
	goto done;

le_1:
	if type2 > entry_variable then do;
le_2:
	     arg (1) = p2;
	     arg (2) = c_a (cg_stat$cur_level - b2 -> block.level, 2);
	     call expmac$many ((make_lv), addr (arg), 2);

	     call m_a (p1, "0"b);
	     p1 -> reference.perm_address = TRUE;
	     call expmac ((store_lv), p1);
	end;

	else do;
	     if ^p1 -> reference.shared then
		p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
	     if ^p2 -> reference.shared then
		p2 -> reference.ref_count = p2 -> reference.ref_count + 1;
	     call base_man$update_base (0, null, 1);
	     call make_both_addressable (p1, p2, "1"b);

	     do i = 1 to 2;
		p1 -> reference.perm_address = TRUE;
		p2 -> reference.perm_address = TRUE;
		call base_man$load_var (1, p2, 1);
		call base_to_core (1, p1);
		call state_man$flush_ref (p2);
		if i = 1 then do;
		     p1 -> address.offset = bit (fixed (fixed (p1 -> address.offset, 15) + 2, 15), 15);
		     substr (p2 -> address.tag, 1, 2) = "00"b;
		     p2 -> address.offset = bit (fixed (fixed (p2 -> address.offset, 15) + 2, 15), 15);
		end;
	     end;

	     p1 -> reference.perm_address = FALSE;
	     p2 -> reference.perm_address = FALSE;
	end;

	goto done;
%page;
/*
 *
 */
assign_op$length_of_varying:
     entry (pt, source);

	dcl      source ptr parameter;

	last_macro = FALSE;
	call load (source, 0);
	call expmac_length_of_varying ((stfx1), pt);
	return;
%page;
/*
 * entry to convert fixed decimal scaled input whose scale is out
 * of range to float decimal output
 */
assign_op$fix_dec_scaled:
     entry (pt);

	always_round, check_size = FALSE;
	p2 = pt;
	s2 = p2 -> reference.symbol;
	p1 = decimal_op$get_float_temp (s2 -> symbol.c_dcl_size, (s2 -> symbol.complex));
	s1 = p1 -> reference.symbol;
	macro = multiply_decimal;
	exponent.pad = "0"b;
	exponent.value = -s2 -> symbol.scale;
	call assign_decimal;
	pt = p1;
	return;
%page;
/*
 * entry to convert float decimal input to fixed decimal scaled output
 * whose scale is out of hardware range
 */
assign_op$to_dec_scaled:
     entry (pt, source);

	always_round, check_size = FALSE;
	p2 = source;
	p1 = pt;
	s1 = p1 -> reference.symbol;
	s2 = p2 -> reference.symbol;
	macro = multiply_decimal;
	exponent.pad = "0"b;
	exponent.value = s1 -> symbol.scale;
	call assign_decimal;
	if ^p1 -> reference.shared then
	     p1 -> reference.evaluated = TRUE;
	return;
%page;
/*
 * procedure to generate assignment macro for strings
 */
eis_move:
     proc;

	if p1 -> reference.temp_ref then
	     p1 -> reference.value_in.storage = TRUE;

	if ^(check_size & p1 -> reference.length ^= null) then do;
	     if all_same then do;
		call expmac$one_eis ((blank_cs), p1);
		if length2 > 0 then
		     addrel (cg_stat$text_base, cg_stat$text_pos - 3) -> instruction.fill =
			substr (s2 -> symbol.initial -> based_cs, 1, 1);
		return;
	     end;

	     if all_ones then do;
		if p1 -> reference.aligned_for_store_ref then
		     if mod (size1, bits_per_char) = 0 then do;
			m1 = one_cs;
			call long_op$one_eis (p1, divide (size1 + bits_per_char - 1, bits_per_char, 17, 0), m1);
			return;
		     end;

		m1 = one_bs;
		call expmac$one_eis (m1, p1);
		return;
	     end;

	     if all_zeros then do;
		if p1 -> reference.aligned_for_store_ref then
		     if p1 -> reference.length = null then do;
			if p1 -> reference.padded_for_store_ref | mod (size1, bits_per_char) = 0 then do;
			     m1 = zero_cs;
			     call long_op$one_eis (p1, divide (size1 + bits_per_char - 1, bits_per_char, 17, 0), m1)
				;
			     return;
			end;
		     end;
		     else if p1 -> reference.padded_for_store_ref then do;
			call load_size (p1);
			if p1 -> reference.ref_count = 1 then
			     call need_temp (p1, "01"b);
			call expmac$zero ((b2c_mac));
			call expmac$one_eis ((zero_cs_q), p1);
			return;
		     end;

		m1 = zero_bs;
		call expmac$one_eis (m1, p1);
		return;
	     end;
	end;

	if check_size then
	     macro = chars_move_ck;
	else
	     macro = chars_move;

	call expmac$two_eis (macro + dt, p1, p2);
     end eis_move;
%page;
/*
 * this procedure gets the length expression of a string and increments
 * reference count preparatory to its use in a macro
 */
get_length:
     proc (pt) returns (ptr);

	dcl      pt ptr parameter;
	dcl      (q, q1) ptr;

	q = pt -> reference.length;

	if q ^= null then do;
	     if q -> node.type = operator_node then do;
		q1 = q -> operand (1);
		if q1 -> reference.shared then
		     q -> operand (1) = copy_temp (q1);
		q = q -> operand (1);
	     end;

	     if ^q -> reference.shared then
		q -> reference.ref_count = q -> reference.ref_count + 1;
	end;

	return (q);
     end get_length;
%page;
/*
 * this procedure  gets the length of a reference such that it can be
 * used in storage by a fullword instruction. This routine may emit code.
 * This routine was written to fix 1754.
 */
get_length_in_storage:
     proc (pt) returns (ptr);

	dcl      pt ptr parameter;
	dcl      p ptr;

	p = get_length ((pt));

	if p ^= null then
	     if ^p -> reference.aligned_ref then
		p = compile_exp$save (p);

	return (p);

     end get_length_in_storage;
%page;
/*
 * this procedure gets the length needed by the section that handles
 *   	vs = vs || expr;
 * this MAY emit code.
 */
get_suffix_length:
     proc (pt) returns (ptr);

	dcl      pt ptr parameter;
	dcl      (p, q) ptr;

	p = pt;

	q = get_length_in_storage (p);

	if q = null then do;
	     if p -> reference.c_length ^= 0 | ^p -> reference.varying_ref then
		q = generate_constant$real_fix_bin_1 ((p -> reference.c_length));
	end;
	else if q -> reference.data_type = real_fix_bin_2 then
	     q = get_single_ref (q);

	return (q);

     end get_suffix_length;
%page;
/*
 *  this procedure executes a macro on the length word of a varying string
 */
expmac_length_of_varying:
     proc (macro, pt);

	dcl      macro fixed bin (15) parameter;
	dcl      pt ptr parameter;

	dcl      p ptr;
	dcl      addr_hold bit (36) aligned;
	dcl      reloc_hold bit (12) aligned;

	p = pt;

	if string (p -> reference.address_in.b) ^= "0"b & ^p -> reference.temp_ref then do;
						/* same restriction on temp_ref as in m_a */
	     if p -> address.offset ^= (15)"0"b | p -> reference.no_address then
		call m_a (p, "00"b);
	     p -> address.offset = (15)"1"b;
	end;
	else do;
	     addr_hold = string (p -> reference.address);
	     reloc_hold = p -> reference.relocation;
	     p -> reference.c_offset = p -> reference.c_offset - 1;
	     call m_a (p, "00"b);
	     p -> reference.c_offset = p -> reference.c_offset + 1;
	end;

	p -> reference.perm_address = TRUE;

	if ^last_macro then
	     if ^p -> reference.shared then
		p -> reference.ref_count = p -> reference.ref_count + 1;

	call expmac (macro, p);

	p -> reference.perm_address = FALSE;

	if string (p -> reference.address_in.b) ^= "0"b & ^p -> reference.temp_ref then
	     p -> address.offset = (15)"0"b;
	else do;
	     string (p -> reference.address) = addr_hold;
	     p -> reference.relocation = reloc_hold;
	end;

     end expmac_length_of_varying;
%page;
/*
 *
 */
scaler:
     proc (amt, type);

	dcl      (amt, type) fixed bin parameter;

	if amt < 0 then do;
	     call xr_man$load_const (abs (amt), 2);
	     call expmac$zero ((truncate (type)));
	end;
	else
	     call expmac ((left_shift (type)), c_a (amt, 1));

     end scaler;
%page;
/*
 * this procedure compares two references ignoring the two length fields
 */
compare_refs:
     proc (p1, p2) reducible returns (bit (1) aligned);

	dcl      (p1, p2) ptr parameter;

	if p1 -> reference.symbol ^= p2 -> reference.symbol then
	     return (FALSE);
	else if p1 -> reference.c_offset ^= p2 -> reference.c_offset then
	     return (FALSE);
	else if ^compare_expression ((p1 -> reference.offset), (p2 -> reference.offset)) then
	     return (FALSE);
	else if ^compare_expression ((p1 -> reference.qualifier), (p2 -> reference.qualifier)) then
	     return (FALSE);
	else
	     return (TRUE);

     end compare_refs;
%page;
/*
 *
 */
adjust_suff_temp:
     proc (pt);

	dcl      pt ptr parameter;
	dcl      p ptr;

	p = pt;
	top = p -> reference.length;
	call adjust_suff_op (top);
	call adjust_ref_count (p, -1);

     end adjust_suff_temp;
%page;
/*
 *
 */
adjust_suff_op:
     proc (pt);

	dcl      pt ptr parameter;
	dcl      (p, q) ptr;
	dcl      i fixed bin;

	p = pt;

	if p -> node.type = operator_node then do;
	     q = p -> operand (1);
	     if ^q -> reference.evaluated then
		if q -> reference.ref_count <= 1 then
		     do i = 2 to p -> operator.number;
			if p -> operand (i) ^= null then
			     call adjust_suff_op ((p -> operand (i)));
		     end;
	end;
	else
	     q = p;

	if p ^= top then
	     if q -> node.type = reference_node then
		if ^q -> reference.shared then
		     call adjust_ref_count (q, -1);

	return;

     end adjust_suff_op;
%page;
/*
 * this issues macro(s) to effect the assignment of a decimal variable
 */
assign_decimal:
     proc;

	dcl      (mac, ninst) fixed bin (15);
	dcl      arg (2, 3) ptr;

	mac = macro + fixed (s1 -> symbol.float | always_round, 1);

	if macro = multiply_decimal then do;
	     arg (1, 3), arg (2, 3) = generate_constant$char_string ("+1" || exponent_char, 3);
	     k = 3;
	end;
	else
	     k = 2;

	ninst = fixed (s1 -> symbol.complex, 1) + 1;

	arg (1, 1) = p1;
	arg (1, 2) = p2;

	if ninst > 1 then do;
	     arg (2, 1) = get_imaginary (p1);
	     arg (2, 2) = get_imaginary (p2);
	end;

	do i = 1 to ninst;
	     call expmac$many_eis (mac, addr (arg (i, 1)), k);

	     if check_size then
		if s1 -> symbol.fixed then
		     call expmac$zero ((size_ck_decimal));
	end;

     end assign_decimal;
%page;
/*
 * this issues warning about stringsize occuring at runtime
 * and generates unconditional signal of stringsize
 */
check_stringsize:
     proc;

	if length1 < length2 then do;
	     if ^cg_stat$cur_statement -> statement.suppress_warnings then
		call error (319, cg_stat$cur_statement, null);
	     call expmac$zero ((signal_stringsize));
	end;

     end check_stringsize;
     end assign_op;
