/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* program to compile min and max functions for pl/1

   Note:	The min and max macros generated by this program make 2 references
   to their input argument.  Hence, the reference count on the reference node
   returned by compile_exp$save must be increased by 1, and the reference
   counts for the 3rd thru last temporary in the case of more than 3 operands
   must be 3 instead of 2 as might be expected.  Since the first temporary
   is merely loaded, a reference count of 2 is sufficient.

   Initial Version:  1 April, 1969 by BLW
	Modified:  5 May, 1971 by BLW for Version II
	Modified: 25 October, 1972 by, BLW
	Modified:	17 October, 1973 by RAB for EIS
	Modified:	10 September, 1975 by RAB to fix 1416
	Modified:	9 December 1976 by RAB to fix pos_dif_fun bug
	Modified:	30 January 1977 by RAB to fix 1570
	Modified:	19 March 1977 by RAB to fix 1597
	Modified:	1 June 1977 by RAB to improve min(atm,exp)
	Modified:	2 June 1977 by RAB to improve register management for 2 args	
	Modified 780830 by PG to remove pos_dif_fun
*/

min_max:
	procedure (pt);

/* parameters */

dcl	pt ptr parameter;				/* points at operator node */

/* automatic */

dcl	(p,op_pt,p2,p3,s1,ref(128)) ptr,
	(i,n_rands,type(128),scale(128)) fixed bin,
	op_code bit(9) aligned,
	which fixed bin(15),
	(p1_fx2,b1,check_scale) bit(1) aligned,
	atom(128) bit(1) aligned;

/* entries */

dcl	compile_exp entry(ptr),
	compile_exp$save entry(ptr) returns(ptr),
	decimal_op entry(ptr,(128) ptr,(128) bit(1) aligned),
	compile_exp$save_fix_scaled entry(ptr,fixed bin,fixed bin) returns(ptr),
	adjust_ref_count entry(ptr,fixed bin),
	state_man$erase_reg entry(bit(19) aligned),
	aq_man$fix_scale entry(ptr,fixed bin,fixed bin),
	load entry(ptr,fixed bin),
	expmac entry(fixed bin(15),ptr),
	expmac$zero entry(fixed bin(15)),
	prepare_operand entry(ptr,fixed bin,bit(1) aligned) returns(ptr);

/* external static */

dcl	cg_stat$temp_ref ptr ext;

/* internal static */

dcl (	rfb1_to_rfb2	init(88),
	min_fx1		init(247),
	max_fx1		init(251)) fixed bin(15) int static;

/* include files */

%include operator;
%include reference;
%include symbol;
%include machine_state;
%include data_types;
%include op_codes;

/* program */

	op_pt = pt;

	n_rands = op_pt -> operator.number;
	do i = 1 to n_rands;
	     ref(i) = prepare_operand((op_pt -> operand(i)),1,b1);
	     type(i) = ref(i) -> reference.data_type;
	     scale(i) = ref(i) -> reference.symbol -> symbol.scale;
	     atom(i) = b1;
	     end;

	op_code = op_pt -> operator.op_code;

	s1 = ref(1) -> reference.symbol;

	if s1 -> symbol.decimal
	then do;
	     call decimal_op(op_pt,ref,atom);
	     goto done;
	     end;

	check_scale = "0"b;
	p1_fx2 = type(1) = real_fix_bin_2;

	if s1 -> symbol.fixed
	then do i = 2 to n_rands;
		if scale(i) ^= scale(1)
		then do;
		     atom(i) = "0"b;
		     check_scale = "1"b;
		     end;

		if p1_fx2
		then if n_rands > 3
		     then if type(i) = real_fix_bin_1
			then atom(i) = "0"b;
		end;

	if op_code = min_fun then which = min_fx1;
	else which = max_fx1;

	if n_rands > 3 then goto mm_long;

	p2 = op_pt -> operand(2);
	p3 = op_pt -> operand(3);

	/* if both operands are the same, compile one & decrement ref_count */

	if p2 = p3
	then do;
	     call compile_exp(p2);
	     if ^ ref(3) -> reference.shared
		then call adjust_ref_count(ref(3),-1);

	     /* since compile_exp will call state_man$update_ref,
	        we must flush the q if we are putting in a temp */

	     if ref(2) -> reference.temp_ref
		then call state_man$erase_reg("01"b);
	     goto done;
	     end;

	/* put longer of two operands on right */

	if type(2) > type(3)
	     then call flip_rands;

	if atom(2)
	then do;
	     if atom(3) then goto mm_aa;

	     /* have f(atm,exp) */

	     if type(2) >= type(3)
	     then do;
		call flip_rands;
		go to mm_ea;
		end;

	     if check_scale & scale(1) ^= scale(3)
	     then do;
		ref(3) = compile_exp$save_fix_scaled(p3,scale(1),type(1));
		type(3) = type(1);
		end;
	     else ref(3) = compile_exp$save(p3);

	     /* have f(atm,atm) */

mm_aa:	     if ref(3) -> reference.value_in.q
	     then if type(2) >= type(3)
		then call flip_rands;

	     call load(ref(2),0);
	     end;
	else do;
	     if atom(3) then goto mm_ea;

	     /* have f(exp,exp) */

	     if check_scale & scale(1) ^= scale(3)
	     then do;
		ref(3) = compile_exp$save_fix_scaled(p3,scale(1),type(1));
		type(3) = type(1);
		end;
	     else ref(3) = compile_exp$save(p3);

	     /* have f(exp,atm) */

mm_ea:	     call compile_exp(p2);

	     if check_scale & scale(1) ^= scale(2)
	     then do;
		call aq_man$fix_scale(ref(2),scale(1),type(1));
		type(2) = type(1);
		end;

	     end;

	if p1_fx2 then if type(2) = real_fix_bin_1
	then call expmac$zero((rfb1_to_rfb2));

	call expmac(which + type(3) - real_fix_bin_1,ref(3));
	goto done;

	/* f(a1,a2,...,an).  evaluate all expressions and if
	   type of result is real_fix_bin_2, convert all single
	   precision fixed to double */

mm_long:	do i = 2 to n_rands;
	     if ^ atom(i)
	     then if (check_scale & scale(1) ^= scale(i)) | (p1_fx2 & type(i) = real_fix_bin_1)
		then do;
		     ref(i) = compile_exp$save_fix_scaled((op_pt -> operand(i)),scale(1),type(1));
		     type(i) = type(1);
		     end;
		else ref(i) = compile_exp$save((op_pt -> operand(i)));

	     end;

	call load(ref(2),0);

	do i = 3 to n_rands;
	     call expmac(which + type(i) - real_fix_bin_1,ref(i));
	     end;

done:	cg_stat$temp_ref = ref(1);

	/* set indicators to reflect the fact that the machine indicators
	   do not correspond to the value of the min|max function */

	machine_state.indicators = -1;
	return;


flip_rands:	proc;

	     /* flips operands for case of 2 operands */

	     p = ref(2);
	     ref(2) = ref(3);
	     ref(3) = p;

	     p = p2;
	     p2 = p3;
	     p3 = p;

	     b1 = atom(2);
	     atom(2) = atom(3);
	     atom(3) = b1;

	     i = type(2);
	     type(2) = type(3);
	     type(3) = i;

	     i = scale(2);
	     scale(2) = scale(3);
	     scale(3) = i;

	     end;
	end;
