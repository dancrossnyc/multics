/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* macro expander for pl/1.

  expmac$many expands a macro with many arguments.

   expmac$one expands a macro with a single argument.  m_a is called
   if the argument is not addressable already.  the parameter 'double'
   being non-zero means that the macro argument represents a double
   length operand.  expmac$one will expand macro+1 if the operand is
   not on an even boundary and macro+2 if it is on an even boundary.

   expmac$abs is used to append a block of words to the output buffer.

   expmac$eis is used to expand a macro consisting of an EIS instruction where
   the result operand is in cg_stat$eis_temp and the other operand is passed as an
   argument to expmac$eis.

   expmac$two_eis is used to expand a macro consisting of an EIS instruction that has
   two operands, both of which are supplied in the argument list.

   expmac$many_eis expands a macro consisting of an EIS instruction and takes all its
   operands from its argument list.

   Initial Version: 10 October, 1968 by BLW
	Modified:  6 April, 1971 by BLW for Version II
	Modified: 26 October 1972 by BLW	
	Modified: 14 February 1973 by RAB
	Modified:	29 May 1973 by RAB for EIS
	Modified:	23 Feb 1976 by RAB to fix 1469
	Modified:	1 Dec 1976 by RAB for -long_profile
	Modified:	6 Mar 1977 by RAB to opt multiply of constants
	Modified:	25 Mar 1977 by RAB to fix 1599
	Modified: 5 May 1977 by SHW for new pl1_operator_names_
	Modified:	15 July 1977 by RAB to fix 1646
	Modified:	6 December 1977 by RAB to fix 1693
	Modified:	15 January 1978 by RAB to fix 1698
	Modified:	8 March 1978 by RAB to fix 1713
	Modified:	11 August 1978 by RAB to change handling of aggregate temp ref counts by expmac$eis and friends
	Modified:	21 August 1978 by RAB to increase obj seg limit from 32K to 128K
	Modified:	25 August 1978 by RAB to help fix 1780
	Modified: 25 April 1979 by PCK to implement 4-bit decimal
	Modified:	18 July 1979 by RAB to fix 1842 (ERR 313 when comparing
		entry vars).  Method of counting down ref counts in put_word
		changed to fix the bug.
	Modified 791029 by PG to make changes so that fix for 1744 does not degrade
		code for abs(floating_expr). Fixes long-outstanding problem with way
		machine_state.indicators is set for instructions that modify both the A and Q.
	Modified 800109 by PG to fix bug 1861 in above change involving pl1_operators_ & handling of indicators.
          Modified 8/19/81 by EBush to keep peepholer from removing what it thinks
                    are no-ops (eppn pn|0) but are really sites for binder relocation. (Bug 2084)
*/

/* format: style3 */
expmac:
     proc (macro, arg_pt);

/* parameters */

dcl	PR		fixed bin (3);
dcl	macro		fixed bin,		/* id of macro to be expanded */
	arg_pt		ptr;			/* ptr to single arg of macro */

/* builtins */

dcl	(abs, addr, addrel, binary, bit, divide, fixed, hbound, lbound, mod, null, ptr, string, substr)
			builtin;

/* automatic */

dcl	(arg_blk, p, q, q2, mac_pt, ref_pt, output_pt, sym_use_pt, reloc_pt, text_pt)
			ptr,
	b72		bit (72) aligned,
	(addressable, found, hold_perm_address)
			bit (1) aligned,
	made_perm_addressable
			bit (1) aligned init ("0"b),
	mop		fixed bin (10),
	(s1, s2, n)	fixed bin,
	inst		bit (10) aligned,
	rhs		bit (18) aligned,
	erase		bit (19) aligned,
	not_constant	bit (1),
	eis		bit (1) aligned init ("0"b),
	count_arg		bit (7) aligned,
	constant_value	fixed bin (18),
	(fw, const_string)	bit (36) aligned,
	(i, j, k, num_args, text_pos, first_pos, size, shift_amount, inc, offset)
			fixed bin (18),
	k71		fixed bin (71),
	mac		fixed bin;

dcl	1 info		aligned like instruction_info_$instruction_info;

/* entries */

dcl	cg_error		entry (fixed bin, fixed bin),
	constant_zero	entry (ptr) returns (bit (1)),
	expmac		entry (fixed bin (15), ptr),
	c_a		entry (fixed bin (18), fixed bin (18)) returns (ptr),
	error		entry (fixed bin, ptr, ptr),
	expmac_test	entry (fixed bin, ptr, (4) ptr, (4) bit (1) aligned) returns (bit (1)),
	m_a		entry (ptr, bit (2) aligned),
	expmac$zero	entry (fixed bin (15)),
	(load, adjust_ref_count)
			entry (ptr, fixed bin),
	need_temp		entry (ptr, bit (2) aligned),
	compile_exp	entry (ptr),
	compile_exp$save	entry (ptr) returns (ptr),
	state_man$erase_reg entry (bit (19) aligned),
	base_man$load_var	entry (fixed bin, ptr, fixed bin),
	aq_man$save_aq	entry (ptr, fixed bin),
	power_of_two	entry (fixed bin (18)) returns (fixed bin (18)) reducible;

/* internal static */

dcl	max_obj_seg_size	fixed bin (17) int static init (131071) options (constant);

dcl	(
	ldfx1		init (7),
	stfx1		init (15),
	sta		init (4),
	load_pt		init (60),
	load_ab		init (618),
	load_sb		init (621),
	fx1_to_fx2	init (88),
	quick_desc_mac	init (279),
	get_desc_size	init (284),
	zero_mac		init (308),
	sxl0		init (345),
	sxl7		init (352),
	stx0		init (714),
	stx7		init (721),
	xr18_to_q		init (735),
	xr_to_q		init (583)
	)		fixed bin (15) int static options (constant);

dcl	add_op		(2) bit (10) int static init ("0001111100"b,
						/* adq */
			"0001111110"b /* adaq */);

dcl	(
	eapbp		init ("0111010100"b),
	lcq		init ("0110111100"b),
	fld		init ("1000110010"b),
	fst		init ("1001011010"b),
	lda		init ("0100111010"b),
	ldq		init ("0100111100"b),
	adq		init ("0001111100"b),
	sbq		init ("0011111100"b),
	mpy		init ("1000000100"b),
	qls		init ("1110111100"b),
	lrs		init ("1110110110"b),
	lrl		init ("1111110110"b),
	arl		init ("1111110010"b),
	tsp4		init ("1101110000"b),
	tsp2		init ("0101110100"b),
	tsp3		init ("0101110110"b),
	tra		init ("1110010000"b),
	eax0		init ("1100100000"b),
	tsx0		init ("1110000000"b)
	)		bit (10) int static options (constant);

dcl	(
	lda_dl		init ("010011101000000111"b),
	lda_du		init ("010011101000000011"b),
	mpy_dl		init ("100000010000000111"b)
	)		bit (18) int static options (constant);

dcl	dl_inst		(0:3) bit (18) aligned int static options (constant) init ("001111110000000111"b,
						/* sbq ,dl */
			"000111110000000111"b,	/* adq ,dl */
			"011011110000000111"b,	/* lcq ,dl */
			"010011110000000111"b);	/* ldq ,dl */

dcl	(
	sbq_dl		defined (dl_inst (0)),
	adq_dl		defined (dl_inst (1)),
	lcq_dl		defined (dl_inst (2)),
	ldq_dl		defined (dl_inst (3))
	)		bit (18) aligned;

dcl	(
	eppbp_bp_up_zero	init ("010000000000000000011101010001000000"b),
	epplp_lp_up_zero	init ("100000000000000000011111000001000000"b),
	eppab_ab_up_zero	init ("001000000000000000011101001101000000"b),
	eppbb_bb_up_zero	init ("011000000000000000011101011101000000"b),
	epplb_lb_up_zero	init ("101000000000000000011111001101000000"b),
	eppsb_sb_up_zero	init ("111000000000000000011111011101000000"b),
	eax0_0_al		init ("000000000000000000110010000000000101"b),
	fld_0_dl		init ("000000000000000000100011001000000111"b),
	llr_36		init ("000000000000100100111111111000000000"b),
	ldq_0_dl		init ("000000000000000000010011110000000111"b),
	tpl_3_ic		init ("000000000000000011110000101000000100"b),
	ora_0_dl		init ("000000000000000000010111101000000111"b),
	adq_0_dl		init ("000000000000000000000111110000000111"b),
	sbq_0_dl		init ("000000000000000000001111110000000111"b),
	mpy_1_dl		init ("000000000000000001100000010000000111"b),
	div_1_dl		init ("000000000000000001101000110000000111"b)
	)		bit (36) int static options (constant);

dcl	(
	als_ins		init ("000000000000000000111011101000000000"b),
	lls_ins		init ("000000000000000000111011111000000000"b),
	anaq_ap		init ("000000000000000000011111111001000000"b)
	)		bit (36) int static;	/* these get set */

/* external static */

dcl	(
	cg_stat$text_base,
	cg_stat$text_reloc_base,
	cg_stat$cur_node,
	cg_stat$complex_ac,
	cg_stat$sym_use_base,
	cg_stat$cur_statement
	)		ptr ext,
	(
	pl1_operator_names_$last,
	cg_stat$max_program_size
	)		fixed bin ext,
	cg_stat$used_operator
			bit (900) ext,
	cg_stat$last_macro	fixed bin (15) ext,
	cg_stat$text_pos	fixed bin (18) ext;

dcl	1 instruction_info_$instruction_info
			(0:1023) aligned ext static,
	  2 changes	unaligned,
	    3 a		unal bit (1),
	    3 q		unal bit (1),
	    3 indicators	unal bit (1),
	    3 b		(1:6) unal bit (1),
	    3 x		(0:7) unal bit (1),
	    3 dr		unal bit (1),
	  2 directable	unal bit (1),
	  2 fixed_pt	unal bit (1),
	  2 float_pt	unal bit (1),
	  2 some_base	unal bit (1),
	  2 pad		unal bit (5),
	  2 num_words	unal fixed bin (7),
	  2 double_ins	unal bit (1);

dcl	instruction_info_$operators
			aligned ext static;

dcl	macro_table_$macro_count
			fixed bin ext,
	macro_table_$macro_table
			(1000) bit (72) ext static;

/* based */

dcl	1 operator_info	aligned based (addr (instruction_info_$operators)),
	  2 n_entries	fixed bin,
	  2 entry		(1 refer (operator_info.n_entries)),
	    3 first	fixed bin (18) uns unal,
	    3 last	fixed bin (18) uns unal,
	    3 info	aligned like instruction_info_$instruction_info;

dcl	arg		(num_args) ptr based (p);

dcl	1 macro_def	aligned based (p),
	  2 rel_ptr	unaligned bit (18),		/* rel ptr to body if size > 0 */
	  2 op_code	unaligned bit (10),		/* op_code if size = 0 */
	  2 size		unaligned bit (8),		/* size of body if multi instructions */
	  2 erase		unaligned bit (15),		/* which registers unaltered */
	  2 no_al		unaligned bit (1),		/* "1"b if no AL modification allowed */
	  2 no_ql		unaligned bit (1),		/* "1"b if no QL modification allowed */
	  2 perm		unaligned bit (1),		/* "1"b if arg1 should be made perm addressable */
	  2 cat		unaligned bit (1),		/* "1"b if target length should be taken from source length */
	  2 length_in_q	unaligned bit (1),		/* "1"b if length for move is in q register */
	  2 compare	unaligned bit (1),		/* "1"b if macro is an EIS comparison */
	  2 xec_eis	unaligned bit (1);		/* "1"b if macro xec's EIS instruction */

dcl	1 arg_word	aligned based (p),
	  2 dummy		unaligned bit (3),
	  2 number	unaligned bit (3),		/* arg number */
	  2 increment	unaligned bit (12),		/* add this to arg offset */
	  2 ignored	unaligned bit (12),
	  2 modifier	unaligned bit (6);

dcl	1 instruction	aligned based (p),
	  2 base		unaligned bit (3),
	  2 offset	unaligned bit (15),
	  2 op_code	unaligned bit (10),
	  2 flag		unaligned bit (1),
	  2 ext_base	unaligned bit (1),
	  2 tag		unaligned bit (6);

dcl	1 ic_instruction	based aligned,
	  2 offset	unaligned bit (18),
	  2 op_code	unaligned bit (10),
	  2 flag		unaligned bit (1),
	  2 ext_base	unaligned bit (1),
	  2 tag		unaligned bit (6);

dcl	1 forward_ref	based aligned,
	  2 eis_flag	unaligned bit (1),
	  2 offset	unaligned bit (17),
	  2 pad		unaligned bit (18);

dcl	full_word		bit (36) aligned based;

dcl	1 reloc		aligned based,
	  2 skip1		unal bit (12),
	  2 left_rel	unal bit (6),
	  2 skip2		unal bit (12),
	  2 right_rel	unal bit (6);

dcl	1 half_word	aligned based,
	  2 left		unaligned bit (18),
	  2 right		unaligned bit (18);

dcl	fix_bin		fixed bin based;

dcl	1 packed_ptr_st	based aligned,
	  2 packedptr	ptr unal;

/* include files */

%include operator_names;
%include machine_state;
%include nodes;
%include cg_reference;
%include symbol;
%include operator;
%include data_types;
%include boundary;
%include cgsystem;
%include relocation_bits;
%include bases;

/* program */

	k = 0;

	p = arg_pt;
	if p -> reference.temp_ref
	then do;
		if p -> reference.data_type ^= real_fix_bin_1
		then goto set_one;

		if p -> reference.value_in.storage
		then goto set_one;
		if p -> reference.array_ref
		then goto set_one;
		if p -> reference.aggregate
		then goto set_one;

		if macro = stfx1
		then goto set_one;
		if macro = zero_mac
		then goto set_one;
		if macro = load_pt
		then goto set_one;
		if macro >= load_ab & macro <= load_sb
		then go to set_one;
		if macro >= sxl0 & macro <= sxl7
		then goto set_one;
		if macro >= stx0 & macro <= stx7
		then goto set_one;
		if macro = quick_desc_mac
		then goto set_one;
		if macro = get_desc_size
		then goto set_one;

/* have reference to single precision fixed binary temp without
	        value in storage.  if value is in an index register, we'll
	        transfer it to storage or the q register */

		call save_temp;
		if macro = ldfx1
		then return;
	     end;

	goto set_one;

expmac$many:
     entry (macro, arg_pt, arg_cnt);

dcl	arg_cnt		fixed bin;		/* number of arguments */

	if arg_cnt <= 0
	then return;
	arg_blk = arg_pt;
	num_args = arg_cnt;

	do i = 1 to num_args;
	     p = arg_blk -> arg (i);
	     if ^p -> reference.perm_address
	     then call m_a (p, "0"b);
	end;

normal:
	mac = macro;
	goto join;

expmac$one:
     entry (macro, arg_pt, double);

dcl	double		fixed bin;		/* non-zero if double length operand */

	k = double;

set_one:
	num_args = 1;

	ref_pt = arg_pt;
	if ^ref_pt -> reference.perm_address
	then call m_a (ref_pt, k ^= 0);

	arg_blk = addr (ref_pt);

	if k = 0
	then goto normal;
	if ref_pt -> reference.even
	then mac = macro + 2;
	else mac = macro + 1;

join:
	if mac < 1
	then goto unknown;

	if mac > macro_table_$macro_count
	then do;
unknown:
		call cg_error (302, mac);
		return;
	     end;

	cg_stat$last_macro = mac;

	mac_pt = addr (macro_table_$macro_table (mac));
	if mac_pt -> full_word = "0"b
	then return;

	do i = 1 to num_args;
	     p = arg_blk -> arg (i);
	     if ^p -> reference.shared
	     then if p -> reference.ref_count = 1
		then call need_temp (p, "11"b);
	end;

	erase = mac_pt -> macro_def.erase;

	if erase
	then call state_man$erase_reg (erase);

	not_constant = "1"b;
	count_arg = (7)"0"b;

	first_pos, text_pos = cg_stat$text_pos;

/* check for no AL modification allowed */

	if mac_pt -> macro_def.no_al
	then do;
		p = arg_blk -> arg (1);
		if substr (p -> address.tag, 3, 4) = "0101"b
						/* al */
		then do;
			substr (p -> address.tag, 3, 4) = "1000"b;
						/* x0 */
			addrel (cg_stat$text_base, text_pos) -> full_word = eax0_0_al;
			text_pos = text_pos + 1;
		     end;
	     end;

	if mac_pt -> macro_def.perm
	then do;
		made_perm_addressable = "1"b;
		hold_perm_address = arg_blk -> arg (1) -> reference.perm_address;
		arg_blk -> arg (1) -> reference.perm_address = "1"b;
	     end;

	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);

	size = fixed (mac_pt -> macro_def.size, 8);
	if size = 0
	then do;

/* macro is just an op_code, use of arg_1 is implied */

		p = arg_blk -> arg (1);
		output_pt -> full_word = string (p -> reference.address);
		output_pt -> instruction.op_code = mac_pt -> macro_def.op_code;

		q2 = p -> reference.symbol;
		if q2 ^= null
		then sym_use_pt -> packedptr = q2;

		inst = output_pt -> instruction.op_code;
		mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);

		if p -> reference.ic_ref
		then do;
			inc = 0;
			call text_ref;
		     end;

		reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
		reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);

		if ^p -> reference.shared & ^substr (count_arg, 1, 1)
		then substr (count_arg, 1, 1) = "1"b;

/* eliminate instructions which are effectively nop's -- if they really are ! */

		fw = output_pt -> full_word;

		if reloc_pt -> left_rel = rc_a
		then do;
			if fw = eppbp_bp_up_zero
			then goto done;
			if fw = epplp_lp_up_zero
			then goto done;
			if fw = eppab_ab_up_zero
			then go to done;
			if fw = eppbb_bb_up_zero
			then go to done;
			if fw = epplb_lb_up_zero
			then go to done;
			if fw = eppsb_sb_up_zero
			then go to done;
		     end;
		if fw = ora_0_dl
		then goto done;
		if fw = adq_0_dl
		then goto done;
		if fw = sbq_0_dl
		then goto done;
		if fw = mpy_1_dl
		then if cg_stat$cur_node -> operand (1) -> reference.data_type = real_fix_bin_1
		     then go to done;
		if fw = div_1_dl
		then goto done;

		rhs = output_pt -> right;
		q = addrel (output_pt, -1);

/* the following section attempts to remove code from the
	        sequences generated for string assignments and conversion
	        from bit to fixed.  Let N be the shift amount of the LRL,
	        if the preceding instruction is an lda which referecnes
	        a direct constant, the code attempts to shift the constant
	        reference and delete the lrl instruction.
	        if the preceding instruction is
			anaq	ap|2*(72-N)	(72-n)"1"b
	        the anaq instruction is removed.  if the preceding word is
			als	N
	        the two shift instructions are replaced by the instruction
			anaq	ap|144+2*N	(N)"0"b || (72-N)"1"b
	        if the preceding word is
			als	N-36
	        and the instruction before that is an lda, the
	        lda is changed to an ldq, the als and the lrl are
	        replaced by the instruction
			anaq	ap|144+2*N	(N)"0"b || (72-N)"1"b
	        Finally, if the preceding instruction is
			lls	N
	        it and the lrl are replaced by the same anaq as above */

		if rhs = lrl | rhs = arl
		then do;
			shift_amount = fixed (output_pt -> left, 18);

			if q -> right = lda_du
			then do;
				const_string = q -> left;
				goto l7;
			     end;

			if q -> right = lda_dl
			then do;
				const_string = (18)"0"b || q -> left;

l7:
				b72 = "0"b;
				substr (b72, shift_amount + 1) = const_string;
				if substr (b72, 37, 36)
				then goto l1;

				if b72 = "0"b & rhs = lrl
				then do;
					q -> full_word = fld_0_dl;
					goto done;
				     end;

				if substr (b72, 19, 18) = "0"b
				then do;
					q -> left = b72;
					q -> right = lda_du;
					goto done;
				     end;

				if substr (b72, 1, 18) = "0"b
				then do;
					q -> left = substr (b72, 19, 18);
					q -> right = lda_dl;
					goto done;
				     end;

				goto l1;
			     end;

			substr (anaq_ap, 1, 18) = bit (fixed (2 * (72 - shift_amount), 18), 18);
			if q -> full_word = anaq_ap
			then do;
				q -> full_word = fw;
				goto done;
			     end;

			substr (als_ins, 1, 18) = bit (shift_amount, 18);
			if q -> full_word = als_ins
			then goto ga;

			if shift_amount < 37
			then goto tls;
			substr (als_ins, 1, 18) = bit (fixed (shift_amount - 36, 18), 18);
			if q -> full_word = als_ins
			then do;
				q2 = addrel (q, -1);
				if q2 -> instruction.op_code ^= lda
				then goto l1;
				q2 -> instruction.op_code = ldq;
				goto ga;
			     end;

tls:
			substr (lls_ins, 1, 18) = bit (shift_amount, 18);
			if q -> full_word ^= lls_ins
			then goto l1;
ga:
			substr (anaq_ap, 1, 18) = bit (fixed (144 + 2 * shift_amount, 18), 18);
			q -> full_word = anaq_ap;
			goto done;
		     end;

		if rhs = lrs
		then do;

/* check for anaq	ap|2*(72-N) */

			shift_amount = fixed (output_pt -> left, 18);
			substr (anaq_ap, 1, 18) = bit (fixed (2 * (72 - shift_amount), 18), 18);
			if q -> full_word = anaq_ap
			then do;
				q -> full_word = fw;
				go to done;
			     end;
		     end;

		if rhs = qls
		then do;
			if q -> right ^= qls
			then goto l1;

/* have two consecutive qls instructions, combine them */

			q -> left = bit (fixed (fixed (q -> left, 18) + fixed (output_pt -> left, 18), 18), 18);
			goto done;
		     end;

/* the following section recognizes consecutive adq or sbq
	        instructions and attempts to combine constant terms */

		if rhs = adq_dl
		then s1 = 1;
		else if rhs = sbq_dl
		then s1 = -1;
		else goto m1;

		j = 0;
		if q -> right = adq_dl
		then s2 = 1;
		else if q -> right = sbq_dl
		then s2 = -1;
		else do;

/* if word before ldq has 2 in offset field, it may be
		        part of min | max macro so we'll skip the optimization */

			if addrel (q, -1) -> left = "000000000000000010"b
			then goto l1;

			j = 2;
			if q -> right = ldq_dl
			then s2 = 1;
			else if q -> right = lcq_dl
			then s2 = -1;
			else goto l1;
		     end;

/* if we are in abs sequence, skip the optimization */

		if addrel (q, -2) -> full_word = tpl_3_ic
		then go to m1;

		k = s1 * fixed (output_pt -> left, 18) + s2 * fixed (q -> left, 18);

		if k = 0
		then do;
			if j ^= 0
			then q -> full_word = ldq_0_dl;
			else do;
				output_pt = q;
				reloc_pt = addrel (reloc_pt, -1);
				sym_use_pt = addrel (sym_use_pt, -1);
				text_pos = text_pos - 1;
			     end;
			goto done;
		     end;

		if abs (k) > 111111111111111111b
		then goto l1;

		q -> right = dl_inst (j + fixed (k > 0, 1));

		q -> left = bit (k, 18);
		goto done;

m1:
		if not_constant
		then goto l1;

/* the follwing section first tries to optimize multiplications
	        with 2 constant operands, and then tries to replace
	        multipications by a constant power of two by a left shift
	        instruction */

		if inst = mpy
		then do;
			if cg_stat$cur_node -> operand (1) -> reference.data_type ^= real_fix_bin_1
			then goto l1;

			if rhs = mpy_dl & (q -> right = ldq_dl | q -> right = lcq_dl)
			     & addrel (q, -1) -> left ^= "000002"b3 & addrel (q, -2) -> full_word ^= tpl_3_ic
			then do;
				k71 = fixed (output_pt -> left, 18) * fixed (q -> left, 18);

				if k71 <= 111111111111111111b
				then do;
					q -> left = bit (fixed (k71, 18), 18);
					go to done;
				     end;
			     end;

			constant_value = fixed (const_string, 36);
			k = power_of_two (constant_value);
			if k = 0
			then goto l1;

			if q -> right = qls
			then do;
				q -> left = bit (fixed (fixed (q -> left, 18) + k, 18), 18);
				goto done;
			     end;

			output_pt -> full_word = bit (k, 18) || qls;
			goto l1;
		     end;

l1:
		text_pos = text_pos + 1;
		goto done;
	     end;

/* have macro of size words, may have arguments used */

	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);
	addressable = "1"b;

	do i = 0 to size - 1;

	     call put_word;
	end;

done:
	if count_arg
	then do i = 1 to num_args;
		if substr (count_arg, i, 1)
		then call adjust_ref_count (arg_blk -> arg (i), -1);
	     end;

	if text_pos >= cg_stat$max_program_size
	then call cg_error (311, cg_stat$max_program_size);

	do i = first_pos to text_pos - 1;

	     inst = text_pt -> instruction.op_code;
	     mop = binary (substr (inst, 1, 9), 9) + 512 * binary (substr (inst, 10, 1), 1);
	     info = instruction_info_$instruction_info (mop);
	     PR = binary (text_pt -> instruction.base, 3);

/* See if we have a reference to a pl1_operator_. Note that the following tests are
   carefully arranged in such a way as to make the code execute as quickly as possible.
   Needless to say, the following tests rely on knowledge of how the generated code
   addresses operators. Note that not all references use pr0, so we don't test that. */

	     if text_pt -> instruction.ext_base & (text_pt -> instruction.tag = ""b)
		& ((inst = tsx0) | (inst = tsp2) | (inst = tra) | (inst = tsp4) | (inst = tsp3))
	     then do;
		     offset = binary (text_pt -> instruction.offset, 15);

		     if offset <= pl1_operator_names_$last
		     then substr (cg_stat$used_operator, offset, 1) = "1"b;

		     if (inst = tsx0) | (inst = tsp3)
		     then do;

/* We have a normal or math operator. See how it affects the registers & indicators.
   A major assumption here is that an operator that modifies the Q or AQ
   also sets the ARITHMETIC indicators for that register. Most of the operators
   do just that. All operators that behave otherwise (i.e. set the LOGICAL
   indicators) must be in the operator_info table in instruction_info. */

			     do j = lbound (operator_info.entry, 1) to hbound (operator_info.entry, 1)
				while (operator_info.entry (j).last < offset);
			     end;

			     if j <= hbound (operator_info.entry, 1)
			     then if operator_info.entry (j).first <= offset
				then found = "1"b;
				else found = "0"b;
			     else found = "0"b;

			     if found
			     then info = operator_info.entry (j).info;
			     else do;
				     string (info.changes) = substr (erase, 1, 2);
						/* A, Q */
				     info.changes.indicators = "1"b;
				     info.fixed_pt = "1"b;
						/* one of these must be true... */
				     info.float_pt = "1"b;
						/* ...all exceptions are in table */

				     if substr (erase, 14, 1)
				     then info.changes.b (1) = "1"b;
				end;
			end;
		     else if inst = tsp4
		     then string (info.changes) = "111111111"b;

		end;

	     if eis & xec_eis
	     then string (info.changes) = "001"b;

/* The following statement should set the indicators to -1 (invalid), but we can't
   do so until all of the places that depend on the incorrect value have been
   fixed to set it to 0 themselves. Anybody that issues sztl-type instructions
   (for example) is affected. */

	     if info.changes.indicators
	     then machine_state.indicators = 0;

	     if info.changes.q
	     then do;
		     q_reg.changed = i;
		     q_reg.instruction = text_pt -> full_word;
		end;

	     if info.changes.a
	     then do;
		     a_reg.changed = i;
		     a_reg.instruction = text_pt -> full_word;
		end;

	     if (info.fixed_pt | info.float_pt) & info.changes.q
	     then machine_state.indicators = ind_arithmetic;
	     else if info.changes.indicators & info.changes.a
	     then machine_state.indicators = ind_logical;

	     if info.some_base
	     then call change_base_ (i, which_base (PR));

	     else do PR = lbound (info.changes.b, 1) to hbound (info.changes.b, 1);
		     if info.changes.b (PR)
		     then call change_base_ (i, (PR));
		end;


	     do j = 0 to 7;
		if info.changes.x (j)
		then do;
			index_regs (j).changed = i;
			index_regs (j).instruction = text_pt -> full_word;
			machine_state.indicators = ind_x (j);
		     end;
	     end;

	     if info.changes.dr
	     then machine_state.indicators = ind_decimal_reg;

	     text_pt = addrel (text_pt, 1);

/* Next sequence skips over EIS descriptors if they exist */

	     nwords = info.num_words - 1;
	     if eis
	     then if xec_eis
		then nwords = 2;

	     if nwords > 0
	     then do;

/* eis instruction */

		     if ^compare
		     then if machine_state.indicators = ind_known_refs
			then do;

/* we have set a value without setting the indicators,
		        remove it from the indicators */

				p = arg_blk -> arg (1);
				if p = indicators_ref (2)
				then machine_state.indicators = ind_invalid;
				else if p = indicators_ref (3)
				then machine_state.indicators = ind_invalid;
			     end;

		     i = i + nwords;
		     text_pt = addrel (text_pt, nwords);
		end;

	end;

	cg_stat$text_pos = text_pos;

	if made_perm_addressable
	then arg_blk -> arg (1) -> reference.perm_address = hold_perm_address;

	return;

expmac$zero:
     entry (macro);

	cg_stat$last_macro, mac = macro;

	if mac < 1
	then goto unknown;
	if mac > macro_table_$macro_count
	then goto unknown;

	num_args = 0;
	count_arg = (7)"0"b;

	mac_pt = addr (macro_table_$macro_table (mac));

	if mac_pt -> full_word = "0"b
	then return;

	erase = mac_pt -> macro_def.erase;

	if erase
	then call state_man$erase_reg (erase);

	size = fixed (mac_pt -> macro_def.size, 8);

	first_pos, text_pos = cg_stat$text_pos;
	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);

/* there must be a macro body if there are no args */

	if size = 0
	then do;
		call cg_error (304, mac);
		return;
	     end;

	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);
	do i = 0 to size - 1;
	     output_pt -> full_word = mac_pt -> full_word;
	     reloc_pt -> full_word = "0"b;

/* convert the sequence
			ldq	x
			llr	36
	        into the instruction
			lda	x	*/

/* We cannot do the optimization if the
	        q register could have been loaded via
	        more than 1 path (min or max bifs)*/

	     if output_pt -> full_word = llr_36
	     then if machine_state.indicators = ind_arithmetic
		then do;
			q = addrel (output_pt, -1);
			if q -> instruction.op_code = ldq
			then do;
				q -> instruction.op_code = lda;
				goto l4;
			     end;
		     end;


	     output_pt = addrel (output_pt, 1);
	     reloc_pt = addrel (reloc_pt, 1);
	     text_pos = text_pos + 1;

l4:
	     mac_pt = addrel (mac_pt, 1);
	end;

	goto done;

expmac$abs:
     entry (blk_pt, blk_cnt);

dcl	blk_pt		ptr,			/* points at block to be appended */
	blk_cnt		fixed bin;		/* number of words in block */

dcl	blk		(blk_cnt) fixed bin based;

	if blk_cnt <= 0
	then return;

	cg_stat$last_macro = 0;

/* we use the fact that the relocation segment will be
	   filled with zeros as its length grows */

	addrel (cg_stat$text_base, cg_stat$text_pos) -> blk = blk_pt -> blk;

	cg_stat$text_pos = cg_stat$text_pos + blk_cnt;
	if cg_stat$text_pos >= cg_stat$max_program_size
	then call cg_error (311, cg_stat$max_program_size);

	return;

expmac$interpret:
     entry (macro_start, node_pt, refs, atom);

/* This entry is called to interpret the macro sequence
	   starting at "macro_start" */

dcl	macro_start	fixed bin,		/* start of sequence */
	node_pt		ptr,			/* points at operator node */
	refs		(4) ptr,			/* ref nodes for operands */
	atom		(4) bit (1) aligned;	/* ON if operand is atomic */

dcl	(b1, b2, b3)	bit (1),
	(depth, code)	fixed bin,
	ref		(4) ptr defined (refs),
	(
	stack		(10),
	rand		(4)
	)		ptr;

dcl	1 special_word	aligned based,
	  2 part1		unal bit (18),
	  2 op		unal bit (9),
	  2 skip		unal bit (3),
	  2 part2		unal bit (6);

dcl	special_erase	bit (15) aligned based;

dcl	sp_erase		bit (19) aligned;

	mac_pt = addr (macro_start);
	goto init;

expmac$conditional:
     entry (macro, node_pt, refs, atom);

	mac_pt = addr (macro_table_$macro_table (macro));

	erase = mac_pt -> macro_def.erase;

	if erase
	then call state_man$erase_reg (erase);

	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);

/* initialize */

init:
	first_pos, text_pos = cg_stat$text_pos;
	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);

	num_args = node_pt -> operator.number;

	rand (2) = node_pt -> operand (2);
	rand (3) = node_pt -> operand (3);
	if num_args >= 4
	then rand (4) = node_pt -> operand (4);

	code = fixed (atom (2) || atom (3), 2);

	arg_blk = addr (refs);
	addressable = "0"b;
	count_arg = (7)"0"b;

	depth = 0;

/* if bit 28 of word from macro table is off, this is ordinary instruction */

loop:
	if ^mac_pt -> instruction.flag
	then do;
		call put_word;
		goto loop;
	     end;

/* have special control word */

	mop = fixed (mac_pt -> special_word.op, 9);
	s2 = fixed (mac_pt -> special_word.part2, 9);
	s1 = fixed (mac_pt -> special_word.part1, 18);
	k = fixed (mac_pt -> arg_word.number, 3);
	if k > 0
	then if k <= num_args
	     then p = ref (k);
	goto sw (mop);

/* end of macro sequence */

sw (0):
	if depth = 0
	then goto done;

	mac_pt = stack (depth);
	depth = depth - 1;
	goto next;

/* IF operator */

sw (1):
	b2 = "1"b;
	goto test;

/* IFNOT operator */

sw (2):
	b2 = "0"b;

test:
	if s2 = 1
	then b1 = ref (2) -> reference.value_in.q;
	else if s2 = 2
	then b1 = ref (3) -> reference.value_in.q;
	else if s2 = 3
	then b1 = ref (2) -> reference.value_in.a;
	else if s2 = 4
	then b1 = ref (3) -> reference.value_in.a;
	else if s2 = 5
	then b1 = ref (2) -> reference.value_in.complex_aq;
	else if s2 = 6
	then b1 = ref (3) -> reference.value_in.complex_aq;
	else if s2 = 7
	then b1 = constant_zero (ref (2));
	else if s2 = 8
	then b1 = constant_zero (ref (3));
	else if s2 = 9
	then b1 = atom (2);
	else if s2 = 10
	then b1 = atom (3);
	else if s2 = 11
	then b1 = atom (4);
	else b1 = expmac_test (s2, node_pt, refs, atom);

	if b1 = b2
	then do;

/* test succeeded */

next:
		mac_pt = addrel (mac_pt, 1);
		goto loop;
	     end;

/* test failed */

	goto sw (4);

/* FLIPTO operator */

sw (3):
	q = ref (2);
	ref (2) = ref (3);
	ref (3) = q;

	q = rand (2);
	rand (2) = rand (3);
	rand (3) = q;

	b1 = atom (2);
	atom (2) = atom (3);
	atom (3) = b1;

	code = fixed (atom (2) || atom (3), 2);

/* JUMP operator */

sw (4):
	if s1 = 0
	then goto done;
	mac_pt = ptr (mac_pt, s1);
	goto loop;

/* PUT operator */

sw (5):
	depth = depth + 1;
	stack (depth) = mac_pt;
	goto sw (4);

/* FETCH operator */

sw (6):
	b2 = "0"b;

f1:
	b1 = atom (k);
	b3 = "0"b;

f2:
	cg_stat$text_pos = text_pos;

	if b1
	then call load (ref (k), 0);
	else call compile_exp (rand (k));

	if b2 & ref (k) -> reference.data_type ^= real_fix_bin_2
	then call expmac$zero ((fx1_to_fx2));

	if b3
	then if ref (k) -> reference.value_in.complex_aq
	     then do;
		     q = ref (k);
		     string (q -> reference.address) = string (cg_stat$complex_ac -> reference.address);
		     q -> reference.relocation = cg_stat$complex_ac -> reference.relocation;
		     q -> reference.perm_address = "1"b;
		end;
	     else ref (k) = rand (k) -> operand (1);

f3:
	text_pos = cg_stat$text_pos;
	output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
	goto next;

/* GET_FX2 operator */

sw (7):
	b2 = "1"b;
	goto f1;

/* COMPILE operator */

sw (8):
	b1, b2, b3 = "0"b;
	goto f2;

/* CPLALT operator */

sw (9):
	b3 = "1"b;
	b1, b2 = "0"b;
	goto f2;

/* CPLSAVE operator */

sw (10):
	cg_stat$text_pos = text_pos;

	ref (k) = compile_exp$save (rand (k));

	goto f3;

/* LOAD operator */

sw (11):
	b1 = "1"b;
	b2, b3 = "0"b;
	goto f2;

/* ADD operator */

sw (12):
	if p -> reference.no_address
	then call call_ma;

	output_pt -> full_word = string (p -> reference.address);
	output_pt -> instruction.op_code = add_op (p -> reference.data_type);

	q2 = p -> reference.symbol;
	if q2 ^= null
	then sym_use_pt -> packedptr = q2;

	reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
	reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);

	output_pt = addrel (output_pt, 1);
	reloc_pt = addrel (reloc_pt, 1);
	sym_use_pt = addrel (sym_use_pt, 1);
	text_pos = text_pos + 1;
	goto next;

/* SWITCH operator */

sw (13):
	if s2 = 1
	then n = code;
	else if s2 = 2
	then n = fixed (node_pt -> operator.op_code, 9);
	else if s2 = 3
	then n = ref (1) -> reference.data_type;
	else if s2 = 4
	then n = ref (2) -> reference.data_type;
	else if s2 = 5
	then n = ref (3) -> reference.data_type;

	mac_pt = addrel (mac_pt, n - s1 + 1);
	goto loop;

/* ERASE operator */

sw (14):
	cg_stat$text_pos = text_pos;

	sp_erase = mac_pt -> special_erase;
	call state_man$erase_reg (sp_erase);
	goto f3;

/* BUMP operator */

sw (15):
	if ^p -> reference.shared
	then p -> reference.ref_count = p -> reference.ref_count + 1;

	goto next;

/* DROP operator */

sw (16):
	if ^p -> reference.shared
	then call adjust_ref_count (p, -1);

	goto next;

expmac$fill_usage:
     entry (val, last_use);

dcl	(val, last_use, use, prev_use)
			fixed bin (17);

	use = last_use;
	do while (use ^= 0);
	     output_pt = addrel (cg_stat$text_base, use);
	     prev_use = fixed (output_pt -> forward_ref.offset, 17);

	     if output_pt -> forward_ref.eis_flag
	     then do;
		     output_pt -> forward_ref.eis_flag = "0"b;
		     use = use - output_pt -> descriptor.char;
		     output_pt -> descriptor.char = 0;
		end;

	     call set_offset (val - use);
	     use = prev_use;
	end;

	return;




/* Macro expander for EIS instructions */

expmac$eis:
     entry (macro, arg_pt);

dcl	lreg		(3) bit (1) aligned;	/* "1"b if length is in a register */
dcl	len		(3) bit (4) aligned;	/* register containing length */
dcl	count		(3) bit (1) aligned;	/* "1"b if reference count is to be decremented */

dcl	cat		bit (1) aligned;		/* "1"b if target length should be taken from source length */
dcl	length_in_q	bit (1) aligned;		/* "1"b if length for move is in q register */
dcl	compare		bit (1) aligned;		/* "1"b if macro is an EIS comparison */
dcl	xec_eis		bit (1) aligned;		/* "1"b if macro xec's an EIS instruction */
dcl	(nwords, type)	fixed bin;
dcl	ichar		fixed bin (3);
dcl	ibit		fixed bin (4);
dcl	scale		fixed bin (6);
dcl	ptarray		(2) ptr;

dcl	mf		(3) fixed bin (6) int static init (30, 12, 3);
						/* location of modification factor */

dcl	cg_stat$eis_temp	ptr ext;

dcl	1 descriptor	based aligned,		/* layout of operand descr */
	  2 word_address	bit (18) unal,
	  2 char		fixed bin (2) uns unal,
	  2 bit		fixed bin (4) uns unal,
	  2 length	bit (12) unal;

dcl	1 four_bit_descriptor
			based aligned,		/* EIS 4-bit operand descriptor */
	  2 word_address	bit (18) unal,
	  2 char		fixed bin (3) uns unal,
	  2 bit		fixed bin (3) uns unal,
	  2 length	bit (12) unal;


dcl	1 mod_factor	aligned,			/* layout of modification_factor field */
	  2 ext_base	bit (1) unal,
	  2 tag		unal,
	    3 length_in_reg bit (1),
	    3 indirect_descriptor
			bit (1),
	    3 offset_reg	bit (4);

dcl	copy_temp		entry (ptr) returns (ptr);
dcl	make_n_addressable	entry (ptr, fixed bin);
dcl	load_size$xr_or_aq	entry (ptr, bit (4) aligned);
dcl	state_man$unlock	entry ();
dcl	aq_man$lock	entry (ptr, fixed bin);

	num_args = 2;
	ptarray (1) = cg_stat$eis_temp;
	ptarray (2) = arg_pt;
	arg_blk = addr (ptarray);
	go to join_eis;

expmac$one_eis:
     entry (macro, arg_pt);

	num_args = 1;
	arg_blk = addr (arg_pt);
	go to join_eis;

expmac$two_eis:
     entry (macro, arg_pt, arg_pt2);

dcl	arg_pt2		ptr;

	num_args = 2;
	ptarray (1) = arg_pt;
	ptarray (2) = arg_pt2;
	arg_blk = addr (ptarray);
	go to join_eis;

expmac$many_eis:
     entry (macro, arg_pt, arg_cnt);

	if arg_cnt <= 0
	then return;
	arg_blk = arg_pt;
	num_args = arg_cnt;

join_eis:
	eis = "1"b;
	count_arg = (7)"0"b;

/* Check for short string temporaries not in storage.  If found, then store
   from aq */

	do i = 1 to num_args;
	     p = arg_blk -> arg (i);
	     if p -> reference.temp_ref
	     then if ^p -> reference.value_in.storage & ^p -> reference.array_ref & ^p -> reference.aggregate
		then if p -> reference.data_type >= char_string
		     then if ^p -> reference.long_ref & ^p -> reference.varying_ref
			then if p -> reference.value_in.a
			     then do;
				     if p -> reference.shared
				     then p, arg_blk -> arg (i) = copy_temp (p);
				     p -> reference.ref_count = p -> reference.ref_count + 1;
				     p -> reference.value_in.storage = "1"b;
				     p -> reference.store_ins = bit (cg_stat$text_pos, 18);
				     size = p -> reference.c_length * convert_size (p -> reference.data_type);

				     call expmac$one ((sta), p, fixed (size > bits_per_word, 1));
				end;
			     else call error315;
			else ;
		     else if p -> reference.data_type > 0
		     then if p -> reference.data_type <= real_fix_bin_2
			then if p -> reference.value_in.q
			     then call aq_man$save_aq (p, 0);
			     else call save_temp;
	end;

/* Initialize */

	mac = macro;

	if macro <= 0
	then go to unknown;
	if macro > macro_table_$macro_count
	then go to unknown;

	mac_pt = addr (macro_table_$macro_table (mac));
	if mac_pt -> full_word = "0"b
	then return;

	cat = mac_pt -> macro_def.cat;
	length_in_q = mac_pt -> macro_def.length_in_q;
	compare = mac_pt -> macro_def.compare;
	xec_eis = mac_pt -> macro_def.xec_eis;
	if xec_eis
	then n = -num_args;
	else n = num_args;
	if length_in_q
	then call aq_man$lock (null, 2);

/* Make all rands addressable */

	call make_n_addressable (arg_blk, n);

/* Get lengths for all the rands and determine whose reference counts are
  to be decremented */

	do i = 1 to num_args;
	     p = arg_blk -> arg (i);

	     if length_in_q
	     then do;
		     lreg (i) = "1"b;
		     len (i) = "0110"b;		/* q */
		end;
	     else if cat & i = 1
	     then ;
	     else do;
		     lreg (i) =
			p -> reference.length ^= null | p -> reference.c_length > 4095
			| (p -> reference.varying_ref & p -> reference.c_length = 0) | xec_eis;
		     if lreg (i)
		     then call load_size$xr_or_aq (p, len (i));
		end;
	     count (i) =
		^(p -> reference.shared | (i = 1 & p -> reference.temp_ref & ^p -> reference.aggregate & ^compare));
	     if count (i)
	     then if p -> reference.ref_count = 1
		then call need_temp (p, "01"b);
	end;

	if cat
	then do;
		lreg (1) = lreg (2);
		len (1) = len (2);
	     end;

	erase = mac_pt -> macro_def.erase;
	if erase
	then call state_man$erase_reg (erase);

	cg_stat$last_macro = mac;

	text_pos, first_pos = cg_stat$text_pos;
	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);

	size = fixed (mac_pt -> macro_def.size, 8);

	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);

/* Start filling in the text */

	output_pt -> full_word = mac_pt -> full_word;
	reloc_pt -> full_word = "0"b;

	inc = 0;
	inst = output_pt -> instruction.op_code;

	if ^xec_eis
	then do;
		mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);
		nwords = instruction_info_$instruction_info (mop).num_words;
	     end;
	else nwords = 3;

/* Loop to fill in the operand descriptors */

	do i = 1 to nwords - 1;

	     output_pt = addrel (output_pt, 1);
	     reloc_pt = addrel (reloc_pt, 1);
	     sym_use_pt = addrel (sym_use_pt, 1);

	     mac_pt = addrel (mac_pt, 1);

	     k = fixed (mac_pt -> arg_word.number, 3);
	     if mac_pt -> instruction.base
	     then k = 0;

/* Check for use of argument */

	     if k ^= 0
	     then do;

		     if k <= num_args
		     then p = arg_blk -> arg (k);
		     else do;
			     call cg_error (303, macro);
			     go to step;
			end;

		     q2 = p -> reference.symbol;
		     if q2 ^= null
		     then sym_use_pt -> packedptr = q2;

		     output_pt -> full_word = string (p -> reference.address);
		     type = mac_pt -> descriptor.bit;

/* See if we must build a descriptor */

/* Meanings of values of type (operand types of macros in macro_table.table) */
/* 0 = address	   */
/* 1 = decimal	   */
/* 2 = 8-bit character */
/* 3 = bit	   */
/* 4 = 4-bit character */

		     if type > 0
		     then do;
			     string (mod_factor) = substr (string (p -> reference.address), 30, 7);
			     mod_factor.length_in_reg = lreg (k);

			     if lreg (k)
			     then output_pt -> descriptor.length = "00000000"b || len (k);
			     else do;
				     q = p;
				     if cat
				     then if k = 1
					then q = arg_blk -> arg (2);
				     if mac_pt -> descriptor.length = (12)"0"b
				     then output_pt -> descriptor.length =
					     bit (fixed (q -> reference.c_length, 12), 12);
				     else output_pt -> descriptor.length = mac_pt -> descriptor.length;
				end;

			     if ^xec_eis
			     then substr (text_pt -> full_word, mf (i), 7) = string (mod_factor);

			     if type <= 2 | type = 4
			     then do;
				     ichar = p -> reference.c_f_offset;
				     ibit = 0;
				end;
			     else do;
				     ichar = divide (p -> reference.c_f_offset, bits_per_char, 2, 0);
				     ibit = mod (p -> reference.c_f_offset, bits_per_char);
				end;

			     if ichar > 0
			     then if q2 ^= null & type = 1
				then if q2 -> symbol.unaligned & q2 -> symbol.decimal
				     then output_pt -> four_bit_descriptor.char = ichar;
				     else output_pt -> descriptor.char = ichar;
				else output_pt -> descriptor.char = ichar;
			     if ibit > 0
			     then output_pt -> descriptor.bit = ibit;

			     if type = 1
			     then do;
				     if p -> reference.data_type = complex_fix_dec
					| p -> reference.data_type = complex_flt_dec
				     then output_pt -> descriptor.length =
					     bit (divide (p -> reference.c_length, 2, 12, 0), 12);
				     if p -> reference.data_type = real_fix_dec
					| p -> reference.data_type = complex_fix_dec
				     then do;
					     if q2 ^= null
					     then if q2 -> symbol.unaligned & q2 -> symbol.decimal
						then output_pt -> four_bit_descriptor.bit = 5;
						else output_pt -> descriptor.bit = 1;
					     else output_pt -> descriptor.bit = 1;
					     if q2 ^= null
					     then do;
						     scale = q2 -> symbol.scale;
						     if scale > max_dec_scale | scale < min_dec_scale
						     then scale = 0;
						     else scale = -scale;
						     if scale < 0
						     then scale = scale + 64;
						     if scale ^= 0
						     then substr (output_pt -> descriptor.length, 1, 6) =
							     bit (scale, 6);
						end;
					end;
				     else if q2 ^= null
				     then if q2 -> symbol.unaligned & q2 -> symbol.decimal
					then output_pt -> four_bit_descriptor.bit = 4;
						/* 4-bit float decimal */

				     if k = 1
				     then if instruction_info_$instruction_info (mop).changes.dr
					then do;
						p -> reference.value_in.decimal_aq = "1"b;
						decimal_reg.variable = p;
					     end;
				end;
			     else if type = 4
			     then do;
				     output_pt -> four_bit_descriptor.bit = 4;
				     output_pt -> four_bit_descriptor.char = ichar;
				end;
			end;

		     if p -> reference.ic_ref
		     then call text_ref;

		     reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
		     reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);

		     if count (k)
		     then call adjust_ref_count (p, -1);
		end;

	     else do;
		     output_pt -> full_word = mac_pt -> full_word;
		     reloc_pt -> full_word = "0"b;
		end;
step:
	end;

/* Unlock all registers locked for this instruction */

	call state_man$unlock;

	text_pos = text_pos + nwords;

/* See if we have non-EIS sequence following EIS instruction.  If so, put_word will handle it */

	if size > nwords
	then do;
		output_pt = addrel (output_pt, 1);
		reloc_pt = addrel (reloc_pt, 1);
		sym_use_pt = addrel (sym_use_pt, 1);
		mac_pt = addrel (mac_pt, 1);
		eis = "0"b;
		do i = nwords to size - 1;
		     call put_word;
		end;
	     end;

	go to done;



put_word:
     proc;

dcl	inc_orig		fixed bin;

/* check for use of argument */

	k = fixed (mac_pt -> arg_word.number, 3);
	if mac_pt -> instruction.tag
	then k = 0;
	if mac_pt -> instruction.base
	then k = 0;

	inst = mac_pt -> instruction.op_code;
	mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);

/* check for use of argument */

	if k ^= 0
	then do;

		if k <= num_args
		then p = arg_blk -> arg (k);
		else do;
			call cg_error (303, macro);
			return;
		     end;

/* check for base register being loaded */

		if inst = eapbp
		then do;
			call call_base_man;
			goto l3;
		     end;

/* make sure arg is addressable */

		if ^addressable
		then call call_ma;

		fw = string (p -> reference.address);

		inc, inc_orig = fixed (mac_pt -> arg_word.increment, 12);

/* if macro word is of form
			op argk+inc
		   and the corresponding argument has indirection,
		   we must either load value of inc into an index,
		   or we must load base register with address */

		if inc = 0
		then goto copy;

		if substr (p -> address.tag, 1, 2) = "00"b
		then goto copy;

		if p -> address.tag = "010000"b	/* * */
		then do;

/* have simple case, just load value of inc into x0 */

			output_pt -> left = bit (fixed (inc, 18), 18);
			output_pt -> right = eax0;

			substr (fw, 31, 6) = "111000"b;
						/* *0 */

			output_pt = addrel (output_pt, 1);
			reloc_pt = addrel (reloc_pt, 1);
			sym_use_pt = addrel (sym_use_pt, 1);
			text_pos = text_pos + 1;
			inc = 0;
		     end;
		else do;
			call adjust_ref_count (p, 1);
			call call_base_man;
			fw = string (p -> reference.address);
		     end;

/* copy word from macro table into output */

copy:
		output_pt -> full_word = mac_pt -> full_word;

/* combine kth arg with macro word */

		output_pt -> left = "0"b;
		output_pt -> full_word = output_pt -> full_word | fw;

		q2 = p -> reference.symbol;
		if q2 ^= null
		then sym_use_pt -> packedptr = q2;

		if p -> reference.ic_ref
		then call text_ref;
		else if inc > 0
		then if output_pt -> instruction.ext_base
		     then output_pt -> instruction.offset =
			     bit (fixed (fixed (output_pt -> instruction.offset, 15) + inc, 15), 15);
		     else output_pt -> left = bit (fixed (fixed (output_pt -> left, 18) + inc, 18), 18);

		reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
		reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);

		if ^p -> reference.shared & inc_orig = 0 & ^substr (count_arg, k, 1)
		then substr (count_arg, k, 1) = "1"b;

	     end;

	else do;
		output_pt -> full_word = mac_pt -> full_word;
		p = null;
		reloc_pt -> full_word = "0"b;
	     end;

	if reloc_pt -> left_rel = rc_a
	then do;
		if output_pt -> full_word = eppbp_bp_up_zero
		then goto l3;
		if output_pt -> full_word = epplp_lp_up_zero
		then goto l3;
		if output_pt -> full_word = eppab_ab_up_zero
		then go to l3;
		if output_pt -> full_word = eppbb_bb_up_zero
		then go to l3;
		if output_pt -> full_word = epplb_lb_up_zero
		then go to l3;
		if output_pt -> full_word = eppsb_sb_up_zero
		then go to l3;
	     end;

	q = addrel (output_pt, -1);

/* following section flushes sequence
			fld	x
			fst	x
	        which may arise in some complex arithmetic sequences */

	if inst = fst
	then do;
		fw = output_pt -> full_word;
		substr (fw, 19, 10) = fld;
		if q -> full_word = fw
		then goto prev;
	     end;

	if i > 0
	then goto l2;

	if output_pt -> right = adq_dl
	then s1 = 1;
	else if output_pt -> right = sbq_dl
	then s1 = -1;
	else goto l2;

	j = 0;
	if q -> right = adq_dl
	then s2 = 1;
	else if q -> right = sbq_dl
	then s2 = -1;
	else do;

/* if word before ldq has 2 in offset field, it may be
		        part of min | max macro so we'll skip the optimization */

		if addrel (q, -1) -> left = "000000000000000010"b
		then goto l2;

		j = 2;
		if q -> right = ldq_dl
		then s2 = 1;
		else if q -> right = lcq_dl
		then s2 = -1;
		else goto l2;
	     end;

/* if we are in abs  sequence, skip optimization */

	if addrel (q, -2) -> full_word = tpl_3_ic
	then go to l2;

	k = s1 * fixed (output_pt -> left, 18) + s2 * fixed (q -> left, 18);

	if k = 0
	then do;
		if j ^= 0
		then q -> full_word = ldq_0_dl;
		else do;
prev:
			output_pt = q;
			reloc_pt = addrel (reloc_pt, -1);
			sym_use_pt = addrel (sym_use_pt, -1);
			text_pos = text_pos - 1;
		     end;
		goto l3;
	     end;

	if abs (k) > 111111111111111111b
	then goto l2;

	q -> right = dl_inst (j + fixed (k > 0, 1));

	q -> left = bit (k, 18);
	goto l3;

l2:
	output_pt = addrel (output_pt, 1);
	reloc_pt = addrel (reloc_pt, 1);
	sym_use_pt = addrel (sym_use_pt, 1);
	text_pos = text_pos + 1;

l3:
	mac_pt = addrel (mac_pt, 1);
     end;

call_base_man:
     proc;

dcl	hold_perm_address	bit (1) aligned;

	cg_stat$text_pos = text_pos;

	if addressable
	then do;
		hold_perm_address = p -> reference.perm_address;
		p -> reference.perm_address = "1"b;
	     end;

	call base_man$load_var (2, p, 1);

	if addressable
	then p -> reference.perm_address = hold_perm_address;

	text_pos = cg_stat$text_pos;
	output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);

     end;

call_ma:
     proc;

	cg_stat$text_pos = text_pos;

	call m_a (p, "0"b);

	text_pos = cg_stat$text_pos;
	output_pt = addrel (cg_stat$text_base, text_pos);
	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);

     end;

set_offset:
     proc (off_val);

dcl	pt		ptr,
	off_val		fixed bin (18);

	pt = output_pt;

	if off_val >= 0
	then pt -> ic_instruction.offset = bit (off_val, 18);
	else pt -> ic_instruction.offset = bit (fixed (262144 + off_val, 18), 18);

     end;

text_ref:
     proc;

dcl	(q, s)		ptr,
	offset		fixed bin (18),
	temp		fixed bin (35);

	offset = text_pos;

	if p -> reference.defined_ref
	then s = p -> reference.qualifier;
	else s = p;
	s = s -> reference.symbol;
	if s = null
	then goto so2;
	if s -> node.type = label_node
	then goto so1;

	if s -> symbol.label
	then goto so1;
	if s -> symbol.entry
	then goto so1;
	if ^s -> symbol.constant
	then goto so;

	not_constant = "0"b;

	q = s -> symbol.initial;
	if q = null
	then goto so1;

	if p -> reference.c_offset ^= 0
	then if p -> reference.units ^= word_
	     then goto so;

	if p -> reference.forward_ref
	then q = addrel (q, inc + p -> reference.c_offset);
	else q = addrel (cg_stat$text_base, inc + fixed (substr (string (p -> reference.address), 1, 18), 18));

	const_string = q -> full_word;

	if instruction_info_$instruction_info (mop).directable
	then do;

		if eis
		then do;
			if i = 2
			then if q -> right = "0"b
			     then do;
				     output_pt -> left = q -> left;
				     substr (text_pt -> full_word, 15, 4) = "0011"b;
						/* du */
				     return;
				end;
			go to so;
		     end;

		if q -> left = "0"b
		then do;
is_dl:
			output_pt -> left = q -> right;
			output_pt -> instruction.tag = "000111"b;
						/* dl */
			return;
		     end;

		if q -> right = "0"b
		then do;
			output_pt -> left = q -> left;
			output_pt -> instruction.tag = "000011"b;
						/* du */
			return;
		     end;

		if q -> fix_bin > 0
		then goto so;

		temp = -q -> fix_bin;
		q = addr (temp);

		if (18)"0"b || q -> right ^= q -> full_word
		then goto so;

		if inst = ldq
		then inst = lcq;
		else if inst = adq
		then inst = sbq;
		else if inst = sbq
		then inst = adq;
		else if inst = lcq
		then inst = ldq;
		else goto so;

		output_pt -> instruction.op_code = inst;
		mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);
		goto is_dl;

	     end;

so:
	s -> symbol.allocate = "1"b;

so1:
	if p -> reference.forward_ref
	then do;
		if s -> symbol.location > max_obj_seg_size
		then do;
			call cg_error (333, max_obj_seg_size);
			return;
		     end;
		output_pt -> forward_ref.offset = bit (fixed (s -> symbol.location, 17), 17);
		if eis
		then do;
			output_pt -> forward_ref.eis_flag = "1"b;
			s -> symbol.location = offset + i;
			output_pt -> descriptor.char = i;
		     end;
		else s -> symbol.location = offset;
	     end;
	else do;
so2:
		call set_offset (fixed (output_pt -> ic_instruction.offset, 18) + inc - offset);
	     end;
     end;


save_temp:
     proc;

dcl	i		fixed bin (18);
dcl	mac		fixed bin (15);

/* have reference to fixed binary temp without value in storage.
	        if value is in an index register, we'll transfer it to storage
	        or the q register.  If value is in q, we'll store it unless
	        the original macro was ldfx1, in which case we have an error. */

	if p -> reference.value_in.q
	then do;
		if macro = ldfx1
		then call error315;
		else do;
			p -> reference.value_in.storage = "1"b;
			p -> reference.ref_count = p -> reference.ref_count + 1;
			call expmac (stfx1, p);
		     end;
		return;
	     end;

	if string (p -> reference.value_in.x) = "0"b
	then do;
		call error315;
		return;
	     end;

	do i = 0 to 7 while (^p -> reference.value_in.x (i));
	end;

	if macro = ldfx1
	then do;
		if p -> reference.symbol -> symbol.c_dcl_size > default_fix_bin_p
		then mac = xr18_to_q;
		else mac = xr_to_q;
		q = c_a (i, 8);			/* 0,i */
		call expmac (mac, q);
		call adjust_ref_count (p, -1);
		return;
	     end;

	p -> reference.value_in.storage = "1"b;
	p -> reference.ref_count = p -> reference.ref_count + 2;
	call expmac ((zero_mac), p);
	call expmac (sxl0 + i, p);

     end;


error315:
     proc;

	call error (315, cg_stat$cur_statement, p);

     end;

change_base_:
     procedure (insx, base);
declare	insx		fixed bin (18);
declare	base		fixed bin;
declare	k		fixed bin;
declare	q		ptr;

	if insx <= base_regs (base).changed
	then return;

	base_regs (base).changed = insx;
	base_regs (base).instruction = text_pt -> full_word;

	q = base_regs (base).variable;
	k = base_regs (base).type;
	if q = null
	then k = 0;

	if k = 1
	then q -> reference.value_in.b (base) = "0"b;
	else if k = 2
	then q -> reference.address_in.b (base) = "0"b;

	base_regs (base).type = 0;

     end change_base_;

     end;
