/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(74-01-01,Klinger), approve(), audit(), install():
      Written 1974 by Ross Klinger.
  2) change(75-08-16,Grady), approve(), audit(), install():
      Modified by Mike Grady to process -ordered_fields.
  3) change(82-05-05,GDixon), approve(), audit(), install():
      Modified by Gary Dixon to greatly extend and document the
      interface.
  4) change(83-04-17,Schimke), approve(), audit(), install():
      Modified by Dave Schimke to add linus_table entrypoint
      reorganizing the code into several internal procedures and
      add numeric sort mode.
  5) change(83-07-22,Schimke), approve(), audit(), install():
      Modified by Dave Schimke to fix bug in -to regular expression
      handling, add integer sort and replace calls to search_file_
      with calls to search_file_$silent.
  6) change(84-12-14,Lippard), approve(85-01-16,MCR7139),
     audit(85-12-16,GDixon), install(85-12-17,MR12.0-1001):
      Modified by Jim Lippard to properly initialize case_regexp
      array and properly sort numeric fields.
  7) change(86-09-16,Lippard), approve(86-09-29,MCR7551),
     audit(86-10-13,Dickson), install(86-10-17,MR12.0-1188):
      Modified to make sort_seg_$string clean up its temp segments on
      normal exit.
  8) change(87-05-08,Hergert), approve(87-05-08,MCR7671),
     audit(87-05-08,Dupuis), install(87-05-20),MR12.1-1032):
      Modified to not miss the last tuple of each component of an MSF.
                                                   END HISTORY COMMENTS */



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* Name: sort_seg_								*/
	/*									*/
	/* Subroutine for sorting segments or strings, based upon one or more sort fields within	*/
	/* sort units.								*/
	/*									*/


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* OVERVIEW OF THE SORTING PROCESS:						*/
	/*									*/
	/* Overview: Sorting is performed by dividing the input up into delimited sort strings,	*/
	/* and then blocking some number of strings (1 or more, EXCLUDING the delimiters)	*/
	/* together to form sort units.  Sorting is done by comparing these sort units, and then	*/
	/* reordering the delimited sort strings based upon the sort results.  The sort units	*/
	/* are compared by identifying one or more sort fields within each sort unit, and then	*/
	/* comparing the contents of sort fields in one unit with corresponding fields in	*/
	/* another unit.  A single sort field may encompass the entire sort unit, or only a part	*/
	/* of it.  Fields may be compared in ascending or descending order, with or without	*/
	/* sensitivity to letter case.						*/
	/*									*/
	/* To begin the sorting process, the input is divided into delimited strings, and the	*/
	/* strings are blocked into delimited units (du's), which are the sort strings and	*/
	/* delimiters blocked to form the du.  It is these delimited units which are reordered 	*/
	/* in the sorted output.						          */
	/*									*/
	/* In order to perform a comparison, the delimiter(s) must be removed from the du to	*/
	/* form an undelimited unit (uu).  Finally, the sort fields are identified in the uu,	*/
	/* and copied with optional translation to implement non_case_sensitive and descending	*/
	/* sorts.									*/
	/*									*/
	/* The du's are identified by pointer/length pairs (dup/dul) which overlay the actual	*/
	/* input.  These are stored in a pair of structures.  The uu's (du's with the delimiters	*/
	/* removed) are constructed in a temp seg (uu_str), and identified by pointer/length	*/
	/* pairs (uup/uul).  Sort fields from each uu are copied in field order into a temp	*/
	/* segment (sf_str) identified by a pointer (sfp) and a fixed length (Lall_fields).	*/
	/* Each field is translated to lowercase/inverted to implement			*/
	/* non_case_sensitive/descending comparison of a field.  Numeric fields are converted to  */
	/* float dec(59) values, then encoded as character strings for sorting.  Similarly,       */
	/* integer fields are converted to fixed bin(71) values, and then encoded as character    */
	/* strings for sorting.  This grouping of fields allows a single pass sort to perform     */
	/* multi-field comparison operations.  A stability field is added to the end of each      */
	/* group of sort fields to insure that groups having the same value appear in the output  */
	/* in their original order.           	                                                  */
          /*                                                                                        */
	/* Of course, in special cases, some of the steps above can be bypassed for efficiency.	*/
	/* In fact, the most common types of sorts can be special-cased to improve efficiency.	*/
	/* For example, when sort string delimiters are fixed-length and the blocking factor is	*/
	/* 1, there is no need to determine the dul values.  These can be computed from uul	*/
	/* plus the length of the fixed delimiter.  When blocking factor is 1, copying the	*/
	/* undelimited unit into uu_str can be avoided by treating each du minus the delimiter	*/
	/* as the undelimited unit.  Thus dup = uup, so uup need not be set.  Several other,	*/
	/* similar special cases are used to further improve efficiency when possible.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

sort_seg_:
	procedure;
	return;

    dcl	lcb_ptr                       ptr,                /* linus control block ptr for table entry (In)   */
          caller			char(*),		/* name of calling command. (In)		*/
	desc_array                    (*) ptr,            /* descriptors (or place holders) for each sort   */
						/* field for numeric sort on table entrypoint     */

	in_dir			char(*),		/* dir part of input seg pathname. (In)		*/
	in_ent			char(*),		/* entry part of input seg pathname (In)	*/
	in_ptr                        ptr,                /* pointer to the table rows structure (In)       */
	in_string			char(*),		/* input string to be sorted. (In)		*/
	out_dir			char(*),		/* dir part of output seg pathname (In)		*/
	out_ent			char(*),		/* entry part of output seg pathname (In)	*/
          out_ptr                       ptr,                /* ptr to the sorted table structure (In)         */
	out_string		char(*),		/* output string in which sorted results go. (Out)*/
	out_len			fixed bin(21),	/* length (in chars) of sorted output seg. (Out)	*/
	temp_dir                      char (*),           /* pathname of dir to be used for temp segs (In)  */
	temp_seg_mgr$get		entry (ptr, char(*), char(*), ptr, fixed bin(35)),
	temp_seg_mgr$release	entry (ptr, char(*), ptr, fixed bin(35)),
	undelim_char_index		fixed bin(21),	/* index in output of first char of an undelimited*/
						/*   string.  Any string not followed by a	*/
						/*   delimiter is treated as such an undelimited	*/
						/*   string. (Out)				*/
	code			fixed bin(35);	/* status code. (Out)			*/

    dcl	Ibk			fixed bin(21),	/* number of sort strings in this sort unit so far*/
	Ichar			fixed bin(21),
          Icomp        	          fixed bin(21),	/* index of components being sorted.              */
	Idu			fixed bin(21),	/* index in input of start of delimited sort unit	*/
	Iend			fixed bin(21),	/* index in a sort unit of last char of a field.	*/
	If			fixed bin,	/* index into field specification array.	*/
	Iline_end			fixed bin(21),
	Imatch			fixed bin(21),	/* index in input of first char matching delimiter*/
	Imatch_end		fixed bin(21),	/* index in input of last char matching delimiter */
          Imerge                        fixed bin,          /* index of the table component to be merged      */
          Iptr                          fixed bin(21),      /* row ptr index in table ptr seg                 */
	Inl			fixed bin(21),
          Iseg                          fixed bin,          /* index in array of ptr segs of table structure  */
	Isf_str			fixed bin(21),	/* index of next, unsused char in sf_str string.	*/
	Iss			fixed bin(21),	/* index in input of start of next sort string.	*/
	Istart			fixed bin(21),	/* index in a sort unit of start char of a field. */
	Its                           fixed bin,          /* index in array of saved temp segs              */
	Iu			fixed bin(21),	/* index of a sort unit.			*/
	Iu_prev			fixed bin(21),	/* index of sort unit prior to Iu (in sorted ord) */
	Iuss			fixed bin(21),	/* index in input of start of this sort string.	*/
	Iuu			fixed bin(21),	/* index in uu_str of start of next sort unit.	*/
	Iuu_str			fixed bin(21),	/* index in uu_str of next, unused character.	*/
	Ix			fixed bin(21),	/* index into idx array of sorted unit indices.	*/
	Lall_fields		fixed bin(24),	/* combined length of all sort unit fields.	*/
	Ldelim			fixed bin(21),	/* length of fixed-sized sort string delims.	*/
	Ldss			fixed bin(21),	/* length of sort string with its delimiter.	*/
	Ldu			fixed bin(21),	/* length of delimited sort unit.		*/
	Ldu_prev			fixed bin(21),	/* length of prior delimited sort unit.		*/
         (Lin, Lout)	          fixed bin(21),
	Lmatch			fixed bin(21),	/* length of part of input matching delimter.	*/
	Luss			fixed bin(21),	/* length of sort string without its delimiter.	*/
	Luu			fixed bin(21),	/* length of undelimited sort unit		*/
	Luu_str			fixed bin(21),	/* length of used portion of uu_str.		*/
	Luu_temp			fixed bin(21),	/* length of uu_temp (temp copy of uu + NL).	*/
	Ndups			fixed bin(21),	/* number of duplicate sort units in a row.	*/
	Ndups_prev		fixed bin(21),	/* value of Ndups when prev sort unit was examined*/
						/*   0 = no duplicates			*/
						/*   1 = 1 duplicate, etc			*/
	Nlines			fixed bin(21),
	Nsf_str_array		fixed bin,
    	Nu			fixed bin(24),	/* number of sort units.                          */
         (Oin, Oout)		fixed bin(21),	/* offsets of input/output strings from start of	*/
						/*   their containing segments.		*/
         (Paccess, Pin, Pout)	          ptr,
         (Pdul, Pdup, Pidx, Pout_real, Pout_temp, Psf_str, Psfa(64), Psfl, Psfp, Puu_str, Puu_temp, Puul, Puup)
				ptr,		/* ptrs to temp segments.			*/
         (Psave, Pspp, Psup, Psupo, Psppo)
                                        ptr,		/* ptrs to linus_table structures.                */
         (Pidx1, Pidx_merge, Psfp1, Psfp_merge, Psf1, Psf_merge)  
                                        ptr,		/* ptrs to merge overlays and sort fields         */

	Psf_str_array (Nsf_str_array) ptr based (addr(Psfa)),
	Screated_output_seg		bit(1),
	Sblocked			bit(1),		/* sort strings are blocked several to a sort unit*/
	Sdescending_sort		bit(1),		/* If only one sort field spanning entire unit is */
						/*   given, descending sort can be implemented	*/
						/*   most efficiently as a special case.	*/
	Sfield			bit(1),		/* sort field(s) include only part of each sort 	*/
						/*   unit, not 1 field spanning entire unit.	*/
	Snon_case_sensitive_sort	bit(1),		/* If only one sort field spanning entire unit is */
						/*   given, non_case_sensitive translating must be*/
						/*   done as special case.			*/
          Snumeric                      bit(1),             /* Are any sort modes numeric?                    */
	Soverlap			bit(1),		/* Input and output overlaps, forcing placement	*/
						/*   of sort output in a temp seg.		*/
	Stemp_dir			bit(1),		/* If temp dir is to be used for temp segs.       */
	Svarying_delimiters		bit(1),		/* A regular expression delimits records.  Since	*/
						/*   the strings matching regexp are of varying	*/
						/*   length, we must record total length of each	*/
						/*   sort unit, including its delimiters.	*/
	Svarying_fields		bit(1),		/* sort fields have varying widths.		*/
	Syes			bit(1),
         (bc_in, bc_out)		fixed bin(24),
	component_number              fixed bin,	/* index of table components                      */
          comp_base_number              bit(18),
	encd_len                      fixed bin(21),
	encd_str                      char(256),
	id			char(15) varying,
          max_Lout                      fixed bin(21);
    dcl	stable			char(4) based(addr(Iu));

    dcl	in			char(Lin) based(Pin),
	in_char (Lin)		char(1) based(Pin),
	out			char(max_Lout) based(Pout);

    dcl	1 idx			aligned based(Pidx),
	  2 N			fixed bin(24),	/* array of sorted sort unit indices.		*/
	  2 I (Nu)		fixed bin(24),
	du			char(Ldu) based(dup.P(Iu)),
	du_prev			char(Ldu_prev) based(dup.P(Iu_prev)),
	1 dup			aligned based(Pdup),/* delimited units - (as in original input)	*/
	  2 N			fixed bin(24),	/*   ptrs to original sort units including their	*/
	  2 P (Nu)		ptr unal,		/*   delimiters.				*/
	1 dul			aligned based(Pdul),/*   lengths of original sort units, including	*/
	  2 N			fixed bin(24),	/*   their delimiters.			*/
	  2 L (Nu)		fixed bin(24);
	


						/* LINUS_TABLE structures                         */
    dcl	1 idx1			aligned based (Pidx1), 
	  2 N			fixed bin(24),	/* merge sort indices                             */
	  2 I (idx1.N)
	                              fixed bin(24),

	1 idx_merge		aligned based (Pidx_merge),
	  2 N			fixed bin(24),	/* merge sort indices                             */
	  2 I (idx_merge.N)
	                              fixed bin(24),

	1 sfp1			aligned based (Psfp1),
	  2 N			fixed bin(24),	/* merge sort field overlay                       */
	  2 P (sfp1.N)
	                              ptr unal,

	1 sfp_merge		aligned based (Psfp_merge),
	  2 N			fixed bin(24),	/* merge sort field overlay                       */
	  2 P (sfp_merge.N)
	                              ptr unal,

          sf1                           char(Lall_fields) based (Psf1),
          sf_merge                      char(Lall_fields) based (Psf_merge),

          1 supo                        aligned based (Psupo),
            2 N                         fixed bin (21),	/* ptrs to the table rows.                        */
            2 P (supo.N)                ptr unal,
          1 sppo                        based (Psppo),
            2 N                         fixed bin,
            2 P (sppo.N)                ptr unal,
          1 save                        aligned based (Psave),
            2 N                         fixed bin,	/* saved ptrs for merging.                        */
            2 Nsf_strs                  fixed bin,          
            2 dup_ptr (save.N)          ptr,		/* row ptrs                                       */
            2 idx_ptr (save.N)          ptr,		/* sorted indices                                 */
            2 sfp_ptr (save.N)          ptr,		/* sort fields                                    */
            2 sf_str_ptr (save.Nsf_strs)
                                        ptr,		/* sort strings                                   */

          1 spp                         aligned based(Pspp),/* ptrs to the sup segments and msf components.   */
            2 N                         fixed bin,
	  2 M                         fixed bin,
	  2 sorted                    bit (1),     
	  2 P (spp.N)                 ptr unal,
	  2 C (spp.M)                 ptr unal,

          1 sup                         aligned based (Psup),/* ptrs to the table rows                        */
            2 N                         fixed bin (21),
            2 P (sup.N)                 ptr unal;		

	
						/* undelimited units			*/
    dcl	uu			char(uul.L(Iu)) based(uup.P(Iu)),
	uu_str			char(Luu_str) based(Puu_str),
	uu_str_char (Luu_str)	char(1) based(Puu_str),
	uu_temp                       char(Luu_temp) based (Puu_temp),
	1 uup			aligned based(Puup),/*   ptrs to blocked sort units containing 	*/
	  2 N			fixed bin(24),	/*   several sort strings without their delimiters*/
	  2 P (Nu)		ptr unal,
	1 uul			aligned based(Puul),/*   lengths of undelimited units.		*/
	  2 N			fixed bin(24),
	  2 L (Nu)		fixed bin(24),

						/* sort fields				*/
	sf			char(Lall_fields) based(sfp.P(Iu)),
	sf_ncs			char(sfl.L(Iu)) based(sfp.P(Iu)),
	sf_prev			char(Lall_fields) based(sfp.P(Iu_prev)),
	sf_str			char(max_seg_size) based(Psf_str),
						/*   string containing ordered sort fields built	*/
						/*   from all sort units.  Field groups from all	*/
						/*   units have the same length.		*/
	sf_str_char (max_seg_size)	char(1) based(Psf_str),
	1 sfp			aligned based(Psfp),/*   ptrs to sort fields from each unit.	*/
	  2 N			fixed bin(24),
	  2 P (Nu)		ptr unal,
	1 sfl			aligned based(Psfl),
	  2 N			fixed bin(24),
	  2 L (Nu)		fixed bin(24);

    dcl	search_file_$silent		entry (ptr, fixed bin(21), fixed bin(21), ptr, fixed bin(21),
				     fixed bin(21), fixed bin(21), fixed bin(21), fixed bin(35)),
	sort_items_indirect_$adj_char	entry (ptr, ptr, ptr),
	sort_items_indirect_$char	entry (ptr, ptr, fixed bin(24));

    dcl	AZ			char(26) int static options(constant)
				     init("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
	NL			char(1) int static options(constant) init("
"),
	ZERO			char(1) int static options(constant) init("0"),
	az			char(26) int static options(constant)
				     init("abcdefghijklmnopqrstuvwxyz");

    dcl  (addr, baseno, bin, charno, currentsize, dim, divide, fixed, floor, index,
	length, max, min, mod, null, rtrim, substr, sum, translate, unspec)
				builtin,
	cleanup			condition,
	conversion	          condition;

    dcl	access_$reset		entry (ptr, fixed bin(35)),
	access_$set_temporarily	entry (char(*), char(*), fixed bin(2), bit(*), ptr, fixed bin(35)),
	command_query_$yes_no	entry() options (variable),
	hcs_$delentry_seg		entry (ptr, fixed bin(35)),
	hcs_$make_seg		entry (char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35)),
	initiate_file_		entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35)),
	ioa_			entry options(variable),
	sub_err_			entry() options(variable),
	terminate_file_		entry (ptr, fixed bin(24), bit(*), fixed bin(35));

    dcl  (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant),
          1 FIXED_BIN_71_DESC	          aligned int static options (constant),
	  2 version 	          bit(1) unal init("1"b),
	  2 type		          fixed bin(6) unsigned unal init(1),
	  2 packed	          bit(1) unal init("0"b),
	  2 dimension	          bit(4) unal init("0"b),
	  2 scale		          fixed bin(11) unal init(0),
	  2 precision	          fixed bin(11) unal init(71),
    	1 FLOAT_DEC_59_DESC	          aligned int static options (constant),
	  2 version 	          bit(1) unal init("1"b),
	  2 type		          fixed bin(6) unsigned unal init(10),
	  2 packed	          bit(1) unal init("0"b),
	  2 dimension	          bit(4) unal init("0"b),
	  2 scale		          fixed bin(11) unal init(0),
	  2 precision	          fixed bin(11) unal init(59),
	SEGMENT			fixed bin(2) int static options(constant) init(1),
          STRING                        fixed bin(2) int static options (constant) init(2),
          TABLE                         fixed bin(2) int static options (constant) init(3),
	Sdebug			bit(1) int static init("0"b),
         (error_table_$bad_conversion,
	error_table_$chars_after_delim,
	error_table_$file_is_full,
	error_table_$moderr,
	error_table_$no_delimiter,
	error_table_$nomatch,	
	error_table_$no_w_permission,
	error_table_$noentry,
	error_table_$out_of_bounds,
	error_table_$unimplemented_version,
	error_table_$zero_length_seg) fixed bin(35) ext static,
          max_ptrs_per_seg              fixed bin(21) int static init(0),
	max_seg_size		fixed bin(21) int static init(0),
	sys_info$max_seg_size	fixed bin(35) ext static;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


seg:	entry (caller, ss_info_ptr, in_dir, in_ent, out_dir, out_ent,
	       out_len, undelim_char_index, code);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This entry point sorts segments.						*/
	/*									*/
	/* Overview:								*/
	/* 1) Initialize output arguments.						*/
	/* 2) Establish cleanup on unit to terminate segments, restore any changed ACLs, etc.	*/
	/* ORDER OF REMAINING OPERATIONS IS IMPORTANT---					*/
	/* 3) Try to initiate an existing output segment.  If found without access, ask user if	*/
	/*    access should be temporarily changed to allow the sort to occur.  If segment not	*/
	/*    found, create it but mark it for possible deletion should sort fail for other	*/
	/*    reasons.  Note that, when the output seg replaces the input seg, forcing access	*/
	/*    may make it easier to sort the input segment to which you normally have no access.	*/
	/*    In this case, it is important to initiate the output segment first, because we only	*/
	/*    change access for output segment, never for input segment.			*/
	/* 4) Initiate the input segment.						*/
	/* 5) Invoke internal procedures prepare_to_sort and sort to do the actual sorting.       */
          /* 6) If sort succeeds, invoke internal procedure output to prepare the output segment.   */
	/* 7) If sort succeeds, truncate, set bit count and terminate output segment.  If it      */
          /*    fails, terminate (or delete if we created) the output segment.  Also, terminate     */
          /*    input and restore any ACL changes.                                        	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	out_len = 0;				/* Initialize output args.			*/
	undelim_char_index = 0;

	Pin = null;				/* Handle unexpected release.			*/
	Pout = null;
	Paccess = null;
	Screated_output_seg = FALSE;
	Stemp_dir = FALSE;

	Pidx = null;				/* Be prepared to cleanup temp segments.           */
          Soverlap = FALSE;
	Pdup, Pdul = null;
	Nsf_str_array = dim(Psfa,1);
	Psf_str_array(*), Psf_str, Psfp, Psfl = null;
	Nsf_str_array = 1;
	Puu_str, Puup, Puul, Puu_temp = null;
	Pout_temp = null;
	Pout_real = null;
	on cleanup call seg_janitor(TERM_FILE_TERM, Screated_output_seg);

RE_INIT_OUTPUT:					/* Initiate output segment.			*/
	call initiate_file_ (out_dir, out_ent, W_ACCESS, Pout, bc_out, code);

	if code = error_table_$no_w_permission |
	   code = error_table_$moderr then do;		/*   It exists, but caller cannot access it.	*/
	   call command_query_$yes_no (Syes, code, caller,
"Should ^a temporarily set read/write access on the sort output segment
^s(^a^[>^]^a)^[^/^; ^]to allow sorting to proceed?", "^sDo you want to set write access
on sort output segment^[^/^; ^](^a^[>^]^a)^s?", caller,
	      length("to allow sorting to proceed") + length(rtrim(out_dir)) +
	      length(">") + length(rtrim(out_ent)) + length("()?") > 76,
	      out_dir, out_dir^=">", out_ent,
	      length("to allow sorting to proceed") + length(rtrim(out_dir)) +
	      length(">") + length(rtrim(out_ent)) + length("()?") > 76);
	   if ^Syes then go to SEG_EXIT;
	   call access_$set_temporarily (out_dir, out_ent, SEGMENT, RW_ACCESS, Paccess, code);
	   if code = 0 then go to RE_INIT_OUTPUT;
	   call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
	      "While temporarily setting access on output segment^/(^a^[>^]^a).", out_dir, out_dir^=">", out_ent);
	   go to SEG_EXIT;
	   end;

	if code = error_table_$noentry then do;		/*   It does not exist.  Create it.		*/
	   Screated_output_seg = TRUE;
	   call hcs_$make_seg (out_dir, out_ent, "", RW_ACCESS_BIN, Pout, code);
	   if Pout ^= null then code = 0;
	   end;
	if code ^= 0 then do;			/*   Error during creation/initiation.		*/
	   call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
	      "While ^[creating^;initiating^] the sort output segment^/(^a^[>^]^a).",
	      Screated_output_seg,  out_dir, out_dir^=">", out_ent);
	   go to SEG_EXIT;
	   end;
	max_Lout = sys_info$max_seg_size * 4;

	call initiate_file_ (in_dir, in_ent, R_ACCESS, Pin, bc_in, code);
	if code ^= 0 then do;			/* Initiate input segment.			*/
	   call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
	      "While initiating input segment^/(^a^[>^]^a).", in_dir, in_dir^=">", in_ent);
	   go to SEG_EXIT;
	   end;
	Lin = divide(bc_in, 9, 21, 0);

	call prepare_to_sort(SEGMENT);		/* This internal procedure does the scan work.	*/
	if code ^= 0 then goto SEG_EXIT;

	call sort(SEGMENT);				/* This internal procedure does the sort work.	*/
	if code ^= 0 then goto SEG_EXIT;

	call output();				/* This internal procedure prepares the output.   */
	if code ^= 0 then goto SEG_EXIT;
	call seg_janitor (TERM_FILE_TRUNC_BC_TERM, FALSE);
	return;

SEG_EXIT:	call seg_janitor(TERM_FILE_TERM, Screated_output_seg);
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


sort_seg_$string:
	entry (caller, ss_info_ptr, in_string, out_string, out_len,
	       undelim_char_index, code);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This entry point sorts strings.						*/
	/*									*/
	/* Overview:								*/
	/* 1) Initialize output arguments.						*/
	/* 2) Set input and output pointers to identify the input/output character strings parms. */
          /* 3) Establish cleanup on unit to release temp segments used for sorting.                */
	/* 4) Invoke internal prepare_to_sort procedure to scan the input string.		*/
	/* 5) Invoke internal sort procedure to do actual sorting.				*/
	/* 6) Invoke internal output procedure to prepare the output.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	out_len = 0;
	undelim_char_index = 0;
	code = 0;

	Pin = addr(in_string);
	Lin = length(in_string);
	Pout = addr(out_string);
	max_Lout = length(out_string);
	Stemp_dir = FALSE;

	Pidx = null;				/* Be prepared to cleanup temp segments.	*/
          Soverlap = FALSE;
	Pdup, Pdul = null;
	Nsf_str_array = dim(Psfa,1);
	Psf_str_array(*), Psf_str, Psfp, Psfl = null;
	Nsf_str_array = 1;
	Puu_str, Puup, Puul, Puu_temp = null;
	Pout_temp = null;
	Pout_real = null;
	on cleanup call sort_janitor();

	call prepare_to_sort (STRING);
	if code ^= 0 then goto STRING_EXIT;
	call sort (STRING);
	if code ^= 0 then goto STRING_EXIT;
	call output;

STRING_EXIT:
	call sort_janitor();
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

linus_table:
	entry (lcb_ptr, caller, ss_info_ptr, temp_seg_mgr$get, temp_seg_mgr$release, 
               temp_dir, in_ptr, desc_array, out_ptr, code);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This entry point sorts the linus table structure.				*/
	/*									*/
	/* Overview:								*/
	/* 1) Scan input into individual components to be sorted.                                 */
	/* 2) Establish cleanup on unit to release saved sort results used for merging.           */
	/* 3) Sort the individual components.                                                     */
	/* 4) Merge the resulting sorted components.                                              */
          /* 5) Cleanup.                                                                            */
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	code = 0;
	if temp_dir = "" then Stemp_dir = FALSE;
	else Stemp_dir = TRUE;

	Pout, Pin = null;				/* Just to keep the common code happy.            */
	Psave = null;				/* Handle unexpected release.			*/

	component_number = 0;
	Pidx = null;				/* Be prepared to cleanup temp segments.          */
          Soverlap = FALSE;
	Pdup, Pdul = null;
	Nsf_str_array = dim(Psfa,1);
	Psf_str_array(*), Psf_str, Psfp, Psfl = null;
	Nsf_str_array = 1;
	Puu_str, Puup, Puul, Puu_temp = null;
	Pout_temp = null;
	Pout_real = null;
 	on cleanup call table_janitor ();
	
	Pspp = in_ptr;
	Psppo = out_ptr;
	id = rtrim(caller) || " ";
	if ^get_temp_seg (id, "saved sort ptrs", Psave) then goto TABLE_EXIT;
						/* save temp seg                                  */ 
  	save.N = spp.M;				
	save.Nsf_strs = 0;

	do Icomp = 1 to spp.M;
	   save.idx_ptr(Icomp) = null;
	   save.sfp_ptr(Icomp) = null;
	   save.dup_ptr(Icomp) = null;
	   component_number = Icomp;
	   call prepare_to_sort (TABLE);
	   if code ^= 0 then goto TABLE_EXIT;
	   call sort (TABLE);			/* This internal procedure does the sort           */
	   if code ^= 0 then goto TABLE_EXIT;		/* work for one segment's worth of rows.           */

	   save.dup_ptr(Icomp) = Pdup;		/* save sort info for merging                      */
	   Puup = null;
	   Pdup = null;
	   save.idx_ptr(Icomp) = Pidx;
 	   Pidx = null;
	   save.sfp_ptr(Icomp) = Psfp;
	   Psfp = null;
	   addr(save.sf_str_ptr(save.Nsf_strs +1)) -> Psf_str_array = Psf_str_array;
	   save.Nsf_strs = save.Nsf_strs + dim(Psf_str_array, 1);
	   Psf_str_array = null;
	   Psf_str = null;
	   call sort_janitor();
	   end;
        
	if spp.M = 1 then do;			/* short cut if we don't have an msf               */
	   Psupo = sppo.P(1);
	   Pdup = save.dup_ptr(1);
	   Pidx = save.idx_ptr(1);
	   supo.N, Nu = dup.N;
	   do Iu = 1 to supo.N;
	      supo.P (Iu) = dup.P (idx.I(Iu));
	      end;
	   end;

	else call merge;				/* Here is the work of merging the                 */
						/* sorted components                               */

TABLE_EXIT:
	call table_janitor;

	return;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* These two entry points turn special debugging code on/off.  It is off by default.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

debug_on:
dbn:	entry();

	Sdebug = TRUE;
	return;

debug_off:
dbf:	entry();

	Sdebug = FALSE;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
	/*								        */
	/* I N T E R N A L   P R O C E D U R E S				        */
	/*								        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


prepare_to_sort:	proc (type );

    dcl   type                          fixed bin (2);	/* 1=seg,2=string,3=linus_table                   */
    dcl   found                         bit(1);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* INITIALIZATION:								*/
	/* 1) Check version of sort_seg_info structure.					*/
	/* 2) Check for empty input string.						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if max_seg_size = 0 then max_seg_size = sys_info$max_seg_size*4; 

	if ss_info.version ^= SS_info_version_1 then do;	/* Validate info structure version.		*/
	   code = error_table_$unimplemented_version;
	   call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
	      "sort_seg_ does not implement version ^a of the ss_info structure
(see sort_seg_info.incl.pl1).  It expects version ^a instead.",
	      ss_info.version, SS_info_version_1);
	   return;
	   end;

          if type ^= TABLE then if length (in) = 0 then do;	/* Check for no input to be sorted.		*/
	   if type  = SEGMENT then do;		
	      code = error_table_$zero_length_seg;
	      call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
	         "The sort input segment is empty^/(^a^[>^]^a).",
	         in_dir, in_dir^=">", in_ent);
	      end;
	   return;
	   end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK INPUTS:								*/
	/* 1) Check for input string/seg overlapping output string/seg.  This condition requires	*/
	/*    that a temp seg be used for preparing the output.  The output is then  copied from	*/
	/*    the temp seg into the output string/seg.					*/
	/* 2) Examine ss_info to determine various sorting cases, including--			*/
	/*    Svarying_delimiters = are sort string delimiters varying length or fixed length?	*/
	/*    Sblocked = do sort units consist of several sort strings, or just one?		*/
	/*    Snumeric = is any sort field a numeric sort?			          */
	/*    Sfield = are one or more specific sort fields identified, or is each sort unit	*/
	/*	     treated as the only sort field?					*/
	/*    Sdescending_sort = if each sort unit is the sort field, is the sort a descending	*/
	/*		     sort?						*/
	/*    Snon_case_sensitive_sort = if each sort unit is the sort field, is the sort	*/
	/*			   non_case_sensitive?				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if type = TABLE then Soverlap = FALSE;
	else if baseno(addr(in)) = baseno(addr(out)) then do;
	   Oin = charno (addr(in));			/* Check for input overlapping output storage.	*/
	   Oout = charno (addr(out));
	   if Oin < Oout then 
	      Soverlap = Oin + length(in) > Oout;
	   else if Oin > Oout then
	      Soverlap = Oout + length(out) > Oin;
	   else
	      Soverlap = TRUE;
	   end;
	else  Soverlap = FALSE;

	Svarying_delimiters = (ss_info.delim.type = SS_reg_exp);
						/* Do sort string delimiters have varying length? */
	Sblocked = ss_info.block_size > 1;		/* Is each sort unit composed of several strings? */
          Snumeric = FALSE;
	do If = 1 to ss_info.field_count;		/* Is any field a numeric sort field?             */
	   if ss_info.field(If).modes.numeric | ss_info.field(If).modes.integer then Snumeric = TRUE;
	   end;
	Sfield = TRUE;				/* Is the only field composed of the entire sort  */
	Sdescending_sort = FALSE;			/*   unit?  If so, descending and 		*/
	Snon_case_sensitive_sort = FALSE;		/*   non_case_sensitive sorts must be 		*/
	if ^Snumeric then				/*   special-cased, unless the sort is numeric or */
	   if ss_info.field_count = 1 then		/*   integer.				*/
	      if ss_info.field(1).from.type = SS_index &
	         ss_info.field(1).from.number = 1 &
	         ss_info.field(1).to.type = SS_length &
	         ss_info.field(1).to.number = -1 then do;
	         Sfield = FALSE;
	         Sdescending_sort = ss_info.field(1).modes.descending;
	         Snon_case_sensitive_sort = ss_info.field(1).modes.non_case_sensitive;
	         end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
	/*								        */
	/* GET TEMP SEGMENTS:						        */
	/*								        */
	/* Obtain temp segments to hold the various arrays described in the "OVERVIEW OF THE    */
	/* SORTING PROCESS" comment.						        */
	/*								        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	   
	id = rtrim(caller) || " ";			/* Get necessary temp segments.		*/
						/* required temp segments.			*/
	if ^get_temp_seg (id, "sort indices", Pidx) then goto PREPARE_EXIT;
	if ^get_temp_seg (id, "delim unit ptrs", Pdup) then goto PREPARE_EXIT;
	if ^get_temp_seg (id, "undelim unit lths", Puul) then goto PREPARE_EXIT;

	if Sblocked | Svarying_delimiters then 
	   if ^get_temp_seg (id, "delim unit lths", Pdul) then goto PREPARE_EXIT;
	if Sblocked then do;			/*   sort units without string delimiters	*/
	   if ^get_temp_seg (id, "undelim unit strs", Puu_str) then goto PREPARE_EXIT;
	   if ^get_temp_seg (id, "undelim unit ptrs", Puup) then goto PREPARE_EXIT;
	   end;

	if Sfield | Snon_case_sensitive_sort then do;	/*   combined sort fields for each unit		*/
	   if ^get_temp_seg (id, "sort field strs", Psf_str) then goto PREPARE_EXIT;
	   Psf_str_array(Nsf_str_array) = Psf_str;
	   if ^get_temp_seg (id, "sort field ptrs", Psfp) then goto PREPARE_EXIT;
	   end;

	if Snon_case_sensitive_sort then do;
	   if ^get_temp_seg (id, "sort field lths", Psfl) then goto PREPARE_EXIT;
	   end;
        

	if Soverlap then do;
	   if ^get_temp_seg (id, "temp output seg", Pout_temp) then goto PREPARE_EXIT;
	   Pout_real = Pout;
	   Pout = Pout_temp;
	   end;

	if type = TABLE then do;			/* Instead of SCANNING                            */


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
	/*								        */
	/* PREPARE COMPONENT:						        */
	/* 1) Step through the row ptrs looking for segment changes.		        */
	/* 2) Put row ptrs into dup.p and set uul.l				        */
	/*								        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	   code = 0;
	   Nu = 0; 
	   comp_base_number = baseno (spp.C(component_number));
	   if spp.sorted then do;			/* NORMAL CASE: search all ptrs for matches        */
	      do Iseg = 1 to spp.N;
	         Psup = spp.P(Iseg);
	         do Iptr = 1 to sup.N;
		  if comp_base_number = baseno (sup.P(Iptr)) then do;
		     Nu = Nu + 1;
		     dup.P(Nu) = sup.P(Iptr);
		     uul.L(Nu) = ss_info.delim.number;
		     end;
		  end;
	         end;
	      end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
	/*								        */
	/*  SPECIAL CASE: If the table wasn't previously sorted we can	                  */
	/*                expect all component ptrs to be contiguous.		        */
	/*								        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	   else do;				/* SPECIAL CASE: contiguous ptrs                   */
	      found = FALSE;
	      do Iseg = 1 to spp.N;
	         Psup = spp.P(Iseg);
	         do Iptr = 1 to sup.N;
		  if comp_base_number = baseno (sup.P (Iptr)) then do;
		     Nu = Nu + 1;
		     dup.P(Nu) = sup.P(Iptr);
		     uul.L(Nu) = ss_info.delim.number;
		     found = TRUE;
		     end;
		  else if found then goto LOOP_EXIT;
		  end;
	         end;
LOOP_EXIT:      end;

	   dup.N, uul.N = Nu;
	   return;
	   end;					/* TABLE                                          */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* SCANNING:								*/
	/* 1) Scan input into sort strings.						*/
	/* 2) Block strings into sort units						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Nu = 0;					/* No sort units found so far.		*/
	Iss = 1;					/* First sort string begins a char 1 of input.	*/

	Idu = 1;					/* Initialize index/length pairs for du and uu.	*/
	Ldu = 0;
	Iuu = 1;
	Luu = 0;

	Iuu_str = 1;				/* Initialize index/length pair for uu_str temp	*/
	Luu_str = max_seg_size;

	do while (Iss <= length(in));			/* Scan until input is exhausted.		*/
	   do Ibk = 1 to ss_info.block_size while (Iss <= length(in));
						/* Block scanned sort strings into sort units.	*/
	      Iuss = Iss;
	      go to FIND_DELIM(ss_info.delim.type);	/* Do scanning by delimiter type.		*/

FIND_DELIM(1):  if (Iss-1)+ss_info.delim.number > length(in) then
	         go to UNDELIM_CHARS;			/* Fixed length sort strings.  Check for last	*/
	      Ldss, Luss = ss_info.delim.number;	/*   sort string being too short.		*/
	      Iss = Iss + ss_info.delim.number;
	      go to END_FIND_DELIM;
						
FIND_DELIM(3):  Imatch = index (substr(in, Iss), ss_info.delim.string);
	      if Imatch = 0 then go to UNDELIM_CHARS;	/* Sort strings delimited by char strings.	*/
	      Luss = Imatch-1;
	      Ldss = Luss + length(ss_info.delim.string);
	      Iss = (Iss-1) + Imatch + length(ss_info.delim.string);
	      go to END_FIND_DELIM;

FIND_DELIM(4):  call search_file_$silent (addr(substr(ss_info.delim.string,1)), 1,
	         length(ss_info.delim.string),		/* Sort strings delimited by reg exp.		*/
	         addr(in), Iss, length(in),
	         Imatch, Imatch_end, code);
	      if code = 0 then do;
	         Lmatch = Imatch_end - Imatch + 1;
	         if substr(ss_info.delim.string, length(ss_info.delim.string),1) = "$" then
		   Lmatch = Lmatch + 1;
	         Luss = Imatch - Iss;
	         Ldss = Luss + Lmatch;
	         Iss = Imatch + Lmatch;
	         go to END_FIND_DELIM;
	         end;
	      else if code = error_table_$nomatch then do;
	         code = 0;
	         go to UNDELIM_CHARS;
	         end;
	      else do;
	         call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		  "Invalid syntax in regular expression:  -delimiter /^a/",
		  ss_info.delim.string);
	         go to PREPARE_EXIT;
	         end;

END_FIND_DELIM: Ldu = Ldu + Ldss;
	      Luu = Luu + Luss;
	      if Sblocked then do;
	         substr(uu_str, Iuu_str, Luss) = substr(in, Iuss, Luss);
	         Iuu_str = Iuu_str + Luss;
	         end;
	      end;
	   
	   Nu = Nu + 1;
	   dup.P(Nu) = addr(in_char(Idu));
	   uul.L(Nu) = Luu;
	   if Sblocked | Svarying_delimiters then
	      dul.L(Nu) = Ldu;
	   if Sblocked then do;
	      uup.P(Nu) = addr(uu_str_char(Iuu));
	      Iuu = Iuu + Luu;
	      end;
	   Idu = Idu + Ldu;
	   Ldu, Luu = 0;
	   end;

UNDELIM_CHARS:					/* Check for input chars beyond last sort string. */
	if Iss ^= length(in) + 1 then do;		/* This is undelimited input which will remain	*/
	   undelim_char_index = Iss;			/* at end of sorted results.			*/
	   Iline_end = 0;
	   do Nlines = 0 by 1 while (Iline_end < Iss);
	      Inl = index(substr(in,Iline_end+1), NL);
	      if Inl = 0 then
	         Inl = length(in) - Iline_end;
	      Iline_end = Iline_end  + Inl;
	      end;
	   Ichar = Iss - (Iline_end - Inl);
	   if Soverlap then do;
	      call command_query_$yes_no (Syes, error_table_$chars_after_delim,
	         caller, "The sort input ^[segment^;string^] does not end with a sort delimiter.
Instead, characters beginning on line ^d^[ (character ^d)^;^s^] follow
the final delimiter in the sort ^[segment
(^a^[>^]^a)^;string^3s^]." || "
Answer yes if you want to proceed with the sort.  The characters
following the final delimiter will remain at the end of the sorted results.
Proceed with the sort?", "
^sCharacters on line ^d^[ (character ^d)^;^s^] follow final sort delimiter.
Do you still want to sort the ^[segment^;string^]?", (type  = SEGMENT), Nlines,
	         Ichar>1, Ichar, (type  = SEGMENT), in_dir, in_dir^=">", in_ent);
	      if ^Syes then do;
	         code = error_table_$chars_after_delim;
	         go to PREPARE_EXIT;
	         end;
	      end;
	   else do;
	      call sub_err_ (error_table_$chars_after_delim, caller, ACTION_DEFAULT_RESTART, null, 0, "
Warning: Characters on line ^d^[ (character ^d)^;^s^] follow final sort delimiter.
These characters will appear at end of sorted results.  Sorting continues^[
(^a^[>^]^a)^;^3s^].",
	         Nlines, Ichar>1, Ichar, (type  = SEGMENT),
	         in_dir, in_dir^=">", in_ent);
	      end;
	   end;
	if Nu = 0 then do;
	   code = error_table_$no_delimiter;
	   call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
	      "No sorting delimiters were found in sort input ^[segment
(^a^[>^]^a).^;string.^]", (type  = SEGMENT), in_dir, in_dir^=">", in_ent);
	   go to PREPARE_EXIT;
	   end;

PREPARE_EXIT:
        if code ^= 0 then call sort_janitor;
        return;
        end prepare_to_sort;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

sort:	proc (type);
    dcl	Lfield (ss_info.field_count+1)		/* length of each field in the sort unit.	*/
				fixed bin(21),
	case_regexp (ss_info.field_count)		/* regexp case for -to regexpr handling           */
				fixed bin,
	case_field (ss_info.field_count)		/* sort type case for sort mode handling           */
				fixed bin,
          type                          fixed bin (2);	/* 1=seg,2=string,3=linus_table                   */

		
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* GENERALIZING THE SPECIAL CASES:						*/
	/* 1) When not blocked (ie, block_count = 1), the uu ptrs = the du ptrs and the uu_str	*/
	/*    overlays the input.							*/
	/* 2) When not blocked and fixed-length delimiters, the du lengths = the uu lengths plus	*/
	/*    the fixed-length of the delimiter.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if ^Sblocked then Puup = Pdup;
	else Luu_str = Iuu_str - 1;

	if ^(Sblocked | Svarying_delimiters) then do;	/* This code can never be entered for SS_regexp	*/
	   Pdul = Puul;				/*   type delimiters			*/
	   if ss_info.delim.type = SS_length then	/* For fixed-length sort strings, there is no	*/
	      Ldelim = 0;				/*   special delimiting character.		*/
	   else					/* For fixed string delimiter (SS_string type),	*/
	      Ldelim = length (ss_info.delim.string);	/*   length of delimiter is fixed and must be	*/
	   end;					/*   added to dul.L values.			*/
	else Ldelim = 0;				/* For regular expression delimiters (SS_reg_exp	*/
						/*   type), the length of delimiter is already	*/
						/*   included in dul values.			*/


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* SPECIAL-CASED FIELD PROCESSING:						*/
	/* 1 field, which equals the entire sort unit, with non_case_sensitive sorting--	*/
	/* 1) Copy each uu into the sf_str temp, translating to lowercase as you go.		*/
	/* 2) Add a sort stability field to the end of each copied unit.  The stability field is	*/
	/*    simply the unit number, treated as a character string.			*/
	/* 3) Set sf ptr/len pair (sfp/sfl)						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Snon_case_sensitive_sort then do;
	   Isf_str = 1;
	   do Iu = 1 to Nu;
	      sfl.L(Iu) = length(uu) + length(stable);
	      if (Isf_str-1) + sfl.L(Iu) > max_seg_size then do;
	         Nsf_str_array = Nsf_str_array + 1;
	         if ^get_temp_seg (id, "sort field strs", Psf_str) then goto SORT_EXIT;
	         Psf_str_array(Nsf_str_array) = Psf_str;
	         Isf_str = 1;
	         end;
(nostrz,nostrg,nosize,nosubrg):			/* prefixes due to bug in PL/I                     */
	      sfp.P(Iu) = addr(sf_str_char(Isf_str));
	      substr(sf_ncs,1,length(uu)) = translate (uu, az, AZ);
	      substr(sf_ncs, length(uu)+1) = stable;
	      Isf_str = Isf_str + length(sf_ncs);
	      end;
	   end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* NORMAL FIELD PROCESSING:							*/
	/* Several fields, or 1 field which does NOT span the entire sort unit--		*/
	/* 1) Determine whether all of the sort fields are fixed length.			*/
	/* 2) If so, compute the length of all sort fields, including a stability field.	*/
          /*    (For numeric/integer fields, call encode numeric to determine the field length.)    */
	/*    Store in  Lall_fields.							*/
	/* 3) If not, scan each sort unit to compute length of sort fields for that unit.  For    */
          /*    numeric fields, call encode numeric to determine the encoded length of the field.   */
	/*    Then length of all sort fields is sum of max of sort field lengths for each unit.   */
	/*    Put in Lall_fields.							*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* Initialize case_regexp array. */
	do If = 1 to ss_info.field_count;
	     if ss_info.field(If).to.string = "$" then
		case_regexp(If) = 1;
	     else if length (ss_info.field(If).to.string) = 0 then
		case_regexp(If) = 4;
	     else if substr(ss_info.field(If).to.string, length(ss_info.field(If).to.string), length("$")) = "$"
		then do;
		     if ^Sblocked & ss_info.delim.type = SS_string
			& ss_info.delim.string = NL then
			case_regexp(If) = 2;
		     else do;
			case_regexp(If) = 3;
			if Puu_temp = null then if ^get_temp_seg (id, "undelim temp strs", Puu_temp) then goto SORT_EXIT;
		     end;
		end;
		else 
		     case_regexp(If) = 4;
	     end;

	if Sfield then do;
	   Svarying_fields = FALSE;
	   do If = 1 to ss_info.field_count while (^Svarying_fields);
	      if ss_info.field(If).to.type = SS_length then
	         if ss_info.field(If).to.number = -1 then Svarying_fields = TRUE;
	         else;
	      else if ss_info.field(If).to.type = SS_index then
	         if ss_info.field(If).from.type = SS_index then;
	         else Svarying_fields = TRUE;
	      else Svarying_fields = TRUE;
	      end;
	   if ^Svarying_fields then do;
	      do If = 1 to ss_info.field_count;		/* compute length of each sort field in units.	*/
	         if ss_info.field(If).modes.numeric then do;
 		  if type  = TABLE then call encode_numeric (addr(ZERO), length(ZERO), desc_array(If),
		     addr(encd_str), Lfield(If), code);
		  else call encode_numeric (addr(ZERO), length(ZERO), addr(FLOAT_DEC_59_DESC),
		     addr(encd_str), Lfield(If), code);
		  end;
	         else if ss_info.field(If).modes.integer
		  then call encode_numeric (addr(ZERO), length(ZERO), addr(FIXED_BIN_71_DESC),
		  addr(encd_str), Lfield(If), code);
	         else if ss_info.field(If).to.type = SS_length then
		  Lfield(If) = ss_info.field(If).to.number;
	         else
		  Lfield(If) = ss_info.field(If).to.number -
		     ss_info.field(If).from.number + 1;
	         end;
	      Lfield(If) = length(stable);		/* Include 4 char field for a sort unit number	*/
	      Lall_fields = sum(Lfield);		/*   to force the sort to be stable.		*/
	      end;
	   else do;				/* Because some sort fields have varying lengths	*/
						/* depending upon sort unit contents, we must go	*/
						/* to the expense of pre-scanning all sort units	*/
						/* to determine longest instance of each field.	*/
	      Lfield(*) = 0;
	      do Iu = 1 to Nu;
	         do If = 1 to ss_info.field_count;
		  if ss_info.field(If).modes.numeric then do;
		     if type = TABLE then call encode_numeric (addr(ZERO), length(ZERO), desc_array(If),
		        addr(encd_str), Lfield(If), code);
		     else call encode_numeric (addr(ZERO), length(ZERO), addr(FLOAT_DEC_59_DESC),
		        addr(encd_str), Lfield(If), code);
		     if case_regexp (If) = 2 then uul.L(Iu) = uul.L(Iu) + length(NL);
		     go to LTH_EMPTY_FIELD;
		     end;
		  else if ss_info.field(If).modes.integer then do;
		     call encode_numeric (addr(ZERO), length(ZERO), addr(FIXED_BIN_71_DESC),
		        addr(encd_str), Lfield(If), code);
		     if case_regexp (If) = 2 then uul.L(Iu) = uul.L(Iu) + length(NL);
		     go to LTH_EMPTY_FIELD;
		     end;
		  else go to LTH_FROM_FIELD(ss_info.field(If).from.type);

LTH_FROM_FIELD(2):	  Istart = ss_info.field(If).from.number;
		  go to END_LTH_FROM_FIELD;

LTH_FROM_FIELD(3):	  Istart = index (uu, ss_info.field(If).from.string);
		  if Istart = 0 then go to LTH_EMPTY_FIELD;
		  Istart = Istart + length(ss_info.field(If).from.string);
		  go to END_LTH_FROM_FIELD;

LTH_FROM_FIELD(4):	  call search_file_$silent (addr(substr(ss_info.field(If).from.string,1)),
		     1, length(ss_info.field(If).from.string),
		     addr(uu), 1, length(uu),
		     Istart, Imatch_end, code);
		  if code = 0 then do;
		     Lmatch = Imatch_end - Istart + 1;
		     Istart = Istart + Lmatch;
		     go to END_LTH_FROM_FIELD;
		     end;
		  else if code = error_table_$nomatch then do;
		     code = 0;
		     go to LTH_EMPTY_FIELD;
		     end;
		  else do;
		     call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		        "Invalid syntax in regular expression:  -field -from /^a/",
		        ss_info.field(If).from.string);
		     go to SORT_EXIT;
		     end;

END_LTH_FROM_FIELD:	  if Istart > length(uu) then go to LTH_EMPTY_FIELD;
		  go to LTH_TO_FIELD(ss_info.field(If).to.type);

LTH_TO_FIELD(1):	  if ss_info.field(If).to.number = -1 then
		     Iend = length(uu);
		  else
		     Iend = min (length(uu), (Istart-1) + ss_info.field(If).to.number);
		  go to END_LTH_TO_FIELD;

LTH_TO_FIELD(2):	  Iend = min(ss_info.field(If).to.number, length(uu));
		  go to END_LTH_TO_FIELD;

LTH_TO_FIELD(3):	  Iend = index (substr(uu,Istart), ss_info.field(If).to.string);
		  if Iend = 0 then go to LTH_EMPTY_FIELD;
		  Iend = Iend + (Istart-1) - 1;
		  go to END_LTH_TO_FIELD;

LTH_TO_FIELD(4):	  go to LTH_TO_REGEXP (case_regexp(If));

LTH_TO_REGEXP(1):	  Iend = length(uu);
		  go to END_LTH_TO_FIELD;

LTH_TO_REGEXP(3):     Luu_temp = uul.L(If);
		  uu_temp = uu;
		  Luu_temp = Luu_temp + length(NL);
		  substr (uu_temp, length(uu_temp), length(NL)) = NL;
		  call search_file_$silent (addr(substr(ss_info.field(If).to.string,1)),
		     1, length(ss_info.field(If).to.string), addr(uu_temp),
		     Istart, length(uu_temp), Iend, Imatch_end, code);
		  go to END_LTH_TO_REGEXP;
  	  
LTH_TO_REGEXP(2):     uul.L(Iu) = uul.L(Iu) + length(NL);
LTH_TO_REGEXP(4):	  call search_file_$silent (addr(substr(ss_info.field(If).to.string,1)),
		     1, length(ss_info.field(If).to.string), addr(uu),
		     Istart, length(uu), Iend, Imatch_end, code);

END_LTH_TO_REGEXP:	  if code = 0 then do;
		     Iend = Iend - 1;
		     go to END_LTH_TO_FIELD;
		     end;
		  else if code = error_table_$nomatch then do;
		     code = 0;
		     go to LTH_EMPTY_FIELD;
		     end;
		  else do;
		     call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		        "Invalid syntax in regular expression:  -field -to /^a/",
		        ss_info.field(If).to.string);
		     go to SORT_EXIT;
		     end;

END_LTH_TO_FIELD:	  Lfield(If) = max(Lfield(If), Iend-Istart+1);
LTH_EMPTY_FIELD:	  end;
	         end;
	      Lfield(ss_info.field_count+1) = length(stable);
	      Lall_fields = sum(Lfield);
	      end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* NORMAL FIELD PROCESSING (cont):						*/
	/* 4) Copy each sort field from the uu into sf_str temp seg.			*/
	/* 5) For non_case_sensitive fields, translate to lowercase as copied.		*/
	/* 6) For descending fields, invert the bit string representation of the field copy.	*/
	/* 7) For numeric fields, encode the character string representation of the field copy.	*/
	/* 8) Set the sfp to point to the field.  Fields for all units are the same length,	*/
	/*    Lall_fields, as computed above.						*/
	/* 9) Add a stability field to the end of each copied unit.			          */
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	   if Snumeric then do;			/* setup to handle a bad numeric conversion.      */
	      on conversion begin;			
	         code = error_table_$bad_conversion;
	         call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		  "^/While encoding field ^d of ^[row^;block^] ^d: ^a^[^/(^a^[>^]^a)^]", If, (type=TABLE), Iu,
		  substr(uu,Istart,Lmatch), (type = SEGMENT), in_dir, in_dir^=">", in_ent);
	         go to SORT_EXIT;
	         end;

	      on size begin;			
	         code = error_table_$out_of_bounds;
	         call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		  "^/While encoding field ^d of ^[row^;block^] ^d: ^a^[^/(^a^[>^]^a)^]", If, (type = TABLE), Iu,
		  substr(uu,Istart,Lmatch), (type = SEGMENT), in_dir, in_dir^=">", in_ent);
	         go to SORT_EXIT;
	         end;
	      end;   

	   Isf_str = 1;
	   case_field(*) = 0;
	   do Iu = 1 to Nu;	      
	      if (Isf_str-1) + Lall_fields > max_seg_size then do;
	         Nsf_str_array = Nsf_str_array + 1;
	         if ^get_temp_seg (id, "sort field strs", Psf_str) then goto SORT_EXIT;
	         Psf_str_array(Nsf_str_array) = Psf_str;
	         Isf_str = 1;
	         end;
(nostrz,nostrg,nosize,nosubrg):			/* prefixes due to bug in PL/I                     */
	      sfp.P(Iu) = addr(sf_str_char(Isf_str));
	      do If = 1 to ss_info.field_count;
	         go to SET_FROM_FIELD(ss_info.field(If).from.type);
	         
SET_FROM_FIELD(2): Istart = ss_info.field(If).from.number;
	         go to END_SET_FROM_FIELD;
	         
SET_FROM_FIELD(3): Istart = index(uu, ss_info.field(If).from.string);
	         if Istart = 0 then go to SET_EMPTY_FIELD;
	         Istart = Istart + length(ss_info.field(If).from.string);
	         go to END_SET_FROM_FIELD;

SET_FROM_FIELD(4): call search_file_$silent (addr(substr(ss_info.field(If).from.string,1)),
		  1, length(ss_info.field(If).from.string),
		  addr(uu), 1, length(uu),
		  Istart, Imatch_end, code);
	         if code = 0 then do;
		  Lmatch = Imatch_end - Istart + 1;
		  Istart = Istart + Lmatch;
		  go to END_SET_FROM_FIELD;
		  end;
	         else if code = error_table_$nomatch then do;
		  code = 0;
		  go to SET_EMPTY_FIELD;
		  end;
	         else do;
		  call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		     "Invalid syntax in regular expression:  -field -from /^a/",
		     ss_info.field(If).from.string);
		  go to SORT_EXIT;
		  end;

END_SET_FROM_FIELD:
	         if Istart > length(uu) then go to SET_EMPTY_FIELD;
	         go to SET_TO_FIELD(ss_info.field(If).to.type);

SET_TO_FIELD(1):   if ss_info.field(If).to.number = -1 then
		  Iend = length(uu);
	         else
		  Iend = min(length(uu), (Istart-1) + ss_info.field(If).to.number);
	         go to END_SET_TO_FIELD;

SET_TO_FIELD(2):   Iend = min(ss_info.field(If).to.number, length(uu));
	         go to END_SET_TO_FIELD;

SET_TO_FIELD(3):   Iend = index (substr(uu,Istart), ss_info.field(If).to.string);
	         if Iend = 0 then go to SET_EMPTY_FIELD;
	         Iend = Iend + (Istart-1) - 1;
	         go to END_SET_TO_FIELD;

SET_TO_FIELD(4):   go to SET_TO_REGEXP(case_regexp(If));

SET_TO_REGEXP(1):  Iend = length(uu);
	         go to END_SET_TO_FIELD;

SET_TO_REGEXP(2):  call search_file_$silent (addr(substr(ss_info.field(If).to.string,1)),
		  1, length(ss_info.field(If).to.string),
		  addr(uu), Istart, length(uu),
		  Iend, Imatch_end, code);
	         uul.L(Iu) = uul.L(Iu) - 1;
	         go to END_SET_TO_REGEXP;

SET_TO_REGEXP(3):  Luu_temp = uul.L(If);
	         uu_temp = uu;
	         Luu_temp = Luu_temp + length(NL);
	         substr (uu_temp, length(uu_temp), length(NL)) = NL;
	         call search_file_$silent (addr(substr(ss_info.field(If).to.string,1)),
		  1, length(ss_info.field(If).to.string), addr(uu_temp),
		  Istart, length(uu_temp), Iend, Imatch_end, code);
	         go to END_SET_TO_REGEXP;

SET_TO_REGEXP(4):  call search_file_$silent (addr(substr(ss_info.field(If).to.string,1)),
		  1, length(ss_info.field(If).to.string), addr(uu),
		  Istart, length(uu), Iend, Imatch_end, code);

END_SET_TO_REGEXP: if code = 0 then do;
		  Iend = Iend - 1;
		  go to END_SET_TO_FIELD;
		  end;
	         else if code = error_table_$nomatch then do;
		  code = 0;
		  go to SET_EMPTY_FIELD;
		  end;
	         else do;
		  call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		     "Invalid syntax in regular expression:  -field -to /^a/",
		     ss_info.field(If).to.string);
		  go to SORT_EXIT;
		  end;

END_SET_TO_FIELD:  Lmatch = Iend-Istart+1;
	         if Lmatch <= 0 then go to SET_EMPTY_FIELD;
	         go to FIELD_TYPE(case_field(If));

FIELD_TYPE(0):      if  ss_info.field(If).modes.non_case_sensitive &
		  ^ss_info.field(If).modes.numeric &
		  ^ss_info.field(If).modes.integer &
		  ^ss_info.field(If).modes.descending then case_field(If) = 1;
	         else
	         if ^ss_info.field(If).modes.non_case_sensitive &
		  ^ss_info.field(If).modes.numeric &
		  ^ss_info.field(If).modes.integer &
		   ss_info.field(If).modes.descending then case_field(If) = 2;
	         else
	         if  ss_info.field(If).modes.non_case_sensitive &
		  ^ss_info.field(If).modes.numeric &
		  ^ss_info.field(If).modes.integer &
		   ss_info.field(If).modes.descending then case_field(If) = 3;
	         else
	         if  ss_info.field(If).modes.numeric &
		  ^ss_info.field(If).modes.integer &
		  ^ss_info.field(If).modes.descending then case_field(If) = 4;
	         else
	         if  ss_info.field(If).modes.numeric &
 		  ^ss_info.field(If).modes.integer &
 		   ss_info.field(If).modes.descending then case_field(If) = 5;
	         else
	         if  ss_info.field(If).modes.integer &
		  ^ss_info.field(If).modes.numeric &
		  ^ss_info.field(If).modes.descending then case_field(If) = 6;
	         else
	         if  ss_info.field(If).modes.integer &
		  ^ss_info.field(If).modes.numeric &
	 	   ss_info.field(If).modes.descending then case_field(If) = 7;
	         else case_field(If) = 8;
	         go to FIELD_TYPE(case_field(If));

FIELD_TYPE(1):     substr(sf_str,Isf_str,Lfield(If)) = translate(substr(uu,Istart,Lmatch),az,AZ);
                   go to NEXT_FIELD;

FIELD_TYPE(2):     unspec(substr(sf_str,Isf_str,Lfield(If))) = ^unspec(substr(uu,Istart,Lmatch));
                   go to NEXT_FIELD;

FIELD_TYPE(3):     substr(sf_str,Isf_str,Lfield(If)) = translate(substr(uu,Istart,Lmatch),az,AZ);
	         unspec(substr(sf_str,Isf_str,Lfield(If))) = ^unspec(substr(sf_str,Isf_str,Lfield(If)));
                   go to NEXT_FIELD;

FIELD_TYPE(4):     if type  = TABLE then call encode_numeric (addr(substr(uu,Istart,Lmatch)), (Lmatch),
		  desc_array(If), addr(substr(sf_str, Isf_str, Lfield(If))), encd_len, code);
	         else call encode_numeric (addr(substr(uu,Istart,Lmatch)), (Lmatch),
		  addr(FLOAT_DEC_59_DESC), addr(substr(sf_str, Isf_str, Lfield(If))), encd_len, code);
	         if code ^= 0 then do;
		  call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		     "^/While encoding field ^d of ^[row^;block^] ^d: ^a^[^/(^a^[>^]^a)^]", If, (type = TABLE), Iu,
		     substr(uu,Istart,Lmatch), (type = SEGMENT), in_dir, in_dir^=">", in_ent);
		  go to SORT_EXIT;
		  end;
                   go to NEXT_FIELD;

FIELD_TYPE(5):     if type  = TABLE then call encode_numeric (addr(substr(uu,Istart,Lmatch)), (Lmatch),
		  desc_array(If), addr(encd_str), encd_len, code);
	         else call encode_numeric (addr(substr(uu,Istart,Lmatch)), (Lmatch),
		  addr(FLOAT_DEC_59_DESC), addr(encd_str), encd_len, code);
	         if code ^= 0 then do;
		  call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		     "^/While encoding field ^d of ^[row^;block^] ^d: ^a^[^/(^a^[>^]^a)^]", If, (type = TABLE), Iu,
		     substr(uu,Istart,Lmatch), (type = SEGMENT), in_dir, in_dir^=">", in_ent);
		  go to SORT_EXIT;
		  end;
	         unspec(substr(sf_str,Isf_str,Lfield(If))) = ^unspec(substr(encd_str, 1, encd_len));
	         go to NEXT_FIELD;

FIELD_TYPE(6):     call encode_numeric (addr(substr(uu,Istart,Lmatch)), (Lmatch),
		  addr(FIXED_BIN_71_DESC), addr(substr(sf_str, Isf_str, Lfield(If))), encd_len, code);
	         if code ^= 0 then do;
		  call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		     "^/While encoding field ^d of ^[row^;block^] ^d: ^a^[^/(^a^[>^]^a)^]", If, (type = TABLE), Iu,
		     substr(uu,Istart,Lmatch), (type = SEGMENT), in_dir, in_dir^=">", in_ent);
		  go to SORT_EXIT;
		  end;
	         go to NEXT_FIELD;

FIELD_TYPE(7):     call encode_numeric (addr(substr(uu,Istart,Lmatch)), (Lmatch),
		  addr(FIXED_BIN_71_DESC), addr(encd_str), encd_len, code);
	         if code ^= 0 then do;
		  call sub_err_ (code, caller, ACTION_DEFAULT_RESTART, null, 0,
		     "^/While encoding field ^d of ^[row^;block^] ^d: ^a^[^/(^a^[>^]^a)^]", If, (type = TABLE), Iu,
		     substr(uu,Istart,Lmatch), (type = SEGMENT), in_dir, in_dir^=">", in_ent);
		  go to SORT_EXIT;
		  end;
	         unspec(substr(sf_str,Isf_str,Lfield(If))) = ^unspec(substr(encd_str, 1, encd_len));
	         go to NEXT_FIELD;

FIELD_TYPE(8):     substr(sf_str,Isf_str,Lfield(If)) = substr(uu,Istart,Lmatch);
	         go to NEXT_FIELD;

SET_EMPTY_FIELD:   if ss_info.field(If).modes.numeric then do;
		  if type  = TABLE then call encode_numeric (addr(ZERO), length(ZERO), desc_array(If),
		     addr(substr(sf_str,Isf_str,Lfield(If))), Lfield(If), code);
		  else call encode_numeric (addr(ZERO), length(ZERO), addr(FLOAT_DEC_59_DESC),
		     addr(substr(sf_str,Isf_str,Lfield(If))), Lfield(If), code);
		  end;
	         else if ss_info.field(If).modes.integer then call encode_numeric (addr(ZERO), length(ZERO),
		  addr(FIXED_BIN_71_DESC), addr(substr(sf_str,Isf_str,Lfield(If))), Lfield(If), code);
	         else substr(sf_str,Isf_str,Lfield(If)) = "";
	         if ss_info.field(If).modes.descending then 
		  unspec(substr(sf_str,Isf_str,Lfield(If))) = ^unspec(substr(sf_str,Isf_str,Lfield(If)));

NEXT_FIELD:        Isf_str = Isf_str + Lfield(If);
	         end;
	      substr(sf_str,Isf_str,Lfield(If)) = stable;
	      Isf_str = Isf_str + Lfield(If);
	      end;
	   end;
	if Snumeric then revert conversion, size;	/* threat of a bad numeric conversion is over.    */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* SORT:									*/
	/* 1) Let sort_items_indirect_ compare sort fields or units, and rearrange unit indices	*/
	/*    (idx).								*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Sfield then do;				/* Sort with fields.			*/
	   sfp.N = Nu;
	   call sort_items_indirect_$char (addr(sfp), addr(idx), Lall_fields);
	   end;
	else if Snon_case_sensitive_sort then do;	/* Simple sort with translation to lower case.	*/
	   sfp.N = Nu;
	   sfl.N = Nu;
	   call sort_items_indirect_$adj_char (addr(sfp), addr(idx), addr(sfl));
	   end;
	else do;					/* Sblocked or ^Sblocked (simple sort)		*/
	   uup.N = Nu;
	   uul.N = Nu;
	   call sort_items_indirect_$adj_char (addr(uup), addr(idx), addr(uul));
	   end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* DEBUGGING CODE:								*/
	/* For each sort unit, print:  sort index, unit number, du, uu and sf (if different from	*/
	/* uu).									*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Sdebug then do;
	   if Sfield then do;
	      call ioa_ ("Lall_fields = ^d, Lfields =^( ^d^)", Lall_fields, Lfield);
	      Luu_longest = 0;
	      do Iu = 1 to Nu;
	         Puu_text = addr(uu);
	         Luu_text = length(uu);
	         do while (find_uu_line());
		  Luu_longest = max(Luu_longest, length(uu_line));
		  end;
	         end;
	      end;
	   Ldu_longest = 0;
	   do Iu = 1 to Nu;
	      Ldu = dul.L(Iu) + Ldelim;
	      if substr(du,Ldu,1) = NL then
	         Ldu = Ldu - 1;
	      Pdu_text = addr(du);
	      Ldu_text = Ldu;
	      do while (find_du_line());
	         Ldu_longest = max(Ldu_longest, length(du_line));
	         end;
	      end;
	   do Iu = 1 to Nu;
	      do Ix = 1 to Nu while(idx.I(Ix) ^= Iu);
	         end;
	      Ldu = dul.L(Iu) + Ldelim;
	      if substr(du,Ldu,1) = NL then
	         Ldu = Ldu - 1;
	      Idu_nl = index(du, NL);
	      Iuu_nl = index(uu, NL);
	      if Sfield then do;
	         Isf_nl = index(sf, NL);
	         if Idu_nl + Iuu_nl + Isf_nl = 0 then
		  call ioa_ ("^4d - ^4d| ""^a""^vx | ""^a""^vx | ""^a""",
		     Ix, Iu, du, Ldu_longest-Ldu,
		     uu, Luu_longest-length(uu),
		     substr(sf,1,Lall_fields-4));
	         else do;
		  Pdu_text = addr(du);
		  Ldu_text = Ldu;
		  Puu_text = addr(uu);
		  Luu_text = length(uu);
		  Psf_text = addr(sf);
		  Lsf_text = Lall_fields-4;
		  Idu, Iuu, Iss = 1;
		  do while (find_du_line() | find_uu_line() | find_sf_line());
		     call ioa_ ("^[^4d - ^4d^;^12t^2s^]^2(| ^[""^; ^]^[^s^a""^vx^;^va ^s^] ^)| ^[""^; ^]^a^[""^]",
		        Idu = 1, Ix, Iu,
		        Idu = 1, length(du_line)>0 & length(du_text)=0,
		        Ldu_longest, du_line, Ldu_longest-length(du_line),
		        Iuu = 1, length(uu_line)>0 & length(uu_text)=0,
		        Luu_longest, uu_line, Luu_longest-length(uu_line),
		        Iss=1, sf_line, length(sf_line)>0 & length(sf_text)=0);
		     Idu, Iuu, Iss = 0;
		     end;
		  end;
	         end;
	      else do;
	         if Idu_nl + Iuu_nl = 0 then
		  call ioa_ ("^4d - ^4d| ""^a""^vx | ""^a""",
		     Ix, Iu, du, Ldu_longest - Ldu, uu);
	         else do;
		  Pdu_text = addr(du);
		  Ldu_text = Ldu;
		  Puu_text = addr(uu);
		  Luu_text = length(uu);
		  Idu, Iuu = 1;
		  do while (find_du_line() | find_uu_line());
		     call ioa_ ("^[^4d - ^4d| ""^;^12t|  ^2s^]^[^s^a""^vx^;^va ^s^] | ^[""^; ^]^a^[""^]",
		        Idu = 1, Ix, Iu,
		        length(du_line)>0 & length(du_text)=0,
		        Ldu_longest, du_line, Ldu_longest-length(du_line),
		        Iuu = 1, uu_line, length(uu_line)>0 & length(uu_text)=0);
		     Idu, Iuu = 0;
		     end;
		  end;
	         end;
	      end;
	   end;
SORT_EXIT:
        if code ^= 0 then call sort_janitor();
        return;
        end sort;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

merge:   proc ();

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
	/*								        */
	/* MERGE THE SORTED COMPONENTS:					        */
	/*								        */
	/* Initialize Imerge and component_idx array to 1.			        */
	/* Then until merging is complete (all components are exhausted):		        */
	/*    1) Compare the sort field at current component_idx for each component to that of  */
	/*       the Imerge component.  Set Imerge to the component number of the lowest.       */
	/*    2) Add the row ptr of this component's current component_idx to the output.       */
	/*    3) Increment this component's component_idx.			        */
	/*    4) Find the lowest component which isn't completely merged. Set Imerge.	        */
	/*    5) Repeat.							        */
	/*								        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


    dcl component_idx (spp.M) fixed bin(21);

         Iseg = 1;					/* init to first output seg                       */
         Psupo = sppo.P(1);
         supo.N = 0;				/* this output seg is empty                       */

         max_ptrs_per_seg = sys_info$max_seg_size - currentsize(supo);
         component_idx(*) = 1;			/* set all indices to 1                           */
         Imerge = 1;				/* assume the first component is lowest to start  */
         do while (Imerge <= spp.M);
	  Pidx_merge = save.idx_ptr(Imerge);
	  Psfp_merge = save.sfp_ptr(Imerge);
	  Psf_merge = sfp_merge.P(idx_merge.I(component_idx(Imerge)));

	  do Iu = Imerge + 1 to spp.M;		/* find the next lowest component to merge        */
	     Pidx1 = save.idx_ptr(Iu);
	     if (component_idx(Iu) <= idx1.N) then do;
	        Psfp1 = save.sfp_ptr(Iu);
	        Psf1 = sfp1.P (idx1.I (component_idx(Iu)));
	        if sf1 < sf_merge then do;
		 Pidx_merge = Pidx1;
		 Psfp_merge = Psfp1;
		 Psf_merge = Psf1;
		 Imerge = Iu;
		 end;
	        end;
	     end;
	  
	  if supo.N = max_ptrs_per_seg then do;		/* this output seg is full                        */
	     if Iseg = sppo.N then do;		/* whoops, can't have more than we're given       */
	        code = error_table_$file_is_full;
	        goto MERGE_EXIT;
	        end;
	     Iseg = Iseg + 1;			/* start a new output seg                         */
	     Psupo = sppo.P(Iseg);
	     supo.N = 0;				/* this seg is empty                              */
	     end;
	  
	  supo.N = supo.N + 1;			/* put this row in output                         */
	  Pdup = save.dup_ptr(Imerge);
	  supo.P(supo.N) = dup.P(idx_merge.I(component_idx(Imerge)));
	  
	  if Sdebug then 
	     call ioa_ ("^2d, ^6d: ^a", Imerge, component_idx(Imerge),sf_merge);
	  
	  component_idx (Imerge) =
	     component_idx (Imerge) + 1;		/* mark this row as used                          */


	  do Imerge = 1 to spp.M			/* find a component which isn't done              */
	     while (component_idx(Imerge) > save.idx_ptr(Imerge) -> idx_merge.N); 
	     end;

	  end;
MERGE_EXIT:
         end merge;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
output:   proc ();

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* COPY SORTED INPUT TO OUTPUT						*/
	/* 1) Copy du's in sort order into output string.					*/
	/* 2) As part of copying, take duplicate_mode into account.  The mode can be--		*/
	/*    -duplicates = copy all units in sort order					*/
	/*    -unique = copy all unique units and first copy of each duplicated unit, in sort	*/
	/*	      order							*/
	/*    -only_duplicates = copy only first of each set of duplicate units, in sort order.	*/
	/*		     Unique units are NOT copied.				*/
	/*    -only_duplicate_keys = copy only units whose sort fields duplicate those of	*/
	/*		         another unit.  Units with unique sort fields are NOT copied. */
	/*    -unique_keys = copy only units whose sort fields do NOT duplicate those oo any	*/
	/*		 other unit.						*/
	/*    -only_unique = copy only units which are not duplicated.			*/
	/*    -only_unique_keys = copy only units whose keys are not duplicated in other units.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Lout = 0;
	Iu_prev = 0;
	Ndups = 0;
	Ndups_prev = 0;
	if Sfield then
	   Lall_fields = Lall_fields - 4;		/* Remove stability indicator.		*/
	do Ix = 1 to idx.N by 1  while (^Sdescending_sort),
	        idx.N to 1 by -1 while (Sdescending_sort);
	   Iu = idx.I(Ix);
	   Ldu = dul.L(Iu) + Ldelim;
	   go to DUP(ss_info.duplicate_mode);

DUP(1):	   substr(out, Lout+1, Ldu) = du;		/* SS_duplicate				*/
	   Lout = Lout + Ldu;
	   go to END_DUP;

DUP(2):	   if Iu_prev > 0 then			/* SS_unique				*/
	      if Ldu_prev = Ldu then
	         if du_prev = du then go to END_DUP_SET_PREV;
	   substr(out, Lout+1, Ldu) = du;
	   Lout = Lout + Ldu;
	   go to END_DUP_SET_PREV;

DUP(3):	   if Iu_prev > 0 then do;			/* SS_only_duplicates			*/
	      if Snon_case_sensitive_sort then do;
	         if Ldu_prev = Ldu then
		  if sfp.P(Iu_prev)->du_prev = sfp.P(Iu)->du then
		     Ndups = Ndups + 1;
		  else Ndups = 0;
	         else Ndups = 0;
	         end;
	      else do;
	         if Ldu_prev = Ldu then
		  if du_prev = du then Ndups = Ndups + 1;
		  else Ndups = 0;
	         else Ndups = 0;
	         end;
	      if Ndups = 1 then do;
	         substr(out, Lout+1, Ldu_prev) = du_prev;
	         Lout = Lout + Ldu_prev;
	         end;
	      end;
	   go to END_DUP_SET_PREV;

DUP(4):	   if ^Sfield then go to DUP(3);		/* SS_only_duplicate_keys			*/
	   if Iu_prev > 0 then do;
	      if Sfield then 
	         if sf_prev = sf then Ndups = Ndups + 1;
	         else Ndups = 0;
	      else do;
	         if Snon_case_sensitive_sort then do;
		  if Ldu_prev = Ldu then
		     if sfp.P(Iu_prev)->du_prev = sfp.P(Iu)->du then
		        Ndups = Ndups + 1;
		     else Ndups = 0;
		  else Ndups = 0;
		  end;
	         else do;
		  if Ldu_prev = Ldu then
		     if du_prev = du then Ndups = Ndups + 1;
		     else Ndups = 0;
		  else Ndups = 0;
		  end;
	         end;
	      if Ndups = 1 then do;
	         substr(out, Lout+1, Ldu_prev) = du_prev;
	         Lout = Lout + Ldu_prev;
	         end;
	      if Ndups > 0 then do;
	         substr(out, Lout+1, Ldu) = du;
	         Lout = Lout + Ldu;
	         end;
	      end;
	   go to END_DUP_SET_PREV;

DUP(5):	   if ^Sfield & ^Snon_case_sensitive_sort then go to DUP(2);
	   if Iu_prev > 0 then do;			/* SS_unique_keys				*/
	      if Snon_case_sensitive_sort then do;
	         if Ldu_prev = Ldu then
		  if sfp.P(Iu_prev)->du_prev = sfp.P(Iu)->du then
		     Ndups = Ndups + 1;
		  else Ndups = 0;
	         else Ndups = 0;
	         end;
	      else do;
	         if sf_prev = sf then Ndups = Ndups + 1;
	         else Ndups = 0;
	         end;
	      end;
	   if Ndups = 0 then do;
	      substr(out, Lout+1, Ldu) = du;
	      Lout = Lout + Ldu;
	      end;
	   go to END_DUP_SET_PREV;

DUP(6):	   if Iu_prev > 0 then do;			/* SS_only_unique				*/
	      if Snon_case_sensitive_sort then do;
	         if Ldu_prev = Ldu then
		  if sfp.P(Iu_prev)->du_prev = sfp.P(Iu)->du then
		     Ndups = Ndups + 1;
		  else Ndups = 0;
	         else Ndups = 0;
	         end;
	      else do;
	         if Ldu_prev = Ldu then
		  if du_prev = du then Ndups = Ndups + 1;
		  else Ndups = 0;
	         else Ndups = 0;
	         end;
	      if Ndups = 0 & Ndups_prev = 0 then do;
	         substr(out, Lout+1, Ldu_prev) = du_prev;
	         Lout = Lout + Ldu_prev;
	         end;
	      end;
	   if Ndups = 0 & ((Ix = idx.N & ^Sdescending_sort) | (Ix = 1 & Sdescending_sort)) then do;
	      substr(out, Lout+1, Ldu) = du;
	      Lout = Lout + Ldu;
	      end;
	   Ndups_prev = Ndups;
	   go to END_DUP_SET_PREV;

DUP(7):	   if ^Sfield then go to DUP(6);		/* SS_only_unique_keys			*/
	   if Iu_prev > 0 then do;
	      if Sfield then 
	         if sf_prev = sf then Ndups = Ndups + 1;
	         else Ndups = 0;
	      else do;
	         if Snon_case_sensitive_sort then do;
		  if Ldu_prev = Ldu then
		     if sfp.P(Iu_prev)->du_prev = sfp.P(Iu)->du then
		        Ndups = Ndups + 1;
		     else Ndups = 0;
		  else Ndups = 0;
		  end;
	         else do;
		  if Ldu_prev = Ldu then
		     if du_prev = du then Ndups = Ndups + 1;
		     else Ndups = 0;
		  else Ndups = 0;
		  end;
	         end;
	      if Ndups = 0 & Ndups_prev = 0 then do;
	         substr(out, Lout+1, Ldu_prev) = du_prev;
	         Lout = Lout + Ldu_prev;
	         end;
	      end;
	   if Ndups = 0 & ((Ix = idx.N & ^Sdescending_sort) | (Ix = 1 & Sdescending_sort)) then do;
	      substr(out, Lout+1, Ldu) = du;
	      Lout = Lout + Ldu;
	      end;
	   Ndups_prev = Ndups;
	   go to END_DUP_SET_PREV;

END_DUP_SET_PREV:
	   Iu_prev = Iu;
	   Ldu_prev = Ldu;

END_DUP:	   end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* FINISH PROCESSING:							*/
	/* 1) If undelimited chars appeared at end of input, copy them exactly to end of output	*/
	/*    segment.  Adjust undelimited char index because length of output may be less than	*/
	/*    length of input (due to -unique, etc).					*/
	/* 2) If input and output strings are overlapping, copy output from temp seg in which we	*/
	/*    placed it originally into the final output string.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if undelim_char_index > 0 then do;
	   substr(out, Lout+1, length(in)-(undelim_char_index-1)) =
	      substr(in, undelim_char_index);
	   Lout = Lout + length(in)-(undelim_char_index-1);
	   undelim_char_index = Lout + 1 - (length(in)-(undelim_char_index-1));
	   end;

	if Soverlap then do;
	   substr(Pout_real -> out, 1, Lout) = substr(out, 1, Lout);
	   Pout = Pout_real;
	   end;
	out_len = Lout;
	end output;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* DEBUGGING DECLARATIONS AND FUNCTIONS						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    dcl  (Idu_nl, Iuu_nl, Isf_nl)	fixed bin(21),
	Ldu_line			fixed bin(21),
	Ldu_longest		fixed bin(21),
	Ldu_text			fixed bin(21),
	Lsf_line			fixed bin(21),
	Lsf_text			fixed bin(21),
	Luu_line			fixed bin(21),
	Luu_longest		fixed bin(21),
	Luu_text			fixed bin(21),
	Pdu_line			ptr,
	Pdu_text			ptr,
	Psf_line			ptr,
	Psf_text			ptr,
	Puu_line			ptr,
	Puu_text			ptr,
	du_line			char(Ldu_line) based(Pdu_line),
	du_text			char(Ldu_text) based(Pdu_text),
	du_text_char (Ldu_text)	char(1) based(Pdu_text),
	sf_line			char(Lsf_line) based(Psf_line),
	sf_text			char(Lsf_text) based(Psf_text),
	sf_text_char (Lsf_text)	char(1) based(Psf_text),
	uu_line			char(Luu_line) based(Puu_line),
	uu_text			char(Luu_text) based(Puu_text),
	uu_text_char (Luu_text)	char(1) based(Puu_text);

find_du_line:
	proc returns(bit(1));

	Pdu_line = addr(du_text);
	Ldu_line = index(du_text, NL);
	if Ldu_line = 0 then Ldu_line = length(du_text);
	if length(du_line) > 0 then do;
	   Pdu_text = addr(du_text_char(Ldu_line+1));
	   Ldu_text = Ldu_text - Ldu_line;
	   if substr(du_line,length(du_line),1) = NL then
	      Ldu_line = Ldu_line - 1;
	   return(TRUE);
	   end;
	else
	   return(FALSE);

find_uu_line:
	entry returns(bit(1));

	Puu_line = addr(uu_text);
	Luu_line = index(uu_text, NL);
	if Luu_line = 0 then Luu_line = length(uu_text);
	if length(uu_line) > 0 then do;
	   Puu_text = addr(uu_text_char(Luu_line+1));
	   Luu_text = Luu_text - Luu_line;
	   if substr(uu_line,length(uu_line),1) = NL then
	      Luu_line = Luu_line - 1;
	   return(TRUE);
	   end;
	else
	   return(FALSE);

find_sf_line:
	entry returns(bit(1));

	Psf_line = addr(sf_text);
	Lsf_line = index(sf_text, NL);
	if Lsf_line = 0 then Lsf_line = length(sf_text);
	if length(sf_line) > 0 then do;
	   Psf_text = addr(sf_text_char(Lsf_line+1));
	   Lsf_text = Lsf_text - Lsf_line;
	   if substr(sf_line,length(sf_line),1) = NL then
	      Lsf_line = Lsf_line - 1;
	   return(TRUE);
	   end;
	else
	   return(FALSE);

	end find_du_line;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


get_temp_seg:
	proc (caller, seg_id, Ptemp) returns (bit(1) aligned);

    dcl	caller			char(*) varying,
          code                          fixed bin(35),
	seg_id			char(*),
	Ptemp			ptr;

    dcl	get_temp_segment_		entry (char(*), ptr, fixed bin(35)),
	release_temp_segment_	entry (char(*), ptr, fixed bin(35));

	if Stemp_dir then call temp_seg_mgr$get (lcb_ptr, caller || "(" || seg_id || ")", temp_dir, Ptemp, code);
	else call get_temp_segment_ (caller || "(" || seg_id || ")", Ptemp, code);

	if code ^= 0 then call sub_err_ (code,  caller, ACTION_DEFAULT_RESTART, null, 0,
	     "While getting temporary segments for sort workspace.");
	return (code = 0);

release_temp_seg:
	entry (caller, seg_id, Ptemp);

	if Stemp_dir then call temp_seg_mgr$release (lcb_ptr, caller || "(" || seg_id || ")", Ptemp, 0);
	else call release_temp_segment_ (caller || "(" || seg_id || ")", Ptemp, 0);
	end get_temp_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
seg_janitor:
	proc(termination_mode, Sdelete_output_file);

    dcl	termination_mode		bit(*),
	Sdelete_output_file		bit(1);

    dcl	code			fixed bin(35);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ORDER OF OPERATION IN CLEANUP IS CRITICAL:					*/
	/* 1) Must first terminate input segment.  Since input and output segments may have been	*/
	/*    the same, forcing access to the output segment may have given us r access to input.	*/
	/*    So therefore, input must be terminated before any forced access is removed.	*/
	/* 2) Then terminate (or delete) output segment, since successful setting of bit count	*/
	/*    and truncation depend upon any forced access.				*/
	/* 3) Finally, restore any ACL changes made by forcing access.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call sort_janitor();

	if Pin ^= null then
	   call terminate_file_ (Pin, 0, TERM_FILE_TERM, code);
	if Pout ^= null then do;
	   if Sdelete_output_file then		/* We created output file and sort failed, so	*/
	      call hcs_$delentry_seg (Pout, code);	/*   we must delete it.			*/
	   else
	      call terminate_file_ (Pout, out_len*9, termination_mode, code);
	   end;
	if Paccess ^= null then			/* If we created output file and sort failed, 	*/
	   call access_$reset (Paccess, code);		/*   access will never have been forced.	*/

	end seg_janitor;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


sort_janitor:
	proc();

	if Soverlap then do;
	   if Pout = Pout_temp then
	      Pout = Pout_real;
	   call release_temp_seg (id, "temp output seg", Pout_temp);
	   end;
	if Puup = Pdup then
	   Puup = null;
	if Puu_str = addr(in) then
	   Puu_str = null;
	if Pdul = Puul then
	   Pdul = null;
	call release_temp_seg (id, "sort indices", Pidx);
	call release_temp_seg (id, "delim unit ptrs", Pdup);
	call release_temp_seg (id, "delim unit lths", Pdul);
	if Psf_str_array(Nsf_str_array) = null then
	   Psf_str_array(Nsf_str_array) = Psf_str;
	do Isf_str = 1 to Nsf_str_array;
	   Psf_str = Psf_str_array(Isf_str);
	   call release_temp_seg (id, "sort field strs", Psf_str);
	   end;
	call release_temp_seg (id, "sort field ptrs", Psfp);
	call release_temp_seg (id, "sort field lths", Psfl);
	call release_temp_seg (id, "undelim unit strs", Puu_str);
	call release_temp_seg (id, "undelim unit ptrs", Puup);
	call release_temp_seg (id, "undelim unit lths", Puul);
	call release_temp_seg (id, "undelim temp strs", Puu_temp);

	end sort_janitor;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
table_janitor:
     proc();

         if Psave ^= null & component_number > 0 then do;
	  if Pdup = save.dup_ptr(component_number) then
	     save.dup_ptr (component_number) = null;
	  if Pidx = save.idx_ptr(component_number) then
	     save.idx_ptr (component_number) = null;
	  if Psfp = save.sfp_ptr(component_number) then
	     save.sfp_ptr (component_number) = null;
	  do Its = 1 to save.Nsf_strs;
	     do Isf_str = 1 to Nsf_str_array;
	        if save.sf_str_ptr(Its) = Psf_str_array(Isf_str) then
		 save.sf_str_ptr(Its) = null;
	        end;
	     end;
	  end;

         call sort_janitor();

         if Psave = null then return;
         do Its = 1 to component_number;				/* cleanup */
	    Pdup = save.dup_ptr(Its);
	    Pidx = save.idx_ptr(Its);
	    Psfp = save.sfp_ptr(Its);
	    call release_temp_seg (id, "delim unit ptrs", Pdup);
	    call release_temp_seg (id, "sort indices", Pidx);
	    call release_temp_seg (id, "sort field ptrs", Psfp);
	    end;

         do Its = 1 to save.Nsf_strs;
	    Psf_str = save.sf_str_ptr(Its);
	    call release_temp_seg (id, "sort field strs", Psf_str);
	    end;

         call release_temp_seg (id, "saved sort ptrs", Psave);

end table_janitor;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

encode_numeric: proc (src_ptr, src_len, dp, encd_ptr, encd_len, code);


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
	/*								        */
	/* This procedure encodes a source value to form a key. All supported data types are    */
	/* encoded in such a fashion that order is preserved. This allows true numeric sorting  */
	/* on the resulting key. This code was "borrowed" from mrds mu_encd_key.pl1.            */
	/*								        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	      
          dcl     dp                     ptr parm;	/* Input: original data descriptor ptr */
          dcl    (bit_length, pad_length)fixed bin (35);
 	dcl     code		 fixed bin (35) parm;/* Output: status code */

						/* max bits allowed in encoded string */

	dcl     (src_ptr,				/* ptr to a source value */
	        cp_ptr)                ptr;               /* pointer to current position in key */

	dcl     (j,				/* index */
	        offset,				/* current bit position in key */
	        p)		 fixed bin;	/* precision of value */

	dcl     encd_len		 fixed bin (21);    /* char. length of key */
	dcl     encd_ptr		 ptr;		/* Output: ptr to  encoded value  */
	dcl     (power_delta,			/* increase in exp. for normaliz. */
	        shift_delta)	 fixed bin (7);	/* no chars to shift for norm. */
	dcl     fb7		 fixed bin (7) based unal; /* template */
	dcl     fb8		 fixed bin (8) based unal unsigned; /* template */
	dcl     1 fxb		 unal based (src_ptr), /* fixed bin template */
		2 sign		 bit (1) unal,
		2 val		 bit (p) unal;

	dcl     1 flb_src		 unal based (src_ptr), /* template for source float bin */
		2 esign		 bit (1) unal,
		2 eval		 bit (7) unal,
		2 msign		 bit (1) unal,
		2 mval		 bit (p) unal;

	dcl     1 flb_enc		 unal based (cp_ptr), /* template for encoded float bin */
		2 msign		 bit (1) unal,
		2 esign		 bit (1) unal,
		2 eval		 bit (7) unal,
		2 mval		 bit (p) unal;

	dcl     1 fxd		 unal based (src_ptr), /* template for fixed dec. */
		2 sign		 char (1) unal,
		2 digit		 (p) pic "9" unal;

	dcl     1 fld_src		 unal based (src_ptr), /* template for float dec source */
		2 msign		 char (1) unal,
		2 digit		 (p) pic "9" unal,
		2 epad		 bit (1) unal,
		2 esign		 bit (1) unal,
		2 eval		 bit (7) unal;

	dcl     1 fld_enc		 unal based (cp_ptr), /* template for float dec encoded */
		2 msign		 char (1) unal,
		2 epad		 bit (1) unal,
		2 esign		 bit (1) unal,
		2 eval		 bit (7) unal,
		2 digit		 (p) pic "9" unal;

	dcl     01 odd_fxd4_src	 based (src_ptr),
		02 pad1		 bit (1) unal,
		02 sign		 bit (4) unal,
		02 digits		 bit (digit_len) unal;

	dcl     01 even_fxd4_src	 based (src_ptr),
		02 pad1		 bit (1) unal,
		02 sign		 bit (4) unal,
		02 digits		 bit (digit_len) unal,
		02 pad2		 bit (4) unal;

	dcl     01 odd_fxd4_enc	 based (cp_ptr),
		02 pad1		 bit (1) unal init ("0"b),
		02 sign		 bit (4) unal,
		02 digits		 bit (digit_len) unal;

	dcl     01 even_fxd4_enc	 based (cp_ptr),
		02 pad1		 bit (1) unal init ("0"b),
		02 pad2		 bit (4) unal init ("0"b),
		02 sign		 bit (4) unal,
		02 digits		 bit (digit_len) unal;

	dcl     01 even_fld4_src	 based (src_ptr),
		02 pad1		 bit (1) unal,
		02 sign		 bit (4) unal,
		02 digits		 bit (digit_len) unal,
		02 exp,
		  03 sign		 bit (1) unal,
		  03 high		 bit (3) unal,
		  03 pad2		 bit (1) unal,
		  03 low		 bit (4) unal,
		  03 pad3		 bit (4) unal;

	dcl     01 odd_fld4_src	 based (src_ptr),
		02 pad1		 bit (1) unal,
		02 sign		 bit (4) unal,
		02 digits		 bit (digit_len) unal,
		02 exp,
		  03 pad2		 bit (1) unal,
		  03 sign		 bit (1) unal,
		  03 exp		 bit (7) unal;

	dcl     01 odd_fld4_enc	 based (cp_ptr),
		02 pad1		 bit (1) unal init ("0"b),
		02 pad2		 bit (1) unal init ("0"b),
		02 sign		 bit (4) unal,
		02 esign		 bit (1) unal,
		02 exp		 bit (7) unal,
		02 digits		 bit (digit_len) unal;

	dcl     01 even_fld4_enc	 based (cp_ptr),
		02 pad1		 bit (1) unal init ("0"b),
		02 pad2		 bit (1) unal init ("0"b),
		02 pad3		 bit (4) unal init ("0"b),
		02 sign		 bit (4) unal,
		02 esign		 bit (1) unal,
		02 exp		 bit (7) unal,
		02 digits		 bit (digit_len) unal;

	dcl     digit_len		 fixed bin;

	dcl     (mdbm_error_$unsup_type,
	        mdbm_error_$key_encd_ovfl) fixed bin (35) ext;

	dcl     valid_decimal_	 entry (fixed bin, ptr, fixed bin) returns (bit (1));
	dcl     mdbm_error_$invalid_dec_data fixed bin (35) ext;

          dcl     assign_                entry (ptr, fixed bin, fixed bin(35), ptr, fixed bin, fixed bin(35));
          dcl     org_ptr                ptr;
	dcl     org_data               fixed dec(59);
	dcl     org_type               fixed bin;
	dcl     char_type              fixed bin init(42) int static options (constant);   /* char_dtype * 2 */

          dcl     org_len                fixed bin (35);
          dcl     src_len                fixed bin (21);
	dcl     target_len_ptr         ptr;
	dcl     1 target_len aligned based (target_len_ptr),
	          2 scale              fixed bin(17) unaligned,
	          2 prec               fixed bin(18) unsigned unaligned;

	cp_ptr = encd_ptr;
	desc_ptr = dp;
	
	/* since we are given only character values,
	   we must convert back to the original type */
	org_ptr = addr(org_data);
	org_type = descriptor.type * 2;
	if descriptor.packed then org_type = org_type + 1;
	
	target_len_ptr = addr(org_len);
	target_len.prec = fixed(descriptor.size.precision);
	target_len.scale = fixed(descriptor.size.scale);
	
	call assign_ (org_ptr, org_type, org_len,
	   src_ptr, char_type, (src_len));
	
	src_ptr = org_ptr;
	go to encode (descriptor.type);		/* go encode this value */
	
encode (1):					/* fixed bin short */
	if descriptor.packed then p = fixed (descriptor.size.precision);
	else p = 35;
	call encode_fxb;
	go to next;
	
encode (2):					/* fixed bin long */
	if descriptor.packed then p = fixed (descriptor.size.precision);
	else p = 71;
	call encode_fxb;
	go to next;
	
encode (3):					/* float bin short */
	if descriptor.packed then p = fixed (descriptor.size.precision);
	else p = 27;
	call encode_flb;
	go to next;

encode (4):					/* float bin long */
	if descriptor.packed then p = fixed (descriptor.size.precision);
	else p = 63;
	call encode_flb;
	go to next;

encode (5):					/* complex fixed bin short */
encode (6):					/* complex fixed bin long */
encode (7):					/* complex float bin short */
encode (8):					/* complex float bin long */
	call error (mdbm_error_$unsup_type);

encode (9):					/* real fixed decimal */
	p = fixed (descriptor.size.precision);		/* will always pack */
	if fxd.sign = "+" then cp_ptr -> fxd.sign = "p";	/* change sign to preserve order */
	else cp_ptr -> fxd.sign = "n";
	if fxd.sign = "-" then /* if negative no, take 9's compl. */
	   do j = 1 to p;
	   cp_ptr -> fxd.digit (j) = 9 - fxd.digit (j);
	   end;
	else do j = 1 to p;				/* if positive, just copy digits */
	   cp_ptr -> fxd.digit (j) = fxd.digit (j);
	   end;
	offset = 9 * (p + 1);
	go to next;

encode (10):					/* real float decimal */
	p = fixed (descriptor.size.precision);
	call encode_fld;
	offset = 9 * (p + 2);
	go to next;

encode (11):					/* complex fixed decimal */
encode (12):					/* complex float decimal */
encode (13):					/* unsupported types */
encode (14):
encode (15):
encode (16):
encode (17):
encode (18):
encode (19):					/* bit string */
encode (21):					/* char. string */
encode (22):					/* varying char. string */
encode (23):
encode (24):
encode (25):
encode (26):
encode (27):
encode (28):
encode (29):
encode (30):
encode (31):
encode (32):
encode (33):
encode (34):
encode (35):
encode (36):
encode (37):
encode (38):
encode (39):
encode (40):
encode (41):
encode (42):
	call error (mdbm_error_$unsup_type);

encode (43):					/* fixed dec 4 */
	call encode_fxd4;
	bit_length = 9 * floor ((fixed (descriptor.size.precision) + 2) / 2);
	if ^descriptor.packed then if mod (bit_length, 36) ^= 0 then do;
	   pad_length = (36 - mod (bit_length, 36));
	   bit_length = bit_length + pad_length;
	   end;
	offset = bit_length;
	go to next;

encode (44):					/* float dec 4 */
	call encode_fld4;
	bit_length = 9 * floor ((fixed (descriptor.size.precision) + 4) / 2);
	if ^descriptor.packed then if mod (bit_length, 36) ^= 0 then do;
	   pad_length = (36 - mod (bit_length, 36));
	   bit_length = bit_length + pad_length;
	   end;
	offset =  bit_length;
	go to next;

encode (45):					/* cmplx float dec packed */
encode (46):					/* cmplx fixed dec packed */
	call error (mdbm_error_$unsup_type);

next:
	encd_len = divide (offset + 8, 9, 17, 0);
	code = 0;
exit:	
	return;


encode_fxb: proc;

/* Procedure to encode fixed bin, merely flips sign bit */

	cp_ptr -> fxb.sign = ^fxb.sign;
	cp_ptr -> fxb.val = fxb.val;
	offset = p + 1;

     end encode_fxb;


encode_flb: proc;

/* Procedure to encode float bin, merely transforms so that bit sort will
   order correctly. */

	flb_enc.msign = ^flb_src.msign;
	flb_enc.mval = flb_src.mval;
	if flb_src.msign = "1"b then /* if is neg. no */
	   addr (flb_enc.esign) -> fb8 = 128 - addr (flb_src.esign) -> fb8; /* compl. exp. */
						/* CHANGE 81-09-19 */
	else do;					/* positive, merely flip sign bit */
	   flb_enc.esign = ^flb_src.esign;
	   flb_enc.eval = flb_src.eval;
	   end;
	offset = p + 9;

     end encode_flb;

encode_fld: proc;
	if ^valid_decimal_ (bin (descriptor.type), src_ptr, bin (descriptor.size.precision))
	then call error (mdbm_error_$invalid_dec_data);
	do j = 1 to p while (fld_src.digit (j) = 0);	/* scan for first non-zero digit */
	end;
	if j > p then do;				/* have zero value */
	   fld_enc.msign = "p";
	   fld_enc.esign,
	      fld_enc.epad,
	      fld_enc.eval = "0"b;
	   do j = 1 to p;
	      fld_enc.digit (j) = 0;
	      end;
	   end;					/* if have zero value */
	else do;					/* for non-zero values */
	   power_delta = p - j + 1;			/* number to add to exponent */
	   shift_delta = j - 1;			/* no. characters to shift */
	   if addr (fld_src.esign) -> fb7 
	      + power_delta > 127 then		/* if will overflow */
	      call error (mdbm_error_$key_encd_ovfl);
	   addr (fld_enc.esign) -> fb7 = addr (fld_src.esign) -> fb7 + power_delta;
	   fld_enc.epad = "0"b;
	   if fld_src.msign = "-" then do;		/* if negative no. */
	      fld_enc.msign = "n";
	      do j = 1 to p - shift_delta;		/* 9's compl. of signif. digits to front */
	         fld_enc.digit (j) = 9 - fld_src.digit (j + shift_delta);
	         end;
	      do j = p - shift_delta + 1 to p;		/* fill in trailing 9's */
	         fld_enc.digit (j) = 9;
	         end;
	      addr (fld_enc.esign) -> fb7 =
	         128 - addr (fld_enc.esign) -> fb7;	/* complement exp. so will sort right */
	      end;				/* if negative no. */
	   else do;				/* if positive no. */
	      fld_enc.msign = "p";
	      do j = 1 to p - shift_delta;		/* move signif. digits to front */
	         fld_enc.digit (j) = fld_src.digit (j + shift_delta);
	         end;
	      do j = p - shift_delta + 1 to p;		/* put in trailing 0's */
	         fld_enc.digit (j) = 0;
	         end;
	      fld_enc.esign = ^fld_enc.esign;		/* flip sign bit so will sort right */
	      end;				/* if positive no. */
	   end;					/* if non-zero */
	end encode_fld;

/* Encoding algorithm for fixed and float decimal unaligned

   for a fixed data type just ignore rules about exponent.

   For negative numbers (sign = "1101"b)
   1. set sign to "0000"b
   2. copy sign of exponent
   3. copy complement of exponent
   4. copy complement of number

   For positive numbers (sign = "1101"b)
   1. set sign to "1111"b
   2. copy number
   3. if number is zero
   a. set exponent to "0000000"b
   b. set sign of exponent to "0"b
   4. if number is not zero
   a. copy exponent
   b. copy sign of exponent

   Note: zero is normally stored as a positive number with the maximum possible
   exponent.
*/

encode_fxd4: proc;
	p = fixed (descriptor.size.precision);
	if mod (p, 2) = 1
	   then do;
	   digit_len = ((p - 1) / 2 * 9) + 4;
	   if odd_fxd4_src.sign = "1101"b
	      then do;
	      odd_fxd4_enc.sign = "0000"b;
	      odd_fxd4_enc.digits = ^(odd_fxd4_src.digits);
	      end;
	   else do;
	      odd_fxd4_enc.sign = "1111"b;
	      odd_fxd4_enc.digits = odd_fxd4_src.digits;
	      end;
	   end;
	else do;
	   digit_len = (p / 2) * 9;
	   if even_fxd4_src.sign = "1101"b
	      then do;
	      even_fxd4_enc.sign = "0000"b;
	      even_fxd4_enc.digits = ^(even_fxd4_src.digits);
	      end;
	   else do;
	      even_fxd4_enc.sign = "1111"b;
	      even_fxd4_enc.digits = even_fxd4_src.digits;
	      end;
	   end;
	end encode_fxd4;

encode_fld4: proc;
	p = fixed (descriptor.size.precision);
	if mod (p, 2) = 1
	   then do;
	   digit_len = (((p - 1) / 2) * 9) + 4;
	   if odd_fld4_src.sign = "1101"b
	      then do;
	      odd_fld4_enc.sign = "0000"b;
	      odd_fld4_enc.esign = odd_fld4_src.exp.sign;
	      odd_fld4_enc.exp = ^(odd_fld4_src.exp.exp);
	      odd_fld4_enc.digits = ^(odd_fld4_src.digits);
	      end;
	   else do;
	      odd_fld4_enc.sign = "1111"b;
	      odd_fld4_enc.digits = odd_fld4_src.digits;
	      if odd_fld4_src.digits = "0"b
	         then do;
	         odd_fld4_enc.esign = "0"b;
	         odd_fld4_enc.exp = "0"b;
	         end;
	      else do;
	         odd_fld4_enc.esign = ^(odd_fld4_src.exp.sign);
	         odd_fld4_enc.exp = odd_fld4_src.exp.exp;
	         end;
	      end;
	   end;
	else do;
	   digit_len = (p / 2) * 9;
	   if even_fld4_src.sign = "1101"b
	      then do;
	      even_fld4_enc.sign = "0000"b;
	      even_fld4_enc.esign = even_fld4_src.exp.sign;
	      even_fld4_enc.exp = ^(even_fld4_src.exp.high) || ^(even_fld4_src.exp.low);
	      even_fld4_enc.digits = ^(even_fld4_src.digits);
	      end;
	   else do;
	      even_fld4_enc.sign = "1111"b;
	      even_fld4_enc.digits = even_fld4_src.digits;
	      if even_fld4_src.digits = "0"b
	         then do;
	         even_fld4_enc.esign = "0"b;
	         even_fld4_enc.exp = "0"b;
	         end;
	      else do;
	         even_fld4_enc.esign = ^(even_fld4_src.exp.sign);
	         even_fld4_enc.exp = even_fld4_src.exp.high || even_fld4_src.exp.low;
	         end;
	      end;
	   end;
	end encode_fld4;

error: proc (cd);

/* error procedure */

	dcl     cd		 fixed bin (35);

	code = cd;
	go to exit;

	end error;
       end encode_numeric;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include access_mode_values;

%include sort_seg_info;

%include mdbm_descriptor;

%include terminate_file;

%include std_descriptor_types;

%include sub_err_flags;

	end sort_seg_;
     
