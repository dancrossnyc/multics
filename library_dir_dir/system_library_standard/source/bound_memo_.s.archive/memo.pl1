/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1989                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(1986-07-11,Rauschelbach), approve(1986-07-11,MCR7450),
     audit(1986-08-05,GJohnson), install(1986-08-08,MR12.0-1122):
     Changed argument processing to accept short name -dft for -default.
  2) change(1986-07-15,Rauschelbach), approve(1986-07-15,MCR7472),
     audit(1986-08-05,GJohnson), install(1986-08-08,MR12.0-1122):
     Write access checking and error handling were changed to fix an endless
     loop.  Argument processing was changed to handle null or zero secondary
     arguments.  The expiration_string variable was changed to a based type to
     accomodate long date strings. Changed default location of memo segment to
     user_info_$homedir, as is documented instead of
     static_project>static_person. Non error messages were changed to use ioa_
     instead of com_err_. Moved and added initialized of variables to
     initialize_memo.
  3) change(1986-08-25,Lippard), approve(1986-07-15,PBF7472),
     audit(1986-09-10,GWMay), install(1986-09-11,MR12.0-1152):
     Fix bug with checking write access.
  4) change(1988-09-20,Flegel), approve(1988-12-07,MCR8021),
     audit(1988-12-14,Lee), install(1989-01-23,MR12.3-1010):
     phx21142 - included "-match" in the option_count calculation so that an
                     action_arg is required.
  5) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


memo: procedure () options (variable);

/* *	This is a command procedure for maintaining a list of memos, with differing maturity dates,
   *	and various options for processing.
   *
   *	Completely rewritten, June, 1979, W. Olin Sibert
   *      Changed iox_$order to iox_$control, 2/12/82 R. Holmstedt
   */

dcl  code fixed bin (35);
dcl  nargs fixed bin;           /* Moved out of process_args to global 				*/
dcl  rsp pointer;
dcl  rsl fixed bin (21);
dcl  rs char (rsl) varying based (rsp);
dcl  P_arg_list ptr;        /* for use with the new argument routine cu_$arg_ptr_rel 			*/
dcl  P_expiration_string ptr;        /* pointer for based expiration_string				*/
dcl  L_expiration_string fixed bin (21);    /* length for based expiration_string			*/
dcl  complain entry variable options (variable);

dcl  temp1 fixed bin;
dcl  idx fixed bin;
dcl  temp_date fixed bin (71);
dcl (month_value, day_of_month, year_value) fixed bin;
dcl  zone_value char (4) aligned;
dcl  fs_mode fixed bin (5);


dcl (list_sw, print_sw, delete_sw, postpone_sw) bit (1) aligned;
dcl (set_memo_sw, set_pathname_sw) bit (1) aligned;
dcl (alarm_sw, invisible_sw, call_sw, per_process_sw, repeat_sw,
     expires_sw, remains_sw, single_sw, repeat_count_sw) bit (1) aligned;
dcl (mature_sw, immature_sw) bit (1) aligned;
dcl (turn_timer_on_sw, turn_timer_off_sw) bit (1) aligned;
dcl  status_sw bit (1) aligned;
dcl (brief_sw, totals_sw, force_sw) bit (1) aligned;
dcl  process_memos_sw bit (1) aligned;
dcl  select_options_specified_sw bit (1) aligned;
dcl  af_sw bit (1) aligned;
dcl  memo_segment_modified bit (1) aligned;		/* set if we do something likely to change the bitcount */
dcl (have_read_access, have_write_access) bit (1) aligned;
dcl  complained bit (1) aligned init("0"b);                 /* set if we gave a benign complaint		*/
      
dcl  default_memo_directory char (64) internal static init("");
dcl  time_now fixed bin (71);
dcl  memo_time_now fixed bin (35);

dcl 1 term_switch aligned like terminate_file_switches;      /* switches for terminate_file_ functions	*/
dcl 1 arg_flags aligned like memo_segment_entry.flags;
dcl 1 set_flags aligned like memo_segment_entry.flags;
dcl 1 select_flags aligned like memo_segment_entry.flags;

dcl  maturity_time fixed bin (71);
dcl (from_time, to_time) fixed bin (71);
dcl  postpone_time fixed bin (71);
dcl  repeat_string char (32);
dcl  repeat_count fixed bin;
dcl  expiration_string char (L_expiration_string) based (P_expiration_string); /* based to accomodate very long expiration time descriptions */
dcl  expiration_time fixed bin (71);
dcl  expiration_delta fixed bin (35);

dcl  memo_text char (132) varying;			/* text of memo to set */

dcl  dname char (168);
dcl  ename char (32);

dcl  n_match_strings fixed bin;			/* number of slots actually used in the array */
dcl  match_string (40) char (32) varying;		/* strings to match against memo text */
dcl  n_memo_numbers fixed bin;			/* number of slots used in array */
dcl 1 memo_number (200) aligned,			/* ranges of memo numbers to list/print/delete/postpone */
    2 start fixed bin (17) unaligned,
    2 finish fixed bin (17) unaligned;
dcl  n_class_names fixed bin;				/* number of class names specified */
dcl  class_name (20) char (32);			/* and the array containing their names */

dcl  memo_match_count fixed bin;

dcl  memo_bits (MAX_NUMBER_MEMOS) bit (1) unaligned;

dcl  static_initialized bit (1) aligned internal static init ("0"b); 
                                                            /* initialized flag */
dcl  static_pointer pointer internal static init (null ()); /* static pointer to default memo segment */
dcl  static_dname char (168) internal static init ("");	/* pathname of default memo segment */
dcl  static_ename char (32) internal static init ("");	/* pathname of default memo segment */
dcl  static_uid bit (36) aligned internal static init (""b); /* static UID of segment, for validity checking */
dcl  memo_timers_enabled bit (1) aligned internal static init ("0"b);
dcl  memo_invocation_count fixed bin internal static init (0);
dcl  end_of_time fixed bin (71) internal static init (-1);
dcl  end_of_memo_time fixed bin (35) internal static init (-1);
dcl  static_person char (32) varying internal static init ("");
dcl  static_project char (32) varying internal static init ("");


dcl  active_fnc_err_ entry options (variable);
dcl  com_err_ entry options (variable);
dcl  command_query_$yes_no entry options (variable);
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
dcl  cu_$arg_list_ptr entry (ptr);
dcl  cu_$af_return_arg_rel entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);
dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);
dcl  decode_clock_value_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin,
     fixed bin (71), fixed bin, char (4) aligned);
dcl  encode_clock_value_ entry (fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin,
     fixed bin (71), fixed bin, char (4) aligned, fixed bin (71), fixed bin (35));
dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$fs_get_mode entry (pointer, fixed bin (5), fixed bin (35));
dcl  hcs_$get_uid_seg entry (pointer, bit (36) aligned, fixed bin (35));
dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), pointer, fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), pointer, fixed bin (35));
dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  ioa_$ioa_switch entry options (variable);
dcl  iox_$control entry (ptr, char(*), ptr, fixed bin(35));
dcl  memo_delete_ entry (pointer, fixed bin, bit (1) aligned);
dcl  memo_list_ entry (pointer, fixed bin, bit (*));
dcl  memo_list_$format_time entry (fixed bin (71)) returns (char (40) varying);
dcl  memo_process_memos_ entry (pointer, (*) bit (1) unaligned, fixed bin (35), bit(1) aligned);
dcl  memo_set_ entry (pointer, char (*), bit (36) aligned, fixed bin (35), fixed bin (35), char (*)) returns (fixed bin);
dcl  memo_timer_set_ entry (pointer, entry);
dcl  memo_upgrade_memo_segment_ entry (pointer);
dcl  memo_util_$end_of_time entry () returns (fixed bin (71));
dcl  timer_manager_$reset_alarm_call entry (entry);
dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
dcl  user_info_ entry (char (*), char (*), char (*));
dcl  user_info_$homedir entry (char (*));
     
dcl  iox_$user_io pointer external static;
dcl  iox_$error_output pointer external static;
dcl  sys_info$time_correction_constant fixed bin (71) external static;

dcl (error_table_$badopt,
     error_table_$bad_conversion,
     error_table_$inconsistent,
     error_table_$noarg,
     error_table_$noentry,
     error_table_$no_r_permission,     
     error_table_$no_w_permission,
     error_table_$not_act_fnc) fixed bin (35) external static;

dcl  SPACE char (1) aligned init (" ") internal static options (constant);
dcl  WHOAMI char (32) internal static options (constant) init ("memo");

dcl  (cleanup, conversion, size) condition;

dcl (null, substr, length, maxlength, binary, min, divide, multiply, ltrim, rtrim, convert, char, clock, hbound, index, string, verify) builtin;

%page;


	call initialize_memo ();			/* set things up */

	memo_segment_modified = "0"b;

	on condition (cleanup) call clean_things_up ();	/* set up to restart the timers */

	memo_invocation_count = memo_invocation_count + 1; /* Remember that there is an active invocation */
          call cu_$arg_list_ptr (P_arg_list);
	
	call process_args ();			/* find out about our arguments */

	if dname = "" then do;			/* no pathname explicitly specified, use default. */
	     call get_default_memo_seg ();
	     memo_segment_ptr = static_pointer;		/* set our pointer */
	     end;

	else if set_pathname_sw then do;		/* otherwise, perhaps set it in static */
	     static_pointer = null ();		/* new memo seg */
	     static_dname = dname;
	     static_ename = ename;
	     static_uid = ""b;

	     call get_default_memo_seg ();		/* get the new default one */
	     memo_segment_ptr = static_pointer;
	     end;

	else do;					/* otherwise, just use it for now */
	     call hcs_$initiate_count (dname, ename, "", 0, 0, memo_segment_ptr, code);
	     if memo_segment_ptr = null () then do;
		call complain (code, WHOAMI,"^/memo segment ^a>^a does not exist.", dname, ename);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

               /* handling for this temporarily known memo segment must be handled seperately */
               call hcs_$fs_get_mode (memo_segment_ptr, fs_mode, code); /* now, see if we have access */
	     if code ^= 0 then do;			/* seems unlikely */
	        call complain (code, WHOAMI, "^a>^a", dname, ename);
	        complained = "1"b;
         	        goto MAIN_RETURN;
	        end;
          
	     if fs_mode = (R_ACCESS_BIN + W_ACCESS_BIN) | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN + W_ACCESS_BIN) then
	        have_write_access, have_read_access = "1"b;
	     else if fs_mode = R_ACCESS_BIN | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN) then
	        have_read_access = "1"b;

	     if ^have_read_access then do;			/* sorry, can't do anything at all with it */
	        call complain (error_table_$no_r_permission, WHOAMI,
"^/memo segment: ^a>^a", dname, ename);
                  complained = "1"b;
	        goto MAIN_RETURN;
                  end;

               if memo_segment.version ^= MEMO_SEGMENT_VERSION_3 then do;
		call complain (0, WHOAMI, "Memo segment ^a>^a is not compatible with current version of memo.",
		     dname, ename);
		complained = "1"b;
		goto MAIN_RETURN;
		end;
	     end;					/* of getting memo segment pointer */

%page;

	if status_sw then do;			/* report status of default memo segment */
	     call ioa_ ("Default memo segment is ^[^a>^a (^p), UID = ^w^;<<Unset>>^]",
		(static_pointer ^= null ()), static_dname, static_ename, static_pointer, static_uid);
	     if static_pointer ^= null () then
		call ioa_ ("Default memo segment is version ^d, ^d slots max used.",
		     static_pointer -> memo_segment.version, static_pointer -> memo_segment.max_number_used);

	     call ioa_ ("Memo timers are ^[en^;dis^]abled.", memo_timers_enabled);
	     complained = "1"b;
	     goto MAIN_RETURN;			/* all done, since we know -status was only operation */
	     end;
	  

	if process_memos_sw then do;			/* select the memos, and process them. Selection defaults to */
	     call select_memos ();			/* mature, nonalarm memos, if user did not specify otherwise */

	     if memo_match_count > 0 then do;
		memo_segment_modified = "1"b; 	/* assume this will modify it */
		call memo_process_memos_ (memo_segment_ptr, memo_bits, memo_time_now, have_write_access);
		end;

	     else if ^brief_sw then			/* only print silly message if user wants it, of course */
		call ioa_$ioa_switch (iox_$error_output, "No memos.");
	     end; 				/* of case for no explicitly specified options */

%page;

	else if print_sw then do;			/* print selected memos */
	     call select_memos ();

	     if memo_match_count = 0 then do;		/* nothing there */
NO_MEMOS_SELECTED:	if ^brief_sw then call ioa_$ioa_switch (iox_$error_output, "No memos selected.");
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     do idx = 1 to memo_segment.max_number_used;
		if memo_bits (idx) = "1"b then do;
		     call ioa_ ("^3d)^2x^a", idx, memo_entry (idx).data);
		     end;
		end;				/* of loop through memos */
	     end; 				/* of case for deletion */


	else if list_sw then do;			/* produce formatted memo listing */
	     call select_memos ();

	     if (memo_match_count = 0) & ^af_sw then	/* nothing there */
		goto NO_MEMOS_SELECTED;

	     if totals_sw then do;			/* just print (or return) total count */
		if af_sw then rs = ltrim (char (memo_match_count));
		else call ioa_ ("^d memos selected.", memo_match_count);
		end;

	     else do idx = 1 to memo_segment.max_number_used;
		if memo_bits (idx) = "1"b then do;
		     if af_sw then do;		/* list as an AF returns a list of memo numbers */
			if length (rs) > 0 then rs = rs || " "; /* separated, natch, by spaces */
			rs = rs || ltrim (char (idx));
			end;			/* of AF case */
		     else call memo_list_ (memo_segment_ptr, idx, ""b);
		     end;
		end;				/* of loop through memos */
	     end; 				/* of case for listing */

%page;


	else if delete_sw then do;			/* delete selected memos */
	     call select_memos ();			/* find out about the ones to delete */

	     if memo_match_count = 0 then goto NO_MEMOS_SELECTED; /* nothing there */

	     if ^have_write_access then do;
		call complain (0, WHOAMI, "Must have w access to ^a>^a to delete memos.", dname, ename);
		goto MAIN_RETURN;
		end;

	     memo_segment_modified = "1"b;		/* remember that it has been modified */

	     do idx = 1 to memo_segment.max_number_used;	/* loop through them all */
		if memo_bits (idx) = "1"b then do;	/* this one was selected */
		     call memo_delete_ (memo_segment_ptr, idx, force_sw);
		     end;
		end;				/* of loop through memos */
	     end; 				/* of case for deletion */


	else if postpone_sw then do;			/* postpone some until later */
	     call select_memos ();

	     if memo_match_count = 0 then goto NO_MEMOS_SELECTED; /* nothing there */

	     if ^have_write_access then do;
		call complain (0, WHOAMI, "Must have w access to ^a>^a to postpone memos.", dname, ename);
		goto MAIN_RETURN;
		end;

	     memo_segment_modified = "1"b;		/* remember that it has been modified */

	     do idx = 1 to memo_segment.max_number_used;
		if memo_bits (idx) = "1"b then do;
		     memo_entry (idx).time = from_gmt (postpone_time);
		     end;
		end;
	     end; 				/* of case for postponement */

%page;

	else if set_memo_sw then do;			/* we are to set one */
	     set_flags = arg_flags;			/* copy flags from whatever was specified earlier */
	     set_flags.print = "1"b;

	     if call_sw then do;
		set_flags.execute = "1"b;
		set_flags.print = "0"b;
		end;

	     if invisible_sw then maturity_time = end_of_time; /* kludgy way of indicating invisibility */

	     if maturity_time = -1 then maturity_time = time_now;

	     if expires_sw then do;			/* must calculate "expiration delta" here, since there isn't */
		call convert_date_to_binary_$relative	/* room to store the actual string. Thus, values like "1month" */
		     (expiration_string, expiration_time, maturity_time, code); /* may behave strangely */

		if code ^= 0 then do;
		     call complain (code, WHOAMI, "Expiration time ^a. Memo not set.", expiration_string);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		if expiration_time <= maturity_time then do; /* can't expire before set, dummy. */
		     call complain (0, WHOAMI, "Expiration time ^a happens before maturity (^a). Memo not set.",
			expiration_string, memo_list_$format_time (maturity_time));
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		expiration_delta = divide ((expiration_time - maturity_time), 1000000, 35, 0); /* change to seconds */
		end;

	     else expiration_delta = 0;		/* otherwise, doesn't expire */

	     if ^have_write_access then do;
		call complain (0, WHOAMI, "Must have w access to ^a>^a to set a memo. Memo not set.", dname, ename);
		goto MAIN_RETURN;
		end;

	     memo_segment_modified = "1"b;

	     temp1 = memo_set_ (memo_segment_ptr, (memo_text), string (arg_flags),
		from_gmt (maturity_time), expiration_delta, repeat_string);

	     if af_sw then rs = ltrim (char (temp1));	/* return index of memo which just got set */
	     end;					/* of case for setting a memo */

%page;

	if turn_timer_off_sw then			/* now, turn timers on and off, and set them */
	     memo_timers_enabled = "0"b;
	if turn_timer_on_sw then
	     memo_timers_enabled = "1"b;

MAIN_RETURN:					/* all done here */
	call clean_things_up ();			/* turn timers on & clean up, if necessary */

	return;

%page;


memo$alarm_entry: entry ();

/* *	This entry is invoked by the alarm timer which goes off to make alarm memos work */

	call initialize_memo ();

	complain = com_err_;    /* moved in front of on unit to avoid window				*/

          call hcs_$fs_get_mode (static_pointer, fs_mode, code); /* now, see if we have access */
	if code ^= 0 then do;			/* seems unlikely */
	   call complain (code, WHOAMI, "^a>^a", dname, ename);
         	   return;
	   end;
          
	if fs_mode = (R_ACCESS_BIN + W_ACCESS_BIN) | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN + W_ACCESS_BIN) then
	   have_write_access = "1"b;

	on condition (cleanup) call clean_things_up ();	/* turn timers back on, etc. */

	memo_invocation_count = memo_invocation_count + 1;

	memo_segment_ptr = static_pointer;
	if memo_segment_ptr = null () then do;
	     call complain (0, WHOAMI, "No memo segment is active. Please type ""memo"" to reset.");
	     return;
	     end;

	call select_mature_memos ("1"b);		/* select all mature alarm memos */

	if memo_match_count > 0 then do;
	     memo_segment_modified = "1"b;		/* assume it will get modified */
	     call memo_process_memos_ (memo_segment_ptr, memo_bits, memo_time_now, have_write_access);
	     end;
	else call complain (0, WHOAMI, "Warning: Alarm received with no memos mature.");

	call iox_$control (iox_$user_io, "start", (null ()), (0));

	call clean_things_up ();			/* exit in an orderly fashion */

	return;					/* done with alarm_entry */

%page;

select_all_memos: proc ();

/* *	This procedure selects all existing memos. */

dcl  idx fixed bin;

	memo_match_count = 0;
	string (memo_bits) = ""b;			/* start out with none */

	do idx = 1 to memo_segment.max_number_used;
	     if memo_entry (idx).taken ^= ""b then do;
		memo_match_count = memo_match_count + 1;
		memo_bits (idx) = "1"b;
		end;
	     end;					/* of loop through memos */

	return;
	end select_all_memos;
       


select_mature_memos: proc (P_alarm);

/* *	This procedure selects all the mature memos which are either alarm or non-alarm */

dcl  P_alarm bit (1) aligned;

dcl  idx fixed bin;

	memo_match_count = 0;
	string (memo_bits) = ""b;			/* start out with none */

	do idx = 1 to memo_segment.max_number_used;
	     if memo_entry (idx).taken ^= ""b then
		if memo_entry (idx).flags.alarm = P_alarm then /* perform filtering on alarmedness */
		     if memo_entry (idx).time <= memo_time_now then do; /* got one */
			memo_match_count = memo_match_count + 1;
			memo_bits (idx) = "1"b;
			end;
	     end;					/* of loop through memos */

	return;
	end select_mature_memos;
       
%page;

select_memos: proc () options (non_quick);

/* *	This procedure sets bits in the memo_bits array to indicate which memos have been selected.
   *	It has knowledge of the type of operation being performed; that is, it behaves differently
   *	when printing, listing, deleting, or postponing. */

dcl  string_match_bits (memo_segment.max_number_used) bit (1) unaligned;
dcl  range_match_bits (memo_segment.max_number_used) bit (1) unaligned;
dcl  type_match_bits (memo_segment.max_number_used) bit (1) unaligned;
dcl  range_match_count (n_memo_numbers) fixed bin;

dcl  total_string_match_count fixed bin;
dcl (idx, jdx) fixed bin;
dcl  matched bit (1) aligned;
dcl (start, finish) fixed bin;


	string (string_match_bits) = ""b;		/* start out with none */
	string (range_match_bits) = ""b;
	string (type_match_bits) = ""b;
	range_match_count (*) = 0;

	if delete_sw | postpone_sw then do;		/* special checking, since otherwise no args would mean "all" */
	     if n_match_strings = 0 & n_memo_numbers = 0 then do; /* can't delete just "invisible", etc. memos, either. */
		call complain (0, WHOAMI, "At least one memo specifier must be used for deletion or postponement.");
		complained = "1"b;
		goto MAIN_RETURN;
		end;
	     end;

	if n_memo_numbers = 0 & n_match_strings = 0 & ^select_options_specified_sw then do;
	     if print_sw | process_memos_sw then	/* mark only the mature ones, if -print or -process specified */
		call select_mature_memos ("0"b);	/* select mature, non-alarm memos */
	     else call select_all_memos ();		/* select all existing memos */
	     return;
	     end;

	if n_match_strings > 0 then do;
	     total_string_match_count = 0;
	     do idx = 1 to memo_segment.max_number_used;	/* try to match against strings */
		if memo_entry (idx).taken ^= ""b then do;
		     do jdx = 1 to n_match_strings while (^string_match_bits (idx));
			if index (memo_entry (idx).data, match_string (jdx)) > 0 then do;
			     string_match_bits (idx) = "1"b;
			     total_string_match_count = total_string_match_count + 1;
			     end;
			end;
		     end;
		end;
	     end;

	if n_memo_numbers > 0 then do;
	     do idx = 1 to n_memo_numbers;		/* loop through all the ranges */
		start = min (memo_segment.max_number_used + 1, memo_number (idx).start);
		finish = min (memo_segment.max_number_used, memo_number (idx).finish);
		do jdx = start to finish;
		     if memo_entry (jdx).taken ^= ""b then do;
			range_match_bits (jdx) = "1"b;
			range_match_count (idx) = range_match_count (idx) + 1;
			end;
		     end;
		end;
	     end;

	if select_options_specified_sw then do;		/* only select certain types of memos */
	     select_flags = arg_flags;
	     if ^invisible_sw & string (select_flags) = ""b then do; /* no explicitly specified options */
		string (select_flags) = "777777777777"b3; /* turn them all on */
		select_flags.pad1 = ""b;		/* except for the padding */
		end;

	     do idx = 1 to memo_segment.max_number_used;
		if memo_entry (idx).taken ^= ""b then do;
		     matched = "0"b;
		     if (string (memo_entry (idx).flags) & string (select_flags)) ^= ""b then
			matched = "1"b;		/* got it by selecting on flags */

		     if from_time ^= -1 then do;	/* see if it's in the right time range */
			matched = "1"b;
			if memo_entry (idx).time >= end_of_memo_time then matched = "0"b; /* discard invisibles */
			else if memo_entry (idx).time < from_gmt (from_time) then matched = "0"b;
			else if memo_entry (idx).time > from_gmt (to_time) then matched = "0"b;
			end;

		     if invisible_sw then		/* kludge mechanism to select invisible memos because it's */
			if memo_entry (idx).time >= end_of_memo_time then /* done by date, rather than having a flag */
			     matched = "1"b;

		     if string_match_bits (idx) then    /* phx21142 - another kludge to pass match strings */
			matched = "1"b;		/* ... as a match is a select_option */

		     type_match_bits (idx) = matched;
		     end;
		end;				/* of loop through memos */
	     end;

	if n_memo_numbers > 0 then do;		/* see if any of the numbers or ranges lost */
	     do idx = 1 to n_memo_numbers;
		if range_match_count (idx) = 0 then do; /* yup... */
		     if memo_number (idx).start = memo_number (idx).finish then
			call complain (0, WHOAMI, "No memos selected by specifier ^d.", memo_number (idx).start);
		     else call complain (0, WHOAMI, "No memos selected by range ^d:^d.",
			memo_number (idx).start, memo_number (idx).finish);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;
		end;
	     end;

	if n_memo_numbers > 0 then do;
	     string (memo_bits) = string (range_match_bits);
	     if n_match_strings > 0 then
		string (memo_bits) = string (memo_bits) & string (string_match_bits);
	     if select_options_specified_sw then
		string (memo_bits) = string (memo_bits) & string (type_match_bits);
	     end;

	else if n_match_strings > 0 then do;
	     string (memo_bits) = string (string_match_bits);
	     if select_options_specified_sw then
		string (memo_bits) = string (memo_bits) & string (type_match_bits);
	     end;

	else string (memo_bits) = string (type_match_bits);

	memo_match_count = 0;
	do idx = 1 to memo_segment.max_number_used;	/* now count the total number of matches */
	     if memo_bits (idx) = "1"b then
		memo_match_count = memo_match_count + 1;
	     end;

	return;
	end select_memos;
       
%page;

process_args: proc ();

/* *	This procedure processes command arguments for the memo command. */

dcl  argno fixed bin;
dcl (al, al1) fixed bin (21);
dcl (ap, ap1) pointer;
dcl  arg char (al) based (ap);
dcl  arg1 char (al1) based (ap1);
dcl (n1, n2, n3) fixed bin (35);
dcl (collecting_memo_sw, collecting_numbers_sw) bit (1) aligned;
dcl (action_count, real_action_count, option_count) fixed bin;
dcl  might_set_sw bit (1) aligned;
dcl  answer bit (1) aligned;
dcl  repeat_time fixed bin (71);

	    
	    

	call cu_$af_return_arg_rel (nargs, rsp, rsl, code, P_arg_list);
	if code = 0 then do;
	     af_sw = "1"b;
	     complain = active_fnc_err_;
	     rs = "";
	     end;

	else if code = error_table_$not_act_fnc then do;
	     af_sw = "0"b;
	     complain = com_err_;
	     end;

	else do;
	     call com_err_ (code, WHOAMI);
	     complained = "1"b;
	     goto MAIN_RETURN;
	     end;

%page;
	might_set_sw = "1"b;			/* assume memo is gonna get set until we learn otherwise */
	collecting_memo_sw = "0"b;			/* true as soon as we encounter first apparent memo text */
	collecting_numbers_sw = "0"b;			/* true if we are collecting numbers, rather than text. */


%page;

LOOP_THROUGH_ARGUMENTS:

	do argno = 1 to nargs;
	     call cu_$arg_ptr_rel (argno, ap, al, (0), P_arg_list);
	     if list_sw | print_sw | postpone_sw | delete_sw | process_memos_sw then do;
		might_set_sw = "0"b;
		collecting_numbers_sw = "1"b;
		end;

	     if substr (arg, 1, 1) ^= "-" | collecting_memo_sw then do; /* not a control arg, see what to do */
		if ^collecting_memo_sw & ^collecting_numbers_sw then /* if not numbers, time to start with text */
		     collecting_memo_sw = "1"b;

		if collecting_numbers_sw then do;	/* try it out as a number */
		     might_set_sw = "0"b;		/* we're doing some sort of list/print/whatever, so no memo */
		     n1 = verify (arg, "0123456789:");	/* is it a number or a range ? */
		     if n1 ^= 0 then do;
BAD_MEMO_NUMBER:		code = error_table_$bad_conversion;
			call complain (code, WHOAMI,
			     "Memo number must be a positive integer or a range, not ""^a"".", arg);
			complained = "1"b;
			goto MAIN_RETURN;
			end;

		     n1 = index (arg, ":");		/* get index of range delimiter */
		     if n1 = 0 then do;		/* no colon, just a single integer */
		          on conversion, size goto BAD_MEMO_NUMBER;
                              n2 = convert (n2, arg);
                              revert conversion, size;
			n3 = n2;			/* range start and end are the same */
			end;

		     else do;			/* otherwise, it's a range */
			if n1 = 1 | n1 = al then	/* colon at start or end */
			     goto BAD_MEMO_NUMBER;

			on conversion, size goto BAD_MEMO_NUMBER;
			n2 = convert (n2, substr (arg, 1, n1 -1)); /* start of range */
			n3 = convert (n3, substr (arg, n1 + 1));   /* end of range */
			revert conversion, size;

			if n3 < n2 then do;		/* can't list 12 through 10, y'know.... */
			     call complain (0, WHOAMI,
				"The upper bound of a range must be greater than the lower bound: ^a", arg);
			     complained = "1"b;
			     goto MAIN_RETURN;
			     end;
			end;

                         if n2 = 0 then do;     /* null second argument check */
		        call complain (0, WHOAMI,
"0 is not an acceptable memo number.");
                            complained = "1"b;
		        goto MAIN_RETURN;
		        end;

		     if n_memo_numbers >= hbound (memo_number, 1) then do;
			call complain (0, WHOAMI, "Too many memo numbers specified. Max is ^d.",
			     hbound (memo_number, 1));
			complained = "1"b;
			goto MAIN_RETURN;
			end;

		     n_memo_numbers = n_memo_numbers + 1; /* remember this one in our list */
		     memo_number (n_memo_numbers).start = n2;
		     memo_number (n_memo_numbers).finish = n3;
		     end;				/* of case for a number */

		else if collecting_memo_sw then do;	/* otherwise, add it to the memo text string */
		     if al + 1 + length (memo_text) > maxlength (memo_text) then do;
			call complain (0, WHOAMI, "Memo text is too long. Max is ^d characters. Memo not set.",
			     maxlength (memo_text));
			complained = "1"b;
			goto MAIN_RETURN;
			end;

		     if length (memo_text) > 0 then	/* add a space if not first word */
			memo_text = memo_text || SPACE;
		     memo_text = memo_text || arg;	/* and add the argument as well */
		     might_set_sw = "1"b;		/* all further error messages should say Memo not set */
		     set_memo_sw = "1"b;		/* we know we're supposed to set it, now */
		     end;				/* of case for adding memo text */

		end;				/* of case for non control argument */

	     else if arg = "-memo" then do;		/* means next arg is memo text */
		if collecting_numbers_sw then do;
		     call complain (error_table_$inconsistent, WHOAMI,
			"Memo setting (with -memo) may not be combined with any other operations. Memo not set.");
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		if argno = nargs then do;
		     call complain (error_table_$noarg, WHOAMI, "Some memo text must follow -memo.^2xMemo not set.");
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		collecting_memo_sw = "1"b;
		end;

	     else if arg = "-brief" | arg = "-bf" then brief_sw = "1"b;
	     else if arg = "-long" | arg = "-lg" then brief_sw = "0"b;
	     else if arg = "-totals" | arg = "-total" | arg = "-tt" then totals_sw = "1"b;
	     else if arg = "-on" then turn_timer_on_sw = "1"b;
	     else if arg = "-off" then turn_timer_off_sw = "1"b;
	     else if arg = "-force" | arg = "-fc" then force_sw = "1"b;
	     else if arg = "-status" | arg = "-st" then status_sw = "1"b;

	     else if arg = "-invisible" | arg = "-iv" then invisible_sw = "1"b;
	     else if arg = "-alarm" | arg = "-al" then alarm_sw = "1"b;
	     else if arg = "-call" then call_sw = "1"b;
	     else if arg = "-repeat_when_processed" | arg = "-rwp" then per_process_sw = "1"b;
	     else if arg = "-retain" | arg = "-ret" then remains_sw = "1"b;
	     else if arg = "-no_retain" | arg = "-nret" then single_sw = "1"b;

	     else if arg = "-postpone" | arg = "-pp" then do; /* postpone all the memos specified */
		postpone_time = get_next_date_arg ();	/* get the date to postpone to */

		collecting_numbers_sw = "1"b;		/* and get ready to collect memo numbers */
		postpone_sw = "1"b;
		end;

	     else if arg = "-list" | arg = "-ls" then list_sw = "1"b;
	     else if arg = "-print" | arg = "-pr" then print_sw = "1"b;
	     else if arg = "-delete" | arg = "-dl" then delete_sw = "1"b;
	     else if arg = "-process" then process_memos_sw = "1"b;

	     else if arg = "-date" | arg = "-dt" then do; /* midnight of this particular date */
		if maturity_time ^= -1 then do;	/* already have one */
ALREADY_HAVE_DATE:	     call complain (0, WHOAMI,
			"Only one value may be specified with -date or -time.^[^2xMemo not set.^]", might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		maturity_time = get_next_date_arg ();

		call decode_clock_value_ (maturity_time, month_value, day_of_month, year_value, (0), (0), zone_value);
		call encode_clock_value_ (month_value,
		     day_of_month, year_value, 0, 0, 0, 0, 0, zone_value, maturity_time, code);

		if code ^= 0 then do;
		     call complain (code, WHOAMI, "^a^[.^2xMemo not set.^]", arg, might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;
		end;				/* of processing for -date */

	     else if arg = "-time" | arg = "-tm" then do;
		if maturity_time ^= -1 then goto ALREADY_HAVE_DATE;

		maturity_time = get_next_date_arg ();
		end;				/* of processing for -time */

	     else if arg = "-from" | arg = "-fm" then do; /* list memos maturing at or after this time */
		if from_time ^= -1 then do;		/* already have one */
		     call complain (0, WHOAMI, "Only one value may be specified for -from.");
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		from_time = get_next_date_arg ();
		end;				/* of processing for -from */

	     else if arg = "-to" then do;		/* list memos maturing at or before this time */
		if to_time ^= -1 then do;		/* already have one */
		     call complain (0, WHOAMI, "Only one value may be specified for -to.");
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		to_time = get_next_date_arg ();
		end;				/* of processing for -to */

	     else if arg = "-repeat" | arg = "-rp" | arg = "-rpt" then do;
		if repeat_sw then do;		/* we already have one */
		     call complain (0, WHOAMI,
			"Only one value may be specified for -repeat.^[^2xMemo not set.^]", might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		repeat_sw = "1"b;			/* remember that we have a repeat specification */

		if argno = nargs then		/* if last argument, and listing, printing, etc., */
		     if list_sw | print_sw | postpone_sw | delete_sw then /* accept it as an option specification */
			goto END_ARGUMENT_LOOP;

		call get_next_string_arg ();		/* puts it in arg1 */

		if al1 > maxlength (repeat_string) then do; /* too long */
		     call complain (0, WHOAMI, "The repeat string may only be ^d characters.^[^2xMemo not set.^]",
			maxlength (repeat_string), might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		repeat_string = arg1;
		end;				/* of processing for -repeat */


	     else if arg = "-times" then do;		/* limit on how many times we can repeat */
		if "1"b then goto BADOPT;		/* for now, it's unimplemented */
		repeat_count_sw = "1"b;		/* remember that we have one */

		if argno = nargs then		/* if last argument, and listing, printing, etc., */
		     if list_sw | print_sw | postpone_sw | delete_sw then /* accept it as an option specification */
			goto END_ARGUMENT_LOOP;

		call get_next_string_arg ();		/* put it in arg1 */

		on conversion, size goto BAD_CONVERSION;
		repeat_count = convert (repeat_count, arg1);
		revert conversion, size;

		if repeat_count < 1 then goto BAD_REPEAT_COUNT; /* must be positive, ninny (code will be zero) */
		end;				/* of processing for -times */

	     else if arg = "-expires" | arg = "-expire" | arg = "-exp" | arg = "-ex" then do;
		if expires_sw then do;
		     call complain (0, WHOAMI,
			"Only one value may be specified for expiration time.^[^2xMemo not set.^], might_set_sw");
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		expires_sw = "1"b;			/* remember that we have an expiration specification */

		if argno = nargs then		/* if last argument, and listing, printing, etc., */
		     if list_sw | print_sw | postpone_sw | delete_sw then /* accept it as an option specification */
			goto END_ARGUMENT_LOOP;

		call get_next_string_arg ();		/* puts it in arg1 */

		call convert_date_to_binary_ (arg1, temp_date, code);
		if code ^= 0 then do;
		     call complain (code, WHOAMI,
			"^a must be followed by a valid time value not ""^a"".^[^2xMemo not set.^]",
			arg, arg1, might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		L_expiration_string = al1;
                    P_expiration_string = ap1;
		end;				/* of processing for -expires */

	     else if arg = "-class" then do;		/* memos in this class or classes */
		if "1"b then goto BADOPT;		/* for now, it's unimplemented */
		call get_next_string_arg ();		/* puts it in arg1 */

		if al1 > maxlength (class_name (1)) then do; /* too long */
		     call complain (0, WHOAMI, "A class name may only be ^d characters.", maxlength (class_name (1)));
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		if n_class_names >= hbound (class_name, 1) then do;
		     call complain (0, WHOAMI, "Too many class names specified. Max is ^d.", hbound (class_name, 1));
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		n_class_names = n_class_names + 1;
		class_name (n_class_names) = arg1;
		end;				/* of processing for -class */

	     else if arg = "-match" then do;		/* memos matching this string */
		call get_next_string_arg ();		/* puts it in arg1 */

		if al1 > maxlength (match_string (1)) then do; /* too long */
		     call complain (0, WHOAMI, "The match string may only be ^d characters.",
			maxlength (match_string (1)));
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		if n_match_strings >= hbound (match_string, 1) then do;
		     call complain (0, WHOAMI, "Too many match strings specified. Max is ^d.", hbound (match_string, 1));
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		n_match_strings = n_match_strings + 1;
		match_string (n_match_strings) = arg1;
		end;				/* of processing for -match */

	     else if arg = "-path_name" | arg = "-pathname" | arg = "-path" | arg = "-pn" then do;
		if dname ^= "" then do;		/* already have one */
		     call complain (0, WHOAMI, "Only one pathname may be specified.^[^2xMemo not set.^]", might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;

		call get_next_string_arg ();		/* puts it in arg1 */

		if arg1 = "-default" | arg1 = "-dft" then do; /* construct default pathname */
		     call user_info_$homedir (dname);
		     ename = static_person || ".memo";
		     end;

		else do;				/* otherwise, a real pathname */
		     call expand_pathname_$add_suffix (arg1, "memo", dname, ename, code);
		     if code ^= 0 then do;
			call complain (code, WHOAMI, "^a^[.^2xMemo not set.^]", arg1, might_set_sw);
			complained = "1"b;
			goto MAIN_RETURN;
			end;
		     end;
		end;				/* of processing for -pathname */

	     else do;				/* not one of ours, Jack. */
BADOPT:		call complain (error_table_$badopt, WHOAMI, "^a^[.^2xMemo not set.^]", arg, might_set_sw);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

END_ARGUMENT_LOOP:
end LOOP_THROUGH_ARGUMENTS;
	  

%page;

	if (^set_memo_sw) & (maturity_time > 0) & (to_time = -1) & (from_time = -1) then do;
	     to_time = maturity_time; 		/* Kludge to make memo -print -time 2359.9 work like it */
	     maturity_time = -1;			/* used to work. */
	     end;

	if to_time > 0 & from_time = -1 then		/* to without from, list all from beginning */
	     from_time = 0;

	if from_time > 0 & to_time = -1 then		/* from without to, list all until the end of time */
	     to_time = end_of_time;

	action_count = binary (set_memo_sw, 1)
	     + binary (process_memos_sw, 1)
	     + binary (postpone_sw, 1)
	     + binary (delete_sw, 1)
	     + binary (list_sw, 1)
	     + binary (print_sw, 1);

	string (arg_flags) = ""b;			/* copy the flags into a copy of the structure */
	arg_flags.repeatsw = repeat_sw;
	arg_flags.single = single_sw;
	arg_flags.remains = remains_sw;
	arg_flags.expires = expires_sw;
	arg_flags.execute = call_sw;
	arg_flags.alarm = alarm_sw;
	arg_flags.per_process = per_process_sw;

	option_count = binary (invisible_sw, 1)		/* whether any memo options were specified */
	     + binary ((string (arg_flags) ^= ""b), 1)	/* assorted options here */
	     + binary (mature_sw, 1)
	     + binary (immature_sw, 1)
	     + binary ((maturity_time ^= -1), 1)
	     + binary ((repeat_count ^= -1), 1)
	     + binary ((from_time ^= -1), 1)
	     + binary ((n_match_strings ^= 0), 1);	/* MF - phx21142 - -match needs to be included */

	select_options_specified_sw = (option_count > 0); /* flag for use in select_memos */

/* *	Now check for various illegal combinations. An example is provided for most of these,
   *	which illustrates the type of error that might cause the illegal combination. */

	if turn_timer_on_sw & turn_timer_off_sw then	/* memo -on -off */
	     call inconsistent ("-on and -off.");

	real_action_count = action_count;		/* to detect those options which may be combined */

	if action_count = 0 & (turn_timer_on_sw | turn_timer_off_sw) then do; /* allow timer to be turned on and off */
	     if option_count > 0 then			/* along with other actions, as well as alone */
		call inconsistent ("No memo options may be specified when turning the timers on and off.");
	     real_action_count = 1;			/* memo -invisible -off */
	     end;

	if action_count = 0 & dname ^= "" then do;	/* memo -invisible -pathname >frobboz */
	     if option_count > 0 then
		call inconsistent ("No memo options may be specified when setting the default pathname.");
	     set_pathname_sw = "1"b;			/* we are to set the static pathname */
	     memo_timers_enabled = "0"b;		/* turn this off, so switching segs won't blow us out */
	     real_action_count = 1;			/* turn it into an "action", so succeeding tests will work */
	     end;

	if real_action_count = 0 & option_count = 0 then do; /* if no other options specified, we're just to process */
	     turn_timer_on_sw = "1"b;		/* mature memos and turn on the timers */
	     process_memos_sw = "1"b;			/* so indicate that */
	     end;

	else if real_action_count = 0 then do;		/* nothing specified */
	     call complain (error_table_$noarg, WHOAMI,	/* memo -invisible */
		"Some action must be specified when memo options are specified.^2xMemo not set.");
	     complained = "1"b;
	     goto MAIN_RETURN;
	     end;					/* of case for no explicit actions */

	if repeat_sw then do;			/* check the repeat time for validity */
	     call convert_date_to_binary_$relative (repeat_string, repeat_time, time_now, code);
	     if code ^= 0 then do;
		call complain (code, WHOAMI,
		     "-repeat must be followed by a valid time offset, not ""^a"".^[^2xMemo not set.^]",
		     repeat_string, set_memo_sw);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     if repeat_time <= time_now then do;
		call complain (0, WHOAMI, "The repeat string ^a yields a time in the past.^[^2xMemo not set.^]",
		     repeat_string, set_memo_sw);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     if set_memo_sw & ^force_sw & ((repeat_time - time_now) < (60 * 1000000)) then do; /* allow forcing */
						/* if setting a memo, not supposed to say -repeat 1second */
		call command_query_$yes_no (answer, 0, WHOAMI, "", /* but give the user a chance anyway */
		     "The repeat interval ^a is less than one minute. Do you still wish to use it?", repeat_string);
		if answer = "0"b then do;
		     call complain (0, WHOAMI, "Memo not set.");
		     complained = "1"b;
		     goto MAIN_RETURN;
		     end;
		end;
	     end; 				/* of testing for -repeat */

%page;

	if action_count > 1 then call inconsistent	/* memo -delete -print */
	     ("Only one action (printing, listing, deletion, postponement or memo setting) may be specified.");

	if force_sw & ^(delete_sw | postpone_sw | set_memo_sw) then /* memo -force -list */
	     call inconsistent ("-force may only be specified with -delete or -postpone.");

	if set_memo_sw & (from_time ^= -1 | mature_sw | immature_sw) then
	     call inconsistent			/* memo -from 3days Shoot first, ask questions later. */
		("The -from, -to, -mature and -immature control arguments may not be combined with memo setting.");

	if af_sw & ^(set_memo_sw | list_sw) then	/* ps [memo -delete 10] */
	     call inconsistent ("Only memo setting and listing are allowed as an active function.");

	if (from_time ^= -1) & (maturity_time ^= -1) then /* memo -ls -date Monday -from Tuesday */
	     call inconsistent ("The -from and -to arguments may not be combined with -date or -time.");

	if set_memo_sw & ^alarm_sw & remains_sw then	/* memo -remains Buy new aardvark leash. */
	     call inconsistent ("-remains may only be used when setting an alarm memo.");

	if set_memo_sw & ^repeat_sw & per_process_sw then /* memo -per_process Check for elephants in the basement. */
	     call inconsistent ("-repeat_when_processed may only be used when setting a repeating memo.");

	if set_memo_sw & brief_sw then		/* memo -brief Buy 3 cans of frog propellant tomorrow! */
	     call inconsistent ("-brief not allowed when setting a memo.");

	if set_memo_sw & (n_memo_numbers > 0 | n_match_strings > 0) then /* memo -match EGGs Win 20 free dance lessons */
	     call inconsistent ("No memo numbers or match strings may be specified when setting a memo.");

	if set_memo_sw & (n_class_names > 1) then	/* memo -class C1 -class C2 This is a ring 1 multi-class memo */
	     call inconsistent ("At most one memo class may be specified when setting a memo.");

	if status_sw & nargs > 1 then 		/* This is cheating, but I really want it only for debugging */
	     call inconsistent ("-status must be the only argument if it is specified.");

	if totals_sw & ^list_sw then			/* memo -delete -tt */
	     call inconsistent ("-totals may only be used with -list.");

	return;

BAD_CONVERSION:	     code = error_table_$bad_conversion;
BAD_REPEAT_COUNT:	     call complain (code, WHOAMI,
			"-times must be followed by a positive number, not ""^a"".^[^2xMemo not set.^]",
			arg1, might_set_sw);
		     complained = "1"b;
		     goto MAIN_RETURN;
%page;

get_next_date_arg: proc () returns (fixed bin (71));

/* *	This procedure extracts the next argument in the string, and returns it as a clock value */

dcl  temp_time fixed bin (71);

	     if argno = nargs then do;
		call complain (error_table_$noarg, WHOAMI,
		     "Date/Time after ^a.^[^2xMemo not set.^]", arg, might_set_sw);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     argno = argno + 1;
	     call cu_$arg_ptr_rel (argno, ap1, al1, (0), P_arg_list);

	     call convert_date_to_binary_ (arg1, temp_time, code);
	     if code ^= 0 then do;
		call complain (code, WHOAMI, "^a ^a^[.^2xMemo not set.^]", arg, arg1, might_set_sw);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     return (temp_time);
	     end get_next_date_arg;
	  

get_next_string_arg: proc ();

/* *	This procedure extracts the next argument in the string, and returns it as a clock value */

	     if argno = nargs then do;
		call complain (error_table_$noarg, WHOAMI, "After ^a.^[^2xMemo not set^]", arg, might_set_sw);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     argno = argno + 1;
	     call cu_$arg_ptr_rel (argno, ap1, al1, (0), P_arg_list);

	     return;
	     end get_next_string_arg;
	  


inconsistent: proc (P_message);

/* *	This procedure just calls complain with the message and punts. */

dcl  P_message char (*) parameter;

	     call complain (error_table_$inconsistent, WHOAMI, "^a^[^2xMemo not set.^]", P_message, set_memo_sw);
	     complained = "1"b;
	     goto MAIN_RETURN;

	     end inconsistent;
	  

	end process_args;
       

%page;

get_default_memo_seg: proc ();

/* *	This procedure tries to set the static_pointer to point to the right default memo segment */

dcl  temp_uid bit (36) aligned;

	if static_pointer ^= null () then do;		/* it claims we have one, so let's check.... */
	     call hcs_$get_uid_seg (static_pointer, temp_uid, code);
	     if code ^= 0 then do;
MEMO_SEG_ERROR:	call complain (code, WHOAMI, "^a>^a", static_dname, static_ename);
		complained = "1"b;
		goto MAIN_RETURN;
		end;

	     if temp_uid ^= static_uid then do;		/* Oh dear. Reused segment number.... */
		call com_err_ (0, WHOAMI, "Warning: ^a>^a has been terminated since last invocation of memo command.",
		     static_dname, static_ename);
		static_pointer = null ();		/* flag it as invalid */
		end;
	     end;

	if static_pointer = null () then do;		/* the segment isn't there. Let's see if we can find it */
	     if static_dname = "" then do;		/* first call, so set the pathname to the right default. */
		static_dname = default_memo_directory;
		static_ename = static_person || ".memo";
		dname = static_dname;
		ename = static_ename;
		end;

	     call hcs_$initiate_count (static_dname, static_ename, "", (0), 0, static_pointer, code);

	     if static_pointer = null () & code = error_table_$noentry then do; /* create if not there ? */
		call hcs_$make_seg (static_dname, static_ename, "", R_ACCESS_BIN + W_ACCESS_BIN, static_pointer, code);

		if static_pointer = null () then goto MEMO_SEG_ERROR; /* couldn't create, give up. */
		else call ioa_ ("^a: Creating ^a>^a.", WHOAMI, static_dname, static_ename);

		static_pointer -> memo_segment.version = MEMO_SEGMENT_VERSION_3; /* start out right.... */
		end;				/* of attempt to create memo segment */

	     if static_pointer = null () then		/* still?? we lost, then */
		goto MEMO_SEG_ERROR;

	     call hcs_$get_uid_seg (static_pointer, static_uid, code); /* remember its identifier, for good measure */
	     if code ^= 0 then goto MEMO_SEG_ERROR;
	     end;					/* of nonexistent memo seg case */

	call hcs_$fs_get_mode (static_pointer, fs_mode, code); /* now, see if we have access */
	if code ^= 0 then do;			/* seems unlikely */
	     call complain (code, WHOAMI, "^a>^a", dname, ename);
	     complained = "1"b;
	     goto MAIN_RETURN;
	     end;

	if fs_mode = (R_ACCESS_BIN + W_ACCESS_BIN) | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN + W_ACCESS_BIN) then
	     have_write_access, have_read_access = "1"b;
	else if fs_mode = R_ACCESS_BIN | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN) then
	     have_read_access = "1"b;

	if ^have_read_access then do;			/* sorry, can't do anything at all with it */
	     call complain (error_table_$no_r_permission, WHOAMI, "
memo segment: ^a>^a", static_dname, static_ename);

	     goto MAIN_RETURN;
	     end;

	if static_pointer -> memo_segment.version < MEMO_SEGMENT_VERSION_3 then /* try to covert */
	     call memo_upgrade_memo_segment_ (static_pointer); /* before testing again */

	if static_pointer -> memo_segment.version ^= MEMO_SEGMENT_VERSION_3 then do;
	     call complain (0, WHOAMI, "Memo segment ^a>^a is is not the correct version.", static_dname, static_ename);
	     complained = "1"b;
	     goto MAIN_RETURN;
	     end;

	return;
	end get_default_memo_seg;
       
%page;

initialize_memo: proc ();

/* *	This procedure initializes various variables for an invocation of memo. */

dcl (person, project) char (32);

	if ^static_initialized then do;
	     end_of_time = memo_util_$end_of_time ();	/* call and find out */
	     end_of_memo_time = from_gmt (end_of_time);
	     call user_info_ (person, project, (""));
	     static_person = rtrim (person);
	     static_project = rtrim (project);
	     call user_info_$homedir (default_memo_directory);
	     static_initialized = "1"b;
	     end;

	P_expiration_string = null;
	L_expiration_string = 0;
	P_arg_list = null;
	call timer_manager_$reset_alarm_call (memo$alarm_entry);

	complained = "0"b;
	memo_bits (*) = ""b;
	time_now = clock ();
	memo_time_now = from_gmt (time_now);
/* variable initializations moved here from process_args so they will be initialized from both entry points	*/
	memo_segment_modified = "0"b;			/* start out assuming that it wasn't modified */
	memo_segment_ptr = null ();			/* and with a null pointer to it */
 	memo_text = "";				/* the collected text of the memo being set */
	n_match_strings, n_memo_numbers = 0;		/* how many match strings/memo numbers have been collected */
	n_class_names = 0;				/* how many memo classes to process */
	list_sw, print_sw, delete_sw, postpone_sw = "0"b; /* one per action, other than setting */
	process_memos_sw = "0"b;			/* this is done if nothing else is specified */
	set_memo_sw = "0"b;
	set_pathname_sw = "0"b;			/* whether to use the specified pathname permanently */
	select_options_specified_sw = "0"b;
	maturity_time = -1;				/* the date we are interested in */
	repeat_string = "";				/* how often to repeat the memo */
	repeat_count = -1;				/* max number of times it gets repeated before exploding */
	repeat_sw, expires_sw, remains_sw, single_sw,	/* set if the option in question is to be used */
	     per_process_sw, alarm_sw, call_sw, repeat_count_sw, invisible_sw = "0"b;
	dname, ename = "";				/* pathname of specified memo segment */
	brief_sw = "0"b;				/* controls noisiness of messages */
	force_sw = "0"b;				/* whether or not to force deletion */
	totals_sw = "0"b;				/* for listing only, print total count rather than memos */
	turn_timer_on_sw, turn_timer_off_sw = "0"b;	/* timer control flags */
	af_sw = "0"b;
	fs_mode = 0;
	status_sw = "0"b;				/* whether to report status of default memo segment */
	from_time, to_time = -1;			/* time to list from/to */
	mature_sw, immature_sw = "0"b;		/* select only mature/immature memos */
	have_write_access = "0"b;
	have_read_access = "0"b;
          complained ="0"b;
	nargs = 0;

	return;
	end initialize_memo;
       


from_gmt:	proc (clock_value) returns (fixed bin (35));

dcl  clock_value fixed bin (71) parameter;
dcl  memo_time fixed bin (35);

	memo_time = divide ((clock_value - sys_info$time_correction_constant), 1000000, 35, 0);

	return (memo_time);
	end from_gmt;
       

clean_things_up: proc ();

/* *	This is the cleanup handler procedure; actually, all it does is turn timers back on if needed. */
dcl  size builtin;

     if static_pointer = null then     /* check if we got here before static variables were set */
        return;                        /* if so, no need to clean them up */
     if have_write_access | complained then do; /* do we need to clean up the static variables? */
	if memo_segment_modified then			/* set the bitcount, maybe? */
	     if memo_segment_ptr ^= null () then
		call hcs_$set_bc_seg (memo_segment_ptr, multiply ((size (memo_segment_header)
		     + memo_segment.max_number_used * size (memo_segment_entry)), 36, 24, 0), (0));

	memo_invocation_count = memo_invocation_count - 1; /* "unstack" */
	if memo_invocation_count < 0 then memo_invocation_count = 0;

	if static_pointer ^= null () then		/* only if we have one, of course */
	     if memo_timers_enabled then
		if memo_invocation_count = 0 then	/* Only outermost invocation diddles timers */
		     call memo_timer_set_ (static_pointer, memo$alarm_entry);
           end;
        
        else do; /* terminate the file we can't use, and clear the static variables that describe it */
           term_switch.truncate = "0"b;
           term_switch.set_bc = "0"b;
           term_switch.terminate = "1"b;  /* set switch for terminate_file_ to terminate a null reference name*/
           term_switch.force_write = "1"b; /* set switch to remove modified memo segment from main memory	*/
           term_switch.delete = "0"b;
           call terminate_file_ (memo_segment_ptr, 0, string (term_switch),
	    code);
           if code ^= 0 then
              call complain (code, WHOAMI, 
"Unable to terminate memo segment. ^/memo segment: ^a>^a.", dname, ename);
	 else do;
	    static_pointer = null;   /* reset static variables 					*/
              static_initialized = "0"b;
	    static_uid = ""b;
	    memo_timers_enabled = "0"b;
	    memo_invocation_count = 0;
	    end_of_time = -1;
	    end_of_memo_time = -1;
	    static_person = "";
	    static_project = "";
              if list_sw | print_sw | (list_sw & set_pathname_sw & nargs = 3) | (print_sw & set_pathname_sw & nargs = 3) then;
              else 
	       call complain (error_table_$no_w_permission,WHOAMI,"^a>^a.
Unable to delete or reschedule memos. Memos disabled.",static_dname,static_ename);
	    static_dname = "";
	    static_ename = "";
	    end;
	 end;
        return;
        end clean_things_up;
%page; %include memo_segment;
%page; %include access_mode_values;
%page; %include terminate_file;
       

	end memo; 				/* external procedure memo */
