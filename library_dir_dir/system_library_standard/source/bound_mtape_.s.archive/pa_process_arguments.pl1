/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *                                                         *
   *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(82-03-18,Spratt), approve(), audit(), install():
     Written.
  2) change(83-05-01,York), approve(), audit(), install():
     William M.  York and Suzanne Krupp: to prepare for exposure release as
     part of the new tape software.
  3) change(83-06-20,Spratt), approve(), audit(), install():
     Converted from process_arguments_.pl1.  Renamed the main entry
     $argument_list, added the $argument_array and $argument_string entries,
     and the code which supports them.
  4) change(83-06-27,Spratt), approve(), audit(), install():
     Moved the search list code into a separate module, pa_search_list.
  5) change(83-06-29,York), approve(), audit(), install():
     Get all the excluded options out of the definition, fix checking
     for required arguments, and add validation of arguments.
  6) change(83-07-01,York), approve(), audit(), install():
     Interpret a required argument as meaning that only one instance of the
     argument is required even if more are allowed.  Also improved error
     messages and set proper maximum value lengths for the dimensions of the
     result pva.
  7) change(83-07-01,Spratt), approve(), audit(), install():
     Fixed to use the new calling sequence of $get_default_linear_form.  The
     process_arguments_$argument_string entry is now used to parse the
     default_linear_form into an initial result_print_vector_array.  This
     interaction should be improved so that the invocation of
     pa_process_arguments which gets the default_linear_form and the
     invocation of pa_process_arguments can share the processed form of the
     definition.  Fixed to call CONVERT_STRING_TO_ARG_LIST for the
     default_linear_form.
  8) change(83-07-07,Spratt), approve(), audit(), install():
     Fixed to use a first_arg_idx of 1 when processing the default linear
     form.  Also fixed to report a missing explanation instead of taking a
     null pointer fault.  Changed to evaluate active strings in default linear
     forms.
  9) change(83-07-08,Spratt), approve(), audit(), install():
     Changed to use "-quote -foo" instead of "--foo" to force the
     interpretation of "-foo" as an option value and not an option reference
     name.  Moved the invocation of PRINT_EXPLANATION into the main
     option-value-processing do-group of the ARG_LOOP to ensure that the
     control_argument_ptr is set.
 10) change(83-07-20,Spratt), approve(), audit(), install():
     Changed the CONVERT_ARRAY_TO_LIST to return a null arg_list_ptr when the
     input argument_array has one element which equals "".  Changed
     CONVERT_STRING_TO_LIST to return a null arg_list_ptr when the input
     arg_string equals "".
 11) change(83-07-25,SKrupp), approve(), audit(), install():
     Fixed handling of implied options that have arguments prefixed by a
     "-quote".  Fixed MISPLACED_CONTROL_ARGUMENT to test for
     control_argument_is_in_effect as well as what it already tests for.
 12) change(83-08-03,SKrupp), approve(), audit(), install():
     Added result validation and fixed assorted bugs.
 13) change(83-08-28,SKrupp), approve(), audit(), install():
     Added argument validation explanations and the ability to force arguments
     to be taken literally in to the -quote facility.
 14) change(85-10-03,GWMay), approve(85-10-03,MCR7282), audit(85-12-16,GDixon),
     install(85-12-17,MR12.0-1001):
     Reformatted history comments.  Modified PROCESS_ARGUMENT_LIST to
     initialize the control_argument_is_in_effect,
     using_implicit_control_argument and option_accepts_explicit_argument
     switches to false.
                                                   END HISTORY COMMENTS */

/* format: style2,ind3 */
pa_process_arguments:
   proc ();


/* START OF DECLARATIONS */
/* Parameter */

      dcl	    p_command_name	       char (*);
      dcl	    p_arg_processing_mode  fixed bin;
      dcl	    p_arg_list_ptr	       ptr;
      dcl	    p_first_arg_idx	       fixed bin;
      dcl	    p_arg_array	       (*) char (*) varying;
      dcl	    p_arg_string	       char (*) varying;
      dcl	    p_definition_print_vector_array_ptr
			       ptr;
      dcl	    p_work_area_ptr	       ptr;
      dcl	    p_result_print_vector_array_ptr
			       ptr;
      dcl	    p_code	       fixed bin (35);

/* Automatic */

      dcl	    using_implicit_control_argument
			       bit (1) aligned init ("0"b);
      dcl	    last_arg_idx_processed fixed bin init (0);
      dcl	    first_arg_idx	       fixed bin init (0);
      dcl	    (arg_list_ptr, default_arg_list_ptr)
			       ptr init (null);
      dcl	    dim_idx	       fixed bin;
      dcl	    max_value_arg_len      fixed bin;
      dcl	    (implied_control_argument_name_identifier, control_argument_name_identifier,
	    next_implied_control_argument_name_identifier, result_control_argument_name_identifier,
	    argument_name_identifier, initial_argument_name_identifier, next_argument_name_identifier,
	    option_presence_identifier, argument_presence_identifier, explanation_identifier, synonym_identifier,
	    validation_string_identifier, antonym_identifier, result_instance_identifier,
	    result_command_name_identifier, result_order_identifier, default_argument_value_identifier,
	    negative_default_argument_value_identifier, excluded_option_identifier)
			       fixed bin;
      dcl	    implied_control_argument_ptr
			       ptr;
      dcl	    vector_idx	       fixed bin;
      dcl	    temp_idx	       fixed bin;
      dcl	    real_vector_count      fixed bin;
      dcl	    control_argument_name_dim_id
			       fixed bin;
      dcl	    old_control_argument_name_dim_id
			       fixed bin;
      dcl	    old_print_vector_ptr   ptr;
      dcl	    old_control_argument_ptr
			       ptr;
      dcl	    root_control_argument_ptr
			       ptr;
      dcl	    arg_exists	       bit (1) aligned;
      dcl	    option_accepts_explicit_argument
			       bit (1) aligned;
      dcl	    control_argument_is_in_effect
			       bit (1) aligned init ("0"b);
      dcl	    exists_implied_control_argument
			       bit (1) aligned init ("0"b);
      dcl	    implied_control_argument_name_ptr
			       ptr;
      dcl	    implied_control_argument_name_length
			       fixed bin;
      dcl	    first_argument_name_ptr
			       pointer;
      dcl	    first_argument_name_len
			       fixed bin;
      dcl	    global_instance_count  fixed bin init (0);
      dcl	    value_idx	       fixed bin init (0);
      dcl	    arg_idx	       fixed bin;
      dcl	    nargs		       fixed bin;
      dcl	    arg_ptr	       ptr;
      dcl	    arg_len	       fixed bin;
      dcl	    force_interpretation_as_non_control_argument
			       bit (1) aligned init ("0"b);
      dcl	    control_argument_ptr   ptr;
      dcl	    arg_info_ptr	       ptr;
      dcl	    name_array_idx	       fixed bin;
      dcl	    active_string	       char (4096) varying;
      dcl     active_explanation     char(4096) varying;
      dcl	    result	       char (5) varying;


      dcl	    name_array_count       fixed bin init (0);

      dcl	    1 name_array	       (200),
	      2 name_ptr	       ptr,
	      2 def_ptr	       ptr,
	      2 antonym	       bit (1) aligned;

      dcl	    1 value	       (100),
	      2 arg_name_ptr       ptr,
	      2 arg_name_len       fixed bin,
	      2 arg_ptr	       ptr,
	      2 arg_len	       fixed bin;

      dcl	    default_linear_form_string
			       char (4096) varying init ("");
      dcl     command_name_str       char(86) var init("");
      dcl     validate_result_identifier fixed bin;
      dcl     validate_result_explanation_identifier fixed bin;
      dcl     validate_result_list_ptr ptr;
      dcl     validate_result_explanation_list_ptr ptr;
      dcl     list_ptr ptr;
      dcl     node_ptr ptr;
      dcl     force_literal_identifier fixed bin;
      dcl     validate_explanation_identifier fixed bin;

/* Based */

      dcl	    based_real_fix_bin_1u  fixed bin (35) based unaligned;

      dcl	    name_array_name	       char (256) varying based (name_array (name_array_idx).name_ptr);

      dcl	    active_string_length   fixed bin (21) based (addr (active_string));
      dcl     active_explanation_length
                                     fixed bin(21) based(addr(active_explanation));
      dcl	    active_string_nonvarying
			       char (4096) based (addwordno (addr (active_string), 1));
      dcl     active_explanation_nonvarying
                                     char(4096) based(addwordno(addr(active_explanation), 1));

      dcl	    implied_control_argument_name
			       char (implied_control_argument_name_length) varying
			       based (implied_control_argument_name_ptr);
      dcl	    first_argument_name    char (first_argument_name_len) based (first_argument_name_ptr);
      dcl	    arg		       char (arg_len) based (arg_ptr);
      dcl	    arg_char_array	       (arg_len) char (1) based (arg_ptr);

      dcl	    1 control_argument     based (control_argument_ptr),
	      2 next	       ptr,
	      2 previous	       ptr,
	      2 excluded_option_chain
			       pointer,
	      2 control_argument_name_ptr
			       ptr,
	      2 control_argument_name_length
			       fixed bin,
	      2 first_arg_vector_idx
			       fixed bin,
	      2 last_arg_vector_idx
			       fixed bin,
	      2 initial_arg_vector_idx
			       fixed bin,
	      2 vector_idx	       fixed bin,
	      2 instance_count     fixed bin,		/* how many so far this command line? */
	      2 instances_required fixed bin,		/* how many must we have? */
	      2 flags	       unaligned,
	        3 accepts_explicit_argument
			       bit (1),
	        3 antonym	       bit (1),
	        3 pad	       bit (34);

      dcl	    control_argument_name  char (control_argument.control_argument_name_length)
			       based (control_argument.control_argument_name_ptr);

      dcl	    1 arg_info	       based (arg_info_ptr),
	      2 arg_name_ptr       ptr,
	      2 arg_name_len       fixed bin,
	      2 explanation_ptr    ptr,
	      2 validation_string_ptr
			       ptr,
	      2 validation_string_length
			       fixed bin,
                2 validate_explanation_ptr
                                     ptr,
	      2 arg_def_vector_idx fixed bin,
	      2 number_of_required_occurences
			       fixed bin,
	      2 default_argument_value_ptr
			       pointer,
	      2 default_argument_value_len
			       fixed bin,
                2 flags            unaligned,
                  3 got_explicit_value
                                   bit(1),
                  3 force_literal  bit(1),
                  3 pad            bit(34);


      dcl	    arg_name	       char (arg_info.arg_name_len) based (arg_info.arg_name_ptr);
      dcl	    arg_explanation	       char (sys_info$max_seg_size) varying based (arg_info.explanation_ptr);
      dcl	    validation_string      char (arg_info.validation_string_length) based (arg_info.validation_string_ptr);
      dcl     validate_explanation   char(sys_info$max_seg_size) var based(arg_info.validate_explanation_ptr);

      dcl	    1 excluded_option      aligned based,
	      2 next_excluded_option
			       pointer,
	      2 option_name_length fixed bin,
	      2 option_name	       char (excluded_option_name_length refer (excluded_option.option_name_length));
      dcl	    excluded_option_name_length
			       fixed bin;

      dcl	    work_area	       area (sys_info$max_seg_size) based (p_work_area_ptr);

      dcl     1 validate_result_list like list based(validate_result_list_ptr);

      dcl     1 validate_result_explanation_list like list based(validate_result_explanation_list_ptr);

      dcl     1 list based(list_ptr),
                2 head_ptr ptr,
                2 tail_ptr ptr;

      dcl     1 node based(node_ptr),
                2 str_len fixed bin(21),
                2 str_ptr ptr,
                2 next_ptr ptr;


/* Builtin */

      dcl	    (addr, addcharno, addwordno, after, index, length, null, reverse, rtrim, substr, unspec)   builtin;

/* Condition */

      dcl	    active_function_error  condition;
      dcl     cleanup                condition;
      dcl     stringrange            condition;

/* Constant */

      dcl	    MY_NAME	       init ("pa_process_arguments") char (20) static options (constant);
      dcl	    (
	    NO_MODE	       init (1),
	    PROMPT_MODE	       init (2),
	    MENU_MODE	       init (3),
	    NUMBER_OF_NON_ARGUMENT_DIMENSIONS
			       init (4),
	    SLOT_INCREASE_FACTOR   init (25),
	    RETRY_LIMIT	       init (10)
	    )		       fixed bin internal static options (constant);
      dcl	    PROCESS_ARGUMENTS_SEARCH_LIST_NAME
			       init ("process_arguments") char (17) internal static options (constant);

      dcl	    (
	    COMMAND_NAME_DIM_NAME  init ("command name"),
	    DEFAULT_LINEAR_FORM_DIM_NAME
			       init ("default linear form"),
	    CONTROL_ARGUMENT_NAME_DIM_NAME
			       init ("option"),
	    SYNONYM_DIM_NAME       init ("synonym"),
	    ANTONYM_DIM_NAME       init ("negative form"),
	    EXCLUDED_OPTION_DIM_NAME
			       init ("excluded option"),
	    IMPLIED_CONTROL_ARGUMENT_NAME_DIM_NAME
			       init ("initial implied option"),
	    NEXT_IMPLIED_CONTROL_ARGUMENT_NAME_DIM_NAME
			       init ("next implied option"),
	    ARGUMENT_NAME_DIM_NAME init ("argument"),
	    INITIAL_ARGUMENT_NAME_DIM_NAME
			       init ("initial argument"),
	    NEXT_ARGUMENT_NAME_DIM_NAME
			       init ("next argument"),
	    DEFAULT_ARGUMENT_VALUE_DIM_NAME
			       init ("default value"),
	    NEGATIVE_VALUE_DIM_NAME
			       init ("negative value"),
	    ARGUMENT_VALIDATION_STRING_DIM_NAME
			       init ("validation string"),
	    EXPLANATION_DIM_NAME   init ("explanation"),
	    ARGUMENT_PRESENCE_DIM_NAME
			       init ("presence required"),
	    INSTANCE_DIM_NAME      init ("instance"),
	    RESULT_ORDER_DIM_NAME  init ("order"),
	    VALIDATE_RESULT_DIM_NAME
                                     init("validate result"),
              VALIDATE_RESULT_EXPLANATION_DIM_NAME
                                     init("validate result explanation"),
              VALIDATE_EXPLANATION_DIM_NAME
                                     init("validate explanation"),
              FORCE_LITERAL_DIM_NAME
                                     init("force literal")
	    )		       char (64) varying internal static options (constant);
      dcl	    NO_ARGUMENT	       init ("NONE") char (32) varying internal static options (constant);

      dcl	    LEFT_BOUND_STR	       init("&(") char(2) int static options(constant);
      dcl     RIGHT_BOUND_STR	       init(")") char(1) int static options(constant);
      dcl	    ARG_PROC_MSG	       init("(argument processing)") char(21) int static options(constant);

      dcl     (
              CONTROL_ARGUMENT_NAME_DIM_IDX init(1),
              INSTANCE_DIM_IDX init(2),
              COMMAND_NAME_DIM_IDX init(3),
              RESULT_ORDER_DIM_IDX init(4)
              ) fixed bin int static options(constant);

/* Entry */

      dcl	    process_arguments_$argument_string
			       entry (char (*), fixed bin, char (*) var, ptr, ptr, ptr, fixed bin (35));

      dcl	    ioa_$rsnnl	       entry () options (variable);

      dcl	    cv_dec_check_	       entry (char (*), fixed bin (35)) returns (fixed bin (35));
      dcl	    sub_err_	       entry () options (variable);
      dcl	    com_err_	       entry () options (variable);
      dcl	    ioa_		       entry () options (variable);
      dcl	    decode_descriptor_     entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin, fixed bin);
      dcl	    search_paths_$get      entry (char (*), bit (36), char (*), ptr, ptr, fixed bin, ptr, fixed bin (35));
      dcl	    expand_pathname_       entry (char (*), char (*), char (*), fixed bin (35));
      dcl	    requote_string_	       entry (char (*)) returns (char (*));
      dcl	    process_arguments_$get_definition
			       entry (char (*) var, ptr, ptr, fixed bin (35));
      dcl	    process_arguments_$get_default_linear_form
			       entry (char (*) var, char (*) var, fixed bin (35));
      dcl     process_arguments_$get_option_value
                                     entry options(variable);
      dcl	    cu_$evaluate_active_string
			       entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35));
      dcl     find_condition_frame_  entry (ptr) returns(ptr);
      dcl     find_condition_info_   entry (ptr, ptr, fixed bin(35));
      dcl     define_area_          entry (ptr, fixed bin(35));
      dcl     release_area_         entry (ptr);

/* External */

      dcl	    error_table_$asynch_change
			       fixed bin (35) ext static;
      dcl	    error_table_$noarg     fixed bin (35) ext static;
      dcl	    vd_error_$dimension_already_defined
			       fixed bin (35) ext;
      dcl	    vd_error_$no_vector    fixed bin (35) ext;
      dcl	    error_table_$fatal_error
			       fixed bin (35) ext;
      dcl	    sys_info$max_seg_size  fixed bin (35) ext static;
      dcl	    error_table_$badopt    fixed bin (35) ext;
      dcl	    error_table_$bad_arg   fixed bin (35) ext;
      dcl	    error_table_$smallarg  fixed bin(35) ext static;
          dcl     error_table_$unimplemented_version fixed bin(35) ext static;

/* END OF DECLARATIONS */

argument_array:
   entry (p_command_name, p_arg_processing_mode, p_arg_array, p_definition_print_vector_array_ptr, p_work_area_ptr,
      p_result_print_vector_array_ptr, p_code);
      call CONVERT_ARGUMENT_ARRAY_TO_LIST (p_arg_array, p_work_area_ptr, arg_list_ptr);
      first_arg_idx = 1;
      goto JOIN;

argument_string:
   entry (p_command_name, p_arg_processing_mode, p_arg_string, p_definition_print_vector_array_ptr, p_work_area_ptr,
      p_result_print_vector_array_ptr, p_code);
      call CONVERT_ARGUMENT_STRING_TO_LIST (p_arg_string, p_work_area_ptr, arg_list_ptr);
      first_arg_idx = 1;
      goto JOIN;


argument_list:
   entry (p_command_name, p_arg_processing_mode, p_arg_list_ptr, p_first_arg_idx, p_definition_print_vector_array_ptr,
      p_work_area_ptr, p_result_print_vector_array_ptr, p_code);
      arg_list_ptr = p_arg_list_ptr;
      first_arg_idx = p_first_arg_idx;
%page;
JOIN:

      command_name_str = rtrim(p_command_name) || " " || ARG_PROC_MSG;

      p_result_print_vector_array_ptr = null;
      if p_definition_print_vector_array_ptr = null
      then
         do;
	  call
	     process_arguments_$get_definition ((p_command_name), p_work_area_ptr, p_definition_print_vector_array_ptr,
	     p_code);
	  if p_code ^= 0
	  then
	     do;
	        call REPORT_MISSING_DEFINITION(p_code);
	        return;
	     end;
         end;

      call process_arguments_$get_default_linear_form ((p_command_name), default_linear_form_string, p_code);
      if p_code ^= 0 | default_linear_form_string = ""
      then do;
           if (p_code = vd_error_$no_vector | default_linear_form_string = "") &
              arg_list_ptr = null
	 then do;
                p_code = vd_error_$no_vector;          /* Make sure nonzero p_code is returned. */
	      call com_err_((0), (command_name_str), "There is no default linear form.");
	      return;
	 end;
	 else if p_code = vd_error_$no_vector
	 then p_code = 0;
	 else if p_code ^= 0
           then do;
	      call com_err_(p_code, (command_name_str), "Unable to get the default linear form for ""^a"".", p_command_name);
	      return;
	 end;
      end;

      call SETUP_DIM_IDS_AND_CONTROL_ARGUMENT_LIST;
      alloc arg_info in (work_area);
      print_vector_array_ptr = null;

      if p_result_print_vector_array_ptr = null
      then
         do;
	  result_control_argument_name_identifier = 1;
	  result_command_name_identifier = 2;
	  result_instance_identifier = 3;
	  result_order_identifier = 4;
	  call
	     vector_util_$init_print_vector_array (p_work_area_ptr, SLOT_INCREASE_FACTOR,
	     CONTROL_ARGUMENT_NAME_DIM_NAME, COMMAND_NAME_DIM_NAME, INSTANCE_DIM_NAME, RESULT_ORDER_DIM_NAME,
	     p_result_print_vector_array_ptr, p_code);
	  if p_code ^= 0
	  then return;
         end;
      else call SET_RESULT_IDS;

      p_result_print_vector_array_ptr
         -> print_vector_array.dimension_table (result_command_name_identifier).maximum_value_length =
         length (p_command_name);

      if default_linear_form_string ^= ""
      then
         do;
	  call
	     cu_$evaluate_active_string (null (), "do " || requote_string_ ((default_linear_form_string)),
	     NORMAL_ACTIVE_STRING, default_linear_form_string, p_code);
	  if p_code ^= 0
	  then return;


	  call CONVERT_ARGUMENT_STRING_TO_LIST (default_linear_form_string, p_work_area_ptr, default_arg_list_ptr);
	  call PROCESS_ARGUMENT_LIST (default_arg_list_ptr, 1, p_code);
	  if p_code ^= 0
	  then return;
         end;

      if arg_list_ptr ^= null
      then call PROCESS_ARGUMENT_LIST (arg_list_ptr, first_arg_idx, p_code);

      if p_code ^= 0
      then return;

/* Now compress the print vector array, removing entries that we
         nulled out earlier. */

      do vector_idx = 1 to p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors;
         if p_result_print_vector_array_ptr -> print_vector_array.vector_slot (vector_idx) = null ()
         then
	  do;					/* copy the remaining vectors down one slot */
	     p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors =
	        p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors - 1;
	     do temp_idx = vector_idx to p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors;
	        p_result_print_vector_array_ptr -> print_vector_array.vector_slot (temp_idx) =
		 p_result_print_vector_array_ptr -> print_vector_array.vector_slot (temp_idx + 1);
	     end;					/* make sure to check the same slot again */
	     vector_idx = vector_idx - 1;
	  end;
      end;

      call VALIDATE_RESULTS(p_code);

      return;					/* Effective end of process_arguments. */
%page;
SET_IDS:
   proc;
      call SET_ID (SYNONYM_DIM_NAME, synonym_identifier);
      call SET_ID (ANTONYM_DIM_NAME, antonym_identifier);
      call SET_ID (EXCLUDED_OPTION_DIM_NAME, excluded_option_identifier);
      call SET_ID (IMPLIED_CONTROL_ARGUMENT_NAME_DIM_NAME, implied_control_argument_name_identifier);
      call SET_ID (EXPLANATION_DIM_NAME, explanation_identifier);
      call SET_ID (CONTROL_ARGUMENT_NAME_DIM_NAME, control_argument_name_identifier);
      call SET_ID (ARGUMENT_NAME_DIM_NAME, argument_name_identifier);
      call SET_ID (INITIAL_ARGUMENT_NAME_DIM_NAME, initial_argument_name_identifier);
      call SET_ID (NEXT_ARGUMENT_NAME_DIM_NAME, next_argument_name_identifier);
      call SET_ID (DEFAULT_ARGUMENT_VALUE_DIM_NAME, default_argument_value_identifier);
      call SET_ID (NEGATIVE_VALUE_DIM_NAME, negative_default_argument_value_identifier);
      call SET_ID (NEXT_IMPLIED_CONTROL_ARGUMENT_NAME_DIM_NAME, next_implied_control_argument_name_identifier);
      call SET_ID (ARGUMENT_PRESENCE_DIM_NAME, argument_presence_identifier);
      call SET_ID (ARGUMENT_VALIDATION_STRING_DIM_NAME, validation_string_identifier);
      call SET_ID (VALIDATE_RESULT_DIM_NAME, validate_result_identifier);
      call SET_ID (VALIDATE_RESULT_EXPLANATION_DIM_NAME, validate_result_explanation_identifier);
      call SET_ID (FORCE_LITERAL_DIM_NAME, force_literal_identifier);
      call SET_ID (VALIDATE_EXPLANATION_DIM_NAME, validate_explanation_identifier);

   end SET_IDS;
%skip;
SET_ID:
   proc (p_dim_name, p_identifier);
      dcl	    p_dim_name	       char (*) varying;
      dcl	    p_identifier	       fixed bin;
      do p_identifier = 1 to p_definition_print_vector_array_ptr -> print_vector_array.number_of_dimensions
         while (p_definition_print_vector_array_ptr -> print_vector_array.dimension_table (p_identifier).name
         ^= p_dim_name);
      end;
      if p_identifier > p_definition_print_vector_array_ptr -> print_vector_array.number_of_dimensions
      then p_identifier = -1;
   end SET_ID;
%page;
SET_RESULT_IDS:
   proc;
      call SET_RESULT_ID (COMMAND_NAME_DIM_NAME, result_command_name_identifier);
      call SET_RESULT_ID (RESULT_ORDER_DIM_NAME, result_order_identifier);
      call SET_RESULT_ID (INSTANCE_DIM_NAME, result_instance_identifier);
      call SET_RESULT_ID (CONTROL_ARGUMENT_NAME_DIM_NAME, result_control_argument_name_identifier);
   end SET_RESULT_IDS;
%skip;
SET_RESULT_ID:
   proc (p_dimension_name, p_identifier);

      dcl	    p_dimension_name       char (*) varying;
      dcl	    p_identifier	       fixed bin;

      do p_identifier = 1 to p_result_print_vector_array_ptr -> print_vector_array.number_of_dimensions
         while (p_result_print_vector_array_ptr -> print_vector_array.dimension_table (p_identifier).name
         ^= p_dimension_name);
      end;
      if p_identifier > p_result_print_vector_array_ptr -> print_vector_array.number_of_dimensions
      then p_identifier = -1;

   end SET_RESULT_ID;
%page;
SETUP_DIM_IDS_AND_CONTROL_ARGUMENT_LIST:
   proc;

      dcl	    dim_idx	       fixed bin;
      dcl	    temp_ptr	       pointer;

      call SET_IDS;
      print_vector_ptr = null;
      control_argument_ptr = null;
      control_argument_name_dim_id = -1;
      implied_control_argument_name_ptr = null;
      implied_control_argument_ptr = null;
      exists_implied_control_argument = "0"b;
      validate_result_list_ptr = null;
      validate_result_explanation_list_ptr = null;

      do vector_idx = 1 to p_definition_print_vector_array_ptr -> print_vector_array.number_of_vectors;
         old_control_argument_name_dim_id = control_argument_name_dim_id;
         old_print_vector_ptr = print_vector_ptr;
         call SETUP_VECTOR_AND_CONTROL_ARGUMENT_NAME_DIM_ID (vector_idx, print_vector_ptr, control_argument_name_dim_id);
         if control_argument_name_dim_id = -1
         then call SETUP_IMPLIED_CONTROL_ARGUMENT;
         else
	  do;
	     if control_argument_ptr = null
	     then call SETUP_NEW_CONTROL_ARGUMENT;


/* check to see if we have finished the definition of the
	        option we were just working on */
	     else if print_vector.dimension (control_argument_name_dim_id).value
		   ^= old_print_vector_ptr -> print_vector.dimension (old_control_argument_name_dim_id).value
	     then
	        do;
		 call CLOSE_OUT_CONTROL_ARGUMENT_DEFINITION;
		 call SETUP_NEW_CONTROL_ARGUMENT;
	        end;

/* see if this is the initial implied option */
	     if vector_idx = control_argument.vector_idx
	     then if implied_control_argument_name_ptr ^= null
		then if control_argument_name = implied_control_argument_name
		     then
		        do;
			 implied_control_argument_ptr = control_argument_ptr;
			 exists_implied_control_argument = "1"b;
		        end;

/* Now check for other dimensions in the vector that define
	        other attributes of the option */

	     call GET_DIM_IDX (print_vector_ptr, argument_name_identifier, dim_idx);
	     if dim_idx > 0
	     then
	        do;
		 if print_vector_ptr -> print_vector.dimension (dim_idx).value = first_argument_name
		 then control_argument.initial_arg_vector_idx = vector_idx;
		 if control_argument.first_arg_vector_idx = 0
		 then
		    do;
		       control_argument.first_arg_vector_idx = vector_idx;
		       control_argument.last_arg_vector_idx = vector_idx;
		    end;
	        end;

/* See if there is an excluded option dimension */
	     call GET_DIM_IDX (print_vector_ptr, excluded_option_identifier, dim_idx);
	     if dim_idx > 0
	     then
	        do;
		 excluded_option_name_length = length (print_vector_ptr -> print_vector.dimension (dim_idx).value);
		 allocate excluded_option in(work_area) set (temp_ptr);
		 temp_ptr -> excluded_option.option_name = print_vector_ptr -> print_vector.dimension (dim_idx).value;
		 temp_ptr -> excluded_option.next_excluded_option = control_argument.excluded_option_chain;
		 control_argument.excluded_option_chain = temp_ptr;
	        end;

/* see if the vector defines a synonym for the option */
	     call ADD_SYNONYM;

	  end;

            call SETUP_RESULT_VALIDATION_INFO(print_vector_ptr, validate_result_list_ptr, validate_result_explanation_list_ptr);

      end;

/* We have run out of vectors, close out the last option definition */
      call CLOSE_OUT_CONTROL_ARGUMENT_DEFINITION;

   end SETUP_DIM_IDS_AND_CONTROL_ARGUMENT_LIST;
%page;
ADD_SYNONYM:
   proc;
      dcl	    dim_idx	       fixed bin;

      call GET_DIM_IDX (print_vector_ptr, synonym_identifier, dim_idx);
      if dim_idx = -1
      then return;

      name_array_count = name_array_count + 1;
      name_array (name_array_count).name_ptr = addr (print_vector.dimension (dim_idx).value);
      name_array (name_array_count).def_ptr = control_argument_ptr;

/* See if this synonym is really an antonym. Will be used for filling
         in the default value later. */
      call GET_DIM_IDX (print_vector_ptr, antonym_identifier, dim_idx);
      name_array (name_array_count).antonym = (dim_idx ^= -1);

   end ADD_SYNONYM;
%page;
SETUP_NEW_CONTROL_ARGUMENT:
   proc ();

      old_control_argument_ptr = control_argument_ptr;

      alloc control_argument in (work_area);
      control_argument.next = null;
      control_argument.previous = old_control_argument_ptr;
      if old_control_argument_ptr = null
      then root_control_argument_ptr = control_argument_ptr;
      else old_control_argument_ptr -> control_argument.next = control_argument_ptr;

/* relies on vector_idx being set by caller, presumably while looping
         through all the vectors */
      control_argument.vector_idx = vector_idx;

      control_argument.control_argument_name_ptr =
         addrel (addr (print_vector.dimension (control_argument_name_dim_id).value), 1);
      control_argument.control_argument_name_length =
         length (print_vector.dimension (control_argument_name_dim_id).value);

      control_argument.excluded_option_chain = null ();
      control_argument.initial_arg_vector_idx = 0;
      control_argument.first_arg_vector_idx = 0;
      control_argument.last_arg_vector_idx = 0;
      control_argument.accepts_explicit_argument = "0"b;

/* Get the name of the initial arg for this option. If there is no
         such dimension, the option doesn't accept command line arguments.
         However, it may still have one argument whose value will be filled
         in from the default. This is how -long/-brief style flags work. */

      call GET_DIM_IDX (print_vector_ptr, initial_argument_name_identifier, dim_idx);
      if dim_idx ^= -1
      then
         do;
	  first_argument_name_ptr = addrel (addr (print_vector_ptr -> print_vector.dimension (dim_idx).value), 1);
	  first_argument_name_len = length (print_vector_ptr -> print_vector.dimension (dim_idx).value);
	  control_argument.accepts_explicit_argument = "1"b;
         end;
      else
         do;
	  first_argument_name_ptr = addr (NO_ARGUMENT);
	  first_argument_name_len = length (NO_ARGUMENT);
	  control_argument.accepts_explicit_argument = "0"b;
         end;

/* at this point we should find the option_presence dimension a gets its
         value, but it isn7t in the DB yet. */
      control_argument.instance_count = 0;		/* this field isn't examined yet */
      control_argument.instances_required = 1;

   end SETUP_NEW_CONTROL_ARGUMENT;

CLOSE_OUT_CONTROL_ARGUMENT_DEFINITION:
   procedure;

      if control_argument_ptr = null ()
      then return;

      control_argument.last_arg_vector_idx = vector_idx - 1;

      if ^control_argument.accepts_explicit_argument	/* the option doesn't accept explicit args, but we still have
	         to set the initial arg idx so defaults work later */
      then control_argument.initial_arg_vector_idx = control_argument.first_arg_vector_idx;

/* if no argument matched the name of the first argument for this
	    option (as specified in the definition for this command), then
	    signal an error. */

      else if (control_argument.initial_arg_vector_idx = 0)
      then call
	    sub_err_ (error_table_$fatal_error, MY_NAME, ACTION_CANT_RESTART, null (), 0,
	    "First argument of ""^a"" specified for option ""^a"" of command ""^a"" is not defined.",
	    first_argument_name, control_argument_name);

   end CLOSE_OUT_CONTROL_ARGUMENT_DEFINITION;
%page;
SETUP_VECTOR_AND_CONTROL_ARGUMENT_NAME_DIM_ID:
   proc (p_vector_idx, p_print_vector_ptr, p_control_argument_name_dim_id);
      dcl	    p_vector_idx	       fixed bin;
      dcl	    p_print_vector_ptr     ptr;
      dcl	    p_control_argument_name_dim_id
			       fixed bin;
      p_print_vector_ptr = p_definition_print_vector_array_ptr -> print_vector_array.vector_slot (p_vector_idx);
      call GET_DIM_IDX (p_print_vector_ptr, control_argument_name_identifier, p_control_argument_name_dim_id);
   end SETUP_VECTOR_AND_CONTROL_ARGUMENT_NAME_DIM_ID;
%page;
SETUP_IMPLIED_CONTROL_ARGUMENT:
   proc;
      dcl	    dim_idx	       fixed bin;
      call GET_DIM_IDX (print_vector_ptr, implied_control_argument_name_identifier, dim_idx);

      if dim_idx = -1
      then return;
      implied_control_argument_name_ptr = addr (print_vector.dimension (dim_idx).value);
      implied_control_argument_name_length = length (print_vector.dimension (dim_idx).value);
   end SETUP_IMPLIED_CONTROL_ARGUMENT;
%page;
PROCESS_ARGUMENT_LIST:
   proc (pal_p_arg_list_ptr, pal_p_first_arg_idx, pal_p_code);
      dcl	    pal_p_arg_list_ptr     ptr parameter;
      dcl	    pal_p_first_arg_idx    fixed bin parameter;
      dcl	    pal_p_code	       fixed bin (35) parameter;

      nargs = pal_p_arg_list_ptr -> arg_list.header.arg_count - pal_p_first_arg_idx + 1;
      last_arg_idx_processed = pal_p_first_arg_idx - 1;
      force_interpretation_as_non_control_argument = "0"b;
      value_idx = 0;
      max_value_arg_len = 0;
      unspec(arg_info) = "0"b;
      control_argument_is_in_effect = "0"b;
      using_implicit_control_argument = "0"b;
      option_accepts_explicit_argument = "0"b;

      control_argument_ptr = null;


ARG_LOOP:
      do arg_idx = pal_p_first_arg_idx to pal_p_arg_list_ptr -> arg_list.header.arg_count;
         arg_ptr = pal_p_arg_list_ptr -> arg_list.arg_ptrs (arg_idx);
         call decode_descriptor_ (pal_p_arg_list_ptr -> arg_list.desc_ptrs (arg_idx), 0, 0, "0"b, 0, arg_len, 0);

         force_interpretation_as_non_control_argument = (force_interpretation_as_non_control_argument |
					       (arg_info.force_literal & control_argument_is_in_effect));

/*         if arg = "-quote" & ^force_interpretation_as_non_control_argument
         then
	  do;
	     last_arg_idx_processed = arg_idx;
	     force_interpretation_as_non_control_argument = "1"b;
	  end;					/* Now for the non-option cases.
         else */

         if index (arg, "-") ^= 1 | force_interpretation_as_non_control_argument
         then
	  do;					/* if there is no explicit option in effect,
		  try the current implied option */
	     force_interpretation_as_non_control_argument = "0"b;
	     if ^control_argument_is_in_effect
	     then if exists_implied_control_argument
		then
		   do;				/* If we already processed the previous token,
			  don't do it again. */
		      if last_arg_idx_processed < (arg_idx - 1)
		      then call CLOSE_OUT_OPTION;

		      control_argument_ptr = implied_control_argument_ptr;
		      call
		         SETUP_FIRST_ARG_INFO (control_argument_ptr, option_accepts_explicit_argument, arg_info_ptr);
						/* if this option doesn't accept an argument,
			  the current token is bogus */
		      if ^option_accepts_explicit_argument
		      then call
			    sub_err_ (error_table_$fatal_error, MY_NAME, ACTION_CANT_RESTART, null (), 0,
			    "Error in definition. Implied option ^a doesn't accept arguments.",
			    control_argument_name);

		      control_argument_is_in_effect, using_implicit_control_argument = "1"b;
		   end;
	     if arg = "?"
	     then
	        do;
		 last_arg_idx_processed = arg_idx;
		 call PRINT_EXPLANATION;
	        end;

/* OK, the token is an argument to an option. */
	     else
	        do;

		 call PROCESS_ARGUMENT (pal_p_code);
                     if pal_p_code = error_table_$bad_arg
                     then do;
                          call PRINT_VALIDATION_EXPLANATION();
                          return;
                     end;
                     else if pal_p_code ^= 0
                     then return;
	        end;
	  end;

         else if MISPLACED_CONTROL_ARGUMENT ()
         then
	  do;
	     pal_p_code = error_table_$noarg;
	     call
	        com_err_ (pal_p_code, (command_name_str),
	        "^/Encountered option ^a instead of the ^a argument to option ^a.", requote_string_ (arg),
	        requote_string_ (arg_name), requote_string_ (control_argument_name));
	     return;
	  end;

/* The token is an option */
         else
CONTROL_ARGUMENT:
	  do;					/* If we already processed the previous token,
	       don't do it again. */
	     if last_arg_idx_processed < (arg_idx - 1)
	     then call CLOSE_OUT_OPTION;

	     using_implicit_control_argument = "0"b;

/* See if the token matches any known option name */
	     do name_array_idx = 1 to name_array_count while (arg ^= name_array_name);
	     end;
	     if name_array_idx > name_array_count
	     then
	        do;
		 call REPORT_UNRECOGNIZED_CONTROL_ARGUMENT ();
		 return;
	        end;

	     control_argument_ptr = name_array (name_array_idx).def_ptr;

/* depending on which name (e.g. -foo vs. -no_foo) was used
	        to find this option, set the antonym flag */
	     control_argument.antonym = name_array (name_array_idx).antonym;

/* fill in arg_info structure for the option's first arg */
	     call SETUP_FIRST_ARG_INFO (control_argument_ptr, option_accepts_explicit_argument, arg_info_ptr);

/* if the option has args, future tokens should be interpreted
	        as "belonging" to this option, so we say the option is still
	        in effect.  If the option has no args, future tokens are
	        unrelated to the option. */

	     control_argument_is_in_effect = option_accepts_explicit_argument;
	     if ^control_argument_is_in_effect
	     then call CLOSE_OUT_OPTION;
	  end CONTROL_ARGUMENT;
      end ARG_LOOP;

/* The loop above increments the arg_idx to one 
         past the last argument. Set it back for comparison purposes. */
      arg_idx = arg_idx - 1;

/* No more command line arguments.  Check to see if any more were
         required. */

      if using_implicit_control_argument
      then
         do;					/* if the pending option is implicit we don't care if there
	         is no associated argument as long as we have seen at least
	         one instance of the option before, e.g. "copy foo bar"
	         is OK even though there is a pending implicit
	         -source_pathname option with a required argument */

	  if control_argument.instance_count = 0
	  then
	     do;
	        call SETUP_FIRST_ARG_INFO (control_argument_ptr, option_accepts_explicit_argument, arg_info_ptr);
	        if ^option_accepts_explicit_argument
	        then call
		      sub_err_ (error_table_$fatal_error, MY_NAME, ACTION_CANT_RESTART, null (), 0,
		      "Error in definition. Implied option ^a doesn't accept arguments.", control_argument_name);
	        if (arg_info.number_of_required_occurences > 0)
	        then
		 do;
		    pal_p_code = error_table_$noarg;
		    call REPORT_MISSING_ARGUMENT ();
		    return;
		 end;
	     end;
         end;

/* if the option was explicit, then honor the required flag */
      else if control_argument_is_in_effect
      then if (arg_info.number_of_required_occurences > 0)
	 then
	    do;
	       pal_p_code = error_table_$noarg;
	       call REPORT_MISSING_ARGUMENT ();
	       return;
	    end;

/* Close out the last token if it hasn't been processed yet */
      if last_arg_idx_processed < arg_idx
      then call CLOSE_OUT_OPTION;

   end PROCESS_ARGUMENT_LIST;
%page;
PROCESS_ARGUMENT:
   proc (p_code);

      dcl	    p_code	       fixed bin (35) parameter;
      dcl	    temp_value_idx	       fixed bin;


      if ^control_argument_is_in_effect
      then
         do;
	  p_code = error_table_$bad_arg;
	  call com_err_ (p_code, (command_name_str), "^/Argument ^a can not be matched with any option.", arg);
	  return;
         end;

/* Validate the argument value if possible */
      if arg_info.validation_string_ptr ^= null ()
      then
         do;					/* Get a temp for the requoted string */
	  call
	     ioa_$rsnnl ("do ^a ^a", active_string_nonvarying, active_string_length,
	     requote_string_ ("[" || validation_string || "]"), requote_string_ (arg));

	  on active_function_error
	     begin;
	        goto validation_error_return;
	     end;

	  call cu_$evaluate_active_string (null (), (active_string), NORMAL_ACTIVE_STRING, result, p_code);
	  if p_code ^= 0
	  then return;

	  revert active_function_error;

	  if result ^= "true"
	  then
	     do;
validation_error_return:
	        p_code = error_table_$bad_arg;
	        call
		 com_err_ (p_code, (command_name_str), "^/Invalid argument ^a for option ^a", requote_string_ (arg),
		 requote_string_ (control_argument_name));
	        return;
	     end;
         end;

      value_idx = value_idx + 1;
      value (value_idx).arg_name_ptr = arg_info.arg_name_ptr;
      value (value_idx).arg_name_len = arg_info.arg_name_len;
      value (value_idx).arg_ptr = arg_ptr;
      value (value_idx).arg_len = arg_len;
      max_value_arg_len = max (max_value_arg_len, arg_len);

      call SETUP_NEXT_ARG_INFO (control_argument_ptr, arg_exists, arg_info_ptr);
      control_argument_is_in_effect = arg_exists;

      if ^control_argument_is_in_effect
      then call CLOSE_OUT_OPTION;
      else
         do;
	  do temp_value_idx = 1 to value_idx while (arg_info.arg_name_ptr ^= value (temp_value_idx).arg_name_ptr);
	  end;
	  if temp_value_idx <= value_idx
	  then /* Only one occurence of each named argument can be present per "result" vector. */
	       call ADD_VALUE_TO_RESULT;
         end;
   end PROCESS_ARGUMENT;
%page;
GET_NEXT_IMPLIED_CONTROL_ARGUMENT:
   proc;
      print_vector_ptr =
         p_definition_print_vector_array_ptr -> print_vector_array.vector_slot (control_argument.vector_idx);

      call GET_DIM_IDX (print_vector_ptr, next_implied_control_argument_name_identifier, dim_idx);
      if dim_idx = -1
      then return;
      else
         do;
	  implied_control_argument_name_ptr = addr (print_vector.dimension (dim_idx).value);
	  implied_control_argument_name_length = length (print_vector.dimension (dim_idx).value);
	  do control_argument_ptr = root_control_argument_ptr repeat (control_argument.next)
	     while (control_argument.next ^= null & control_argument_name ^= implied_control_argument_name);
	  end;
	  if control_argument_name = implied_control_argument_name
	  then
	     do;
	        exists_implied_control_argument = "1"b;
	        implied_control_argument_ptr = control_argument_ptr;
	     end;
	  else
	     do;
	        exists_implied_control_argument = "0"b;
	        implied_control_argument_ptr = null;
	     end;
         end;
   end GET_NEXT_IMPLIED_CONTROL_ARGUMENT;
%page;
/* Internal routine to close out the current option.  This is called
   when we run out of arguments for a particular option (either by getting
   all the arguments we expect or encountering the next option), or when
   there are no more tokens on the command line. */

CLOSE_OUT_OPTION:
   procedure;

      if control_argument_ptr = null ()
      then return;

/* If no explicit value was specified for the argument to this option
	   then see if there was a default argument value in the definition. */

      if ^arg_info.got_explicit_value
      then if arg_info.default_argument_value_ptr ^= null ()
	 then
	    do;
	       value_idx = value_idx + 1;
	       value (value_idx).arg_name_ptr = arg_info.arg_name_ptr;
	       value (value_idx).arg_name_len = arg_info.arg_name_len;
	       value (value_idx).arg_ptr = arg_info.default_argument_value_ptr;
	       value (value_idx).arg_len = arg_info.default_argument_value_len;

	       max_value_arg_len = max (max_value_arg_len, value (value_idx).arg_len);
	    end;

      call ADD_VALUE_TO_RESULT;

/* If the option that we just processed is the same as the current
	   implied option, move on to the next implied option */
      if exists_implied_control_argument
      then if control_argument_name = implied_control_argument_name
	 then call GET_NEXT_IMPLIED_CONTROL_ARGUMENT;

      return;
   end CLOSE_OUT_OPTION;
%page;
/* Routine to add the vector for this option (including all argument values)
   to the result pva. */

ADD_VALUE_TO_RESULT:
   proc;

      dcl	    temp_value_idx	       fixed bin;
      dcl	    dim_idx	       fixed bin;
      dcl	    value_arg_name	       char (value (temp_value_idx).arg_name_len)
			       based (value (temp_value_idx).arg_name_ptr);
      dcl	    instance_count_pic     pic "999v";
      dcl	    order_pic	       pic "999v";

      dcl	    value_arg	       char (value (temp_value_idx).arg_len) based (value (temp_value_idx).arg_ptr);

      last_arg_idx_processed = arg_idx;

      call
         vector_util_$append_general_print_vector (p_work_area_ptr, SLOT_INCREASE_FACTOR, "1"b, (-1), value_idx + 4,
         max (length (control_argument_name), length (p_command_name), max_value_arg_len),
         p_result_print_vector_array_ptr, p_code);
      if p_code ^= 0
      then
         do;
	  call
	     sub_err_ (p_code, p_command_name, "h", null, 0,
	     "^/Unable to add the result vector for the ""^a"" control argument (and 
associated arguments) ending with argument number ^d.", control_argument_name, arg_idx);
	  return;
         end;

      print_vector_ptr =
         p_result_print_vector_array_ptr
         -> print_vector_array.vector_slot (p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors);

/* Fill in all the non-argument-value dimensions */
      print_vector.dimension (INSTANCE_DIM_IDX).identifier = result_instance_identifier;
      instance_count_pic = global_instance_count;
      print_vector.dimension (INSTANCE_DIM_IDX).value = instance_count_pic;
      global_instance_count = global_instance_count + 1;

      print_vector.dimension (CONTROL_ARGUMENT_NAME_DIM_IDX).identifier = result_control_argument_name_identifier;
      print_vector.dimension (CONTROL_ARGUMENT_NAME_DIM_IDX).value = control_argument_name;

/* now set the maximum option name length. */
      p_result_print_vector_array_ptr
         -> print_vector_array.dimension_table (result_control_argument_name_identifier).maximum_value_length =
         max (p_result_print_vector_array_ptr
         -> print_vector_array.dimension_table (result_control_argument_name_identifier).maximum_value_length,
         length (control_argument_name));

      p_result_print_vector_array_ptr
         -> print_vector_array.dimension_table (result_control_argument_name_identifier).maximum_value_length =
         max (p_result_print_vector_array_ptr
         -> print_vector_array.dimension_table (result_control_argument_name_identifier).maximum_value_length,
         length (control_argument_name));

      print_vector.dimension (COMMAND_NAME_DIM_IDX).identifier = result_command_name_identifier;
      print_vector.dimension (COMMAND_NAME_DIM_IDX).value = p_command_name;
      print_vector.dimension (RESULT_ORDER_DIM_IDX).identifier = result_order_identifier;
      order_pic = p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors;
      print_vector.dimension (RESULT_ORDER_DIM_IDX).value = order_pic;

/* Now fill in all the arguments */
      do temp_value_idx = 1 to value_idx;

/* skip over those dims that we already filled in */
         dim_idx = temp_value_idx + NUMBER_OF_NON_ARGUMENT_DIMENSIONS;

         call
	  vector_util_$append_dimension_print (p_work_area_ptr, "0"b, value_arg_name, null,
	  p_result_print_vector_array_ptr, print_vector.dimension (dim_idx).identifier, p_code);
         if p_code ^= 0
         then if p_code = vd_error_$dimension_already_defined
	    then p_code = 0;
	    else return;
         print_vector.dimension (dim_idx).value = value_arg;

/* keep track of longest dimension id */
         p_result_print_vector_array_ptr
	  -> print_vector_array.dimension_table (print_vector.dimension (dim_idx).identifier).maximum_value_length =
	  max (p_result_print_vector_array_ptr
	  -> print_vector_array.dimension_table (print_vector.dimension (dim_idx).identifier).maximum_value_length,
	  length (value_arg));

      end;


      max_value_arg_len = 0;
      value_idx = 0;

   end ADD_VALUE_TO_RESULT;
%page;
/* Routine to set up state information for a an option that has just been
   encountered on the command line. */

SETUP_FIRST_ARG_INFO:
   proc (p_control_argument_ptr, p_option_accepts_explicit_argument, p_arg_info_ptr);
      dcl	    p_control_argument_ptr ptr;
      dcl	    p_option_accepts_explicit_argument
			       bit (1) aligned;
      dcl	    p_arg_info_ptr	       ptr;
      dcl	    1 p_arg_info	       like arg_info based (p_arg_info_ptr);

      dcl	    idx		       fixed bin;
      dcl	    (temp_print_vector_ptr, temp_excluded_option_ptr)
			       pointer;

/* First remove any vectors belonging to options that are excluded
         by the current option */

      do idx = 1 to p_result_print_vector_array_ptr -> print_vector_array.number_of_vectors;
         temp_print_vector_ptr = p_result_print_vector_array_ptr -> print_vector_array.vector_slot (idx);

/* loop through the chain of excluded options, checking the option
	    names against the option that owns the current vector */
         do temp_excluded_option_ptr = (p_control_argument_ptr -> control_argument.excluded_option_chain)
	  repeat (temp_excluded_option_ptr -> excluded_option.next_excluded_option)
	  while ((temp_excluded_option_ptr ^= null ())
	  & (p_result_print_vector_array_ptr -> print_vector_array.vector_slot (idx) ^= null ()));

/* If this vector belongs to an excluded option, free it */
	  if temp_print_vector_ptr -> print_vector.dimension (1).value
	     = temp_excluded_option_ptr -> excluded_option.option_name
	  then
	     do;
	        free temp_print_vector_ptr -> print_vector;
	        p_result_print_vector_array_ptr -> print_vector_array.vector_slot (idx) = null ();
	     end;
         end;
      end;

      p_arg_info.arg_def_vector_idx = 0;

/* Keep track of how many times we see each control argument */
      p_control_argument_ptr -> control_argument.instance_count =
         p_control_argument_ptr -> control_argument.instance_count + 1;

      p_arg_info.force_literal = "0"b;

      call SETUP_NEXT_ARG_INFO (p_control_argument_ptr, p_option_accepts_explicit_argument, p_arg_info_ptr);

      p_option_accepts_explicit_argument = p_control_argument_ptr -> control_argument.accepts_explicit_argument;

   end SETUP_FIRST_ARG_INFO;


SETUP_NEXT_ARG_INFO:
   proc (p_control_argument_ptr, p_arg_exists, p_arg_info_ptr);
      dcl	    p_control_argument_ptr ptr;
      dcl	    p_arg_exists	       bit (1) aligned;
      dcl	    p_arg_info_ptr	       ptr;
      dcl	    1 p_arg_info	       like arg_info based (p_arg_info_ptr);
      dcl	    p_arg_name	       char (p_arg_info.arg_name_len) based (p_arg_info.arg_name_ptr);
      dcl	    local_print_vector_ptr ptr;
      dcl	    temp_dimension_identifier
			       fixed bin;
      dcl	    dim_idx	       fixed bin;
      dcl	    p_control_argument_name
			       char (p_control_argument_ptr -> control_argument.control_argument_name_length)
			       based (p_control_argument_ptr -> control_argument.control_argument_name_ptr);

      if p_arg_info.arg_def_vector_idx ^= 0
      then call FIND_NEXT_ARG (p_arg_info.arg_def_vector_idx, local_print_vector_ptr, dim_idx);
      else if p_control_argument_ptr -> control_argument.initial_arg_vector_idx = 0
      then
         do;
	  arg_exists = "0"b;
	  return;
         end;
      else
         do;
	  p_arg_info.arg_def_vector_idx = p_control_argument_ptr -> control_argument.initial_arg_vector_idx;
	  call SETUP_VECTOR_AND_ARG_NAME_DIM_IDX (p_arg_info.arg_def_vector_idx, local_print_vector_ptr, dim_idx);
         end;
      if dim_idx = -1
      then
         do;
	  p_arg_exists = "0"b;
	  return;
         end;
      p_arg_exists = "1"b;
      if local_print_vector_ptr = null
      then
         do;
	  if p_arg_info.number_of_required_occurences > 0
	  then p_arg_info.number_of_required_occurences = p_arg_info.number_of_required_occurences - 1;
	  return;
         end;

/* Fill in arg_info structure with data for this argument. */

      p_arg_info.arg_name_ptr = addrel (addr (local_print_vector_ptr -> print_vector.dimension (dim_idx).value), 1);
      p_arg_info.arg_name_len = length (local_print_vector_ptr -> print_vector.dimension (dim_idx).value);

      call GET_DIM_IDX (local_print_vector_ptr, validation_string_identifier, dim_idx);
      if dim_idx > 0
      then
         do;
	  p_arg_info.validation_string_ptr =
	     addrel (addr (local_print_vector_ptr -> print_vector.dimension (dim_idx).value), 1);
	  p_arg_info.validation_string_length =
	     length (local_print_vector_ptr -> print_vector.dimension (dim_idx).value);
         end;
      else p_arg_info.validation_string_ptr = null ();

      call GET_DIM_IDX(local_print_vector_ptr, validate_explanation_identifier, dim_idx);
      if dim_idx > 0
      then p_arg_info.validate_explanation_ptr = addr(local_print_vector_ptr->print_vector.dimension(dim_idx).value);
      else p_arg_info.validate_explanation_ptr = null;

      call GET_DIM_IDX (local_print_vector_ptr, explanation_identifier, dim_idx);
      if dim_idx > 0
      then p_arg_info.explanation_ptr = addr (local_print_vector_ptr -> print_vector.dimension (dim_idx).value);
      else p_arg_info.explanation_ptr = null;

      call GET_DIM_IDX (local_print_vector_ptr, argument_presence_identifier, dim_idx);

/* If there is such a dim, the arg is required.  Later we may want a count of
   the number of required occurences, but for now it is yes or no. */
      if dim_idx = -1
      then p_arg_info.number_of_required_occurences = 0;
      else p_arg_info.number_of_required_occurences = 1;

/* If the option was -no_foo, get the negative default value for the
         argument, otherwise get the regular default */
      if control_argument.antonym
      then temp_dimension_identifier = negative_default_argument_value_identifier;
      else temp_dimension_identifier = default_argument_value_identifier;

/* Now try to find the default value for this argument. */
      call GET_DIM_IDX (local_print_vector_ptr, temp_dimension_identifier, dim_idx);
      if dim_idx = -1
      then p_arg_info.default_argument_value_ptr = null ();
      else
         do;
	  p_arg_info.default_argument_value_ptr =
	     addrel (addr (local_print_vector_ptr -> print_vector.dimension (dim_idx).value), 1);
	  p_arg_info.default_argument_value_len =
	     length (local_print_vector_ptr -> print_vector.dimension (dim_idx).value);
         end;

      call GET_DIM_IDX(local_print_vector_ptr, force_literal_identifier, dim_idx);
      p_arg_info.force_literal = (dim_idx ^= -1);

/* This flag is used later to determine if we have seen an explicit value
         for this argument on the command line. If not, use the default value*/
      p_arg_info.got_explicit_value = "0"b;

      return;


SETUP_VECTOR_AND_ARG_NAME_DIM_IDX:
   proc (p_vector_idx, p_print_vector_ptr, p_dim_idx);
      dcl	    p_vector_idx	       fixed bin;
      dcl	    p_print_vector_ptr     ptr;
      dcl	    p_dim_idx	       fixed bin;

      p_print_vector_ptr = p_definition_print_vector_array_ptr -> print_vector_array.vector_slot (p_vector_idx);
      call GET_DIM_IDX (p_print_vector_ptr, argument_name_identifier, p_dim_idx);
   end SETUP_VECTOR_AND_ARG_NAME_DIM_IDX;


FIND_NEXT_ARG:
   proc (p_vector_idx, p_print_vector_ptr, p_dim_idx);
      dcl	    p_vector_idx	       fixed bin;
      dcl	    p_print_vector_ptr     ptr;
      dcl	    p_dim_idx	       fixed bin;
      dcl	    next_arg_dim_idx       fixed bin;
      dcl	    temp_print_vector_ptr  ptr;

      p_dim_idx = 0;
      p_print_vector_ptr = p_definition_print_vector_array_ptr -> print_vector_array.vector_slot (p_vector_idx);

/* No next_argument dimension means use the same argument again.
         Returning a null pointer is a convention for this case. */
      call GET_DIM_IDX (p_print_vector_ptr, next_argument_name_identifier, next_arg_dim_idx);
      if next_arg_dim_idx = -1
      then
         do;
	  p_print_vector_ptr = null;
	  return;
         end;

/* If the next arg is the same as this arg, use the same values */
      else if p_print_vector_ptr -> print_vector.dimension (next_arg_dim_idx).value = p_arg_name
      then
         do;
	  p_print_vector_ptr = null ();
	  return;
         end;

/* If there is no next argument at all, indicate that fact. */
      else if p_print_vector_ptr -> print_vector.dimension (next_arg_dim_idx).value = NO_ARGUMENT
      then
         do;
	  p_dim_idx = -1;
	  p_print_vector_ptr = null;
	  return;
         end;

      do p_vector_idx = p_control_argument_ptr -> control_argument.first_arg_vector_idx
         to p_control_argument_ptr -> control_argument.last_arg_vector_idx;
         call SETUP_VECTOR_AND_ARG_NAME_DIM_IDX (p_vector_idx, temp_print_vector_ptr, p_dim_idx);
         if p_dim_idx = -1
         then call
	       sub_err_ (error_table_$fatal_error, p_command_name, "h", null, 0,
	       "^/Vector ^d of the definition is in the argument definition range of vectors
for control argument ""^a"", but does not specify an argument name (as it must).", p_vector_idx, p_control_argument_name)
	       ;
         else if temp_print_vector_ptr -> print_vector.dimension (p_dim_idx).value
	       = p_print_vector_ptr -> print_vector.dimension (next_arg_dim_idx).value
         then
	  do;
	     p_print_vector_ptr = temp_print_vector_ptr;
	     return;
	  end;
      end;
      p_code = error_table_$fatal_error;
   end FIND_NEXT_ARG;
   end SETUP_NEXT_ARG_INFO;
%page;
GET_DIM_IDX:
   proc (p_print_vector_ptr, p_identifier, p_dim_idx);
      dcl	    p_print_vector_ptr     ptr;
      dcl	    p_identifier	       fixed bin;
      dcl	    p_dim_idx	       fixed bin;

      do p_dim_idx = 1 to p_print_vector_ptr -> print_vector.number_of_dimensions
         while (p_print_vector_ptr -> print_vector.dimension (p_dim_idx).identifier ^= p_identifier);
      end;
      if p_dim_idx > p_print_vector_ptr -> print_vector.number_of_dimensions
      then p_dim_idx = -1;

   end GET_DIM_IDX;



MISPLACED_CONTROL_ARGUMENT:
   proc () returns (bit (1) aligned);
      if arg_info_ptr = null
      then return ("0"b);
      else return ((arg_info.number_of_required_occurences > 0) & ^using_implicit_control_argument
	    & control_argument_is_in_effect);
   end MISPLACED_CONTROL_ARGUMENT;
REPORT_UNRECOGNIZED_CONTROL_ARGUMENT:
   proc;
      p_code = error_table_$badopt;
      call com_err_ (p_code, (command_name_str), """^a""", arg);
   end REPORT_UNRECOGNIZED_CONTROL_ARGUMENT;
%page;
REPORT_MISSING_ARGUMENT:
   proc;
      call
         com_err_ (error_table_$noarg, (command_name_str), "^/Expected the ""^a"" argument of the ""^a"" control argument.",
         arg_name, control_argument_name);

   end REPORT_MISSING_ARGUMENT;
%page;
REPORT_MISSING_DEFINITION:
   proc(code);

      dcl code fixed bin(35);

      call
         com_err_ (code, (command_name_str),
         "Unable to locate the argument-processing^/syntax definition for this command.");

   end REPORT_MISSING_DEFINITION;
%page;
PRINT_EXPLANATION:
   proc;
      if arg_info.explanation_ptr ^= null
      then call ioa_ ("Explanation for the ""^a"" argument of the ^[(implicit)^] ""^a"" option:
^a", arg_name, using_implicit_control_argument, control_argument_name, arg_explanation);
      else call
	    ioa_ ("There is no explanation provided for the ""^a"" argument of the ^[(implicit)^] ""^a"" option.",
	    arg_name, using_implicit_control_argument, control_argument_name);
   end PRINT_EXPLANATION;

%page;

PRINT_VALIDATION_EXPLANATION: proc();

  /* Automatic */

          dcl code fixed bin(35);

          if arg_info.validate_explanation_ptr ^= null
          then do;
               call MAKE_V_SUBSTITUTIONS((validate_explanation), arg_name, arg, active_explanation_nonvarying, active_explanation_length, code);
               if code ^= 0
               then call sub_err_(code, MY_NAME, ACTION_CANT_RESTART, null, 0,
                  "^/Unable to make substitutions in the validation explanation:^/""^a"".",
                  validate_explanation);
               else call ioa_((active_explanation));
          end;

     end PRINT_VALIDATION_EXPLANATION;
%page;
CONVERT_ARGUMENT_ARRAY_TO_LIST:
   proc (caatl_p_arg_array, caatl_p_work_area_ptr, caatl_p_arg_list_ptr);
      dcl	    caatl_p_arg_array      (*) char (*) varying;
      dcl	    caatl_p_work_area_ptr  ptr;
      dcl	    caatl_p_arg_list_ptr   ptr;

      dcl	    caatl_al_arg_count     fixed bin init (0);
      dcl	    caatl_arg_idx	       fixed bin init (0);
      dcl	    1 caatl_arg_descriptor_template
			       like arg_descriptor;
      dcl	    caatl_arg_descriptor_ptr
			       ptr init (null);

      dcl	    caatl_work_area	       area based (caatl_p_work_area_ptr);
      dcl	    1 caatl_arg_list       based (caatl_p_arg_list_ptr),
	      2 header	       like arg_list.header,
	      2 arg_ptrs	       (caatl_al_arg_count refer (caatl_arg_list.header.arg_count)) ptr,
	      2 desc_ptrs	       (caatl_al_arg_count refer (caatl_arg_list.header.arg_count)) ptr;
      dcl	    1 caatl_arg_descriptor based (caatl_arg_descriptor_ptr) like arg_descriptor;

      caatl_p_arg_list_ptr = null;

      caatl_al_arg_count = hbound (caatl_p_arg_array, 1);
      if caatl_al_arg_count = 1 & caatl_p_arg_array (1) = ""
      then return;

      alloc caatl_arg_list in (caatl_work_area);
      caatl_arg_list.header.pad1 = "0"b;
      caatl_arg_list.header.call_type = Interseg_call_type;
      caatl_arg_list.header.desc_count = caatl_al_arg_count;
      caatl_arg_list.header.pad2 = "0"b;
      caatl_arg_descriptor_template.flag = "1"b;
      caatl_arg_descriptor_template.type = char_dtype;
      caatl_arg_descriptor_template.packed = "0"b;
      caatl_arg_descriptor_template.number_dims = 0;
      caatl_arg_descriptor_template.size = 0;

      do caatl_arg_idx = 1 to caatl_al_arg_count;
         caatl_arg_list.arg_ptrs (caatl_arg_idx) = addwordno (addr (caatl_p_arg_array (caatl_arg_idx)), 1);
         alloc caatl_arg_descriptor in (caatl_work_area);
         caatl_arg_descriptor = caatl_arg_descriptor_template;
         caatl_arg_descriptor.size = length (caatl_p_arg_array (caatl_arg_idx));
         caatl_arg_list.desc_ptrs (caatl_arg_idx) = caatl_arg_descriptor_ptr;
      end;

   end CONVERT_ARGUMENT_ARRAY_TO_LIST;
%page;
CONVERT_ARGUMENT_STRING_TO_LIST:
   proc (castl_p_arg_string, castl_p_work_area_ptr, castl_p_arg_list_ptr);
      dcl	    castl_p_arg_string     char (*) varying;
      dcl	    castl_p_work_area_ptr  ptr;
      dcl	    castl_p_arg_list_ptr   ptr;

      dcl	    castl_al_arg_count     fixed bin init (0);
      dcl	    1 castl_arg_descriptor_template
			       like arg_descriptor;
      dcl	    castl_arg_descriptor_ptr
			       ptr init (null);
      dcl	    castl_arg_link_ptr     ptr init (null);

      dcl	    (castl_arg_idx, castl_arg_index, castl_new_arg_index, castl_arg_length, castl_quote_index,
	    castl_old_quote_index) fixed bin init (0);
      dcl	    (castl_root_arg_link_ptr, castl_old_arg_link_ptr)
			       ptr init (null);

      dcl	    castl_work_area	       area based (castl_p_work_area_ptr);
      dcl	    1 castl_arg_list       based (castl_p_arg_list_ptr),
	      2 header	       like arg_list.header,
	      2 arg_ptrs	       (castl_al_arg_count refer (castl_arg_list.header.arg_count)) ptr,
	      2 desc_ptrs	       (castl_al_arg_count refer (castl_arg_list.header.arg_count)) ptr;
      dcl	    1 castl_arg_descriptor based (castl_arg_descriptor_ptr) like arg_descriptor;
      dcl	    1 castl_arg_link       based (castl_arg_link_ptr),
	      2 next_ptr	       ptr,
	      2 arg_ptr	       ptr,
	      2 arg_length	       fixed bin,
	      2 desc_ptr	       ptr;

      dcl	    (
	    CASTL_SPACE_CHAR       init (" "),
	    CASTL_TAB_CHAR	       init ("	"),
	    CASTL_QUOTE_CHAR       init ("""")
	    )		       char (1) internal static options (constant);

      castl_p_arg_list_ptr = null;

      if castl_p_arg_string = ""
      then return;

      castl_al_arg_count = 0;

      castl_arg_descriptor_template.flag = "1"b;
      castl_arg_descriptor_template.type = char_dtype;
      castl_arg_descriptor_template.packed = "0"b;
      castl_arg_descriptor_template.number_dims = 0;
      castl_arg_descriptor_template.size = 0;

      castl_new_arg_index = 1;
      castl_arg_index = 1;
      castl_arg_length = 0;

CASTL_PARSE_LOOP:
      do while (castl_new_arg_index > 0);
         castl_new_arg_index =
	  verify (substr (castl_p_arg_string, castl_arg_index + castl_arg_length), CASTL_SPACE_CHAR || CASTL_TAB_CHAR);
         if castl_new_arg_index > 0
         then
CASTL_HAVE_ARG:
	  do;
	     castl_arg_index = castl_arg_length + castl_arg_index + castl_new_arg_index - 1;
	     castl_arg_length =
	        search (substr (castl_p_arg_string, castl_arg_index), CASTL_SPACE_CHAR || CASTL_TAB_CHAR);
	     if castl_arg_length = 0
	     then castl_arg_length = length (castl_p_arg_string) - castl_arg_index + 1;
	     else castl_arg_length = castl_arg_length - 1;

	     castl_quote_index =
	        index (substr (castl_p_arg_string, castl_arg_index, castl_arg_length), CASTL_QUOTE_CHAR);
	     castl_old_quote_index = castl_arg_index;

CASTL_QUOTE_LOOP:
	     do while (castl_quote_index > 0);
	        castl_quote_index = castl_old_quote_index + castl_quote_index;
CASTL_DOUBLE_QUOTE_LOOP:
	        do while (substr (castl_p_arg_string, castl_quote_index, 1) = CASTL_QUOTE_CHAR);
		 castl_old_quote_index = castl_quote_index;
		 castl_quote_index = index (substr (castl_p_arg_string, castl_old_quote_index + 1), CASTL_QUOTE_CHAR);
		 if castl_quote_index = 0
		 then call
		         sub_err_ (error_table_$fatal_error, MY_NAME, ACTION_CANT_RESTART, null, 0,
		         "^/Unable to process the ^a command.
There is a missing quote character after character ^d, in its argument string:
^a.", requote_string_ ((p_command_name)), castl_old_quote_index, requote_string_ ((castl_p_arg_string)));

		 castl_quote_index = castl_old_quote_index + castl_quote_index;
	        end CASTL_DOUBLE_QUOTE_LOOP;

	        castl_old_quote_index = castl_quote_index;
	        castl_quote_index = index (substr (castl_p_arg_string, castl_old_quote_index), CASTL_QUOTE_CHAR);
	        castl_arg_length =
		 search (substr (castl_p_arg_string, castl_quote_index + castl_old_quote_index),
		 CASTL_SPACE_CHAR || CASTL_TAB_CHAR) + castl_quote_index + castl_old_quote_index - 1;
	        castl_quote_index =
		 index (substr (castl_p_arg_string, castl_old_quote_index + castl_quote_index, castl_arg_length),
		 CASTL_QUOTE_CHAR);
	     end CASTL_QUOTE_LOOP;

	     castl_old_arg_link_ptr = castl_arg_link_ptr;
	     alloc castl_arg_link in (castl_work_area);

	     if castl_old_arg_link_ptr = null
	     then castl_root_arg_link_ptr = castl_arg_link_ptr;
	     else castl_old_arg_link_ptr -> castl_arg_link.next_ptr = castl_arg_link_ptr;

	     castl_arg_link.arg_ptr = addcharno (addwordno (addr (castl_p_arg_string), 1), castl_arg_index - 1);

	     alloc castl_arg_descriptor in (castl_work_area);
	     castl_arg_descriptor = castl_arg_descriptor_template;
	     castl_arg_descriptor.size = castl_arg_length;

	     castl_arg_link.desc_ptr = castl_arg_descriptor_ptr;

	     castl_al_arg_count = castl_al_arg_count + 1;
	  end CASTL_HAVE_ARG;
      end CASTL_PARSE_LOOP;

      alloc castl_arg_list in (castl_work_area);
      castl_arg_list.header.pad1 = "0"b;
      castl_arg_list.header.call_type = Interseg_call_type;
      castl_arg_list.header.desc_count = castl_al_arg_count;
      castl_arg_list.header.pad2 = "0"b;

      castl_arg_link_ptr = castl_root_arg_link_ptr;

      do castl_arg_idx = 1 to castl_al_arg_count;

         castl_arg_list.arg_ptrs (castl_arg_idx) = castl_arg_link.arg_ptr;
         castl_arg_list.desc_ptrs (castl_arg_idx) = castl_arg_link.desc_ptr;

         castl_old_arg_link_ptr = castl_arg_link_ptr;
         castl_arg_link_ptr = castl_arg_link.next_ptr;
         free castl_old_arg_link_ptr -> castl_arg_link in (castl_work_area);

      end;

   end CONVERT_ARGUMENT_STRING_TO_LIST;
%page;

/* This procedure takes two lists as input, the validate_result_list
   and the validate_result_explanation_list.  Each member (node) of
   the validate_result_list contains an active function that is
   applied to the results of the previous argument processing
   (i.e., the information in the result_print_vector_array).
   Each member of the validate_result_explanation_list contains
   an explanation (error message) that is printed if the result of
   evaluating the corresponding validate_result_list_node is "false".
   If there is no explanation supplied, a "standard" error message
   This procedure returns on the first error encountered after
   printing an error message.

   The input lists, validate_result_list and validate_result_explanation_list,
   are initialized in "SETUP_DIM_IDS_AND_CONTROL_ARGUMENT_LIST".
*/

VALIDATE_RESULTS: proc(code);

  /* Parameter */

          dcl code fixed bin(35);

  /* Automatic */

	dcl i fixed bin(35);
	dcl result char(5) var;
          dcl vr_ptr ptr;
          dcl vre_ptr ptr;
	dcl vr_ovl_ptr ptr;
	dcl vre_ovl_ptr ptr;

  /* Based */

          dcl validate_result_explanation char(vre_node.str_len) var based(vre_node.str_ptr);
          dcl validate_result_str char(vr_node.str_len) var based(vr_node.str_ptr);

          dcl 1 vr_node based(vr_ptr) like node;
          dcl 1 vre_node based(vre_ptr) like node;


          code = 0;

          if validate_result_list_ptr = null
	then return;

          if validate_result_explanation_list_ptr ^= null
          then vre_ptr = validate_result_explanation_list.head_ptr;
          else vre_ptr = null;

          do vr_ptr = validate_result_list.head_ptr repeat(vr_node.next_ptr) while(vr_ptr ^= null);

	     call MAKE_VR_SUBSTITUTIONS((validate_result_str), active_string_nonvarying, active_string_length, code);
	     if code ^= 0
	     then call sub_err_(code, MY_NAME, ACTION_CANT_RESTART, null, 0,
	        "^/Unable to make substitutions in the result validation string:^/""^a"".",
	        validate_result_str);

	     on active_function_error call PRINT_AF_ERROR_MSG("result validation", (active_string));

	     call cu_$evaluate_active_string(null, (active_string), NORMAL_ACTIVE_STRING, result, code);
	     if code ^= 0
	     then call sub_err_(code, MY_NAME, ACTION_CANT_RESTART, null, 0,
	        "^/Unable to evaluate the active string:^/""^a"".",
	        active_string);

	     revert active_function_error;

	     if result ^= "true"
               then do;
	          if vre_ptr ^= null
		then do;
                         call MAKE_VR_SUBSTITUTIONS((validate_result_explanation), active_explanation_nonvarying,
		        active_explanation_length, code);
                         if code ^= 0
                         then call sub_err_(code, MY_NAME, ACTION_CANT_RESTART, null, 0,
		        "^/Unable to make substitutions in the result validation explanation:^/""^a"".",
		        validate_result_explanation);
                         call com_err_(0, (command_name_str), active_explanation);
		end;
		else call com_err_(0, (command_name_str), "Evaluation of the following" ||
		   "^/result validation active string yields ""false"":^/""^a""." ||
		   "^/No explanation has been provided.",
		   active_string);
                    code = error_table_$bad_arg;
		return;
	     end;

               if validate_result_explanation_list_ptr ^= null
               then do;
                    if vre_ptr = null
                    then ;                                            /* End of explanation list. */
                    else vre_ptr = vre_node.next_ptr;
               end;

	end;

	call FREE_LIST (validate_result_list_ptr);
	call FREE_LIST (validate_result_explanation_list_ptr);

     end VALIDATE_RESULTS;

%page;

/* This procedure makes substitutions in an input string and returns
   the resulting character string.  It searches the input string for
   occurences of option names framed on the left by "&(" and on the
   right by ")".  For each such occurence it substitutes the option
   value found in the result_print_vector_array.  If the
   result_print_vector_array contains no such option, the null string
   is substituted.
*/

MAKE_VR_SUBSTITUTIONS: proc(initial_vr_str, buffer, n_chars_ret, code);

  /* Parameter */

          dcl buffer char(*);
	dcl code fixed bin(35);
	dcl initial_vr_str char(*);
	dcl n_chars_ret fixed bin(21);

  /* Automatic */

          dcl begin_looking_pos fixed bin(21);
	dcl found_option bit(1);
          dcl option_name char(length(initial_vr_str)) var;
	dcl search_str_len fixed bin(21);
	dcl search_str_pos fixed bin(21);
	dcl sub_str char(length(buffer)) var;
	dcl temp_buffer char(length(buffer)) var;

  /* Based */

          dcl search_str char(search_str_len) based(addcharno(addr(temp_buffer), (search_str_pos - 1) + 4));          /* 4 for str len at beginning of var str. */
          dcl sub_str_len fixed bin(21) based(addr(sub_str));
	dcl sub_str_nonvar char(length(buffer)) based(addwordno(addr(sub_str), 1));

          code = 0;
	buffer = "";
	n_chars_ret = 0;
	temp_buffer = initial_vr_str;
	begin_looking_pos = 1;

	call STAR_STR_SEARCH((temp_buffer), LEFT_BOUND_STR, RIGHT_BOUND_STR, begin_looking_pos, search_str_pos, search_str_len);

	do while(search_str_pos ^= 0);

               option_name = LR_TRIM((search_str), LEFT_BOUND_STR, RIGHT_BOUND_STR);

	     call process_arguments_$get_option_value(p_result_print_vector_array_ptr, p_work_area_ptr, found_option,
	        option_name, option_value_list_ptr);

	     if ^found_option
	     then sub_str = "";
               else do;
	          call CV_OPTION_VALUES_TO_STRING(option_value_list_ptr, sub_str_nonvar, sub_str_len, code);
	          if code ^= 0
	          then return;
               end;

               call SUBSTITUTE((temp_buffer),(search_str), (sub_str), search_str_pos, addr(temp_buffer), code);
               if code ^= 0
               then return;

               begin_looking_pos = search_str_pos + sub_str_len;

	     call STAR_STR_SEARCH((temp_buffer), LEFT_BOUND_STR, RIGHT_BOUND_STR, begin_looking_pos, search_str_pos, search_str_len);

	end;

	buffer = temp_buffer;
	n_chars_ret = length(temp_buffer);

     end MAKE_VR_SUBSTITUTIONS;

%page;
/* This routine substitutes argument values into a specified character string
   and returns the resulting character string.  It searches the input string
   for occurences of the current argument name framed on the left by "&(
   and on the right by ")".  For each such occurence it substitutes the
   current argument value into the string.
*/

MAKE_V_SUBSTITUTIONS: proc(initial_vr_str, input_arg_name, input_arg_value, buffer, n_chars_ret, code);

  /* Parameter */

          dcl buffer char(*);
          dcl code fixed bin(35);
          dcl initial_vr_str char(*);
          dcl input_arg_name char(*);
          dcl input_arg_value char(*);
          dcl n_chars_ret fixed bin(21);

  /* Automatic */

          dcl arg_name char(length(buffer)) var;
          dcl begin_looking_pos fixed bin(21);
          dcl search_str_len fixed bin(21);
          dcl search_str_pos fixed bin(21);
          dcl temp_buffer char(length(buffer)) var;

  /* Based */

          dcl search_str char(search_str_len) based(addcharno(addr(temp_buffer), (search_str_pos - 1) + 4));          /* 4 for str length at beginning of var str. */

          code = 0;
          buffer = "";
          n_chars_ret = 0;
          temp_buffer = initial_vr_str;
          begin_looking_pos = 1;

          call STAR_STR_SEARCH((temp_buffer), LEFT_BOUND_STR, RIGHT_BOUND_STR, begin_looking_pos, search_str_pos, search_str_len);

          do while(search_str_pos ^= 0);

               arg_name = LR_TRIM(search_str, LEFT_BOUND_STR, RIGHT_BOUND_STR);

               if arg_name = input_arg_name
               then do;
                    call SUBSTITUTE((temp_buffer), (search_str), (input_arg_value), search_str_pos, addr(temp_buffer), code);
                    if code ^= 0
                    then return;
                    begin_looking_pos = search_str_pos + length(input_arg_value);
               end;
               else begin_looking_pos = search_str_pos + search_str_len;

               call STAR_STR_SEARCH((temp_buffer), LEFT_BOUND_STR, RIGHT_BOUND_STR, begin_looking_pos, search_str_pos, search_str_len);

          end;

          buffer = temp_buffer;
          n_chars_ret = length(temp_buffer);

     end MAKE_V_SUBSTITUTIONS;
%page;

/* This procedure searches an input string for occurences of a search string.
   The search string has definite sets of characters on the left and right
   and a non-deterministic set of characters in the middle.  The search
   begins at a designated position in the input string, not always at
   the beginning.  The position of the search string (relative to
   the beginning of the input string) and its length are returned.
   If the search string is not found, a position and length of 0 are
   returned.
*/

STAR_STR_SEARCH: proc(str_to_search, start_str, end_str, initial_begin_looking_pos, search_str_pos, search_str_len);

  /* Parameter */

          dcl end_str char(*);
	dcl initial_begin_looking_pos fixed bin(21);
	dcl search_str_len fixed bin(21);
	dcl search_str_pos fixed bin(21);
          dcl start_str char(*);
          dcl str_to_search char(*);

  /* Automatic */

          dcl begin_looking_pos fixed bin(21);
	dcl end_str_idx fixed bin(21);
	dcl end_str_pos fixed bin(21);
	dcl start_str_idx fixed bin(21);
	dcl start_str_pos fixed bin(21);
	dcl substr_to_search char(length(str_to_search)) var;


          search_str_pos = 0;
	search_str_len = 0;

	begin_looking_pos = initial_begin_looking_pos;
	substr_to_search = substr(str_to_search, begin_looking_pos);

	start_str_idx = index(substr_to_search, start_str);
	if start_str_idx = 0
	then return;

	start_str_pos = begin_looking_pos + start_str_idx - 1;

	begin_looking_pos = start_str_pos + length(start_str);
	substr_to_search = substr(str_to_search, begin_looking_pos);

	end_str_idx = index(substr_to_search, end_str);
	if end_str_idx = 0
	then return;

	end_str_pos = begin_looking_pos + (end_str_idx - 1) + length(end_str) - 1;

	search_str_pos = start_str_pos;
	search_str_len = end_str_pos - start_str_pos + 1;

     end STAR_STR_SEARCH;

%page;

/* This procedure takes a pointer to an option_value_list and returns
   all of the values concatenated together separated by spaces in
   the buffer provided.
*/

CV_OPTION_VALUES_TO_STRING: proc(ovl_ptr, buffer, n_chars_ret, code);

  /* Parameter */

          dcl buffer char(*);
	dcl code fixed bin(35);
	dcl n_chars_ret fixed bin(21);
          dcl ovl_ptr ptr;

  /* Automatic */

          dcl i fixed bin;
          dcl max_buffer_len fixed bin(21);
	dcl option_value_ptr ptr;
	dcl temp_buffer char(length(buffer)) var;
	dcl work_str char(length(buffer)) var;

  /* Based */

          dcl option_value char(sys_info$max_seg_size) var based(option_value_ptr);


          code = 0;
	buffer = "";
	n_chars_ret = 0;
	max_buffer_len = length(buffer);
	temp_buffer = "";

	do i = 1 to ovl_ptr->option_value_list.number_of_values;
	     work_str = temp_buffer;
	     option_value_ptr = ovl_ptr->option_value_list.value(i).ptr;
	     if length(requote_string_((option_value))) + length(work_str) + 1 > max_buffer_len
	     then do;
	          code = error_table_$smallarg;
		return;
	     end;
	     if i = 1
	     then temp_buffer = requote_string_((option_value));
	     else temp_buffer = work_str || " " || requote_string_((option_value));
	end;

	buffer = temp_buffer;
	n_chars_ret = length(temp_buffer);

     end CV_OPTION_VALUES_TO_STRING;

%page;

/* This function takes an input string, and trims one occurence of given
   character strings off the immediate left and immediate right of the input
   string.  It returns the result.
*/

LR_TRIM: proc(str, lchars, rchars) returns(char(*));

  /* Parameter */

          dcl lchars char(*);
	dcl rchars char(*);
	dcl str char(*);

  /* Automatic */

          dcl new_str char(length(str)) var;


          new_str = str;

	if index(new_str, lchars) = 1
	then new_str = after(new_str, lchars);

	if index(reverse(new_str), reverse(rchars)) = 1
	then new_str = reverse(after(reverse(new_str), reverse(rchars)));

	return((new_str));

     end LR_TRIM;

%page;
/* This procedure takes a string that contains an occurence of an "old"
   sequence of characters at a specified position in the string, and
   replaces the old sequence with a new sequence handing the result
   back in a varying character buffer.
*/

(stringrange):
SUBSTITUTE: proc(str, old, new, old_pos, buffer_ptr, code);

  /* Parameter */

          dcl buffer_ptr ptr;
          dcl code fixed bin(35);
          dcl new char(*);
          dcl old char(*);
          dcl old_pos fixed bin(21);
          dcl str char(*);

  /* Automatic */

          dcl left_str char(length(buffer)) var;
          dcl old_len fixed bin(21);
          dcl right_str char(length(buffer)) var;

  /* Based */

          dcl buffer char(sys_info$max_seg_size) var based(buffer_ptr);

          code = 0;

          on stringrange begin;
               code = error_table_$smallarg;
               goto SUBSTITUTE_RETURN;
          end;

          old_len = length(old);

          left_str = substr(str, 1, old_pos - 1);
          right_str = substr(str, old_pos + old_len);

          buffer = left_str || new || right_str;

SUBSTITUTE_RETURN:

          return;

     end SUBSTITUTE;

%page;
/* This procedure is called when evaluating an active function and
   the active_function_error condition is signalled.  It finds the
   condition_info set up for active function errors, extracts
   and prints the error message.
*/

PRINT_AF_ERROR_MSG: proc(af_user_name, af);

  /* Parameter */

          dcl af char(*);
          dcl af_user_name char(*);

  /* Automatic */

          dcl code fixed bin(35);
          dcl stack_ptr ptr;

          dcl 1 auto_condition_info aligned like condition_info;

  /* Based */

          dcl af_error_msg char(com_af_error_info.errmess_lth) based(com_af_error_info.errmess_ptr);
	dcl af_name char(com_af_error_info.name_lth) based(com_af_error_info.name_ptr);

          unspec(auto_condition_info) = "0"b;
          auto_condition_info.version = condition_info_version_1;

          stack_ptr = find_condition_frame_(null);

	call find_condition_info_(stack_ptr, addr(auto_condition_info), code);
	if code ^= 0
	then call sub_err_(code, MY_NAME, ACTION_CANT_RESTART, null,  0,
	   "^/Unable to obtain an error message for an error that occured while" ||
	   "^/processing the ^a active string:^/""^a"".",
	   af_user_name, af);

          com_af_error_info_ptr = auto_condition_info.info_ptr;

          if com_af_error_info.version ^= com_af_error_info_version_3
          then call sub_err_(error_table_$unimplemented_version, MY_NAME, ACTION_CANT_RESTART, null, 0,
	   "^/Unable to obtain the correct version of error information for an error" ||
	   "^/that occured while processing the ^a active string:^/""^a"".",
             af_user_name, af);

          call sub_err_(error_table_$fatal_error, MY_NAME, ACTION_CANT_RESTART, null, 0,
	   "^a^/An error occured while processing the ^a active string:^/""^a"".",
	   af_error_msg, af_user_name, af);

     end PRINT_AF_ERROR_MSG;

%page;

/* This procedure is called to build and maintain the validate_result_list
   and the validate_result_explanation_list.  It looks in a given
   print_vector for a validate_result_string and validate_result_explanation,
   and adds them to the appropriate list if they are found.
*/

SETUP_RESULT_VALIDATION_INFO: proc(pv_ptr, vr_list_ptr, vre_list_ptr);

  /* Parameter */

          dcl pv_ptr ptr;
          dcl vre_list_ptr ptr;
          dcl vr_list_ptr ptr;

          call ADD_TO_LIST(pv_ptr, vr_list_ptr, validate_result_identifier);

          call ADD_TO_LIST(pv_ptr, vre_list_ptr, validate_result_explanation_identifier);

     end SETUP_RESULT_VALIDATION_INFO;


%page;

/* This is a list maintenance procedure.  It adds a node to a list if
   there is a specific dimension value in a given print_vector.
*/

ADD_TO_LIST: proc(pv_ptr, list_ptr, dim_identifier);

  /* Parameter */

          dcl dim_identifier fixed bin;
          dcl list_ptr ptr;
          dcl pv_ptr ptr;

  /* Automatic */

          dcl dim_idx fixed bin;
          dcl new_node_ptr ptr;

          call GET_DIM_IDX(pv_ptr, dim_identifier, dim_idx);

          if dim_idx = -1
          then return;

          call GET_LIST_NODE(list_ptr, new_node_ptr);

          new_node_ptr->node.str_len = length(pv_ptr->print_vector.dimension(dim_idx).value);
          new_node_ptr->node.str_ptr = addr(pv_ptr->print_vector.dimension(dim_idx).value);

     end ADD_TO_LIST;
%page;
/* This is a list maintenance procedure.  It allocates storage for a node
   in a given list, initializes the values in the node, and tacks that node
   on to the end of the list.  It also initializes the list header if
   necessary.
*/

GET_LIST_NODE: proc(list_ptr, new_node_ptr);

  /* Parameter */

          dcl list_ptr ptr;
          dcl new_node_ptr ptr;

          allocate node in(work_area) set(new_node_ptr);
          new_node_ptr->node.next_ptr = null;

          if list_ptr = null
          then do;
               allocate list in(work_area) set(list_ptr);
               list_ptr->list.head_ptr = new_node_ptr;
               list_ptr->list.tail_ptr = new_node_ptr;
          end;
          else do;
               list_ptr->list.tail_ptr->node.next_ptr = new_node_ptr;
               list_ptr->list.tail_ptr = new_node_ptr;
          end;

     end GET_LIST_NODE;
%page;
/* This is a list maintenance procedure.  I frees up all of the storage
   that has been allocated for a list.
*/

FREE_LIST: proc(list_ptr);

  /* Parameter */

          dcl list_ptr ptr;

  /* Automatic */

          dcl next_node_ptr ptr;


          if list_ptr = null
	then return;

          node_ptr = list_ptr->list.head_ptr;

	do while(node_ptr ^= null);
	     next_node_ptr = node.next_ptr;
	     free node;
	     node_ptr = next_node_ptr;
	end;

     end FREE_LIST;

%page;
/* This entry really belongs in vector_util.  It is just temporary.
*/

free_print_vector_array: entry(p_print_vector_array_ptr);

  /* Parameter */

          dcl p_print_vector_array_ptr ptr;

  /* Automatic */

          dcl i fixed bin;

          if p_print_vector_array_ptr = null
	then return;

          print_vector_array_ptr = p_print_vector_array_ptr;

	do i = 1 to print_vector_array.number_of_vectors;
	     print_vector_ptr = print_vector_array.vector_slot(i);
	     free print_vector;
	end;

          free print_vector_array;

	return;

%page;
%include vu_print_vector_array;
%page;
%include arg_list;
%page;
%include vu_entry_dcls;
%page;
%include sub_err_flags;
%page;
%include arg_descriptor;
%page;
%include std_descriptor_types;
%page;
%include cp_active_string_types;
%page;
%include pa_option_value_list;
%page;
%include condition_info_header;
%page;
%include com_af_error_info;
%page;
%include condition_info;

   end pa_process_arguments;
