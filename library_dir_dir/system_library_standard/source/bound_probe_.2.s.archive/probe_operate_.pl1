/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(88-06-08,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Added the procedure 'c_pointer_arithmetic' to  perform addition and
     subraction on pointers.
  2) change(88-06-13,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Modified the 'infix' entry to detect the C_LEFT_SHIFT and C_RIGHT_SHIFT
     operators and call the new procedure 'c_shift_arithmetic'; the
     procedure that performs the shift.
  3) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Added format control comment to make the source more readable.
  4) change(88-09-29,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Created the procedure 'c_mod_arithmetic' to perform the modulous
     operator. Better late than never.
                                                   END HISTORY COMMENTS */


/* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

probe_operate_:
  procedure ();

  call probe_error_$malfunction ();	/* cant call this entry */

  /* This procedure is used to perform simple arithmetic operations on one */
  /* or two values represented by reference nodes. Resultant value is      */
  /* allocated in supplied area, caller must ensure it is large enough. It */
  /* has two entries, infix and prefix, to do the appropriate kind of math */

  /* * 
  *       12 Aug 74, Jeffery M. Broughton:
  *          Initial Version.
  *       ?? Jul 77,  R.J.C. Kissel:
  *          To handle new data types.  When any_to_any_ is updated to handle
  *          all data types, all references to probe_assign_ should be changed
  *          to references to assign_ and probe_assign_ and probe_convert_ 
  *          should be deleted.
  *       ?? Oct 78, James R. Davis:
  *          To add multiplication and division.
  *       ?? Nov 78, JRD:
  *          To do temp allocs in supplied area, not free seg.
  *       ?? Dec 78, JRD:
  *          To check for valid decimal data before trying to use it.
  *       ?? May 79, JRD: 
  *          To use data_type_info_ and packed decimal.
  *       ?? May 79, WOS: 
  *          To convert to probe 4.0.
  *       ?? Nov 79, ???
  *          To use assign_computational_.
  *       31 Mar 80, ??? 
  *          To fix division MPRF 5504 probe bug 184.
  *       ?? Jun 83, JMAthane:
  *          For PASCAL : check for subrange types by calls to 
  *          probe_pascal_$real_type 
  *       17 Jan 84, S. Herbst:
  *          Changed to use generic float decimal types for results of hex 
  *          float computations.
  * */
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

  dcl (
      P_probe_info_ptr	pointer,
      P_opcode		char (1) aligned,
				/* (input) what to do */
      P_code		fixed bin (35),
      1 P_first		aligned like reference_node,
				/* (input) first operand of operation */
      1 P_second		aligned like reference_node,
				/* (input) second operand of infix ops */
      1 P_result		aligned like reference_node
      )			parameter;/* output */

  dcl MAX_GENFD_WORDS	fixed bin int static options (constant)
			init (17);
				/* 16 for fixed dec(59) mantissa, 1 for exp */

  dcl 1 source		(2) aligned like computational_data;
  dcl 1 intermediate	(2) aligned like computational_data;
  dcl 1 result		aligned like computational_data;

  dcl 1 operand		(2) aligned like reference_node;
				/* copies of first and second */

  dcl 1 type_bits		aligned,	/* indicates type, base and mode */
       2 float		bit (1) unaligned,
				/* of the temp or target, which */
       2 binary		bit (1) unaligned,
				/* need not be the same as for the operand */
       2 complex		bit (1) unaligned;

  dcl type_type		fixed bin;/* type_bits, as in fixed bin (3) */

  dcl 1 common_info		(0:7),	/* indexed by type_type */
       2 type_array		fixed bin initial /* type to convert to */
			(real_fix_dec_9bit_ls_dtype,
			cplx_fix_dec_9bit_ls_dtype,
			real_fix_bin_2_dtype,
			cplx_fix_bin_2_dtype,
			real_flt_dec_9bit_dtype,
			cplx_flt_dec_9bit_dtype,
			real_flt_bin_2_dtype,
			cplx_flt_bin_2_dtype),
       2 prec_array		fixed bin
			initial (59, 59, 71, 71, 59, 59, 63, 63),
				/* precision of result */
       2 size_array		fixed bin initial (30, 60, 2, 4, 32, 64, 2, 4);
				/* number of words */

  dcl 1 an_encoded_precision	aligned like encoded_precision;

  dcl 1 type_bits_copy	aligned like type_bits;

  dcl 1 gen_decimal_struc	aligned based,
				/* format of real_flt_dec_generic_dtype */
       2 exponent		fixed bin (35),
       2 mantissa		fixed decimal (59);

  dcl 1 cplx_gen_decimal_struc
			aligned based,
				/* format of cplx_flt_dec_generic_dtype */
       2 (real, imaginary)	aligned like gen_decimal_struc;

  dcl (use_genfd_sw, use_genfd_complex_sw)
			bit (1);
  dcl genfd_type		fixed bin;

  dcl dp			pointer;	/* to storage of temporary */
  dcl op			(2) pointer;
				/* to intermediate values */
  dcl (alloc_size, i, temp_precision)
			fixed bin;

  dcl fixed_bin_real	fixed bin (71) real based;
				/* operand overlays */
  dcl fixed_bin_complex	fixed bin (71) complex based;
  dcl float_bin_real	float bin (63) real based;
  dcl float_bin_complex	float bin (63) complex based;
  dcl fixed_dec_real	fixed dec (59) real based;
  dcl fixed_dec_complex	fixed dec (59) complex based;
  dcl float_dec_real	float dec (59) real based;
  dcl float_dec_complex	float dec (59) complex based;

  dcl (
      probe_et_$bad_operand,
      probe_et_$bad_decimal,
      probe_et_$recorded_message
      )			fixed bin (35) external static;
  dcl probe_pascal_$real_type entry (fixed bin (35), ptr, fixed bin (35), ptr)
			;

  dcl valid_decimal_	entry (fixed bin, ptr, fixed bin)
			returns (bit (1));
  dcl assign_$computational_	entry (ptr, ptr, fixed bin (35));

  dcl (
      generic_math_$add_decimal,
      generic_math_$divide_decimal,
      generic_math_$multiply_decimal,
      generic_math_$subtract_decimal
      )
			entry (1 aligned like gen_decimal_struc,
			1 aligned like gen_decimal_struc,
			1 aligned like gen_decimal_struc);

  dcl (
      generic_math_$add_decimal_complex,
      generic_math_$divide_decimal_complex,
      generic_math_$multiply_decimal_complex,
      generic_math_$subtract_decimal_complex
      )
			entry (1 aligned like cplx_gen_decimal_struc,
			1 aligned like cplx_gen_decimal_struc,
			1 aligned like cplx_gen_decimal_struc);

  dcl generic_math_$negate_decimal
			entry (1 aligned like gen_decimal_struc,
			1 aligned like gen_decimal_struc);
  dcl generic_math_$negate_decimal_complex
			entry (1 aligned like cplx_gen_decimal_struc,
			1 aligned like cplx_gen_decimal_struc);

  dcl (
      probe_error_$malfunction,
      probe_error_$record
      )			entry options (variable);

  dcl (abs, addr, addrel, ceil, divide, fixed, hbound, lbound, mod,
      multiply, null, max, min, pointer, sign, string, substr, unspec)
			builtin;
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

  /* *	The procdedure is simple:
   *	  1) Check the inputs.
   *	  2) Compute attributes of result and temporary.
   *	  3) Convert input to temporary.
   *	  4) Do arithmetic on temp(s).
   *	  5) Assign temporary to result. */


probe_operate_$prefix:
  entry (P_probe_info_ptr, P_opcode, P_first, P_result, P_code);

  probe_info_ptr = P_probe_info_ptr;
  P_code = 0;			/* until we decide otherwise */

  if probe_info.language_type = PASCAL_lang_type
    then
         call probe_pascal_$real_type (P_first.type, P_first.type_ptr,
	    P_first.type, P_first.type_ptr);

  if P_first.type < lbound (data_type_info_$info, 1)
       | P_first.type > hbound (data_type_info_$info, 1) then do;
      call probe_error_$record (probe_info_ptr, probe_et_$bad_operand,
	 P_first.name);
      goto RECORDED_MESSAGE;
    end;

  if ^data_type_info_$info (P_first.type).computational then do;
      call probe_error_$record (probe_info_ptr, probe_et_$bad_operand,
	 P_first.name);
      goto RECORDED_MESSAGE;
    end;


  if data_type_info_$info (P_first.type).arithmetic
       & /* optimize - prefix + of number */
       P_opcode = "+" then do;	/* result is the reference itself */
      P_result.address_ptr = P_first.address_ptr;
      P_result.type = P_first.type;
      P_result.descriptor = P_first.descriptor;
      P_result.precision = P_first.precision;
    end;
    else do;

      /* Must convert operand to a standard arithmetic type before continuing */

      type_bits = compute_type_bits ((P_first.type));
      type_type = fixed (string (type_bits), 3, 0);

      /* gather source attributes */

      use_genfd_sw, use_genfd_complex_sw = "0"b;
      if data_type_info_$info (P_first.type).hex
	 & data_type_info_$info (P_first.type).arithmetic then do;
	use_genfd_sw = "1"b;
	if data_type_info_$info (P_first.type).complex then do;
	    use_genfd_complex_sw = "1"b;
	    genfd_type = cplx_flt_dec_generic_dtype;
	  end;
	  else genfd_type = real_flt_dec_generic_dtype;
        end;

      call setup_structure (P_first, source (1));

      if ^type_bits.binary & ^use_genfd_sw
        then
	   if ^valid_decimal_ ((P_first.type), P_first.address_ptr,
	        (source (1).prec_or_length))
	     then do;
	       call probe_error_$record (probe_info_ptr,
		  probe_et_$bad_decimal, P_first.name);
	       goto RECORDED_MESSAGE;
	     end;

      /* make temp for intermediate, and convert to it */

      unspec (intermediate (1)) = "0"b;
      if use_genfd_sw then do;
	intermediate (1).data_type = genfd_type;
	intermediate (1).prec_or_length =
	     data_type_info_$max_decimal_precision;
	alloc_size = MAX_GENFD_WORDS;
	if use_genfd_complex_sw
	  then alloc_size = alloc_size * 2;
        end;
        else do;
	intermediate (1).data_type = common_info (type_type).type_array;
	intermediate (1).prec_or_length =
	     common_info (type_type).prec_array;
	alloc_size = common_info (type_type).size_array;
        end;
      intermediate (1).scale = source (1).scale;
      intermediate (1).picture_image_ptr = null ();

      dp = allocate_temp (alloc_size);
      intermediate (1).address = dp;

      call assign_$computational_ (addr (intermediate (1)), addr (source (1)),
	 P_code);
      if P_code ^= 0
        then
	   return;

      /* Now do the arithmetic on the intermediate value */

      if P_opcode = "+"
        then ;			/* nothing need be done */

      else if P_opcode = "-" then do;
	if use_genfd_sw
	  then
	       if use_genfd_complex_sw
	         then call generic_math_$negate_decimal_complex
		         (dp -> cplx_gen_decimal_struc,
		         dp -> cplx_gen_decimal_struc);
	         else call generic_math_$negate_decimal
		         (dp -> gen_decimal_struc,
		         dp -> gen_decimal_struc);
	else if type_bits.binary
	  then if type_bits.float
	         then if type_bits.complex
		      then dp -> float_bin_complex =
			      -dp -> float_bin_complex;
		      else dp -> float_bin_real = -dp -> float_bin_real;
	       else if type_bits.complex
	         then dp -> fixed_bin_complex = -dp -> fixed_bin_complex;
	       else dp -> fixed_bin_real = -dp -> fixed_bin_real;
	else if type_bits.float
	  then if type_bits.complex
	         then dp -> float_dec_complex = -dp -> float_dec_complex;
	         else dp -> float_dec_real = -dp -> float_dec_real;
	else if type_bits.complex
	  then dp -> fixed_dec_complex = -dp -> fixed_dec_complex;
	else dp -> fixed_dec_real = -dp -> fixed_dec_real;
        end;			/* of minus */

      else call probe_error_$malfunction (probe_info_ptr, 0,
	      "Invalid prefix operator: ""^a"".", P_opcode);

      if use_genfd_sw then do;
	P_result.type = genfd_type;
	P_result.precision = data_type_info_$max_decimal_precision;
        end;
        else P_result.type = common_info (type_type).type_array;
      P_result.descriptor = P_result.type * 2;

      /* now create some storage in the work area for the result
   This storage must survive our invocation! */

      P_result.address_ptr = allocate_temp (alloc_size);

      call setup_structure (P_result, result);
      call assign_$computational_ (addr (result), addr (intermediate (1)),
	 P_code);
    end;

  P_result.symbol_ptr = null ();
  if P_result.source_info_ptr ^= null
    then
         P_result.source_info_ptr -> source_info.block_ptr,
	    P_result.source_info_ptr -> source_info.stack_ptr,
	    P_result.source_info_ptr -> source_info.entry_ptr = null ();
  P_result.name = "<<temporary>>";
  P_result.flags = "0"b;
  P_result.constant = "1"b;

  return;				/* end of code for probe_operate_$prefix */

%page;
/*****************************************************************************/

probe_operate_$infix:
  entry (P_probe_info_ptr, P_opcode, P_first, P_second, P_result, P_code);

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

c_pointer_arithmetic:
  proc ();

  dcl i			fixed bin;
  dcl tp			ptr;
  dcl total_bits		(2) fixed bin;
  dcl data_value		(2) fixed bin;
  dcl tp_type		fixed bin;
  dcl op_addr		ptr;
  dcl total_bits_to_add	fixed bin (24);
  dcl add_word_offset	fixed bin (17);
  dcl add_bit_offset	fixed bin (5);
  dcl temp_node_ptr		ptr;
  dcl fixed_bin_short	fixed bin (17) based (op_addr);
  dcl fixed_bin_long	fixed bin (71) based (op_addr);
  dcl dec_string		char (32) based (op_addr);
  dcl stored_addr		ptr;
  dcl based_ptr		ptr based;
  dcl based_int		fixed bin (35) based;

  dcl 1 its		based aligned,
       2 pad1		bit (3) unaligned,
       2 segno		bit (15) unaligned,
       2 ringno		bit (3) unaligned,
       2 pad2		bit (9) unaligned,
       2 its_mod		bit (6) unaligned,

       2 offset		fixed bin (17) unaligned,
       2 pad3		bit (3) unaligned,
       2 bit_offset		fixed bin (5) unaligned,
       2 pad4		bit (3) unaligned,
       2 future_mod		bit (6) unaligned;

  dcl pointer_encountered	bit (1);
  dcl code		fixed bin (35);
  dcl probe_create_reference_ entry (ptr, ptr);
  dcl 01 temp_ref		aligned like reference_node;
  dcl probe_builtins_$sizeof_builtin
			entry (ptr, ptr, fixed bin (35));
  dcl 01 sub_refs		aligned like subscript_reference_ptrs;


  /* Get the size of the data type pointed to.      */
  /* Get the number of units                        */
  /* Convert the units to words and bits            */
  /* Add the appropriate fileds of the ITS pointer  */

  if (P_opcode ^= "+" & P_opcode ^= "-") then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "Only addition and subtraction may be done in C pointer arithmetic."
	 );
      goto RECORDED_MESSAGE;
    end;
  total_bits (*) = 0;
  data_value (*) = 0;
  pointer_encountered = "0"b;
  P_result.symbol_ptr = null ();
  do i = 1 to 2;
    if operand (i).type = pointer_dtype then do;
        if (pointer_encountered) then do;
	  call probe_error_$record (probe_info_ptr, 0,
	       "Only one operand in a pointer arithmetic expression may be a pointer."
	       );
	  goto RECORDED_MESSAGE;
	end;
	else pointer_encountered = "1"b;
        P_result.symbol_ptr = operand (i).symbol_ptr;
        if (operand (i).symbol_ptr = null ()
	   & operand (i).c_symbol_ptr = null ()) then do;
	  call probe_error_$record (probe_info_ptr, 0,
	       "Cannot locate the data type of the data pointed to by a pointer"
	       );
	  goto RECORDED_MESSAGE;
	end;
	else do;
	  if (operand (i).symbol_ptr ^= null ())
	    then
	         tp = operand (i).symbol_ptr;
	    else
	         tp = operand (i).c_symbol_ptr;

	  stored_addr = operand (i).address_ptr -> based_ptr;

	  tp = addrel (tp, fixed (tp -> runtime_symbol.son));

	  do while (fixed (tp -> runtime_symbol.type) = c_typeref_dtype);
	    tp = addrel (tp, fixed (tp -> runtime_symbol.son));
	  end;

	  temp_ref = operand (i);
	  temp_ref.symbol_ptr = tp;

	  sub_refs.ptr (1, 1) = addr (temp_ref);
	  call probe_create_reference_ (probe_info_ptr, temp_node_ptr);
	  temp_node_ptr -> reference_node.name = "<<<constant>>>";
	  temp_node_ptr -> reference_node.source_info_ptr =
	       temp_ref.source_info_ptr;
	  temp_node_ptr -> reference_node.optional_info.n_subscripts = 1;
	  temp_node_ptr -> reference_node.subscript_refs_ptr =
	       addr (sub_refs);
	  call probe_builtins_$sizeof_builtin (probe_info_ptr,
	       temp_node_ptr, code);
	  temp_node_ptr -> reference_node.optional_info.n_subscripts = 0;

	  total_bits (i) =
	       temp_node_ptr -> reference_node.address_ptr -> based_int * 9;
	end;
      end;
      else do;
        op_addr = operand (i).address_ptr;
        tp_type = operand (i).type;
        if (tp_type = real_fix_bin_1_dtype)
	then
	     data_value (i) = fixed (fixed_bin_short, 17, 0);
        else if (tp_type = real_fix_bin_2_dtype)
	then
	     data_value (i) = fixed (fixed_bin_long, 17, 0);
        else if (tp_type = real_fix_dec_9bit_ls_dtype)
	then
	     data_value (i) =
		fixed (substr (dec_string, 1, operand (i).precision + 1),
		17, 0);
      end;
  end;				/* end do loop */

  P_result.type = pointer_dtype;

  if (total_bits (1) = 0)
    then
         total_bits_to_add = multiply (total_bits (2), data_value (1), 24, 0);
    else
         total_bits_to_add = multiply (total_bits (1), data_value (2), 24, 0);

  add_word_offset = divide (total_bits_to_add, 36, 17, 0);
  add_bit_offset = fixed (mod (total_bits_to_add, 36), 5, 0);

  P_result.descriptor = P_result.type * 2;

  if P_result.source_info_ptr ^= null
    then
         P_result.source_info_ptr -> source_info.block_ptr,
	    P_result.source_info_ptr -> source_info.stack_ptr,
	    P_result.source_info_ptr -> source_info.entry_ptr = null ();
  P_result.name = "<<temporary>>";
  P_result.flags = "0"b;
  P_result.constant = "1"b;

  P_result.address_ptr = allocate_temp (2);
  P_result.address_ptr -> based_ptr = stored_addr;

  if (P_opcode = "+") then do;
      add_word_offset = P_result.address_ptr -> its.offset + add_word_offset;
      add_bit_offset =
	 P_result.address_ptr -> its.bit_offset + add_bit_offset;
      if (add_bit_offset >= 36) then do;
	add_word_offset =
	     add_word_offset + divide (add_bit_offset, 36, 17, 0);
	add_bit_offset = fixed (mod (add_bit_offset, 36), 5, 0);
        end;
    end;
  else if (P_opcode = "-") then do;
      add_word_offset = P_result.address_ptr -> its.offset - add_word_offset;
      add_bit_offset =
	 P_result.address_ptr -> its.bit_offset - add_bit_offset;
      if (add_bit_offset < 0) then do;
	add_word_offset = add_word_offset - 1;
	add_bit_offset = 36 + add_bit_offset;
        end;
    end;
  P_result.address_ptr -> its.offset = add_word_offset;
  P_result.address_ptr -> its.bit_offset = add_bit_offset;

  end c_pointer_arithmetic;

%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

c_shift_arithmetic:
  proc ();

  dcl (tp_type, data_value)	fixed bin;
  dcl op_addr		ptr;
  dcl fixed_bin_short	fixed bin (17) based (op_addr);
  dcl fixed_bin_long	fixed bin (71) based (op_addr);
  dcl dec_string		char (32) based (op_addr);
  dcl bit_9		(4) unaligned bit (9) based;
  dcl bit_18		(2) unaligned bit (18) based;
  dcl bit_36		bit (36) based;
  dcl bit_72		bit (72) based;
  dcl zeros		bit (72) int static options (constant)
			init ("0"b);
  dcl mod_bits		fixed bin;

  if (probe_info.language_type ^= C_lang_type) then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "The >> and << operators may not be used by the current language");
      goto RECORDED_MESSAGE;
    end;

  tp_type = operand (1).type;

  /* char */
  if (tp_type = char_dtype) then do;
      mod_bits = 9;
      P_result.address_ptr = allocate_temp (1);
      P_result.address_ptr -> bit_9 (1) =
	 operand (1).address_ptr -> bit_9 (1);
    end;

  /* int & short & long */
  else if (tp_type <= real_flt_bin_2_dtype) then do;
      if (tp_type = real_fix_bin_1_dtype | tp_type = real_flt_bin_1_dtype)
        then do;
	P_result.address_ptr = allocate_temp (1);
	if (operand (1).precision <= 18) then do;
	    mod_bits = 18;
	    P_result.address_ptr -> bit_18 (1) =
	         operand (1).address_ptr -> bit_18 (1);
	  end;
	  else do;
	    mod_bits = 36;
	    P_result.address_ptr -> bit_36 =
	         operand (1).address_ptr -> bit_36;
	  end;
        end;
        else do;
	P_result.address_ptr = allocate_temp (2);
	P_result.address_ptr -> bit_72 = operand (1).address_ptr -> bit_72;
	mod_bits = 72;
        end;
    end;

  /* Invalid data type for a shift */
  else
       call probe_error_$record (probe_info_ptr, 0,
	  "Invalid data type for the shift operator.");


  op_addr = operand (2).address_ptr;
  tp_type = operand (2).type;

  if (tp_type = real_fix_bin_1_dtype)
    then
         data_value = fixed (fixed_bin_short, 17, 0);
  else if (tp_type = real_fix_bin_2_dtype)
    then
         data_value = fixed (fixed_bin_long, 17, 0);
  else if (tp_type = real_fix_dec_9bit_ls_dtype)
    then
         data_value =
	    fixed (substr (dec_string, 1, operand (2).precision + 1), 17, 0)
	    ;

  P_result.type = operand (1).type;

  P_result.descriptor = P_result.type * 2;

  P_result.symbol_ptr = null ();
  if P_result.source_info_ptr ^= null
    then
         P_result.source_info_ptr -> source_info.block_ptr,
	    P_result.source_info_ptr -> source_info.stack_ptr,
	    P_result.source_info_ptr -> source_info.entry_ptr = null ();
  P_result.name = "<<temporary>>";
  P_result.flags = "0"b;
  P_result.constant = "1"b;

  if (data_value >= mod_bits) then do;
      substr (P_result.address_ptr -> bit_72, 1, mod_bits) =
	 substr (zeros, 1, mod_bits);
      return;
    end;
  else if (P_opcode = "<")
    then
         substr (P_result.address_ptr -> bit_72, 1, mod_bits) =
	    substr (P_result.address_ptr -> bit_72, data_value + 1,
	    mod_bits - data_value) || substr (zeros, 1, data_value);
  else if (P_opcode = ">")
    then
         substr (P_result.address_ptr -> bit_72, 1, mod_bits) =
	    substr (zeros, 1, data_value)
	    ||
	    substr (P_result.address_ptr -> bit_72, 1,
	    mod_bits - data_value);

  end c_shift_arithmetic;
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

c_mod_arithmetic:
  proc ();

  dcl tp_type		fixed bin;
  dcl op_addr		ptr;
  dcl fixed_bin_short	fixed bin (35) based (op_addr);
  dcl fixed_bin_long	fixed bin (71) based (op_addr);
  dcl dec_string		char (32) based (op_addr);
  dcl (op1, op2)		fixed bin (35);
  dcl mod			builtin;

  if (probe_info.language_type ^= C_lang_type) then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "The % operator may not be used by the current language.");
      goto RECORDED_MESSAGE;
    end;

  op_addr = operand (1).address_ptr;
  tp_type = operand (1).type;

  P_result.type = real_fix_bin_1_dtype;
  P_result.address_ptr = allocate_temp (1);

  if (tp_type = real_fix_bin_1_dtype)
    then
         op1 = operand (1).address_ptr -> fixed_bin_short;
  else if (tp_type = real_fix_bin_2_dtype)
    then
         op1 = fixed (operand (1).address_ptr -> fixed_bin_long, 35, 0);
  else if (tp_type = real_fix_dec_9bit_ls_dtype)
    then
         op1 = fixed (substr (dec_string, 1, operand (1).precision + 1), 35,
	    0);
				/* Invalid data type for modulous */
  else
       call probe_error_$record (probe_info_ptr, 0,
	  "Invalid data type for the modulous operator.");

  op_addr = operand (2).address_ptr;
  tp_type = operand (2).type;

  if (tp_type = real_fix_bin_1_dtype)
    then
         op2 = operand (2).address_ptr -> fixed_bin_short;
  else if (tp_type = real_fix_bin_2_dtype)
    then
         op2 = fixed (operand (2).address_ptr -> fixed_bin_long, 35, 0);
  else if (tp_type = real_fix_dec_9bit_ls_dtype)
    then
         op2 = fixed (substr (dec_string, 1, operand (2).precision + 1), 35,
	    0);
				/* Invalid data type for modulous */
  else
       call probe_error_$record (probe_info_ptr, 0,
	  "Invalid data type for the modulous operator.");

  P_result.descriptor = P_result.type * 2;

  P_result.symbol_ptr = null ();
  if P_result.source_info_ptr ^= null
    then
         P_result.source_info_ptr -> source_info.block_ptr,
	    P_result.source_info_ptr -> source_info.stack_ptr,
	    P_result.source_info_ptr -> source_info.entry_ptr = null ();
  P_result.name = "<<temporary>>";
  P_result.flags = "0"b;
  P_result.constant = "1"b;

  if (op2 = 0) then do;
      call probe_error_$record (probe_info_ptr, 0,
	 "The second argument of the modulous operator is zero.");
      goto RECORDED_MESSAGE;
    end;

  P_result.address_ptr -> fixed_bin_short = mod (op1, op2);

  end c_mod_arithmetic;
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

  probe_info_ptr = P_probe_info_ptr;
  P_code = 0;			/* until we decide otherwise */

  operand (1) = P_first;
  operand (2) = P_second;		/* for easier processing */

  /* check ops for validity ******************** */

  use_genfd_sw, use_genfd_complex_sw = "0"b;

  do i = 1 to 2;			/* check ops for validity */
    if probe_info.language_type = PASCAL_lang_type
      then
	 call probe_pascal_$real_type (operand (i).type,
	      operand (i).type_ptr,
	      operand (i).type, operand (i).type_ptr);

    if operand (i).type < lbound (data_type_info_$info, 1) |
         operand (i).type > hbound (data_type_info_$info, 1) then do;
        call probe_error_$record (probe_info_ptr, probe_et_$bad_operand,
	   operand (i).name);
        goto RECORDED_MESSAGE;
      end;

    /* C pointers may be incremented or decremented */

    if ^data_type_info_$info (operand (i).type).computational &
         probe_info.language_type ^= C_lang_type then do;
        call probe_error_$record (probe_info_ptr, probe_et_$bad_operand,
	   operand (i).name);
        goto RECORDED_MESSAGE;
      end;

    if data_type_info_$info (operand (i).type).hex &
         data_type_info_$info (operand (i).type).arithmetic then do;
        use_genfd_sw = "1"b;
        if data_type_info_$info (operand (i).type).complex then do;
	  use_genfd_complex_sw = "1"b;
	  genfd_type = cplx_flt_dec_generic_dtype;
	end;
        else if ^use_genfd_complex_sw
	then genfd_type = real_flt_dec_generic_dtype;
      end;
  end;

  /* Do C pointer arithmetic */

  if (operand (1).type = pointer_dtype | operand (2).type = pointer_dtype)
    then do;
      call c_pointer_arithmetic ();
      return;
    end;

  /* Do C left and right shift arithmetic */

  if (P_opcode = "<" | P_opcode = ">") then do;
      call c_shift_arithmetic ();
      return;
    end;

  /* Do C % operator */

  if (P_opcode = "%") then do;
      call c_mod_arithmetic ();
      return;
    end;

  /* to compute the attributes of the result - type_bits is cleverly set up so
   that the common attribute may be found by or'ing the separate attributes */

  type_bits = compute_type_bits ((P_first.type));
  type_bits_copy = compute_type_bits ((P_second.type));

  string (type_bits) = string (type_bits) | string (type_bits_copy);

  type_type = fixed (string (type_bits), 3, 0);
  if use_genfd_sw then do;
      P_result.type = genfd_type;
      P_result.precision = data_type_info_$max_decimal_precision;
    end;
    else P_result.type = common_info (type_type).type_array;
  P_result.descriptor = P_result.type * 2;

  P_result.symbol_ptr = null ();
  if P_result.source_info_ptr ^= null
    then
         P_result.source_info_ptr -> source_info.block_ptr,
	    P_result.source_info_ptr -> source_info.stack_ptr,
	    P_result.source_info_ptr -> source_info.entry_ptr = null ();
  P_result.name = "<<temporary>>";
  P_result.flags = "0"b;
  P_result.constant = "1"b;

  if use_genfd_sw then do;
      alloc_size = MAX_GENFD_WORDS;
      if use_genfd_complex_sw
        then alloc_size = alloc_size * 2;
    end;
    else alloc_size = common_info (type_type).size_array;
  P_result.address_ptr = allocate_temp (alloc_size);
  do i = 1 to 2;

    call setup_structure (operand (i), source (i));
    if data_type_info_$info (operand (i).type).decimal
      then if ^valid_decimal_ ((operand (i).type), operand (i).address_ptr,
	      (source (i).prec_or_length)) then do;
	     call probe_error_$record (probe_info_ptr,
		probe_et_$bad_decimal, operand (i).name);
	     goto RECORDED_MESSAGE;
	   end;

    if use_genfd_sw then do;
        intermediate (i).data_type = genfd_type;
        intermediate (i).prec_or_length =
	   data_type_info_$max_decimal_precision;
      end;
      else intermediate (i).data_type = common_info (type_type).type_array;

    if ^data_type_info_$info (source (i).data_type).arithmetic
      then if data_type_info_$info (source (i).data_type).char_string
	   then intermediate (i).prec_or_length =
		   data_type_info_$max_decimal_precision;
	   else intermediate (i).prec_or_length =
		   data_type_info_$max_fixed_binary_precision;

    if (data_type_info_$info (source (i).data_type).decimal |
         data_type_info_$info (source (i).data_type).char_string) &
         type_bits.binary & ^use_genfd_sw then do;
        intermediate (i).prec_or_length =
	   min (ceil (intermediate (i).prec_or_length * 3.332),
	   common_info (type_type).prec_array);
        intermediate (i).scale =
	   ceil (abs (intermediate (i).scale) * 3.332)
	   * sign (intermediate (i).scale);
      end;			/* decimal to bin precision hack */

    op (i), intermediate (i).address = allocate_temp (alloc_size);
  end;

  result.address = P_result.address_ptr;
  result.data_type = P_result.type;
  result.flags = "0"b;


  /* We now branch depending on the opcode. Each opcode computes the precision that the
   operands are to be converted to, does the conversion, does the operation, computes
   the precision of the result, converts the result to proper precision, and returns.
*/

  if P_opcode = "+" | P_opcode = "-" then do;

      /* Compute temporary and result precisions - both temps must have the same scale,
   because the addition is done with two dummies. the decimal points must be in
   the same column, in order to get meaningful results.   */

      /* Rules of PL/I tell what attributes of plus result are */

      if use_genfd_sw
        then result.prec_or_length = data_type_info_$max_decimal_precision;
        else result.prec_or_length = min (common_info (type_type).prec_array,
	        max (source (1).prec_or_length - source (1).scale,
	        source (2).prec_or_length - source (2).scale) +
	        max (source (1).scale, source (2).scale) + 1);
      result.scale = max (source (1).scale, source (2).scale);

      /* for intermediates use max  possible */
      if ^use_genfd_sw
        then intermediate (*).prec_or_length =
	        common_info (type_type).prec_array;
      intermediate (*).scale = max (source (1).scale, source (2).scale);

      do i = 1 to 2;
        call assign_$computational_ (addr (intermediate (i)),
	   addr (source (i)), P_code);
        if P_code ^= 0
	then
	     return;
      end;

      if P_opcode = "+" then do;
	if use_genfd_sw
	  then
	       if use_genfd_complex_sw
	         then call generic_math_$add_decimal_complex
		         (op (1) -> cplx_gen_decimal_struc,
		         op (2) -> cplx_gen_decimal_struc,
		         op (1) -> cplx_gen_decimal_struc);
	         else call generic_math_$add_decimal
		         (op (1) -> gen_decimal_struc,
		         op (2) -> gen_decimal_struc,
		         op (1) -> gen_decimal_struc);
	else if type_bits.binary
	  then if type_bits.float
	         then if type_bits.complex
		      then op (1) -> float_bin_complex =
			      op (1) -> float_bin_complex
			      + op (2) -> float_bin_complex;
		      else op (1) -> float_bin_real =
			      op (1) -> float_bin_real
			      + op (2) -> float_bin_real;
	       else if type_bits.complex
	         then op (1) -> fixed_bin_complex =
		         op (1) -> fixed_bin_complex
		         + op (2) -> fixed_bin_complex;
	       else op (1) -> fixed_bin_real =
		       op (1) -> fixed_bin_real
		       + op (2) -> fixed_bin_real;
	else if type_bits.float
	  then if type_bits.complex
	         then op (1) -> float_dec_complex =
		         op (1) -> float_dec_complex
		         + op (2) -> float_dec_complex;
	         else op (1) -> float_dec_real =
		         op (1) -> float_dec_real
		         + op (2) -> float_dec_real;
	else if type_bits.complex
	  then op (1) -> fixed_dec_complex =
		  op (1) -> fixed_dec_complex
		  + op (2) -> fixed_dec_complex;
	else op (1) -> fixed_dec_real =
		op (1) -> fixed_dec_real + op (2) -> fixed_dec_real;
        end;			/* plus */

      else if P_opcode = "-" then do;
	if use_genfd_sw
	  then
	       if use_genfd_complex_sw
	         then call generic_math_$subtract_decimal_complex
		         (op (1) -> cplx_gen_decimal_struc,
		         op (2) -> cplx_gen_decimal_struc,
		         op (1) -> cplx_gen_decimal_struc);
	         else call generic_math_$subtract_decimal
		         (op (1) -> gen_decimal_struc,
		         op (2) -> gen_decimal_struc,
		         op (1) -> gen_decimal_struc);
	else if type_bits.binary
	  then if type_bits.float
	         then if type_bits.complex
		      then op (1) -> float_bin_complex =
			      op (1) -> float_bin_complex
			      - op (2) -> float_bin_complex;
		      else op (1) -> float_bin_real =
			      op (1) -> float_bin_real
			      - op (2) -> float_bin_real;
	       else if type_bits.complex
	         then op (1) -> fixed_bin_complex =
		         op (1) -> fixed_bin_complex
		         - op (2) -> fixed_bin_complex;
	       else op (1) -> fixed_bin_real =
		       op (1) -> fixed_bin_real
		       - op (2) -> fixed_bin_real;
	else if type_bits.float
	  then if type_bits.complex
	         then op (1) -> float_dec_complex =
		         op (1) -> float_dec_complex
		         - op (2) -> float_dec_complex;
	         else op (1) -> float_dec_real =
		         op (1) -> float_dec_real
		         - op (2) -> float_dec_real;
	else if type_bits.complex
	  then op (1) -> fixed_dec_complex =
		  op (1) -> fixed_dec_complex
		  - op (2) -> fixed_dec_complex;
	else op (1) -> fixed_dec_real =
		op (1) -> fixed_dec_real - op (2) -> fixed_dec_real;
        end;			/* minus */
    end;				/* plus and minus */

  else if P_opcode = "*" then do;

      if use_genfd_sw
        then temp_precision = data_type_info_$max_decimal_precision;
        else temp_precision = common_info (type_type).prec_array;

      if type_bits.float then do;
	P_result.precision, result.prec_or_length,
	     intermediate (*).prec_or_length = temp_precision;
	result.scale, intermediate (*).scale = 0;
	do i = 1 to 2;
	  call assign_$computational_ (addr (intermediate (i)),
	       addr (source (i)), P_code);
	  if P_code ^= 0
	    then
	         return;
	end;
	if use_genfd_sw
	  then
	       if use_genfd_complex_sw
	         then call generic_math_$multiply_decimal_complex
		         (op (1) -> cplx_gen_decimal_struc,
		         op (2) -> cplx_gen_decimal_struc,
		         op (1) -> cplx_gen_decimal_struc);
	         else call generic_math_$multiply_decimal
		         (op (1) -> gen_decimal_struc,
		         op (2) -> gen_decimal_struc,
		         op (1) -> gen_decimal_struc);
	else if type_bits.binary
	  then if type_bits.complex
	         then op (1) -> float_bin_complex =
		         op (1) -> float_bin_complex
		         * op (2) -> float_bin_complex;
	         else op (1) -> float_bin_real =
		         op (1) -> float_bin_real
		         * op (2) -> float_bin_real;
	else if type_bits.complex
	  then op (1) -> float_dec_complex =
		  op (1) -> float_dec_complex
		  * op (2) -> float_dec_complex;
	else op (1) -> float_dec_real =
		op (1) -> float_dec_real * op (2) -> float_dec_real;
        end;			/* float work */

        else do;
	intermediate (*).prec_or_length = temp_precision;
	do i = 1 to 2;
	  intermediate (i).scale = source (i).scale;
	  call assign_$computational_ (addr (intermediate (i)),
	       addr (source (i)), P_code);
	  if P_code ^= 0
	    then
	         return;
	end;


	if type_bits.binary
	  then if type_bits.complex
	         then op (1) -> fixed_bin_complex =
		         op (1) -> fixed_bin_complex
		         * op (2) -> fixed_bin_complex;
	         else op (1) -> fixed_bin_real =
		         op (1) -> fixed_bin_real
		         * op (2) -> fixed_bin_real;
	else if type_bits.complex
	  then op (1) -> fixed_dec_complex =
		  op (1) -> fixed_dec_complex
		  * op (2) -> fixed_dec_complex;
	else op (1) -> fixed_dec_real =
		op (1) -> fixed_dec_real * op (2) -> fixed_dec_real;

	result.prec_or_length = min (common_info (type_type).prec_array,
	     source (1).prec_or_length + source (2).prec_or_length + 1);
	result.scale = source (1).scale + source (2).scale;
        end;			/* fixed point multiplication */

    end;				/* multiply */

  else if P_opcode = "/" then do;
      if use_genfd_sw
        then temp_precision = data_type_info_$max_decimal_precision;
        else temp_precision = common_info (type_type).prec_array;
      result.prec_or_length, intermediate (*).prec_or_length,
	 P_result.precision = temp_precision;
      intermediate (*).scale, result.scale = 0;

      do i = 1 to 2;
        call assign_$computational_ (addr (intermediate (i)),
	   addr (source (i)), P_code);
        if P_code ^= 0
	then
	     return;
      end;

      if use_genfd_sw
        then
	   if use_genfd_complex_sw
	     then call generic_math_$divide_decimal_complex
		     (op (1) -> cplx_gen_decimal_struc,
		     op (2) -> cplx_gen_decimal_struc,
		     op (1) -> cplx_gen_decimal_struc);
	     else call generic_math_$divide_decimal
		     (op (1) -> gen_decimal_struc,
		     op (2) -> gen_decimal_struc,
		     op (1) -> gen_decimal_struc);
      else if type_bits.binary
        then if type_bits.float
	     then if type_bits.complex
		  then op (1) -> float_bin_complex =
			  divide (op (1) -> float_bin_complex,
			  op (2) -> float_bin_complex, 63);
		  else op (1) -> float_bin_real =
			  divide (op (1) -> float_bin_real,
			  op (2) -> float_bin_real, 63);
	   else if type_bits.complex
	     then op (1) -> fixed_bin_complex =
		     divide (op (1) -> fixed_bin_complex,
		     op (2) -> fixed_bin_complex, 71);
	   else op (1) -> fixed_bin_real =
		   divide (op (1) -> fixed_bin_real,
		   op (2) -> fixed_bin_real, 71, 0);
      else if type_bits.float
        then if type_bits.complex
	     then op (1) -> float_dec_complex =
		     divide (op (1) -> float_dec_complex,
		     op (2) -> float_dec_complex, 59);
	     else op (1) -> float_dec_real =
		     divide (op (1) -> float_dec_real,
		     op (2) -> float_dec_real, 59);
      else if type_bits.complex
        then op (1) -> fixed_dec_complex =
	        divide (op (1) -> fixed_dec_complex,
	        op (2) -> fixed_dec_complex, 59, 0);
      else op (1) -> fixed_dec_real =
	      divide (op (1) -> fixed_dec_real, op (2) -> fixed_dec_real,
	      59, 0);

    end;				/* divide */


  call assign_$computational_ (addr (result), addr (intermediate (1)), P_code)
       ;
  an_encoded_precision.prec = result.prec_or_length;
  an_encoded_precision.scale = result.scale;
  unspec (P_result.precision) = unspec (an_encoded_precision);

  return;


RECORDED_MESSAGE:			/* error exit */
  P_code = probe_et_$recorded_message;

  return;

%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

allocate_temp:
  proc (P_size_in_words) returns (ptr);

  dcl P_size_in_words	fixed bin parameter;
  dcl based_bit		bit (P_size_in_words * 36) based;
  dcl result_ptr		ptr;

  allocate based_bit in (expression_area) set (result_ptr);
  return (result_ptr);

  end allocate_temp;
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

setup_structure:
  proc (ref, comp);

  dcl 1 ref		parameter aligned like reference_node;
  dcl 1 comp		parameter aligned like computational_data;
  dcl 1 an_encoded_value	like encoded_precision;

  comp.address = ref.address_ptr;
  comp.data_type = ref.type;
  string (comp.flags) = "0"b;
  comp.flags.packed = ref.flags.packed;
  if data_type_info_$info (ref.type).arithmetic
    then do;
      unspec (an_encoded_value) = unspec (ref.precision);
      comp.prec_or_length = an_encoded_value.prec;
      comp.scale = an_encoded_value.scale;
    end;
    else do;
      comp.prec_or_length = ref.precision;
      comp.scale = 0;
    end;
  if ref.type = picture_runtime_dtype
    then comp.picture_image_ptr = pointer (ref.symbol_ptr, ref.precision);
    else comp.picture_image_ptr = null ();

  end setup_structure;
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

compute_type_bits:
  proc (P_dtype) returns (1 aligned like type_bits);

  dcl P_dtype		fixed bin parameter;

  dcl 1 d_type_bits		aligned like type_bits;

  if data_type_info_$info (P_dtype).arithmetic then do;
      d_type_bits.float = ^data_type_info_$info (P_dtype).fixed;
      d_type_bits.binary = ^data_type_info_$info (P_dtype).decimal;
      d_type_bits.complex = data_type_info_$info (P_dtype).complex;
    end;

    else do;
      d_type_bits.float = "0"b;
      if data_type_info_$info (P_dtype).bit_string
        then
	   d_type_bits.binary = "1"b;
        else d_type_bits.binary = "0"b;
      d_type_bits.complex = "0"b;
    end;

  return (d_type_bits);
  end compute_type_bits;
%page;
/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

%include probe_info;
%page;
%include probe_tokens;
%page;
%include probe_references;
%page;
%include probe_source_info;
%page;
%include std_descriptor_types;
%page;
%include data_type_info_;
%page;
%include probe_lang_types;
%page;
%include encoded_precision;
%page;
%include computational_data;
%page;
%include runtime_symbol;

  end probe_operate_;
