/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(87-06-18,RWaters), approve(87-06-18,MCR7687), audit(87-06-24,Huen),
     install(87-07-15,MR12.1-1040):
     Probe error #108: allow the object command to work w/o source code.
  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
     Added format control comment to make the source more readable.
                                                   END HISTORY COMMENTS */

/* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */

/****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

probe_requests_:
  proc ();

  call probe_error_$malfunction ();	/* dummy entry */

  /* THE PROBE REQUESTS WE CONTAIN ARE:

   after,
   args,
   before,
   enable,
   execute,
   handlers,
   input_description,
   input_switch,
   object,
   output_description,
   output_switch,
   position/use,
   reset,
   source,
   status,
   where


   Modified 16 Sept 79 JRDavis for version 4 break_mgr_ syntax
   Modified 09/20/80 WOS, to make args request work in breakpoint request list. (bug 198) */
  /* Make input_switch & output_switch static (per-process) 09/30/81 S. Herbst */
  /* Add input_description and output_description requetsts 10/01/81 S. Herbst */
  /* Add arguments LEVEL_N and PROC_NAME to args request 10/02/81 S. Herbst */
  /* Add "ps line +N", "ps level +N", and "b STRING" syntax 10/09/81 S. Herbst */
  /* Added object request 11/10/81 S. Herbst */
  /* Fixed for "ps N.M" and "args N.M" (support frames) 12/19/81 S. Herbst */
  /* Fixed object request to not show break instructions 09/15/82 S. Herbst */
  /* Fixed "handlers" to test for null source_info.stack_ptr 10/27/82 S. Herbst */
  /* Added "enable" request (undocumented) for use when debugging probe itself 08/15/83 S. Herbst */
  /* Changed to call probe_block_name_ with "0"b (brief form) 08/26/83 S. Herbst */
  /* Fixed "sc path" to set seg_info.(directory entry)_name 10/11/83 S. Herbst */
  /* Changed position to allow "ps lines +N" and "ps +N line(s)" same as "ps line +N" 02/09/84 S. Herbst */
  /* Fixed (input output)_description to use un-parsed attach description 03/30/84 S. Herbst */
  /* Fixed "ps" (no args) to fill in source_info.instruction_ptr if null 08/02/84 S. Herbst */
  /* Fixed "sc path" to not set seg_info.(directory_name entry_name);these refer to the object 11/07/84 S. Herbst */
  /* Added "wh object", "wh object path", "wh source path" 11/07/84 S. Herbst */
  /* Added synonym "wh obj" for "wh object" 01/03/85 Steve Herbst */
  /* Fixed "wh control" to print stack level as "wh source" does 01/31/85 Steve Herbst */
  /* Changed to allow "object" to work without a source file 05/21/87 RWaters */


  dcl P_probe_info_ptr	pointer parameter;

  dcl (
      PRIVATE		init ("1"b),
      NOT_PRIVATE		init ("0"b)
      )			bit (1) aligned int static options (constant);
  dcl (
      STREAM_INPUT		init (1),
      STREAM_OUTPUT		init (2)
      )			fixed bin int static options (constant);

  dcl NL			char (1) int static options (constant) init ("
");

  dcl code		fixed bin (35);

  dcl 1 new_source_info	aligned like source_info;
  dcl source_ptr		ptr;
  dcl level_string		char (32) varying;
  dcl (frame_number, frame_decimal, level)
			fixed bin;

  dcl 1 map_array		(map_size) aligned based (stmt_map_ptr)
			like statement_map;
  dcl map_size		fixed bin (21);
  dcl stmt_map_ptr		ptr;

  dcl constant_string	char (probe_info.ct -> constant.precision)
			based (probe_info.ct -> constant.data_ptr);
  dcl pathname		char (256) varying;
  dcl attach_description	char (256) varying;

  dcl (
      probe_et_$e_syntax_err,
      probe_et_$bad_ctl_arg,
      probe_et_$bad_line,
      probe_et_$no_statement_map,
      probe_et_$noarg,
      probe_et_$none_active,
      probe_et_$syntax_error,
      probe_et_$too_many_args,
      probe_et_$unimplemented_request
      )			fixed bin (35) external static;

  dcl probe_break_mgr_$print_instructions
			entry (ptr, ptr, ptr, fixed bin);
  dcl probe_error_$malfunction
			entry options (variable);
  dcl probe_error_$warning	entry options (variable);
  dcl error_table_$noentry	fixed bin (35) ext static;
  dcl probe_get_$decimal	entry (ptr, fixed bin, fixed bin,
			fixed bin (35));
  dcl probe_get_$integer	entry (ptr, fixed bin, fixed bin (35));
  dcl probe_get_$line	entry (ptr, ptr, fixed bin, bit (36) aligned,
			fixed bin, fixed bin (35));
  dcl probe_get_$pathname	entry (ptr, char (*) varying, fixed bin (35));
  dcl probe_get_$object	entry (ptr, ptr, fixed bin (35));
  dcl probe_get_$request_list entry (ptr, ptr, fixed bin (21), fixed bin (35))
			;
  dcl probe_block_name_	entry (ptr, ptr, bit (1) aligned)
			returns (char (256) varying);
  dcl probe_error_		entry options (variable);
  dcl probe_line_number_	entry (ptr, 1 aligned like source_info)
			returns (char (64));
  dcl probe_pretty_source_info_
			entry (ptr, ptr, char (*));
  dcl probe_source_segment_$get_file_ptr
			entry (ptr, ptr, fixed bin) returns (ptr);
  dcl probe_source_segment_$list_statement
			entry (ptr, ptr, fixed bin, fixed bin (35));
  dcl probe_stack_trace_$where_source_info
			entry (ptr, ptr, fixed bin, char (*));
  dcl probe_trace_a_stack_	entry (ptr, ptr, bit (1) aligned);

  dcl cv_dec_		entry (char (*)) returns (fixed bin);
  dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
			fixed bin (35));
  dcl ioa_$ioa_switch	entry options (variable);
  dcl ioa_$rsnnl		entry options (variable);
  dcl iox_$attach_name	entry (char (*), ptr, char (*), ptr,
			fixed bin (35));
  dcl iox_$close		entry (ptr, fixed bin (35));
  dcl iox_$destroy_iocb	entry (ptr, fixed bin (35));
  dcl iox_$detach_iocb	entry (ptr, fixed bin (35));
  dcl iox_$open		entry (ptr, fixed bin, bit (1) aligned,
			fixed bin (35));
  dcl pathname_		entry (char (*), char (*)) returns (char (168));
  dcl unique_chars_		entry (bit (*)) returns (char (15));

  dcl (addr, binary, fixed, length, min, null, pointer, rel, rtrim, substr)
			builtin;
SYNTAX_ERROR:			/* general-purpose error exit */
  code = probe_et_$syntax_error;

  call probe_error_ (probe_info_ptr, code, probe_info.request_name);
  goto MAIN_RETURN;


SOME_ERROR:			/* general for error code type errors */
  call probe_error_ (probe_info_ptr, code);
				/* never returns */
  goto MAIN_RETURN;			/* just in case */


MAIN_RETURN:
  return;				/* only such exit from this procedure */

%page;
  dcl probe_get_$io_switch	entry (ptr, ptr, fixed bin (35));
  dcl (
      iox_$user_input,
      iox_$user_output,
      iox_$error_output,
      iox_$user_io
      )			ptr external;

  dcl iocb_ptr		pointer;

input_switch_request:
  entry (P_probe_info_ptr);

  /* *	This request sets the IOCB pointer from which probe does input */


  probe_info_ptr = P_probe_info_ptr;

  if ^probe_info.execute
    then goto MAIN_RETURN;

  if probe_info.ct -> token.type < probe_info.end_token then do;
				/* an argument was supplied */
      call probe_get_$io_switch (probe_info_ptr, iocb_ptr, code);
      if code ^= 0
        then goto SOME_ERROR;
      call reject_argument ();	/* too many arguments */
      if iocb_ptr ^= null ()
        then
	   call set_iocb (probe_static_info.input_switch,
	        probe_static_info.private_input_sw,
	        iocb_ptr, NOT_PRIVATE);
    end;

    else call set_iocb (probe_static_info.input_switch,
	    probe_static_info.private_input_sw,
	    iox_$user_input, NOT_PRIVATE);
				/* default value */

  probe_info.input_switch = probe_static_info.input_switch;

  goto MAIN_RETURN;




output_switch_request:
  entry (P_probe_info_ptr);

  /* *	This request sets the IOCB pointer to which probe does output */


  probe_info_ptr = P_probe_info_ptr;

  if ^probe_info.execute
    then goto MAIN_RETURN;

  if probe_info.ct -> token.type < probe_info.end_token then do;
				/* an argument was supplied */
      call probe_get_$io_switch (probe_info_ptr, iocb_ptr, code);
      if code ^= 0
        then goto SOME_ERROR;
      call reject_argument ();	/* too many arguments */
      if iocb_ptr ^= null ()
        then
	   call set_iocb (probe_static_info.output_switch,
	        probe_static_info.private_output_sw,
	        iocb_ptr, NOT_PRIVATE);
    end;
    else call set_iocb (probe_static_info.output_switch,
	    probe_static_info.private_output_sw,
	    iox_$user_output, NOT_PRIVATE);
				/* default value */

  probe_info.output_switch = probe_static_info.output_switch;

  goto MAIN_RETURN;
%page;
input_description_request:
  entry (P_probe_info_ptr);

  /* This request creates a new IOCB from an attach description and sets the switch for reading input */

  probe_info_ptr = P_probe_info_ptr;

  if ^probe_info.execute
    then goto MAIN_RETURN;

  if probe_info.ct -> token.type >= probe_info.end_token
    then
         call probe_error_ (probe_info_ptr, 0,
	    "Usage: input_description attach_description");

  call rest_of_request (attach_description);

  call iox_$attach_name ("probe_input." || unique_chars_ ("0"b), iocb_ptr,
       (attach_description), null, code);
  if code ^= 0
    then call probe_error_ (probe_info_ptr, code, "^a", attach_description);
  call iox_$open (iocb_ptr, STREAM_INPUT, "0"b, code);
  if code ^= 0 then do;
      call iox_$detach_iocb (iocb_ptr, (0));
      call probe_error_ (probe_info_ptr, code,
	 "Unable to open switch for reading.");
    end;

  call set_iocb (probe_static_info.input_switch,
       probe_static_info.private_input_sw,
       iocb_ptr, PRIVATE);

  probe_info.input_switch = probe_static_info.input_switch;

  go to MAIN_RETURN;

output_description_request:
  entry (P_probe_info_ptr);

  /* Creates an IOCB from an attach description and sets the switch for printing output */

  probe_info_ptr = P_probe_info_ptr;

  if ^probe_info.execute
    then goto MAIN_RETURN;

  if probe_info.ct -> token.type >= probe_info.end_token
    then
         call probe_error_ (probe_info_ptr, (0),
	    "Usage: output_description attach_description");

  call rest_of_request (attach_description);

  call iox_$attach_name ("probe_output." || unique_chars_ ("0"b), iocb_ptr,
       (attach_description), null, code);
  if code ^= 0
    then call probe_error_ (probe_info_ptr, code, "^a", attach_description);
  call iox_$open (iocb_ptr, STREAM_OUTPUT, "0"b, code);
  if code ^= 0 then do;
      call iox_$detach_iocb (iocb_ptr, (0));
      call probe_error_ (probe_info_ptr, code,
	 "Unable to open switch for writing.");
    end;

  call set_iocb (probe_static_info.output_switch,
       probe_static_info.private_output_sw,
       iocb_ptr, PRIVATE);

  probe_info.output_switch = probe_static_info.output_switch;

  go to MAIN_RETURN;
%page;
args_request:
  entry (P_probe_info_ptr);

  dcl block_name		char (256) varying;
  dcl probe_print_arglist_	entry (ptr, ptr);

  probe_info_ptr = P_probe_info_ptr;

  if probe_info.execute then do;
      if probe_info.ct -> token.type >= probe_info.end_token
        then source_ptr = probe_info.ptr_to_current_source;

        else do;
	call probe_trace_a_stack_
	     (probe_info_ptr,
	     probe_info.current_stack_frame -> stack_frame.prev_sp, "1"b);

	lfp = stack_info.level_chain;
	if probe_info.ct -> token.type = CONSTANT_TYPE then do;
				/* args for frame number N */
	    if probe_info.ct -> constant.scale ^= 0
	      then
		 call probe_get_$decimal (probe_info_ptr, frame_number,
		      frame_decimal, code);
	      else do;
	        call probe_get_$integer (probe_info_ptr, frame_number, code)
		   ;
	        frame_decimal = 0;
	      end;
	    if code ^= 0
	      then call probe_error_ (probe_info_ptr, code);
	    if frame_number > stack_info.max_level | frame_number = 0
	      then
NO_FRAME:
	        call probe_error_ (probe_info_ptr, 0,
		   "No frame number ^d^[.^d^]",
		   frame_number, frame_decimal ^= 0, frame_decimal);

	    do while (level_frame.printed_number ^= frame_number |
	         level_frame.printed_decimal ^= frame_decimal);
	      lfp = level_frame.next;
	      if lfp = null
	        then go to NO_FRAME;
	    end;
	    source_ptr = addr (level_frame.source_info);
	  end;
	else if probe_info.ct -> token.type = NAME_TYPE then do;
	    source_ptr = null;
	    do while (source_ptr = null);

	      block_name =
		 probe_block_name_ (probe_info_ptr,
		 addr (level_frame.source_info), "0"b);

	      if block_name = current_identifier_name
	        then
		   source_ptr = addr (level_frame.source_info);
	      else if level_frame.next = null
	        then call probe_error_
		        (probe_info_ptr, 0, "No frame for ^a",
		        current_identifier_name);
	      else lfp = level_frame.next;
	    end;
	  end;

	else go to SYNTAX_ERROR;
        end;

      call probe_print_arglist_ (probe_info_ptr, source_ptr);
    end;
  goto MAIN_RETURN;
%page;
handlers_request:
  entry (P_probe_info_ptr);

  dcl probe_print_handlers_	entry (ptr, ptr);
  dcl token_type		bit (18);
  dcl token_name		char (168);

  probe_info_ptr = P_probe_info_ptr;

  if probe_info.execute then do;

      token_type = probe_info.ct -> token.type;
      if token_type = NAME_TYPE
        then token_name = current_identifier_name;

      if probe_info.ct -> token.type >= probe_info.end_token then do;
	source_ptr = probe_info.ptr_to_current_source;
	if source_ptr -> source_info.stack_ptr = null then do;
	    token_type = NAME_TYPE;
	    token_name =
	         source_ptr -> source_info.seg_info_ptr
	         -> seg_info.entry_name;
	    go to FIND_FRAME;
	  end;
        end;

        else do;
FIND_FRAME:
	call probe_trace_a_stack_
	     (probe_info_ptr,
	     probe_info.current_stack_frame -> stack_frame.prev_sp, "0"b);

	lfp = stack_info.level_chain;
	if token_type = CONSTANT_TYPE then do;
				/* args for frame number N */
	    call probe_get_$integer (probe_info_ptr, frame_number, code);
	    if code ^= 0
	      then call probe_error_ (probe_info_ptr, code);
	    if frame_number > stack_info.max_level | frame_number = 0
	      then
		 call probe_error_ (probe_info_ptr, 0,
		      "No frame number ^d", frame_number);

	    do while (level_frame.printed_number ^= frame_number
	         | level_frame.printed_decimal ^= 0);
	      lfp = level_frame.next;
	    end;
	    source_ptr = addr (level_frame.source_info);
	  end;
	else if token_type = NAME_TYPE then do;
	    source_ptr = null;
	    do while (source_ptr = null);

	      block_name =
		 probe_block_name_ (probe_info_ptr,
		 addr (level_frame.source_info), "0"b);

	      if block_name = token_name
	        then
		   source_ptr = addr (level_frame.source_info);
	      else if level_frame.next = null
	        then call probe_error_
		        (probe_info_ptr, 0, "No frame for ^a",
		        current_identifier_name);
	      else lfp = level_frame.next;
	    end;
	  end;

	else go to SYNTAX_ERROR;
        end;

      call probe_print_handlers_ (probe_info_ptr, source_ptr);
    end;
  goto MAIN_RETURN;
%page;
execute_request:
  entry (P_probe_info_ptr);

  /* *	This is used to execute Multics commands from within probe, primarily
   *	within probe breakpoints. Its syntax is considerably more restrictive
   *	than necessary, and this will be fixed someday soon */

  dcl command_line_lth	fixed bin (21);
  dcl cu_$cp		entry (pointer, fixed bin (21), fixed bin (35));

  dcl command_line_ptr	pointer;


  probe_info_ptr = P_probe_info_ptr;

  call require_argument ();

  if probe_info.ct -> token.type ^= CONSTANT_TYPE
    then
         call probe_error_ (probe_info_ptr, probe_et_$e_syntax_err);

  if probe_info.ct -> constant.data_type ^= char_dtype * 2
    then
         call probe_error_ (probe_info_ptr, probe_et_$e_syntax_err);

  command_line_ptr = probe_info.ct -> constant.data_ptr;
  command_line_lth = probe_info.ct -> constant.scale_and_precision;

  call bump_ct ();			/* get the next token */
  call reject_argument ();		/* only one string at a time */

  if probe_info.execute
    then /* give it to Multics */
         call cu_$cp (command_line_ptr, command_line_lth, (0));

  goto MAIN_RETURN;			/* end of code for execute request */

%page;

source_request:
  entry (P_probe_info_ptr);

  /* *	The source request prints source lines from the program, and can
   *	also be used to specify a pathname to look for the source. */

  dcl number_to_print	fixed bin;
  dcl source_dname		char (168);
  dcl source_ename		char (32);
  dcl source_seg_ptr	pointer;
  dcl expand_pathname_	entry (char (*), char (*), char (*),
			fixed bin (35));
  dcl hcs_$initiate		entry (char (*), char (*), char (*),
			fixed bin (1), fixed bin (2), pointer,
			fixed bin (35));


  probe_info_ptr = P_probe_info_ptr;

  if probe_info.ct -> token.type ^= NAME_TYPE then do;
      if probe_info.ct -> token.type >= probe_info.end_token
        then /* nothing specified, print one line */
	   number_to_print = 1;

      else if probe_info.ct -> token.type = CONSTANT_TYPE then do;
				/* print N lines */
	call probe_get_$integer (probe_info_ptr, number_to_print, code);
	if code ^= 0
	  then goto SOME_ERROR;
	call reject_argument ();	/* can have at most one number */
	if number_to_print < 0
	  then /* and can only print a positive number */
	       call probe_error_ (probe_info_ptr, 0,
		  "Number of source lines to print must be positive.");
        end;

      else goto SYNTAX_ERROR;		/* wrong kind of token here */

      if probe_info.execute then do;	/* do it, if we're supposed to */
	call probe_source_segment_$list_statement
	     (probe_info_ptr, addr (current_source), number_to_print, code);
	if code ^= 0
	  then goto SOME_ERROR;
        end;
    end;

    else do;			/* otherwise, hope it's "source path" */
      if current_identifier_name ^= "path"
        then goto SYNTAX_ERROR;
      call bump_ct ();
      call require_argument ();

      call probe_get_$pathname (probe_info_ptr, pathname, code);
      if code ^= 0
        then goto SOME_ERROR;

      call reject_argument ();	/* can't have anything following the pathname */

      call expand_pathname_ ((pathname), source_dname, source_ename, code);
      if code ^= 0
        then call probe_error_ (probe_info_ptr, code, "^a", pathname);

      call hcs_$initiate (source_dname, source_ename, "", 0, 0,
	 source_seg_ptr, code);
      if source_seg_ptr = null ()
        then
	   call probe_error_ (probe_info_ptr, code, "^a>^a", source_dname,
	        source_ename);

      if probe_info.execute
        then /* set the pointer in seg_info so we'll remember later */
	   current_source.seg_info_ptr -> seg_info.file_pointers (1) =
	        source_seg_ptr;

    end;				/* of code for "source path" */
  goto MAIN_RETURN;			/* end of code for source request */

%page;
object_request:
  entry (P_probe_info_ptr);


  /* Say "object {N}" to print N or 1 stmt's worth of object code. */

  dcl seg_info_ptr		ptr;
  dcl start_offset		fixed bin (21);
  dcl (i, len)		fixed bin;

  probe_info_ptr = P_probe_info_ptr;

  if probe_info.ct -> token.type >= probe_info.end_token
    then number_to_print = 1;
    else do;
      call probe_get_$integer (probe_info_ptr, number_to_print, code);
      if code ^= 0
        then go to SOME_ERROR;
    end;

  seg_info_ptr = current_source.seg_info_ptr;
  if seg_info_ptr = null then do;
      code = probe_et_$bad_line;
      go to SOME_ERROR;
    end;
  stmt_map_ptr = seg_info_ptr -> seg_info.statement_map_ptr;
  if stmt_map_ptr = null then do;
      code = probe_et_$no_statement_map;
      go to SOME_ERROR;
    end;

  map_size = seg_info_ptr -> seg_info.map_size;

  new_source_info = current_source;

  do i = current_source.stmnt_map_entry_index to min (map_size,
       current_source.stmnt_map_entry_index + number_to_print - 1);

    call print_object (i);
  end;
  goto MAIN_RETURN;


print_object:
  proc (P_i);

  /* Prints source line followed by the instructions for it */

  dcl P_i			fixed bin;

  new_source_info.stmnt_map_entry_index = P_i;

  call probe_source_segment_$list_statement (probe_info_ptr,
       addr (new_source_info), 1, code);

  /* Any problems? */
  if code ^= 0 then do;
				/* If we couldn't find the source print a warning, but print the object anyway */
      if code = error_table_$noentry then do;
	call probe_error_$warning (probe_info_ptr, code);
	code = 0;
        end;
        else go to SOME_ERROR;
    end;

  start_offset = fixed (map_array (P_i).location);
  if P_i >= map_size
    then len = 1;
    else len = fixed (map_array (P_i + 1).location) - start_offset;

  call probe_break_mgr_$print_instructions (probe_info_ptr,
       addr (new_source_info),
       pointer (current_source.instruction_ptr, map_array (P_i).location),
       len);

  end print_object;
%page;
position_request:
  entry (P_probe_info_ptr);


  /* Both "position" and "use"

   we accept:

   +N
   -N
   level N
   STRING
   < STRING
   LINE
   PROCEDURE

*/
  dcl print_it		bit (1) aligned;
				/* are we "ps" or "use" */
  dcl (use_level, use_decimal)
			fixed bin;
  dcl line_invocation	fixed bin;
  dcl number_to_position	fixed bin;
  dcl position_lines	bit (1) aligned;
  dcl position_backwards	bit (1) aligned;
  dcl rel_level_sw		bit (1) aligned;
  dcl hp			ptr;
  dcl (loc, next_token_type)	bit (18);

  dcl probe_source_segment_$position_source
			entry (ptr, ptr, fixed bin, fixed bin (35));
  dcl probe_source_segment_$position_source_lines
			entry (ptr, ptr, fixed bin, fixed bin (35));
  dcl probe_source_segment_$find_source
			entry (ptr, ptr, char (*), fixed bin (35));
  dcl probe_stack_trace_$current_level
			entry (ptr) returns (fixed bin);
  dcl probe_stack_trace_$get_level
			entry (ptr, ptr, fixed bin, fixed bin);

  print_it = "1"b;
  goto ps_use_com;


use_request:
  entry (P_probe_info_ptr);


  print_it = "0"b;
  goto ps_use_com;

ps_use_com:
  probe_info_ptr = P_probe_info_ptr;

  code = 0;			/* assume we will win */
  position_lines, position_backwards = "0"b;

  if probe_info.ct -> operator.type >= probe_info.end_token then do;
				/* if no args, return to where we began */
      new_source_info = initial_source;
      if new_source_info.instruction_ptr = null
	 & new_source_info.seg_info_ptr ^= null then do;
	stmt_map_ptr =
	     new_source_info.seg_info_ptr -> seg_info.statement_map_ptr;
	if stmt_map_ptr ^= null then do;
	    loc = map_array (new_source_info.stmnt_map_entry_index)
	         .location;
	    hp = new_source_info.seg_info_ptr -> seg_info.symbol_header_ptr;
	    new_source_info.instruction_ptr = pointer (hp, loc);
	  end;
        end;
      go to GOT_LOCATION;
    end;

  next_token_type = probe_info.ct -> token.next -> token.type;

  if probe_info.ct -> operator.type = MINUS
       | probe_info.ct -> operator.type = PLUS then do;
POSITION_REL:
      if probe_info.ct -> operator.type = MINUS
        then
	   position_backwards = "1"b;

      call bump_ct ();
      if probe_info.ct -> token.type ^= CONSTANT_TYPE
        then
	   goto SYNTAX_ERROR;

      call probe_get_$integer (probe_info_ptr, number_to_position, code);
      if code ^= 0
        then goto SOME_ERROR;

      if probe_info.ct -> token.type = NAME_TYPE
        then
	   if current_identifier_name = "line"
	        | current_identifier_name = "lines" then do;
	       position_lines = "1"b;
	       call bump_ct ();
	     end;

      call reject_argument ();

      if position_backwards
        then number_to_position = -number_to_position;
				/* negate it */

      if probe_info.execute then do;
	new_source_info = current_source;
				/* all the same, except for statement # */
	if position_lines
	  then call probe_source_segment_$position_source_lines
		  (probe_info_ptr, addr (new_source_info),
		  number_to_position, code);

	  else call probe_source_segment_$position_source
		  (probe_info_ptr, addr (new_source_info),
		  number_to_position, code);
        end;
    end;


  else if probe_info.ct -> token.type = CONSTANT_TYPE /* a string */
       & probe_info.ct -> constant.data_type = (char_dtype * 2) then do;
      call reject_next_argument ();	/* make sure theres nothing more */

      if probe_info.execute then do;
	new_source_info = current_source;
	call probe_source_segment_$find_source
	     (probe_info_ptr, addr (new_source_info), constant_string, code)
	     ;
        end;

      call bump_ct ();		/* keep syntax happy */
    end;

  else if probe_info.ct -> token.type = LESS_THAN &
       probe_info.ct -> token.next -> constant.data_type = (char_dtype * 2)
    then do;
				/* < STRING search */
      probe_info.ct = probe_info.ct -> token.next;

      call reject_next_argument;

      call probe_error_ (probe_info_ptr, probe_et_$unimplemented_request,
	 "backwards searching for STRING");

      if probe_info.execute
        then do;
	new_source_info = current_source;
				/* start from here */

	/* add code ere someday */

        end;

      call bump_ct ();

    end;				/* < STRING */

  else if probe_info.ct -> token.type = NAME_TYPE &
       (next_token_type = CONSTANT_TYPE | next_token_type = MINUS
       | next_token_type = PLUS) then do;
      if current_identifier_name = "line" | current_identifier_name = "lines"
        then do;
	position_lines = "1"b;

	call bump_ct ();
	if probe_info.ct -> operator.type = MINUS
	     | probe_info.ct -> operator.type = PLUS
	  then
	       go to POSITION_REL;
	  else go to POSITION_LINE;
        end;

      else if current_identifier_name = "level"
	 | current_identifier_name = "lvl" |
	 current_identifier_name = "lv" then do;

	if next_token_type = MINUS | next_token_type = PLUS then do;
	    rel_level_sw = "1"b;
	    position_backwards = (next_token_type = MINUS);

	    call bump_ct ();
	    if probe_info.ct -> token.next -> token.type ^= CONSTANT_TYPE
	      then go to SYNTAX_ERROR;
	  end;
	  else rel_level_sw = "0"b;

	call bump_ct ();
	call reject_next_argument;

	if probe_info.ct -> constant.scale ^= 0 & ^rel_level_sw
	  then
	       call probe_get_$decimal (probe_info_ptr, use_level,
		  use_decimal, code);
	  else do;
	    call probe_get_$integer (probe_info_ptr, use_level, code);
	    use_decimal = 0;
	  end;
	if code ^= 0
	  then goto SOME_ERROR;

	if probe_info.execute then do;

	    if rel_level_sw then do;
	        if position_backwards
		then use_level = -use_level;

	        use_level =
		   probe_stack_trace_$current_level (probe_info_ptr)
		   + use_level;
	      end;

	    call probe_stack_trace_$get_level (probe_info_ptr,
	         addr (new_source_info),
	         use_level, use_decimal);
	  end;
        end;

      else go to SYNTAX_ERROR;
    end;				/* level N */

  else /* LINE or PROCEDURE */
POSITION_LINE:
    call get_location ();
GOT_LOCATION:
  call reject_argument ();

  /* Now the Syntax is known good */

  /* *	If executing, new_source_info is set, so assign it to current_source.
   *	code is 0 unless search failed, so print if appropriate */

  if probe_info.execute then do;	/* print the new one, if desired */
      if code = 0 then do;		/* it worked. code was left set by all paths above */

	probe_info.language_type =
	     new_source_info.seg_info_ptr -> seg_info.language_type;
	current_source = new_source_info;

	/* in old probe this was also controlled by "mode brief" */

	if print_it
	  then call probe_source_segment_$list_statement (probe_info_ptr,
		  addr (current_source), 1, code);
	if code ^= 0
	  then goto SOME_ERROR;
        end;

        else call probe_error_ (probe_info_ptr, code);
				/* lose, otherwise */
    end;
  goto MAIN_RETURN;			/* end of code for position request */


get_location:
  proc;				/* also used by reset/status */

  if resembles_path ()
    then do;
      call probe_get_$object (probe_info_ptr, addr (new_source_info), code);
      data_type_found = ext_procedure_runtime_dtype;
    end;
    else do;
      call probe_get_$line (probe_info_ptr, addr (new_source_info),
	 line_invocation, "1110"b, data_type_found, code);
    end;
  if code ^= 0
    then goto SOME_ERROR;
  return;


resembles_path:
  proc () returns (bit (1) aligned);

  if probe_info.ct -> token.type = LESS_THAN |
       probe_info.ct -> token.type = GREATER_THAN
    then return ("1"b);
  if probe_info.ct -> token.type = NAME_TYPE &
       probe_info.ct -> token.next -> token.type = GREATER_THAN
    then return ("1"b);
  return ("0"b);
  end resembles_path;
  end get_location;
%page;

where_request:
  entry (P_probe_info_ptr);

  /* *	This prints out information about the current values of the pointers */


  dcl 1 want_locs		aligned,
       2 source		bit (1) unal,
       2 control		bit (1) unal,
       2 path		bit (1) unal;
  dcl location_string	char (256);
  dcl dn			char (168);
  dcl (en, proc_name)	char (32);
  dcl dn_len		fixed bin;
  dcl sip			ptr;

  probe_info_ptr = P_probe_info_ptr;

  want_locs = "0"b;

  if probe_info.ct -> token.type >= probe_info.end_token
    then /* if none specified, print them all */
         want_locs.source, want_locs.control = "1"b;

    else
      do while (probe_info.ct -> token.type < probe_info.end_token);
				/* otherwise, look for good keywords */
      if probe_info.ct -> token.type ^= NAME_TYPE
        then goto WHERE_USAGE;

      if current_identifier_name = "source" | current_identifier_name = "sc" |
	 current_identifier_name = "block" | current_identifier_name = "bk"
				/* allow old forms for a while */
        then want_locs.source = "1"b;
      else if current_identifier_name = "control"
	 | current_identifier_name = "ctl" |
	 current_identifier_name = "object"
	 | current_identifier_name = "obj" |
	 current_identifier_name = "oj"
        then want_locs.control = "1"b;
      else if current_identifier_name = "path"
        then want_locs.path = "1"b;
      else goto WHERE_USAGE;

      call bump_ct ();		/* look at the next token */
    end;

  if ^want_locs.source & ^want_locs.control
    then want_locs.source, want_locs.control = "1"b;
				/* default */

  if ^probe_info.execute
    then goto MAIN_RETURN;

  if want_locs.source then do;
      if want_locs.path then do;
	source_ptr = probe_source_segment_$get_file_ptr
	     (probe_info_ptr, probe_info.ptr_to_current_source, 1);
	call hcs_$fs_get_path_name (source_ptr, dn, dn_len, en, code);
	if code ^= 0 then do;
	    call probe_error_ (probe_info_ptr, code,
	         "Evaluating source pointer.");
	    goto MAIN_RETURN;
	  end;
	location_string = pathname_ (substr (dn, 1, dn_len), en);
        end;
        else call probe_pretty_source_info_ (probe_info_ptr,
	        probe_info.ptr_to_current_source, location_string);
      call ioa_$ioa_switch (probe_info.output_switch, "^a", location_string);
    end;

  if want_locs.control then do;

      call probe_stack_trace_$where_source_info (probe_info_ptr,
	 probe_info.ptr_to_initial_source, level, "");
      call ioa_$rsnnl ("^[(level ^d)^;^s(no active frame)^]",
	 level_string, length (level_string), level >= 0, level);

      if want_locs.path then do;	/* "where object path" */
	sip = current_source.seg_info_ptr;
	location_string =
	     pathname_ (sip -> seg_info.directory_name,
	     sip -> seg_info.entry_name);
	proc_name = sip -> seg_info.segname;
	if proc_name ^= sip -> seg_info.entry_name
	  then /* bound component */
	       location_string =
		  rtrim (sip -> seg_info.segname) || " in "
		  || location_string;
	call ioa_$ioa_switch (probe_info.output_switch, "^a ^a",
	     location_string, level_string);
        end;
      else if initial_source.seg_info_ptr -> seg_info.statement_map_ptr
	 ^= null
        then
	   call ioa_$ioa_switch (probe_info.output_switch,
	        "Control at ^a of ^a ^a",
	        probe_line_number_ (probe_info_ptr, initial_source),
	        probe_block_name_ (probe_info_ptr,
	        probe_info.ptr_to_initial_source, "0"b), level_string);
      else call ioa_$ioa_switch (probe_info.output_switch,
	      "Control at ^a|^o. ^a",
	      probe_block_name_ (probe_info_ptr,
	      probe_info.ptr_to_initial_source, "0"b),
	      binary (rel (initial_source.instruction_ptr), 18, 0),
	      level_string);
    end;

  goto MAIN_RETURN;

WHERE_USAGE:
  call probe_error_ (probe_info_ptr, 0,
       "Only the keywords ""source"", ""control"" or ""object"", and ""path"" are allowed."
       );
  goto MAIN_RETURN;			/* end of code for where request */

%page;

reset_request:
  entry (P_probe_info_ptr);

  reset_req = "1"b;
  goto S_R_COM;


status_request:
  entry (P_probe_info_ptr);

  reset_req = "0"b;
  goto S_R_COM;
  dcl reset_req		bit (1) aligned;
				/* as distinct from source req */
  dcl long_sw		bit (1) aligned;
  dcl case		fixed bin;
  dcl data_type_found	fixed bin;/* LINE: what kind did you find ? */
  dcl mod_type		fixed bin;
  dcl ctl			char (64) varying;


  dcl probe_listen_$check_line
			entry (ptr, ptr, fixed bin (21), fixed bin (35))
			;
  dcl probe_break_mgr_$reset_break_at_line
			entry (ptr, ptr, fixed bin, bit (1) aligned,
			fixed bin (35));
  dcl probe_break_mgr_$reset_breaks_in_seg
			entry (ptr, ptr, bit (1) aligned,
			fixed bin (35));
  dcl probe_break_mgr_$reset_breaks_in_world
			entry (ptr, bit (1) aligned, fixed bin (35));

  dcl probe_break_mgr_$list_breaks_at_line
			entry (ptr, ptr, fixed bin, bit (1) aligned,
			fixed bin (35));
  dcl probe_break_mgr_$list_breaks_in_seg
			entry (ptr, ptr, bit (1) aligned,
			fixed bin (35));
  dcl probe_break_mgr_$list_breaks_in_world
			entry (ptr, bit (1) aligned, fixed bin (35));
  dcl probe_break_mgr_$list_broken_segs
			entry (ptr, fixed bin (35));

  dcl (
      DEFAULT_CASE		init (1), /* nothing */
      WORLD_CASE		init (2), /* -all */
      LINE_CASE		init (3), /* LINE */
      SEG_CASE		init (4), /* OBJECT */
      STAR_CASE		init (5), /* * */
      STRING_CASE		init (6)	/* STRING */
      )			fixed bin internal static options (constant);


  dcl probe_get_$control_arg	entry (ptr, char (64) varying, fixed bin (35));


S_R_COM:

  probe_info_ptr = P_probe_info_ptr;

  /* Now to parse */

  call probe_get_$control_arg (probe_info_ptr, ctl, code);
  if code ^= 0
    then goto SOME_ERROR;

  if ctl = "brief" | ctl = "bf" then do;
      case = DEFAULT_CASE;
      long_sw = "0"b;
    end;
  else if ctl = "long" | ctl = "lg" then do;
      case = DEFAULT_CASE;
      long_sw = "1"b;
    end;
  else do;			/* ctl may be null or supplied - we shall see */
    if ctl = "all" | ctl = "a"
      then case = WORLD_CASE;
    else if ctl ^= ""		/* some other ctl arg, yechh ! */
      then call probe_error_ (probe_info_ptr, probe_et_$bad_ctl_arg,
	      "-" || ctl);
    else if probe_info.ct -> token.type >= probe_info.end_token
      then case = DEFAULT_CASE;
    else if probe_info.ct -> token.type = TIMES
         | probe_info.ct -> token.type = C_INDIRECTION then do;
        call bump_ct ();		/* past * */
        case = STAR_CASE;
      end;
    else if probe_info.ct -> token.type = CONSTANT_TYPE &
         probe_info.ct -> constant.data_type = (char_dtype * 2) then do;
        case = STRING_CASE;
        mod_type = BREAK_AT;
        search_string = constant_string;

        call bump_ct ();
      end;

    else do;			/* it must be LINE or OBJECT */

      /* if a LINE MOD is there, it must be a line */

      mod_type = -1;		/* no such type */
      if probe_info.ct -> token.type = NAME_TYPE
        then if current_identifier_name = "after" |
	        current_identifier_name = "af" |
	        current_identifier_name = "a"
	     then do;
	       call bump_ct ();
	       mod_type = BREAK_AFTER;
	     end;
	   else if current_identifier_name = "before" |
	        current_identifier_name = "be" |
	        current_identifier_name = "b"
	     then do;
	       call bump_ct ();
	       mod_type = BREAK_BEFORE;
	     end;
	   else if current_identifier_name = "at"
	     then do;
	       call bump_ct ();
	       mod_type = BREAK_AT;
	     end;

      call get_location ();		/* much LINE and OBJECT */
      if data_type_found = ext_procedure_runtime_dtype |
	 data_type_found = ext_entry_runtime_dtype
        then do;
	case = SEG_CASE;
	if mod_type >= 0
	  then
	       call probe_error_ (probe_info_ptr, 0,
		  """^a"" not allowed before external procedure.",
		  PLACE (mod_type));
        end;
        else do;
	case = LINE_CASE;
	if mod_type < 0
	  then mod_type = BREAK_AT;
        end;
    end;				/* parsing LINE or PROC */


    call probe_get_$control_arg (probe_info_ptr, ctl, code);
  end;
  if code ^= 0
    then goto SOME_ERROR;

  call reject_argument ();

  /* all parsing done - but must examine ctl */

  if reset_req
    then long_sw = "1"b;		/* default */
  else if case = LINE_CASE
    then long_sw = "1"b;
  else long_sw = "0"b;

  if ctl = "long" | ctl = "lg"
    then long_sw = "1"b;
  else if ctl = "brief" | ctl = "bf"
    then long_sw = "0"b;
  else if ctl ^= ""
    then call probe_error_ (probe_info_ptr, probe_et_$bad_ctl_arg, "-" || ctl)
	    ;

  /* SYNTAX IS NOW KNOWN TO BE GOOD */

  if probe_info.execute
    then if reset_req
	 then do;
	   if case = DEFAULT_CASE
	     then if probe_info.break_slot_ptr = null ()
		  then call probe_error_ (probe_info_ptr,
			  probe_et_$none_active);
		  else do;
		    new_source_info = initial_source;
		    call probe_break_mgr_$reset_break_at_line (
		         probe_info_ptr, addr (initial_source),
		         probe_info.break_slot_ptr -> break_slot.type,
		         long_sw, code);
		  end;
	   else if case = WORLD_CASE | case = STAR_CASE
	     then call probe_break_mgr_$reset_breaks_in_world
		     (probe_info_ptr, long_sw, code);
	   else if case = STRING_CASE then do;
				/* r STRING: reset all matches */
	       new_source_info = current_source;

	       call probe_source_segment_$find_source
		  (probe_info_ptr, addr (new_source_info),
		  (search_string), code);
	       if code ^= 0
	         then goto MAIN_RETURN;
	       first_match = new_source_info.stmnt_map_entry_index;
	       do while ("1"b);
	         call probe_break_mgr_$reset_break_at_line
		    (probe_info_ptr, addr (new_source_info), mod_type,
		    long_sw, code);

	         call probe_source_segment_$find_source
		    (probe_info_ptr, addr (new_source_info),
		    (search_string), code);
	         if code ^= 0
		    | new_source_info.stmnt_map_entry_index = first_match
		 then goto MAIN_RETURN;
	       end;
	     end;
	   else if case = LINE_CASE
	     then call probe_break_mgr_$reset_break_at_line
		     (probe_info_ptr, addr (new_source_info), mod_type,
		     long_sw, code);
	   else if case = SEG_CASE
	     then call probe_break_mgr_$reset_breaks_in_seg (probe_info_ptr,
		     addr (new_source_info), long_sw, code);
	 end;			/* reset cases */
	 else do;
	   if case = DEFAULT_CASE
	     then do;
	       call probe_break_mgr_$list_breaks_in_seg (probe_info_ptr,
		  addr (current_source),
		  long_sw, code);
	       new_source_info = current_source;
	     end;
	   else if case = WORLD_CASE
	     then call probe_break_mgr_$list_breaks_in_world (
		     probe_info_ptr, long_sw, code);
	   else if case = LINE_CASE
	     then call probe_break_mgr_$list_breaks_at_line (probe_info_ptr,
		     addr (new_source_info), mod_type,
		     long_sw, code);
	   else if case = SEG_CASE
	     then call probe_break_mgr_$list_breaks_in_seg (probe_info_ptr,
		     addr (new_source_info),
		     long_sw, code);
	   else if case = STAR_CASE
	     then call probe_break_mgr_$list_broken_segs (probe_info_ptr,
		     code);
	 end;			/* status  cases */

  dcl (
      probe_et_$breakless,
      probe_et_$no_breaks
      )			fixed bin (35) external static;

  if code = probe_et_$breakless
    then call probe_error_ (probe_info_ptr, probe_et_$breakless,
	    PLACE (mod_type),
	    probe_line_number_ (probe_info_ptr, new_source_info));
  else if code = probe_et_$no_breaks then do;
      pathname =
	 rtrim (new_source_info.seg_info_ptr -> seg_info.directory_name);
      pathname = pathname || ">";
				/* it turns out that .entry_name is really the segname */
      pathname =
	 pathname
	 || rtrim (new_source_info.seg_info_ptr -> seg_info.entry_name);
      pathname = pathname || "$";
      pathname =
	 pathname
	 || rtrim (new_source_info.seg_info_ptr -> seg_info.segname);
				/* and .segname is really the entry point name */
      call probe_error_ (probe_info_ptr, probe_et_$no_breaks, pathname);
    end;

  if code ^= 0
    then goto SOME_ERROR;
  goto MAIN_RETURN;

%page;
after_request:
  entry (P_probe_info_ptr);

  /* *	This request sets a breakpoint after the specified line */

  dcl break_location	fixed bin;
  dcl requests_ptr		pointer;
  dcl requests_lth		fixed bin (21);
  dcl search_sw		bit (1) aligned;
  dcl search_string		char (256) varying;
  dcl first_match		fixed bin;
  dcl done		bit (1) aligned;
  dcl DEFAULT_BREAK_REQUEST	char (4) aligned internal static
			options (constant) init ("halt");
  dcl probe_break_mgr_$set_break
			entry (ptr, ptr, fixed bin, pointer,
			fixed bin (21), fixed bin (35));

  break_location = BREAK_AFTER;
  goto AFTER_BEFORE_COMMON;

before_request:
  entry (P_probe_info_ptr);

  /* *     This request sets a breakpoint before the specified line */

  break_location = BREAK_BEFORE;
  goto AFTER_BEFORE_COMMON;


AFTER_BEFORE_COMMON:
  probe_info_ptr = P_probe_info_ptr;


  /* We can accept the following:
   b	default loc and default break list
   b N	explicit loc default break
   b : R	default loc, explicit break list
   b N:R	explicit both

*/

  search_sw = "0"b;

  if probe_info.ct -> token.type >= probe_info.end_token |
       probe_info.ct -> token.type = COLON
    then new_source_info = current_source;

  else if probe_info.ct -> token.type = CONSTANT_TYPE &
       probe_info.ct -> constant.data_type = (char_dtype * 2) then do;
      search_sw = "1"b;
      search_string = constant_string;

      call bump_ct ();
    end;

  else do;
    call probe_get_$line (probe_info_ptr, addr (new_source_info), (0),
         "0000"b, (0), code);
    if code ^= 0
      then goto SOME_ERROR;
  end;

  /* now have loc, default or explicit */


  if probe_info.ct -> token.type >= end_token /* default commands */
    then do;
      requests_ptr = addr (DEFAULT_BREAK_REQUEST);
      requests_lth = length (DEFAULT_BREAK_REQUEST);

    end;
  else if probe_info.ct -> operator.type = COLON then do;
      call bump_ct ();		/* skip over the colon */
      call require_argument ();

      call probe_get_$request_list (probe_info_ptr, requests_ptr,
	 requests_lth, code);
      if code ^= 0
        then goto SOME_ERROR;

      call reject_argument ();	/* nothing may follow the request line */

      probe_info.setting_break = "1"b;

      call probe_listen_$check_line (probe_info_ptr, requests_ptr,
	 requests_lth, code);
      if code ^= 0
        then goto SOME_ERROR;		/* check the syntax */

      probe_info.setting_break = "0"b;
    end;
  else call probe_error_ (probe_info_ptr, 0,
				/* probably commands */
	  "The break location and the requests to be executed must be separated by a colon."
	  );


  if probe_info.execute then do;	/* set the break */
      if search_sw then do;		/* b STRING */
	new_source_info = current_source;

	call probe_source_segment_$find_source
	     (probe_info_ptr, addr (new_source_info), (search_string), code)
	     ;
	if code ^= 0
	  then call probe_error_ (probe_info_ptr, code);
	  else do;
	    first_match = new_source_info.stmnt_map_entry_index;

	    done = "0"b;
	    do while (^done);

	      call set_break;

	      call probe_source_segment_$find_source (probe_info_ptr,
		 addr (new_source_info),
		 (search_string), code);
	      if code ^= 0
		 | new_source_info.stmnt_map_entry_index = first_match
	        then
		   done = "1"b;
	    end;
	    code = 0;
	  end;
        end;

        else call set_break;
    end;

  goto MAIN_RETURN;			/* end of code for after and before requests */



set_break:
  proc;

  call probe_break_mgr_$set_break (probe_info_ptr, addr (new_source_info),
       break_location, requests_ptr, requests_lth, code);
  if code ^= 0
    then goto SOME_ERROR;
  if ^probe_static_info.brief_sw
    then
         call ioa_$ioa_switch (probe_info.output_switch, "Break set ^a ^a",
	    PLACE (break_location),
	    probe_line_number_ (probe_info_ptr, new_source_info));

  end set_break;
%page;
enable_request:
  entry (P_probe_info_ptr);

  /* Undocumented request used when debugging probe itself. Resets the value
   (probe_static_info.last_break_segno, compared against .probe_segno)
   that tells probe it is already stopped at a break inside probe and therefore
   should ignore any recursively hit breaks. Despite "continue", cleanup, and
   other precautions to reset this value when leaving a break in probe, it is
   still sometimes inexplicably left set. */

  P_probe_info_ptr -> probe_info.static_info_ptr
       -> probe_static_info.last_break_segno = "0"b;

  goto MAIN_RETURN;
%page;

  /*	INTERNAL PROCEDURES 	*/

reject_argument:
  proc ();

  /* *	This procedure simply calls probe_error_ if the current token is not the
   *	end of the token chain -- it is called by requests which have processed all
   *	expected arguments and want to barf if there are any extras */

  if probe_info.ct -> token.type < probe_info.end_token
    then
         call probe_error_ (probe_info_ptr, probe_et_$too_many_args);

  return;
  end;				/* reject_argument internal procedure */


reject_next_argument:
  proc ();

  /* *	This is just like reject_argument, except that it tests whether there are any
   *	argument tokens AFTER the current one, rather than starting with the current one */

  if probe_info.ct -> token.next = null ()
    then
         call probe_error_ (probe_info_ptr, probe_et_$too_many_args);

  if probe_info.ct -> token.next -> token.type < probe_info.end_token
    then
         call probe_error_ (probe_info_ptr, probe_et_$too_many_args);

  return;
  end;				/* reject_next_argument internal procedure */


require_argument:
  proc ();

  /* *	This is just like reject_argument, except that it barfs if there are not
   *	any more arguments */

  if probe_info.ct -> token.type >= probe_info.end_token
    then
         call probe_error_ (probe_info_ptr, probe_et_$noarg);

  return;
  end;				/* require_argument internal procedure */


bump_ct:
  proc ();

  /* *	This procedure makes probe_info.ct point at the next token. */


  probe_info.ct = probe_info.ct -> token.next;

  if probe_info.ct = null ()
    then goto SYNTAX_ERROR;		/* some protection against mistakes */

  return;
  end;				/* bump_ct internal procedure */
%page;
rest_of_request:
  proc (P_str);

  /* Returns the rest of the request as a character string */

  dcl P_str		char (*) varying;
  dcl input_buffer		char (probe_info.buffer_lth)
			based (probe_info.buffer_ptr);
  dcl (start_pos, end_pos)	fixed bin (21);

  start_pos = probe_info.ct -> token.location;

  do while (probe_info.ct -> token.type < probe_info.end_token);

    call bump_ct ();
  end;

  end_pos = probe_info.ct -> token.location;

  P_str =
       rtrim (substr (input_buffer, start_pos, end_pos - start_pos + 1), NL);

  return;

  end rest_of_request;




set_iocb:
  proc (P_iocb_ptr, P_private_sw, P_new_iocb_ptr, P_new_private_sw);

  /* Destroys the old IOCB if it was private (created by ids or ods) and
   sets the static IOCB to the new value */

  dcl (P_iocb_ptr, P_new_iocb_ptr)
			ptr;
  dcl (P_private_sw, P_new_private_sw)
			bit (1) aligned;


  if P_private_sw & /* previous IOCB was set by ids or ods */
       P_iocb_ptr ^= iox_$user_input & P_iocb_ptr ^= iox_$user_output &
       P_iocb_ptr ^= iox_$error_output & P_iocb_ptr ^= iox_$user_io then do;
      call iox_$close (P_iocb_ptr, (0));
      call iox_$detach_iocb (P_iocb_ptr, (0));
      call iox_$destroy_iocb (P_iocb_ptr, (0));
    end;

  P_iocb_ptr = P_new_iocb_ptr;
  P_private_sw = P_new_private_sw;

  end set_iocb;

%page;
%include probe_info;
%page;
%include probe_static_info;
%page;
%include probe_tokens;
%page;
%include probe_references;
%page;
%include probe_level_frame;
%page;
%include probe_source_info;
%page;
%include stack_frame;
%page;
%include probe_operators;
%page;
%include std_descriptor_types;
%page;
%include probe_seg_info;
%page;
%include statement_map;
%page;
%include probe_break_slot;
%page;
%include probe_lang_types;
%page;
%include probe_info_constants;

  end probe_requests_;		/* external procedure */
