/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^		DO/EXECUTE_STRING/SUBSTITUTE_ARGUMENTS

      Command/requests to expand specified string by substituting
      arguments, and optionally executing the expansion.

      Created:  30 October 1973 by BLW.
      Modified: 31 December 1974 by Steve Herbst to remove string parameter.
      Modified: 16 December 1975 by Steve Herbst to add &f and &n.
      Modified: 3 March 1976 by Steve Herbst to add &qf and &rf.
      Modified: 3 August 1976 by Steve Herbst to accept any number of
	      mode-changing control arguments.
      Modified: 15 October 1976 by Steve Herbst to fix bug with &f.
      Modified: 16 February 1982 by G. Palter to add ssu_do_request_ and
	      convert to use a standalone subsystem invocation.
      Modified: 28 April 1982 by G. Dixon to allow AF first arg to begin with
	      minus.
      Modified: 8 September 1982 by G. Palter to propagate subsystem/request
	      line aborts. */



/****^  HISTORY COMMENTS:
  1) change(86-08-11,JSLove), approve(86-08-12,MCR7520),
     audit(86-08-14,FCSmith), install(86-10-01,MR12.0-1170):
     Changed to permit control arguments and the control string in the same
     invocation. Added -control_string (-cs) option to permit control string to
     begin with a hyphen.  Added -inhibit_error and -no_inhibit_error as
     synonyms of -absentee and -interactive, respectively. Added -abort_line
     (-abl) mode for subsystem execution.  Improved expansion error
     diagnostics. Changed handling of &r1&r2 to eliminate spurious quote. Added
     &control_string construct and handling of "zeroth" argument.
  2) change(86-08-11,JSLove), approve(86-08-12,MCR7519),
     audit(86-08-14,FCSmith), install(86-10-01,MR12.0-1170):
     Added execute_string and substitute_arguments entries. At this time,
     substantial changes were required to permit the expansion of the
     execute_string AF's -error_value.  Other changes were made for clarity,
     coding standards, performance, robustness and minimizing the stack frame
     size.   The complete set of changes amount to a substantial rewrite,
     including: Removed standalone subsystem invocation.  Changed to allocate
     expanded buffer rather than growing stack frame.  Changed to use PL/I "on"
     statement to set handlers rather than the condition_ subroutine.
  3) change(86-10-09,JSLove), approve(86-10-13,MCR7519),
     audit(86-10-13,Parisek), install(86-10-15,MR12.0-1186):
     Post-installation Bug Fix: changed error message associated with request
     line aborts to not report ssu_et_$request_line_aborted in brief mode.
                                                   END HISTORY COMMENTS */



/* format: style3,ifthenstmt,indcomtxt,indproc,idind30 */

do:
     procedure () options (variable);

declare	P_info_ptr		ptr parameter,	/* subsystem request -> subsystem's internal data */
	P_sci_ptr			ptr parameter;	/* subsystem request -> SCI of subsystem */

declare	(addcharno, addr, addwordno, binary, copy, divide, hbound, index, lbound, length, ltrim, maxlength, min, mod,
	null, rtrim, substr, verify)	builtin;

declare	(active_function_error, any_other, area, cleanup)
				condition;

declare	abort_line		bit (1) aligned,
	allocated_buffer_max_len	fixed bin (21),
	allocated_buffer_ptr	ptr,
	arg_count			fixed bin (17),
	arg_list_ptr		ptr,
	arg_offset		fixed bin (17),
	entrypoint		fixed bin (2),
	error_value_len		fixed bin (21),
	error_value_ptr		ptr,
	execute			bit (1) aligned,
	expansion_buffer		char (256) varying,
	expansion_max_len		fixed bin (21),
	expansion_ptr		ptr,
	inhibit_error		bit (1) aligned,
	rescan_type		fixed bin (17),
	return_value_max_len	fixed bin (21),
	return_value_ptr		ptr,
	sci_ptr			ptr,
	status			fixed bin (35),
	trace			bit (1) aligned,
	unique			char (15) aligned;

declare	allocated_buffer		char (allocated_buffer_max_len) varying based (allocated_buffer_ptr),
	command			char (length (expansion)) based (addwordno (addr (expansion), 1)),
	expansion			char (expansion_max_len) varying based (expansion_ptr),
	return_value		char (return_value_max_len) varying based (return_value_ptr),
	system_area		area based (get_system_free_area_ ());

declare	abort_line_mode		(2) bit (1) aligned static initial ((2) ("1"b)),
	execute_mode		(2) bit (1) aligned static initial ((2) ("1"b)),
	inhibit_error_mode		(2) bit (1) aligned static initial ((2) ("0"b)),
	trace_mode		(3) bit (1) aligned static initial ((3) ("0"b));

declare	AMPERSAND			char (1) static options (constant) initial ("&"),
	BLANK			char (1) static options (constant) initial (" "),
	QUOTE			char (1) static options (constant) initial (""""),
	WHITE			char (5) static options (constant) initial ("
	 ");					/* FF VT NL HT SPACE				*/

declare	(
	DO_ENTRY			initial (1),
	EXECUTE_ENTRY		initial (2),
	SUBSTITUTE_ENTRY		initial (3)
	)			fixed bin (2) static options (constant);

declare	(
	ILLEGAL_CHARACTER		initial (1),
	ILLEGAL_END_CONTROL_STRING	initial (2),
	ILLEGAL_END_ERROR_VALUE	initial (3),
	ILLEGAL_INTEGER		initial (4),
	ILLEGAL_KEYWORD		initial (5),
	ILLEGAL_UNCLOSED		initial (6)
	)			fixed bin (3) static options (constant);

declare	(
	NO_QUOTE_MODIFIER		initial (1),
	PROTECT_QUOTES_MODIFIER	initial (2),
	REQUOTE_MODIFIER		initial (3)
	)			fixed bin (2) static options (constant);

declare	MY_NAME			(3) char (20) static options (constant)
				initial ("do", "execute_string", "substitute_arguments"),
	MY_SHORT_NAME		(3) char (4) varying static options (constant) initial ("do", "exs", "sbag");

declare	(
	PARSER_EXPLICIT_CONTROL_STRING
				initial (1),
	PARSER_FOUND_CONTROL_STRING	initial (2),
	PARSER_WANTS_CONTROL_STRING	initial (3),
	PARSER_WANTS_ERROR_VALUE	initial (4)
	)			fixed bin (3) static options (constant);

declare	REASONS			(6) char (85) varying static options (constant)
				initial ("An invalid character terminates substitution construct ^a.",
				"Substitution construct ^a is incomplete at the end of the control string.",
				"Substitution construct ^a is incomplete at the end of the error value.",
				"The parenthesized part of substitution construct ^a must be an unsigned integer.",
				"^a is not a valid substitution construct.",
				"There is no "")"" terminating substitution construct ^a.");

declare	SPECIAL_CONDITIONS		(5) char (24) varying static options (constant)
				initial ("alrm", "cput", "quit", "program_interrupt", "record_quota_overflow");

declare	(
	COMMAND_USAGE		char (39) initial ("{-control_args} {control_string {args}}"),
	EXS_AF_USAGE		char (37) initial ("{-control_args} control_string {args}"),
	SBAG_AF_USAGE		char (21) initial ("control_string {args}") char (21)
	)			static options (constant);

declare	NO_FROM_WARNING		char (95) static options (constant)
				initial ("""&^[q^;r^]f&n"" must be used instead of argument designator ^a.^[
	Type ""start"" to continue.^]");

declare	TRUNCATION_WARNING		char (127) static options (constant) initial ("
	Only the first ^d characters of the expanded ^[error value^;control string^]
	can be returned.^[  Type ""start"" to continue.^]");

declare	(
	error_table_$badopt,
	error_table_$command_line_overflow,
	error_table_$inconsistent,
	error_table_$noarg,
	error_table_$not_act_fnc,
	ssu_et_$null_request_line,
	ssu_et_$request_line_aborted,
	ssu_et_$subsystem_aborted
	)			fixed bin (35) external;

declare	iox_$error_output		ptr external;

declare	active_fnc_err_		entry () options (variable),
	active_fnc_err_$suppress_name entry () options (variable),
	com_err_			entry () options (variable),
	com_err_$suppress_name	entry () options (variable),
	condition_interpreter_	entry (ptr, ptr, fixed bin (17), fixed bin (17), ptr, char (*), ptr, ptr),
	continue_to_signal_		entry (fixed bin (35)),
	cu_$af_return_arg_rel	entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
	cu_$arg_list_ptr		entry () returns (ptr),
	cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
	cu_$cp			entry (ptr, fixed bin (21), fixed bin (35)),
	cu_$evaluate_active_string	entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
	find_condition_info_	entry (ptr, ptr, fixed bin (35)),
	get_system_free_area_	entry () returns (ptr),
	ioa_			entry () options (variable),
	ioa_$general_rs		entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
				bit (1) aligned),
	ioa_$ioa_switch		entry () options (variable),
	requote_string_		entry (char (*)) returns (char (*)),
	ssu_$abort_line		entry () options (variable),
	ssu_$abort_subsystem	entry () options (variable),
	ssu_$arg_ptr		entry (ptr, fixed bin (17), ptr, fixed bin (21)),
	ssu_$evaluate_active_string	entry (ptr, ptr, char (*), fixed bin (17), char (*) var, fixed bin (35)),
	ssu_$execute_line		entry (ptr, ptr, fixed bin (21), fixed bin (35)),
	ssu_$get_subsystem_and_request_name
				entry (ptr) returns (char (72) varying),
	ssu_$get_request_name	entry (ptr) returns (char (32)),
	ssu_$print_message		entry () options (variable),
	ssu_$return_arg		entry (ptr, fixed bin (17), bit (1) aligned, ptr, fixed bin (21)),
	unique_chars_		entry (bit (*) aligned) returns (char (15) aligned);
%page;
%include condition_info;
%page;
%include cp_active_string_types;
%page;
/* do: entry () options (variable); */

	entrypoint = DO_ENTRY;			/* Execute as command, Substitute as AF */

	go to STANDALONE;

exs:
execute_string:
     entry () options (variable);

	entrypoint = EXECUTE_ENTRY;

	go to STANDALONE;

sbag:
substitute_args:
substitute_arguments:
     entry () options (variable);

	entrypoint = SUBSTITUTE_ENTRY;

STANDALONE:
	sci_ptr = null ();

	go to COMMON;

ssu_do_request_:
     entry (P_sci_ptr, P_info_ptr);

	entrypoint = DO_ENTRY;

	go to SUBSYSTEM;

ssu_execute_string_request_:
     entry (P_sci_ptr, P_info_ptr);

	entrypoint = EXECUTE_ENTRY;

	go to SUBSYSTEM;

ssu_substitute_args_request_:
     entry (P_sci_ptr, P_info_ptr);

	entrypoint = SUBSTITUTE_ENTRY;

SUBSYSTEM:
	sci_ptr = P_sci_ptr;

	go to COMMON;
%page;
/* Actual work starts here */

COMMON:
	allocated_buffer_max_len, error_value_len = 0;
	allocated_buffer_ptr, arg_list_ptr, error_value_ptr = null ();
	expansion_max_len = maxlength (expansion_buffer);
	expansion_ptr = addr (expansion_buffer);
	trace = trace_mode (entrypoint);
	unique = "";

	on cleanup
	     begin;
		if allocated_buffer_ptr ^= null () then free allocated_buffer in (system_area);
	     end;

	if sci_ptr = null ()
	then call check_arguments (cu_$arg_list_ptr ());
	else call ssu_$return_arg (sci_ptr, arg_count, ("0"b), return_value_ptr, return_value_max_len);

	if return_value_ptr = null ()
	then go to COMMAND (entrypoint);
	else go to FUNCTION (entrypoint);

COMMAND (1):					/* "do" */
COMMAND (2):					/* "execute_string" */
	call execute_string_command ();

	if ^execute then go to EGRESS;

	if inhibit_error then on any_other call any_other_handler ();

	if sci_ptr = null ()
	then call cu_$cp (addr (command), length (command), status);
	else call ssu_$execute_line (sci_ptr, addr (command), length (command), status);

	revert any_other;

	if status ^= 0 then call execute_string_command_error ();

	go to EGRESS;

COMMAND (3):					/* "substitute_arguments" */
	call substitute_args_command ();

EGRESS:						/* Common exit and error abort point */
	revert active_function_error, any_other;

	if allocated_buffer_ptr ^= null () then free allocated_buffer in (system_area);

	return;
%page;
FUNCTION (1):					/* "do" */
FUNCTION (3):					/* "substitute_arguments" */
	call substitute_args_function ();

	go to EGRESS;

FUNCTION (2):					/* "execute_string" */
	call execute_string_function ();

	if error_value_ptr ^= null ()
	then do;
		if sci_ptr = null () then on active_function_error call active_function_error_handler ();
		if inhibit_error then on any_other call any_other_handler ();
	     end;

	if sci_ptr = null ()
	then call cu_$evaluate_active_string (null (), command, rescan_type, return_value, status);
	else call ssu_$evaluate_active_string (sci_ptr, null (), command, rescan_type, return_value, status);

	revert active_function_error, any_other;

	if status ^= 0 then call execute_string_function_error ();

	go to EGRESS;

SUBSTITUTE_ERROR_VALUE:
	revert active_function_error, any_other;

	call expand_error_value ();

	go to EGRESS;
%page;
/**** Handler for errors during execution of an active function.  Only
      errors reported by the active function are caught by this handler, as
      opposed to faults which might occur during its execution. */

active_function_error_handler:
     procedure ();

declare	1 CI			aligned like condition_info;

	if trace
	then do;
		CI.version = condition_info_version_1;
		call find_condition_info_ (null (), addr (CI), (0));
		call condition_interpreter_ (null (), null (), 0, 0, CI.mc_ptr, (CI.condition_name), CI.wc_ptr,
		     CI.info_ptr);
	     end;

	go to SUBSTITUTE_ERROR_VALUE;

     end active_function_error_handler;
%page;
/**** Handler for unexpected conditions during execution of the command,
      active function or request line.  Certain conditions are ignored
      (i.e., passed on to other handlers). */

any_other_handler:
     procedure ();

declare	conditionx		fixed bin (17);

declare	1 CI			aligned like condition_info;

	CI.version = condition_info_version_1;
	call find_condition_info_ (null (), addr (CI), (0));

	if length (CI.condition_name) > length ("command_")
	then if substr (CI.condition_name, 1, length ("command_")) = "command_" then go to CONTINUE;

	do conditionx = lbound (SPECIAL_CONDITIONS, 1) to hbound (SPECIAL_CONDITIONS, 1);

	     if CI.condition_name = SPECIAL_CONDITIONS (conditionx) then go to CONTINUE;
	end;

	if return_value_ptr = null () | trace
	then call condition_interpreter_ (null (), null (), 0, 0, CI.mc_ptr, (CI.condition_name), CI.wc_ptr,
		CI.info_ptr);

	if error_value_ptr ^= null ()
	then go to SUBSTITUTE_ERROR_VALUE;
	else go to EGRESS;

CONTINUE:
	call continue_to_signal_ ((0));

	return;

     end any_other_handler;
%page;
/**** Get argument count and active function return value for non-SSU case. */

check_arguments:
     procedure (P_arg_list_ptr) options (non_quick);

declare	P_arg_list_ptr		ptr parameter;

	arg_list_ptr = P_arg_list_ptr;

	call cu_$af_return_arg_rel (arg_count, return_value_ptr, return_value_max_len, status, arg_list_ptr);
	if status = 0 then return;
	if status = error_table_$not_act_fnc then return;

	call com_err_ (status, MY_NAME (entrypoint), "Can't get argument count.");

	go to EGRESS;

     end check_arguments;
%page;
execute_string_command:
     procedure () options (non_quick);

declare	arg_len			fixed bin (21),
	arg_ptr			ptr,
	argx			fixed bin (17),
	control_string_len		fixed bin (21),
	control_string_ptr		ptr,
	parser			fixed bin (3),
	saved_parser		fixed bin (3);

declare	arg			char (arg_len) based (arg_ptr),
	control_string		char (control_string_len) based (control_string_ptr);

	if arg_count = 0 then call usage (COMMAND_USAGE);

	abort_line = abort_line_mode (entrypoint);
	execute = execute_mode (entrypoint);
	inhibit_error = inhibit_error_mode (entrypoint);
	parser = PARSER_WANTS_CONTROL_STRING;

	do argx = 1 to arg_count while (parser ^= PARSER_FOUND_CONTROL_STRING);

	     call get_argument (argx);

	     if parser = PARSER_EXPLICIT_CONTROL_STRING then parser = PARSER_FOUND_CONTROL_STRING;
	     else if substr (arg, 1, min (1, length (arg))) = "-"
	     then if arg = "-abort_line" | arg = "-abl" then abort_line = "1"b;
		else if arg = "-brief" | arg = "-bf" then trace = "0"b;
		else if arg = "-control_string" | arg = "-cs" then parser = PARSER_EXPLICIT_CONTROL_STRING;
		else if arg = "-go" then execute = "1"b;
		else if arg = "-inhibit_error" | arg = "-ihe" | arg = "-absentee" | arg = "-abs"
		then inhibit_error = "1"b;
		else if arg = "-long" | arg = "-lg" then trace = "1"b;
		else if arg = "-no_abort_line" | arg = "-nabl" then abort_line = "0"b;
		else if arg = "-no_go" | arg = "-nogo" then execute = "0"b;
		else if arg = "-no_inhibit_error" | arg = "-nihe" | arg = "-interactive" | arg = "-ia"
		then inhibit_error = "0"b;
		else go to BADOPT;
	     else parser = PARSER_FOUND_CONTROL_STRING;
	end;

	if parser = PARSER_WANTS_CONTROL_STRING
	then do;
		abort_line_mode (entrypoint) = abort_line;
		execute_mode (entrypoint) = execute;
		inhibit_error_mode (entrypoint) = inhibit_error;
		trace_mode (entrypoint) = trace;
		go to EGRESS;
	     end;

	if parser ^= PARSER_FOUND_CONTROL_STRING then go to NOARG;

	arg_offset = argx - 1;

	call expand ();

	return;
%page;
execute_string_function:
     entry ();

	inhibit_error = "0"b;
	parser = PARSER_WANTS_CONTROL_STRING;
	rescan_type = ATOMIC_ACTIVE_STRING;

	do argx = 1 to arg_count while (parser ^= PARSER_FOUND_CONTROL_STRING);

	     call get_argument (argx);

	     if parser = PARSER_EXPLICIT_CONTROL_STRING then parser = PARSER_FOUND_CONTROL_STRING;
	     else if parser = PARSER_WANTS_ERROR_VALUE
	     then do;
		     error_value_len = arg_len;
		     error_value_ptr = arg_ptr;
		     parser = saved_parser;
		end;
	     else if substr (arg, 1, min (1, length (arg))) = "-"
	     then if arg = "-brief" | arg = "-bf" then trace = "0"b;
		else if arg = "-control_string" | arg = "-cs" then parser = PARSER_EXPLICIT_CONTROL_STRING;
		else if arg = "-error_value" | arg = "-erv"
		then do;
			saved_parser = parser;
			parser = PARSER_WANTS_ERROR_VALUE;
		     end;
		else if arg = "-inhibit_error" | arg = "-ihe" then inhibit_error = "1"b;
		else if arg = "-long" | arg = "-lg" then trace = "1"b;
		else if arg = "-no_inhibit_error" | arg = "-nihe" then inhibit_error = "0"b;
		else if arg = "-no_rescan" | arg = "-nrsc" then rescan_type = ATOMIC_ACTIVE_STRING;
		else if arg = "-rescan" | arg = "-rsc" then rescan_type = NORMAL_ACTIVE_STRING;
		else if arg = "-rescan_tokens" | arg = "-rsct" then rescan_type = TOKENS_ONLY_ACTIVE_STRING;
		else go to BADOPT;
	     else parser = PARSER_FOUND_CONTROL_STRING;
	end;

	if parser = PARSER_WANTS_CONTROL_STRING then call usage (EXS_AF_USAGE);

	if parser ^= PARSER_FOUND_CONTROL_STRING then go to NOARG;

	if error_value_ptr = null () & inhibit_error
	then call error (error_table_$inconsistent, "-inhibit_error without -error_value");

	if error_value_ptr ^= null () then inhibit_error = inhibit_error | inhibit_error_mode (entrypoint);

	arg_offset = argx - 1;

	call expand ();

	return;
%page;
execute_string_command_error:
     entry ();

	if sci_ptr = null ()
	then do;
		if status = 100 | ^trace then return;
	     end;
	else if status = ssu_et_$null_request_line then return;
	else if status = ssu_et_$subsystem_aborted then call ssu_$abort_subsystem (sci_ptr);
	else if status = ssu_et_$request_line_aborted & ^trace
	then if abort_line
	     then call ssu_$abort_line (sci_ptr);
	     else return;

	if abort_line then call error (status, "Executing ^a.", requote_string_ (command));

	call warn (status, "Executing ^a.", requote_string_ (command));

	return;

execute_string_function_error:
     entry ();

	if error_value_ptr = null ()
	then do;
		if status = error_table_$command_line_overflow
		then do;
			call warn (status, "Result truncated to ^d characters^[ evaluating ^a^].",
			     return_value_max_len, trace, requote_string_ (command));
			return;
		     end;

		if sci_ptr ^= null ()
		then if status = ssu_et_$subsystem_aborted then call ssu_$abort_subsystem (sci_ptr);
		     else if status = ssu_et_$request_line_aborted & ^trace then call ssu_$abort_line (sci_ptr);

		if trace then call error (status, "Evaluating ^a.", requote_string_ (command));

		return;
	     end;

expand_error_value:
     entry ();

	arg_len = error_value_len;
	arg_ptr = error_value_ptr;

	expansion_max_len = return_value_max_len;
	expansion_ptr = return_value_ptr;

	call expand ();

	return;
%page;
/**** This case is used only by the substitute_arguments command, and
      accepts fewer control arguments than the execute_string cases.  The
      substitute_arguments command and active function have only the
      long/brief mode, since the other modes relate to execution of the
      expansion. */

substitute_args_command:
     entry ();

	if arg_count = 0 then call usage (COMMAND_USAGE);

	parser = PARSER_WANTS_CONTROL_STRING;

	do argx = 1 to arg_count while (parser ^= PARSER_FOUND_CONTROL_STRING);

	     call get_argument (argx);

	     if parser = PARSER_EXPLICIT_CONTROL_STRING then parser = PARSER_FOUND_CONTROL_STRING;
	     else if substr (arg, 1, min (1, length (arg))) = "-"
	     then if arg = "-brief" | arg = "-bf" then trace = "0"b;
		else if arg = "-control_string" | arg = "-cs" then parser = PARSER_EXPLICIT_CONTROL_STRING;
		else if arg = "-long" | arg = "-lg" then trace = "1"b;
		else go to BADOPT;
	     else parser = PARSER_FOUND_CONTROL_STRING;
	end;

	if parser = PARSER_WANTS_CONTROL_STRING
	then do;
		trace_mode (entrypoint) = trace;
		go to EGRESS;
	     end;

	if parser ^= PARSER_FOUND_CONTROL_STRING then go to NOARG;

	arg_offset = argx - 1;

	call expand ();

	call ioa_ ("^a", expansion);

	return;
%page;
/**** This case is very simple.  No control arguments are accepted.  The
      command processor has already allocated a large but non-expandable
      buffer for the expanded string.  We check that we have at least the
      one required argument, and if so, we set up the environment for
      expansion appropriately, do the expansion, and return. */

substitute_args_function:
     entry ();

	if arg_count = 0 then call usage (SBAG_AF_USAGE);

	arg_offset, argx = 1;

	call get_argument (argx);

	expansion_max_len = return_value_max_len;
	expansion_ptr = return_value_ptr;

	call expand ();

	return;

BADOPT:
	call error (error_table_$badopt, "^a", requote_string_ (arg));

NOARG:
	call error (error_table_$noarg, "Following ^a.", requote_string_ (arg));
%page;
error:
	procedure () options (variable);

declare	arg_list_ptr		ptr,
	buffer			char (256),
	buffer_used		fixed bin (21),
	fatal			bit (1) aligned,
	status_ptr		ptr;

declare	buffer_overlay		char (buffer_used) based (addr (buffer)),
	status			fixed bin (35) based (status_ptr);

	     fatal = "1"b;

	     go to COMMON;

warn:
	entry () options (variable);

	     fatal = "0"b;

COMMON:
	     arg_list_ptr = cu_$arg_list_ptr ();
	     call cu_$arg_ptr_rel (1, status_ptr, (0), (0), arg_list_ptr);
	     call ioa_$general_rs (arg_list_ptr, 2, 3, buffer, buffer_used, "0"b, "0"b);

	     if sci_ptr = null ()
	     then do;
		     if return_value_ptr = null ()
		     then call com_err_ (status, MY_NAME (entrypoint), "^a", buffer_overlay);
		     else call active_fnc_err_ (status, MY_NAME (entrypoint), "^a", buffer_overlay);
		     if fatal then go to EGRESS;
		end;
	     else if fatal then call ssu_$abort_line (sci_ptr, status, "^a", buffer_overlay);
	     else call ssu_$print_message (sci_ptr, status, "^a", buffer_overlay);

	     return;

	end error;
%page;
/**** Expand the control string into the expansion.  For simplicity,
      expansion is a varying character string so that PL/I concatenation
      can be used.  The substitution constructs are mostly recognized a
      character at a time by indexing into lists of the characters which
      are presently valid and dispatching on the position of the current
      character in the list.  This is very efficient. */

expand:
	procedure ();

declare	buffer_overflow		bit (1) aligned,
	command_name		char (72) varying,
	construct_pos		fixed bin (21),
	control_string_pos		fixed bin (21),
	nstring			picture "zzzz9",
	from_sw			bit (1) aligned,
	parm_count		fixed bin (17),
	quote_multiplier		fixed bin (21),
	quote_scan_pos		fixed bin (21),
	requote_last		bit (1) aligned,
	requote_sw		fixed bin (2),
	skip			fixed bin (21),
	string_len		fixed bin (21),
	string_ptr		ptr;

declare	construct			char (control_string_pos - construct_pos)
				based (addcharno (addr (control_string), construct_pos)),
	string			char (string_len) based (string_ptr);

	     buffer_overflow, from_sw = "0"b;
	     control_string_len = arg_len;
	     control_string_pos, quote_scan_pos = 0;
	     control_string_ptr = arg_ptr;
	     expansion = "";
	     parm_count = arg_count - arg_offset;
	     quote_multiplier = 1;
	     requote_last = "0"b;
	     requote_sw = NO_QUOTE_MODIFIER;

	     do while (control_string_pos < length (control_string));

		string_len = index (substr (control_string, control_string_pos + 1), AMPERSAND) - 1;
		if string_len < 0 then string_len = length (control_string) - control_string_pos;

		if string_len > 0
		then do;
			string_ptr = addcharno (control_string_ptr, control_string_pos);
			call add_string ();
			control_string_pos = control_string_pos + string_len;
		     end;

		if control_string_pos >= length (control_string) then go to EXPANDED;

		construct_pos = control_string_pos;
		control_string_pos = control_string_pos + length (AMPERSAND) + 1;

		if control_string_pos > length (control_string) then go to END;

		argx = index ("0123456789!(&&cfnqr", substr (control_string, control_string_pos, 1)) - 1;
		go to DISPATCH (argx);

DISPATCH (-1):					/* illegal -- character not in dispatch string */
		call illegal (ILLEGAL_CHARACTER);

DISPATCH (0):					/* A digit has been found.  The number of the */
DISPATCH (1):					/* parameter to be substituted is in argx. */
DISPATCH (2):					/* Here we handle the from_sw processing, and */
DISPATCH (3):					/* the requote_sw processing is handled in */
DISPATCH (4):					/* expand_arg. */
DISPATCH (5):
DISPATCH (6):
DISPATCH (7):
DISPATCH (8):
DISPATCH (9):
		if from_sw
		then do;
			if argx = 0 then argx = 1;	/* &f0 => &f1 */

			from_sw = "0"b;		/* Reset for next construct */

			do argx = argx to parm_count;

			     call expand_arg ();

			     if argx < parm_count
			     then do;
				     string_len = length (BLANK);
				     string_ptr = addr (BLANK);
				     call add_string ();
				end;
			end;
		     end;
		else if argx <= parm_count then call expand_arg ();

		requote_sw = NO_QUOTE_MODIFIER;	/* Reset for next expansion */

		go to SCAN_NEXT;

DISPATCH (10):					/* &! -- Substitute a unique string */
		if unique = "" then unique = unique_chars_ (""b);
		string_len = length (unique);
		string_ptr = addr (unique);
		call add_string ();
		go to SCAN_NEXT;

DISPATCH (11):					/* &( -- Begin a parenthesized parameter index */
		string_len = index (substr (control_string, control_string_pos + 1), ")") - 1;
		if string_len < 0 then call illegal (ILLEGAL_UNCLOSED);
		string_ptr = addcharno (control_string_ptr, control_string_pos);
		control_string_pos = control_string_pos + string_len + length (")");

		string_len = length (rtrim (string, WHITE));
		if string_len = 0 then call illegal (ILLEGAL_INTEGER);

		skip = verify (string, WHITE) - 1;
		string_len = string_len - skip;
		string_ptr = addcharno (string_ptr, skip);
		if verify (string, "0123456789") ^= 0 then call illegal (ILLEGAL_INTEGER);
		if length (ltrim (string, "0")) > 5
		then argx = parm_count + 1;
		else argx = binary (string, 17, 0);

		go to DISPATCH (0);

DISPATCH (12):					/* && -- A literal ampersand */
		string_len = length (AMPERSAND);
		string_ptr = addr (AMPERSAND);
		call add_string ();

		go to SCAN_NEXT;

DISPATCH (13):					/* &f&, &q&, &qf&, &r&, &rf& -- The last parameter */
		if control_string_pos + length ("n") > length (control_string) then go to END;
		control_string_pos = control_string_pos + length ("n");
		if substr (control_string, control_string_pos, length ("n")) ^= "n"
		then call illegal (ILLEGAL_CHARACTER);

		if ^from_sw
		then do;
			call warn (0, NO_FROM_WARNING, requote_sw = PROTECT_QUOTES_MODIFIER,
			     requote_string_ (construct), return_value_ptr ^= null () & sci_ptr = null ());
			from_sw = "1"b;
		     end;

		argx = parm_count;

		go to DISPATCH (0);

DISPATCH (14):					/* &c -- begins &control_string */
		control_string_pos = control_string_pos + length ("ontrol_string");
		if control_string_pos > length (control_string) then call illegal (ILLEGAL_KEYWORD);
		if substr (control_string, construct_pos + 2, length ("control_string")) ^= "control_string"
		then call illegal (ILLEGAL_KEYWORD);

		argx = 0;
		requote_sw = PROTECT_QUOTES_MODIFIER;

		go to DISPATCH (0);

DISPATCH (15):					/* &f, &qf and &rf -- Substitute a range of parameters */
		from_sw = "1"b;

		if control_string_pos >= length (control_string) then go to END;
		control_string_pos = control_string_pos + 1;

		argx = index ("01234567899((&", substr (control_string, control_string_pos, 1)) - 1;
		go to DISPATCH (argx);

DISPATCH (16):					/* &n -- Substitute the number of optional arguments */
		nstring = parm_count;
		string_len = verify (nstring, BLANK) - 1;
		string_ptr = addcharno (addr (nstring), string_len);
		string_len = length (nstring) - string_len;
		call add_string ();

		go to SCAN_NEXT;

DISPATCH (17):					/* &q -- Protect quotes in the parameter */
		requote_sw = PROTECT_QUOTES_MODIFIER;
		go to AFTER_QUOTE_MODIFIER;

DISPATCH (18):					/* &r -- Requote the parameter */
		requote_sw = REQUOTE_MODIFIER;

AFTER_QUOTE_MODIFIER:
		if control_string_pos >= length (control_string) then go to END;
		control_string_pos = control_string_pos + 1;

		argx = index ("01234567899((&&f", substr (control_string, control_string_pos, 1)) - 1;
		go to DISPATCH (argx);

SCAN_NEXT:
	     end;


/**** Argument substitution is completed. */

EXPANDED:
	     if trace
	     then do;
		     if sci_ptr = null ()
		     then command_name = MY_NAME (entrypoint);
		     else command_name = ssu_$get_subsystem_and_request_name (sci_ptr);
		     call ioa_$ioa_switch (iox_$error_output, "^[[^a^[ -error_value^]]^;^a^s^]: (^d) ^a",
			return_value_ptr ^= null (), command_name,
			return_value_ptr = expansion_ptr & entrypoint = EXECUTE_ENTRY, length (command),
			requote_string_ (command));
		end;

	     return;


/**** The end of the string beging expanded was found after an ampersand
      was encountered but before a valid substitution construct was
      completed. */

END:
	     if entrypoint = EXECUTE_ENTRY & expansion_ptr = return_value_ptr
	     then call illegal (ILLEGAL_END_ERROR_VALUE);
	     else call illegal (ILLEGAL_END_CONTROL_STRING);
%page;
/**** These operations are gathered in a subroutine to reduce code size in
      exchange for a very slight performance penalty.  The overlay is used
      to add QUOTE characters to the string in order to avoid a stack
      extension. */

add_quotes:
	     procedure ();

declare	old_len			fixed bin (21);

declare	1 expansion_overlay		aligned based (expansion_ptr),
	  2 len			fixed bin (21),
	  2 str			char (0 refer (expansion_overlay.len));

		call check_buffer ();

		old_len = expansion_overlay.len;
		expansion_overlay.len = expansion_overlay.len + string_len;
		substr (expansion_overlay.str, old_len + 1, string_len) = copy (QUOTE, string_len);

		if buffer_overflow then go to EXPANDED;

		return;

add_string:
	     entry ();

		call check_buffer ();

		expansion = expansion || string;

		if buffer_overflow then go to EXPANDED;

		return;

	     end add_quotes;
%page;
/**** The expansion has become too large for the expansion buffer.
      Allocate a bigger buffer, and free the old one if it was allocated.
      The initial buffer is automatic, and must be not be freed. */

allocate_buffer:
	     procedure ();

declare	new_buffer_ptr		ptr,
	old_buffer_max_len		fixed bin (21);

		new_buffer_ptr = null ();
		old_buffer_max_len = allocated_buffer_max_len;

		on cleanup
		     begin;
			if new_buffer_ptr ^= null () & new_buffer_ptr ^= allocated_buffer_ptr
			then free new_buffer_ptr -> allocated_buffer in (system_area);
		     end;

		on area go to AREA_HANDLER;

		allocated_buffer_max_len =
		     maxlength (expansion) + string_len + length (control_string) + 8 * parm_count;

		allocate allocated_buffer in (system_area) set (new_buffer_ptr);

		new_buffer_ptr -> allocated_buffer = expansion;
		expansion_max_len = allocated_buffer_max_len;

		if allocated_buffer_ptr ^= null ()
		then do;
			allocated_buffer_max_len = old_buffer_max_len;
			free allocated_buffer in (system_area);
		     end;

		allocated_buffer_ptr, expansion_ptr = new_buffer_ptr;

		return;

AREA_HANDLER:
		call error (0, "Can't allocate a buffer large enough to hold the expanded control string.");

	     end allocate_buffer;
%page;
/**** Ensure that there is sufficient space in the expansion buffer to
      permit the addition of string_len characters to the buffer.  If there
      is not, grow the buffer if possible.  The case where we can't try to
      grow the buffer is when the buffer is the active function return
      value.  Since the command processor can't accept a bigger value, we
      announce that the string was truncated and set string_len to what
      will actually fit.  Setting buffer_overflow will cause termination of
      the expansion after the characters have been appended.  Note that
      ssu_$print_message will only return for active functions after the
      user issues "start", but not for the subsystem active request case.
      The only cases where expansion is directlyt overlayed on the return
      value are the do/sbag active function and the -error_value for
      execute_string. */

check_buffer:
	     procedure ();

		if length (string) ^= 0 then requote_last = "0"b;

		if length (expansion) + length (string) <= maxlength (expansion) then return;

		if expansion_ptr = return_value_ptr
		then do;
			buffer_overflow = "1"b;
			string_len = maxlength (expansion) - length (expansion);
			call warn (error_table_$command_line_overflow, TRUNCATION_WARNING, expansion_max_len,
			     entrypoint = EXECUTE_ENTRY, return_value_ptr ^= null () & sci_ptr = null ());
			return;
		     end;

		call allocate_buffer ();		/* Make it bigger */

		return;

	     end check_buffer;
%page;
/**** Get the substitution parameter which is argx after the control
      string, and append it to the expansion with appropriate quote
      processing.  If no quote modifier was specified, then no special
      processing is required.  Otherwise, the string up to this point must
      be scanned to determine the current quote level.  Then the parameter
      is appended with optional requotinq and quotes doubled according to
      the quote level. */

expand_arg:
	     procedure ();

declare	arg_pos			fixed bin (21);

		call get_argument (argx + arg_offset);

		if requote_sw = NO_QUOTE_MODIFIER
		then do;
			string_len = arg_len;
			string_ptr = arg_ptr;
			call add_string ();
			return;
		     end;

		do while (quote_scan_pos < length (expansion));

		     string_len = index (substr (expansion, quote_scan_pos + 1), QUOTE) - 1;
		     if string_len < 0 then string_len = length (expansion) - quote_scan_pos;

		     quote_scan_pos = quote_scan_pos + string_len;
		     if quote_scan_pos < length (expansion)
		     then do;
			     string_len = verify (substr (expansion, quote_scan_pos + 1), QUOTE) - 1;
			     if string_len < 0 then string_len = length (expansion) - quote_scan_pos;
			     quote_scan_pos = quote_scan_pos + string_len;

			     if mod (string_len, quote_multiplier) = 0
			     then do while (mod (string_len, 2 * quote_multiplier) ^= 0);
				     string_len = string_len - quote_multiplier;
				     quote_multiplier = 2 * quote_multiplier;
				end;
			     else do while (string_len ^= 0);
				     quote_multiplier = divide (quote_multiplier, 2, 21, 0);
				     string_len = mod (string_len, quote_multiplier);
				end;
			end;
		end;

		if requote_sw = REQUOTE_MODIFIER
		then do;
			if requote_last
			then expansion = substr (expansion, 1, length (expansion) - quote_multiplier);
			else do;
				string_len = quote_multiplier;
				call add_quotes ();
			     end;
			quote_multiplier = 2 * quote_multiplier;
		     end;

		if quote_multiplier = 1
		then do;
			string_len = arg_len;
			string_ptr = arg_ptr;
			call add_string ();
		     end;
		else do;
			arg_pos = 0;

			do while (arg_pos < length (arg));

			     string_len = index (substr (arg, arg_pos + 1), QUOTE) - 1;
			     if string_len < 0 then string_len = length (arg) - arg_pos;
			     if string_len > 0
			     then do;
				     string_ptr = addcharno (addr (arg), arg_pos);
				     call add_string ();
				     arg_pos = arg_pos + string_len;
				end;

			     if arg_pos < length (arg)
			     then do;
				     string_len = verify (substr (arg, arg_pos + 1), QUOTE) - 1;
				     if string_len < 0 then string_len = length (arg) - arg_pos;
				     arg_pos = arg_pos + string_len;

				     string_len = string_len * quote_multiplier;
				     call add_quotes ();
				end;
			end;
		     end;

		if requote_sw = REQUOTE_MODIFIER
		then do;
			string_len, quote_multiplier = divide (quote_multiplier, 2, 17, 0);
			call add_quotes ();
			requote_last = "1"b;	/* Remember ending quotes in case of &r1&r2 */
		     end;

		quote_scan_pos = length (expansion);	/* Don't let protected expansion affect quote depth */

		return;

	     end expand_arg;
%page;
/**** This routine is invoked if an illegal construct is found.  To keep
      the stack frame from becoming unreasonably large, the various control
      strings are stored in an array so that they can be passed by
      reference. */

illegal:
	     procedure (reason);

declare	reason			fixed bin (3) parameter;

		if control_string_pos > length (control_string) then control_string_pos = length (control_string);

		expansion_buffer = requote_string_ (construct);

		call error (0, REASONS (reason), expansion_buffer);

	     end illegal;

	end expand;
%page;
/**** Get an argument from the argument list.  Note that SSU reserves the
      right to change the argument list format (the entry is replaceable),
      so we can't obtain a pointer to the SSU arglist and use the cu_
      entrypoints. */

get_argument:
	procedure (P_argx);

declare	P_argx			fixed bin (17) parameter;

	     if sci_ptr = null ()
	     then do;
		     call cu_$arg_ptr_rel (P_argx, arg_ptr, arg_len, status, arg_list_ptr);
		     if status ^= 0 then call error (status, "Can't get argument #^d.", P_argx);
		end;
	     else call ssu_$arg_ptr (sci_ptr, P_argx, arg_ptr, arg_len);

	     return;

	end get_argument;
%page;
/**** An error in usage has been detected, probably a missing control
      string.  This internal procedure replaces ssu_$abort_line for this
      purpose because the standard for usage messages for commands and
      active functions is to call the appropriate $suppress_name
      entrypoint.  It also permits the short names to be used in the usage
      messages for the command and active function cases.  For the
      subsystem cases, the standard action of ssu_$abort_line is used,
      because it is desirable to give the subsystem name.  Unfortunately,
      at this writing there is no easy way to get the short name of the
      request for use in the error message. */

usage:
	procedure (usage_string);

declare	usage_string		char (*) parameter;

	     expansion_buffer = "Usage:  ";
	     if return_value_ptr ^= null () then expansion_buffer = expansion_buffer || "[";
	     if sci_ptr = null ()
	     then expansion_buffer = expansion_buffer || MY_SHORT_NAME (entrypoint);
	     else expansion_buffer = expansion_buffer || rtrim (ssu_$get_request_name (sci_ptr));
	     expansion_buffer = expansion_buffer || BLANK;
	     expansion_buffer = expansion_buffer || usage_string;
	     if return_value_ptr ^= null () then expansion_buffer = expansion_buffer || "]";

	     if sci_ptr = null ()
	     then if return_value_ptr = null ()
		then call com_err_$suppress_name (0, MY_NAME (entrypoint), "^a", expansion_buffer);
		else call active_fnc_err_$suppress_name (0, MY_NAME (entrypoint), "^a", expansion_buffer);
	     else call ssu_$abort_line (sci_ptr, 0, "^a", expansion_buffer);

	     go to EGRESS;

	end usage;

     end execute_string_command;

     end do;
