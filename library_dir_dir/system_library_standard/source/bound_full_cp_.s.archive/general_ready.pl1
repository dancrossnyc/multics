/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(69-01-01,Goldman), approve(), audit(),
     install(86-05-22,MR12.0-1057):
     Written by Jay Goldman.  (Don't know when, the date in the change
      field is just to satisfy history_comment. -jjl)
  2) change(83-08-09,Lippard), approve(), audit(),
     install(86-05-22,MR12.0-1057):
     Modified by Jim Lippard to remove reporting of bulk store reads
      and to use the clock builtin.
  3) change(84-02-14,Lippard), approve(), audit(),
     install(86-05-22,MR12.0-1057):
     Modified by Jim Lippard to add -total_xxx and -inc_xxx for
      sf, bf, vr, vw, pft, rcpu and to add the short name -lev to -level.
  4) change(84-04-11,Lippard), approve(), audit(),
     install(86-05-22,MR12.0-1057):
     Modified by Jim Lippard to turn off -call when certain conditions
      occur and to add -active_string (-astr).
  5) change(84-07-31,Lippard), approve(), audit(),
     install(86-05-22,MR12.0-1057):
     Modified by Jim Lippard to add -time_format (-tfmt) and to use the
      user's default date/time, date, and time formats.
  6) change(84-12-05,Lippard), approve(85-01-09,MCR7121),
     audit(85-10-22,Dupuis), install(85-12-16,MR12.0-1001):
     Modified by Jim Lippard to not disable -call or -astr when
      command_question is signalled.
  7) change(85-08-01,Lippard), approve(85-08-26,MCR7262),
     audit(85-10-22,Dupuis), install(85-12-16,MR12.0-1001):
     Modified by Jim Lippard to not set time_format when the argument
      supplied to -tfmt is invalid.
  8) change(86-03-06,Lippard), approve(86-04-21,MCR7385),
     audit(86-05-15,Dickson), install(86-05-22,MR12.0-1057):
     Modified to add short name -fr to -frame.
  9) change(88-08-29, TLNguyen), approve(88-08-08, MCR7961),
     audit(88-09-13, Parisek):
     (a) "general_ready -reset" should work as documented.
     (b) "general_ready -set -astr program_interrupt" should ignore the
         program_interrupt condition.
                                                   END HISTORY COMMENTS */


general_ready:
gr:
     procedure options (variable);

dcl  whoami char (32) static initial ("general_ready") options (constant);

dcl (level_flag,
     frame_flag,
     time_flag,
     date_flag,
     date_time_flag,
     time_format_flag,
     total_flag,
     temp_ready_flag,
     set_level_flag,
     af_flag,
     inc_flag) bit (1) aligned;

dcl (static_arg_list_ptr static,
     cur_arg_list,
     arg_list_ptr,
     temp_argument_ptr,
     temp_argument_descr_ptr) pointer;

dcl 1 arg_list_header aligned based (arg_list_ptr),
    2 twice_arg_count fixed bin (17) unaligned,
    2 code fixed bin (17) unaligned,
    2 twice_desc_count fixed bin (17) unaligned,
    2 pad fixed bin (17) unaligned;

dcl 1 ioa_arg_list static aligned,
    2 header fixed bin (71),
    2 arg_list_ptrs (80) pointer;

dcl 1 arg_list based (arg_list_ptr) aligned,
    2 header fixed bin (71),
    2 arg_ptrs (number_of_data) pointer,
    2 descr_ptrs (number_of_data) pointer;

dcl (
     vcpu_rate,
     real_rate,
     online_rate,
     new_online_rate,
     process_hour_rate,
     milli_mu_rate,
     kmu_rate
     ) float bin internal static;
dcl (
     new_vcpu_rate,
     new_real_rate,
     new_process_hour_rate,
     new_kmu_rate,
     new_milli_mu_rate
     ) float bin automatic;

dcl  dollars_fudge float bin (20) int static initial (0e0);
dcl  login_time fixed bin (71);
dcl  first_time_flag bit (1) aligned int static init ("1"b);

dcl  old_cl char (132) aligned static initial ("");
dcl  old_cll fixed bin static initial (132);
dcl  old_cl_ptr ptr static init (null ());
dcl  based_old_cl char (old_cll) based (old_cl_ptr);

dcl  cl_ptr ptr;
dcl  based_cl char (temp_cll) aligned based;

dcl  sys_area area based (area_ptr);
dcl  area_ptr ptr;
dcl (old_cl_flag,
     old_level_flag,
     old_frame_flag,
     old_total_flag,
     old_time_flag,
     old_date_flag,
     old_date_time_flag,
     old_time_format_flag,
     old_inc_flag) bit (1) aligned static initial ("0"b);

dcl  get_system_free_area_ entry returns (ptr);
dcl  now fixed bin (71);
dcl  next_shift fixed bin (71);
dcl (addr, addrel, after, bin, bit, clock, dim, fixed, float) builtin;
dcl (hbound, length, lbound, max, min, null, substr) builtin;
dcl (ioa_$nnl, ioa_$rsnpnnl) ext entry options (variable);
dcl  ioa_ptr pointer;
dcl  cu_$cp ext entry (ptr, fixed bin, fixed bin (35));
dcl  cu_$gen_call ext entry (ptr, ptr);
dcl  cu_$af_return_arg ext entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cu_$decode_entry_value ext entry (entry, ptr, ptr);
dcl  cu_$evaluate_active_string entry (ptr, char(*), fixed bin, char(*) var, fixed bin(35));
dcl  max_length fixed bin;
dcl  return_ptr ptr;
dcl  user_info_$usage_data ext entry (fixed bin, fixed bin (71),
     fixed bin (71), fixed bin (71), fixed bin (71));
dcl  gr_get_rates_ ext entry (float bin, float bin, float bin, float bin, fixed bin (71));

dcl  cu_$set_ready_proc ext entry (pointer);
dcl  timer_manager_$alarm_call ext entry (fixed bin (71), bit (2) aligned, entry);
dcl  timer_manager_$reset_alarm_call ext entry (entry);
dcl  first_time fixed bin (71) int static init (0);
dcl  hcs_$get_process_usage ext entry (ptr, fixed bin (35));
dcl  error_table_$badopt ext static fixed bin (35);
dcl  error_table_$noarg ext static fixed bin (35);
dcl  error_table_$inconsistent ext static fixed bin (35);

dcl  (any_other, sub_error_) condition;

dcl  find_condition_info_ entry (ptr, ptr, fixed bin(35));
dcl  continue_to_signal_ entry (fixed bin(35));

dcl  sub_err_ entry() options(variable);

dcl  1 ci aligned like condition_info;

dcl 1 ready_mode_flags aligned,
    2 ready_sw bit (1) unaligned,
    2 pad bit (35) unaligned;

dcl 1 new aligned static like process_usage;
dcl 1 old aligned static like new;
dcl 1 last aligned static like new;

dcl  date_time_string char (250) aligned int static;	/* for -date_time */
dcl  date_string char (250) aligned int static;		/* for -date */
dcl  time_string char (250) aligned int static;		/* for -time */
dcl  time_format_string char (250) aligned int static;	/* for -time_format */
dcl  old_time_format char (60) int static;		/* input string for -time_format */
dcl  temp_time_format char (60);
dcl  time_format char (60);

dcl  dt char (24) int static aligned;			/* mm/dd/yy__hhmm.m_zzz_www */
dcl  dt_chars (0:23) char (1) unaligned based (addr (dt));

dcl 1 dt_descr (3) int static,
    2 flag bit (1) initial ((3) (1) "1"b),
    2 type bit (6) initial ((3) (1) "010101"b),		/* character string */
    2 packed bit (1) initial ((3) (1) "1"b),
    2 number_dims bit (4) initial ((3) (1) "0000"b),
    2 size bit (24) initial (
     "000000000000000000000010"b,			/* minute, hour, month, day, year */
     "000000000000000000000011"b,			/* day_name or zone */
     "000000000000000011111010"b);			/* any time string from date_time_$format */

dcl (arg_index,
     dt_offset_index,
     idx) fixed bin;

dcl  dt_incr_string (10) char (4) varying static initial (
     " ^a", " ^a", "^a", " ^a", " ^a", " ^a", " ^a", " ^a", "^a", "^a");

dcl  dt_offset (10) fixed bin static initial (
     10, 10, 12, 0, 17, 21, 0, 0, 3, 6);

dcl  dt_descr_index (10) fixed bin static initial (
     3, 1, 1, 3, 2, 2, 3, 1, 1, 1);

dcl  real_index (30) fixed bin static initial		/* one entry per format option */
    (11, 1, 2, 7, 7, 13, 12, 16,			/* values <= 10 are indices in dt arrays */
     6, 5, 1, 3, 15, 4, 8, 9, 10, 17, 16, 18,		/* maps index in format_args into */
     19, 20, 21, 22, 23, 24, 24, 25, 25, 17);		/* index in dt_* and temp_flag array */

dcl 1 temp_flag (1:25) aligned,
    2 (inc, total) bit (1);

dcl  control_args (4) char (7) static aligned initial ("-set", "-revert", "-call", "-reset");

dcl  prefix_args (2) char (8) static aligned initial ("-string", "-control");

dcl  format_args (30) aligned static char (14) varying initial
    ("vcpu", "-time", "-hour", "-date", "-dt", "mem_units", "cost", "-level",
     "-day_name", "-zone", "-tm", "-minute", "pf", "-date_time", "-month",
     "-day", "-year", "-frame", "-lev", "pft", "sf", "bf", "vr", "vw", "rcpu",
     "-active_string", "-astr", "-time_format", "-tfmt", "-fr");

dcl  format_sw (30) bit (1) static aligned initial
    ("0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "1"b,	/* indicate if arg must match format_arg */
     "1"b, "1"b, "1"b, "1"b, "0"b, "1"b, "1"b, "1"b,	/* exactly or may have leading -inc_ or -total_ */
     "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b,
     "0"b, "1"b, "1"b, "1"b, "1"b, "1"b);

dcl  date_time_ ext entry (fixed bin (71), char (*)aligned);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*))
     returns (char (250) varying);
dcl  default_ioa_string char (32) varying int static initial (
     "^a ^.3f ^d^a^2/");

dcl  default_sw bit (1) static init ("0"b);

dcl (level_no, frame_no) fixed bin;
dcl  level_string char (16) aligned static;
dcl  level_ioa_string char (34) static initial (" ^[level ^d^;frame ^s^]^[,^]^[^d^]");
dcl  listen_$get_level ext entry (fixed bin, fixed bin);
dcl  ioa_$rsnnl ext entry options (variable);

dcl 1 level_descr int static,
    2 flag bit (1) init ("1"b),
    2 type bit (6) init ("010101"b),
    2 packed bit (1) init ("0"b),
    2 number_dims bit (4) init ("0000"b),
    2 size bit (24) init ("000000000000000000010000"b);

dcl  ioa_string char (132) aligned int static;

dcl 1 ioa_string_descr int static,
    2 flag bit (1) initial ("1"b),
    2 type bit (6) initial ("010101"b),
    2 packed bit (1) initial ("0"b),
    2 number_dims bit (4) initial ("0000"b),
    2 size bit (24) initial ("000000000000000000001100"b);

dcl 1 float_descr int static,
    2 flag bit (1) initial ("1"b),
    2 type bit (6) initial ("000011"b),
    2 packed bit (1) initial ("0"b),
    2 number_dims bit (4) initial ("0000"b),
    2 scale bit (12) initial ("000000000000"b),
    2 precision bit (12) initial ("000000010100"b);

dcl 1 integer_descr int static,
    2 flag bit (1) initial ("1"b),
    2 type bit (6) initial ("000001"b),
    2 packed bit (1) initial ("0"b),
    2 number_dims bit (4) initial ("0000"b),
    2 scale bit (12) initial ("000000000000"b),
    2 precision bit (12) initial ("000000100011"b);

dcl (total_dollars,
     inc_dollars,
     new_dollars,
     old_dollars,
     last_dollars,
     total_mem_units,
     inc_mem_units,
     total_vcpu_time,
     inc_vcpu_time,
     total_rcpu_time,
     inc_rcpu_time) float bin (20) int static;

dcl (total_pd_faults,
     total_page_faults,
     total_seg_faults,
     total_bounds_faults,
     total_vtoc_reads,
     total_vtoc_writes,
     inc_pd_faults,
     inc_page_faults,
     inc_seg_faults,
     inc_bounds_faults,
     inc_vtoc_reads,
     inc_vtoc_writes) fixed bin (35) int static;

dcl  ZERO_BS fixed bin (35) int static options (constant) init (0);

dcl  arg char (arglen) unal based (arg_ptr);
dcl (arglen, temp_cll) fixed bin;
dcl (arg_ptr, temp_clp) ptr;
dcl  temp_cl char (temp_cll) based (temp_clp);

dcl  temp_ioa_string char (132) aligned varying;

dcl  bvs_ptr pointer;
dcl 1 temp_ioa_bvss aligned based,
    2 length fixed bin,
    2 string char (132);

dcl 1 based_descr based like temp_ioa_string_descr;
dcl 1 af_return_descr like temp_ioa_string_descr unaligned;
dcl  vs_type bit (6) static initial ("010110"b);

dcl 1 temp_ioa_string_descr unaligned,
    2 flag bit (1),
    2 type bit (6),
    2 packed bit (1),
    2 number_dims bit (4),
    2 size bit (24);

dcl 1 temp_ioa_arg_list aligned like ioa_arg_list;

dcl (argument_ptr (24),
     argument_descr_ptr (24)) pointer;

dcl (argnumber,
     af_offset,
     string_length,
     number_of_data) fixed bin;

dcl  old_number_of_data fixed bin internal static;

dcl (first_args_flag,
     total_format_flag,
     values_set_flag,
     temp_total_flag,
     temp_inc_flag,
     temp_level_flag,
     temp_frame_flag,
     temp_set_flag,
     temp_revert_flag, temp_reset_flag,
     temp_date_flag,
     temp_time_flag,
     temp_date_time_flag,
     temp_time_format_flag,
     doing_dollars,
     incr_string_flag) bit (1) aligned;

dcl  incr_string char (32) varying;

dcl 1 active_string based,
      2 next_active_string_ptr ptr,
      2 descriptor like active_string_descr_const,
      2 num_of_data fixed bin,
      2 input_string_len fixed bin,
      2 input_string char (input_string_length refer (active_string.input_string_len));

dcl input_string_length fixed bin(21);

dcl old_active_string_ptr ptr int static;
dcl (active_string_ptr, temp_active_string_ptr) ptr;

dcl old_last_active_string_ptr ptr int static;
dcl temp_last_active_string_ptr ptr;

dcl  (n_active_strings,
      temp_n_active_strings) fixed bin (21);
dcl  old_n_active_strings fixed bin (21) int static;

dcl  1 active_string_descr_const,
       2 flag bit (1) initial ("1"b),
       2 type bit (6) initial ("010101"b),
       2 packed bit (1) initial ("0"b),
       2 number_dims bit (4) initial ("0000"b),
       2 size bit (24) initial ((24) "0"b);

dcl (cu_$arg_ptr, cu_$af_arg_ptr) ext entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  get_arg_ptr_ entry (fixed bin, ptr, fixed bin, fixed bin (35)) variable;
dcl  code fixed bin (35) static;
dcl (com_err_, active_fnc_err_) ext entry options (variable);
dcl  err_ entry options (variable) variable;
%page;
%include process_usage;
%page;
%include cp_active_string_types;
%page;
%include condition_info;
%page;
%include condition_info_header;
%page;
%include sub_err_flags;
%page;
%include sub_error_info;
%page;
						/*  */
	new.number_wanted = 9;
	go to decode_arg_list;

/* the code for the message and change_shift entry points
   is put at the beginning of the program to insure
   that the code for these entries lies on a single page of
   the object segment */

message:	entry (ready_mode_flags);

	if old_cl_flag then do;
	     if old_cl_ptr = null then old_cl_ptr = addr (old_cl);
	     begin;
dcl  cl_copy char (length (based_old_cl)) aligned;
		cl_copy = based_old_cl;

		on any_other begin;			/* Handle nasty conditions and turn off -call */
		     on sub_error_ system;	/* avoid those loops */
		     ci.version = condition_info_version_1;
		     call find_condition_info_ (null(), addr (ci), code);
		     if code ^= 0 then do;		/* no condition frame */
			call sub_err_ (code, whoami, ACTION_DEFAULT_RESTART, null (), (0), "-call disabled.");
			old_cl_flag = "0"b;
			return;
		     end;
		     if ci.condition_name = "alrm" |
			ci.condition_name = "command_question" |
			ci.condition_name = "cput" |
			ci.condition_name = "finish" |
			ci.condition_name = "quit" |
			ci.condition_name = "sus_" |
			ci.condition_name = "trm_" then;
		     else do;
			if old_cl_flag then /* avoid complaining twice */
			     call sub_err_ ((0), whoami, ACTION_DEFAULT_RESTART, null (), (0),
				"Condition ^a signalled, -call disabled.", ci.condition_name);
			old_cl_flag = "0"b;
		     end;
		     call continue_to_signal_ ((0));
		end;

		call cu_$cp (addr (cl_copy), (old_cll), code);

		revert any_other;
	     end;
	end;
	if ^ready_mode_flags.ready_sw then return;
	temp_ready_flag = "0"b;			/* this is from static arg list */

	if first_time_flag then do;
	     call setup_ready;
	     if code ^= 0 then return;
	end;

do_ready:
	if temp_ready_flag then do;			/* if general_ready invoked only once */
	     if temp_clp ^= null () then begin;		/* and  -call was specified */
dcl  temp_cl_copy char (temp_cll) init (temp_cl);
		call cu_$cp (addr (temp_cl_copy), length (temp_cl_copy), code);
	     end;
	     if af_flag then ioa_ptr = addr (ioa_$rsnpnnl);
	     else ioa_ptr = addr (ioa_$nnl);
	     total_flag = temp_total_flag;
	     inc_flag = temp_inc_flag;
	     cur_arg_list = arg_list_ptr;
	     level_flag = temp_level_flag;
	     frame_flag = temp_frame_flag;
	     time_flag = temp_time_flag;
	     date_flag = temp_date_flag;
	     date_time_flag = temp_date_time_flag;
	     time_format_flag = temp_time_format_flag;
	     time_format = temp_time_format;
	     n_active_strings = temp_n_active_strings;
	     active_string_ptr = temp_active_string_ptr;
	end;
	else do;
	     ioa_ptr = addr (ioa_$nnl);
	     total_flag = old_total_flag;
	     inc_flag = old_inc_flag;
	     level_flag = old_level_flag;
	     frame_flag = old_frame_flag;
	     time_flag = old_time_flag;
	     date_flag = old_date_flag;
	     date_time_flag = old_date_time_flag;
	     time_format_flag = old_time_format_flag;
	     time_format = old_time_format;
	     cur_arg_list, arg_list_ptr = static_arg_list_ptr;
	     n_active_strings = old_n_active_strings;
	     active_string_ptr = old_active_string_ptr;
	     number_of_data = old_number_of_data;
	     temp_n_active_strings = 0;
	     af_flag = "0"b;
	end;

	now = clock ();
	call hcs_$get_process_usage (addr (new), code);
	if code ^= 0 then do;
got_pu_err:
	     call err_ (code, whoami, "error in hcs_$get_process_usage.");
	     return;
	end;
	new_dollars = float (new.virtual_cpu_time, 20)*vcpu_rate
	     + float (now-first_time, 20)*online_rate
	     + float (new.paging_measure*milli_mu_rate, 20)
	     - dollars_fudge;

	new.virtual_cpu_time = new.virtual_cpu_time + old.virtual_cpu_time;	/* add cpu from previous processes */
	new.paging_measure = new.paging_measure + old.paging_measure;

	call date_time_ (now, dt);
	if time_flag then time_string = date_time_$format ("time", now, "", "");
	if date_flag then date_string = date_time_$format ("date", now, "", "");
	if date_time_flag then date_time_string = date_time_$format ("date_time", now, "", "");
	if time_format_flag then time_format_string = date_time_$format (time_format, now, "", "");

	if total_flag then do;
	     total_dollars = new_dollars;
	     total_pd_faults = new.pd_faults;
	     total_page_faults = new.page_faults;
	     total_seg_faults = new.segment_faults;
	     total_bounds_faults = new.bounds_faults;
	     total_vtoc_reads = new.vtoc_reads;
	     total_vtoc_writes = new.vtoc_writes;
	     total_vcpu_time = float (new.virtual_cpu_time, 20)/1e6;
	     total_mem_units = float (new.paging_measure, 20)/1e3;
	     total_rcpu_time = float (new.cpu_time, 20)/1e6;
	end;

	if inc_flag then do;
	     inc_dollars = new_dollars - last_dollars;
	     inc_vcpu_time = float (new.virtual_cpu_time-last.virtual_cpu_time, 20)/1e6;
	     inc_rcpu_time = float (new.cpu_time-last.cpu_time, 20)/1e6;
	     inc_mem_units = float (new.paging_measure-last.paging_measure, 20)/1e3;
	     inc_pd_faults = new.pd_faults - last.pd_faults;
	     inc_page_faults = new.page_faults - last.page_faults;
	     inc_seg_faults = new.segment_faults - last.segment_faults;
	     inc_bounds_faults = new.bounds_faults - last.bounds_faults;
	     inc_vtoc_reads = new.vtoc_reads - last.vtoc_reads;
	     inc_vtoc_writes = new.vtoc_writes - last.vtoc_writes;
	end;

	last_dollars = new_dollars;
	last.paging_measure = new.paging_measure;
	last.virtual_cpu_time = new.virtual_cpu_time;
	last.cpu_time = new.cpu_time;
	last.pd_faults = new.pd_faults;
	last.page_faults = new.page_faults;
	last.segment_faults = new.segment_faults;
	last.bounds_faults = new.bounds_faults;
	last.vtoc_reads = new.vtoc_reads;
	last.vtoc_writes = new.vtoc_writes;

	if default_sw then
	     time_string = date_time_$format ("time", clock (), "", "");

/* if ready message is to contain listener level info, then get it */
	if level_flag | frame_flag then do;
	     call listen_$get_level (level_no, frame_no);
	     if level_no = 1 then level_string = "";
	     else call ioa_$rsnnl (level_ioa_string, level_string, length (level_string), level_flag, level_no,
			(level_flag & frame_flag), frame_flag, frame_no);
	     set_level_flag = "0"b;
	end;
	else level_string = "";

	begin;		/* begin block for active strings */
	     dcl active_string_output (n_active_strings) char (256) varying;
	     if ^af_flag then af_offset = 0;
	     else af_offset = 2;
	     do idx = 1 to n_active_strings;
		active_string_output (idx) = "";

		if ^temp_ready_flag then
		on any_other begin;			/* Handle nasty conditions and turn off active string */
		     on sub_error_ system;	/* avoid those loops */
		     ci.version = condition_info_version_1;
		     call find_condition_info_ (null(), addr (ci), code);
		     if code ^= 0 then do;		/* no condition frame */
			call sub_err_ (code, whoami, ACTION_DEFAULT_RESTART, null (), (0), "Active string ""^a"" disabled.", active_string_ptr -> active_string.input_string);
			active_string_ptr -> active_string.input_string = "";
			return;
		     end;
		     if ci.condition_name = "alrm" |
			ci.condition_name = "command_question" |
			ci.condition_name = "cput" |
			ci.condition_name = "finish" |
			ci.condition_name = "program_interrupt" |
			ci.condition_name = "quit" |
			ci.condition_name = "sus_" |
			ci.condition_name = "trm_" then;
		     else do;
			if active_string_ptr -> active_string.input_string ^= "" then /* avoid complaining twice */
			     call sub_err_ ((0), whoami, ACTION_DEFAULT_RESTART, null (), (0),
				"Condition ^a signalled, active string ""^a"" disabled.", ci.condition_name, active_string_ptr -> active_string.input_string);
			active_string_ptr -> active_string.input_string = "";
		     end;
		     call continue_to_signal_ ((0));
		end;

		if active_string_ptr -> active_string.input_string ^= "" then
		     call cu_$evaluate_active_string (null(), active_string_ptr -> active_string.input_string,
			DEFAULT_ACTIVE_STRING, active_string_output (idx), code);

		revert any_other;

		if code ^= 0 then do;
		     call sub_err_ (code, whoami, ACTION_DEFAULT_RESTART, null (), (0), "Error evaluating active string ""^a"", active string evaluation disabled.", active_string_ptr -> active_string.input_string);
		     active_string_ptr -> active_string.input_string = "";
		end;

		arg_list.arg_ptrs (active_string_ptr -> active_string.num_of_data + af_offset) =
			addr (substr (active_string_output (idx), 1));
		arg_list.descr_ptrs (active_string_ptr -> active_string.num_of_data + af_offset) =
			addr (active_string_ptr -> active_string.descriptor);
		active_string_ptr -> active_string.size = bit (length (active_string_output (idx)));
		active_string_ptr = active_string_ptr -> active_string.next_active_string_ptr;
	     end;
	     call cu_$gen_call (ioa_ptr, cur_arg_list);

	     /* free temp active strings */
	     do idx = 1 to temp_n_active_strings;
		active_string_ptr = temp_active_string_ptr;
		temp_active_string_ptr = active_string_ptr -> active_string.next_active_string_ptr;
		free active_string_ptr -> active_string;
	     end;

	end;

	return;					/* end of message code */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

change_shift: entry;

	call hcs_$get_process_usage (addr (new), code);
	if code ^= 0 then go to got_pu_err;
	now = clock ();
	call gr_get_rates_ (new_vcpu_rate, new_real_rate, new_process_hour_rate,
	     new_kmu_rate, next_shift);

	new_vcpu_rate = new_vcpu_rate/3.6e9;
	new_real_rate = new_real_rate/3.6e9;
	new_process_hour_rate = new_process_hour_rate/3.6e9;
	new_online_rate = new_real_rate + new_process_hour_rate;
	new_milli_mu_rate = new_kmu_rate/1e6;

	dollars_fudge = new.virtual_cpu_time * (new_vcpu_rate-vcpu_rate)
	     + new.paging_measure * (new_milli_mu_rate-milli_mu_rate)
	     + (now-first_time) * (new_online_rate-online_rate)
	     + dollars_fudge;

	vcpu_rate = new_vcpu_rate;
	real_rate = new_real_rate;
	process_hour_rate = new_process_hour_rate;
	online_rate = real_rate + process_hour_rate;
	milli_mu_rate = new_milli_mu_rate;

	if next_shift > now then call timer_manager_$alarm_call (next_shift, "00"b, change_shift);
	return;

/* end of message and change_shift code */

decode_arg_list:					/* general_ready entrypoint gets here */

	if first_time_flag then call setup_ready;

	call cu_$af_return_arg (argnumber, return_ptr, max_length, code);
	if code = 0 then do;
	     af_flag = "1"b;
	     err_ = active_fnc_err_;
	     get_arg_ptr_ = cu_$af_arg_ptr;
	end;
	else do;
	     af_flag = "0"b;
	     err_ = com_err_;
	     get_arg_ptr_ = cu_$arg_ptr;
	end;

	temp_ioa_string = "r";
	argnumber = 0;
	number_of_data = 1;				/* first arg to ioa is ioa control string */
	temp_n_active_strings = 0;
	temp_active_string_ptr, temp_last_active_string_ptr = null ();
	set_level_flag = "0"b;

	first_args_flag = "1"b;
	do arg_index = lbound (temp_flag, 1) to hbound (temp_flag, 1);
	     temp_flag.inc (arg_index) = "0"b;
	     temp_flag.total (arg_index) = "0"b;
	end;

	values_set_flag,
	     temp_total_flag,
	     temp_inc_flag,
	     temp_revert_flag,
	     temp_reset_flag,
	     temp_set_flag
	     = "0"b;
	doing_dollars = "0"b;
	incr_string_flag = "1"b;
	temp_clp = null ();
	temp_level_flag, temp_frame_flag = "0"b;
	temp_time_flag, temp_date_flag, temp_date_time_flag, temp_time_format_flag = "0"b;
	go to read_loop;

repeated_option:
	call err_ (0, whoami, "repeated control arg ^a.", arg);
	return;
read_loop:
	argnumber = argnumber +1;

	call get_arg_ptr_ (argnumber, arg_ptr, arglen, code);
	if code ^= 0 then do;			/* done with arg list, now
						   to setup arglist */

end_of_read_loop:
	     if incr_string_flag then temp_ioa_string = temp_ioa_string||"^/";
	     temp_ioa_string_descr.type = "010101"b;
	     temp_ioa_string_descr.packed = "0"b;
	     temp_ioa_string_descr.number_dims = "0000"b;
	     temp_ioa_string_descr.flag = "1"b;
	     string_length = length (temp_ioa_string);
	     temp_ioa_string_descr.size = bit (bin (string_length, 24), 24); /* set size field */

	     if ^values_set_flag & ^first_args_flag then do; /* i.e., we got only a non-keyword */
		call err_ (error_table_$noarg, whoami, "No values specified for other than default ready message.");
		return;
	     end;

	     if temp_revert_flag then do;		/* process -revert */
		if temp_set_flag then do;		/* -set and -revert are incompatible */
		     call err_ (error_table_$inconsistent, whoami, "-set and -revert");
		     return;
		end;
		if old_cl_ptr ^= null & old_cl_ptr ^= addr (old_cl) then free based_old_cl in (sys_area);
		call cu_$set_ready_proc (null ());
		call timer_manager_$reset_alarm_call (change_shift);
		/* free active strings */
		do idx = 1 to old_n_active_strings;
		     active_string_ptr = old_active_string_ptr;
		     old_active_string_ptr = active_string_ptr -> active_string.next_active_string_ptr;
		     free active_string_ptr -> active_string;
		end;
		if ^values_set_flag & ^temp_reset_flag then return; /* if no values, just revert */
						/* will allow both -revert and -reset */
	     end;
	     if temp_reset_flag then do;		/* reset incremental if -reset */
		now = clock ();
		call hcs_$get_process_usage (addr (new), code);
		if code ^= 0 then go to got_pu_err;
		last_dollars = float (new.virtual_cpu_time, 20)*vcpu_rate
		     + float (now - first_time, 20)*online_rate
		     + float (new.paging_measure*milli_mu_rate, 20)
		     - dollars_fudge;
		last.virtual_cpu_time = new.virtual_cpu_time + old.virtual_cpu_time;
		last.cpu_time = new.cpu_time + old.cpu_time;
		last.paging_measure = new.paging_measure + old.paging_measure;
		last.pd_faults = new.pd_faults;
		last.page_faults = new.page_faults;
		last.segment_faults = new.segment_faults;
		last.bounds_faults = new.bounds_faults;
		last.vtoc_reads = new.vtoc_reads;
		last.vtoc_writes = new.vtoc_writes;

	          date_flag = temp_date_flag;
		time_flag = temp_time_flag;
		date_time_flag = temp_date_time_flag;
		time_format_flag = temp_time_format_flag;

		call date_time_ (now, dt);

		if date_flag then date_string = date_time_$format ("date", now, "", "");
		if time_flag then time_string = date_time_$format ("time", now, "", "");
		if date_time_flag then date_time_string = date_time_$format ("date_time", now, "", "");
		if time_format_flag then time_format_string = date_time_$format (time_format, now, "", "");
		if ^values_set_flag then return;	/* if only -reset (or -revert -reset) just return w/o msg */
	     end;

	     if ^temp_set_flag			/* one time only */
	     then do;
		arg_list_ptr = addr (temp_ioa_arg_list);
		bvs_ptr = addr (temp_ioa_string);
		argument_ptr (1) = addr (bvs_ptr -> temp_ioa_bvss.string);
		argument_descr_ptr (1) = addr (temp_ioa_string_descr);
	     end;
	     else do;
		argument_ptr (1) = addr (ioa_string);
		argument_descr_ptr (1) = addr (ioa_string_descr);
		ioa_string_descr = temp_ioa_string_descr;
		ioa_string = temp_ioa_string;
		if temp_clp ^= null () then do;
		     if old_cl_ptr = null () then string_length = length (old_cl);
		     else string_length = length (based_old_cl);
		     if temp_cll > string_length then do; /* we need more space */
			if old_cl_ptr ^= null () & old_cl_ptr ^= addr (old_cl) then free based_old_cl in (sys_area);
			else area_ptr = get_system_free_area_ ();
			allocate based_cl in (sys_area) set (cl_ptr);
		     end;
		     else if old_cl_ptr = null then cl_ptr = addr (old_cl);
		     else cl_ptr = old_cl_ptr;
		     old_cll = max (string_length, temp_cll);
		     old_cl_flag = "1"b;
		     old_cl_ptr = cl_ptr;
		     based_old_cl = temp_cl;
		end;
		else old_cl_flag = "0"b;
		old_inc_flag = temp_inc_flag;
		old_total_flag = temp_total_flag;
		old_level_flag = temp_level_flag;
		old_frame_flag = temp_frame_flag;
		old_time_flag = temp_time_flag;
		old_date_flag = temp_date_flag;
		old_date_time_flag = temp_date_time_flag;
		old_time_format_flag = temp_time_format_flag;
		old_time_format = temp_time_format;
		static_arg_list_ptr, arg_list_ptr = addr (ioa_arg_list);

		/* free old active strings */
		do idx = 1 to old_n_active_strings;
		     active_string_ptr = old_active_string_ptr;
		     old_active_string_ptr = active_string_ptr -> active_string.next_active_string_ptr;
		     free active_string_ptr -> active_string;
		end;

		old_n_active_strings = temp_n_active_strings;
		old_active_string_ptr = temp_active_string_ptr;
		old_number_of_data = number_of_data;
	     end;

	     if incr_string_flag & temp_ioa_string = "r^/" then do; /* Wants default ready message */
		default_sw = "1"b;
		temp_ioa_string = "r^x" || default_ioa_string;
		call set_default_arg_list;
	     end;
	     else do;
		default_sw = "0"b;
		af_offset = 0;
		do argnumber = 1 to number_of_data;
		     if argnumber = 1 then if af_flag then number_of_data = number_of_data+2;
		     arg_list.arg_ptrs (argnumber+af_offset) = argument_ptr (argnumber);
		     arg_list.descr_ptrs (argnumber+af_offset) = argument_descr_ptr (argnumber);
		     if argnumber = 1 then if af_flag then af_offset = 2;
		end;

		arg_list_header.twice_desc_count,
		     arg_list_header.twice_arg_count = 2 * number_of_data;
		arg_list_header.code = 4;
		arg_list_header.pad = 0;
	     end;

	     temp_ready_flag = "1"b;			/* if we wind up going to do_ready the temp vbls should be used */
	     if af_flag then do;			/* fill in af return arguments */
		arg_list.arg_ptrs (2) = addrel (return_ptr, 1); /* ptr to af return arg */
		arg_list.arg_ptrs (3) = return_ptr;	/* ptr to length word of return arg */
		arg_list.descr_ptrs (3) = addr (integer_descr);
		arg_list.descr_ptrs (2) = addr (af_return_descr);
		af_return_descr.flag = "1"b;
		af_return_descr.type = vs_type;
		af_return_descr.packed = ""b;
		af_return_descr.number_dims = ""b;
		af_return_descr.size = bit (bin (max_length, 17), 24);
		goto do_ready;			/* do a ready msg */
	     end;
	     else if temp_set_flag then do;		/* process -set */
		call cu_$decode_entry_value (message, return_ptr, null ());
		call cu_$set_ready_proc (return_ptr);
	     end;
	     else goto do_ready;			/* no -set */

	     return;				/* ready message is set up or printed */
	end;


/* first_args: */
	if first_args_flag then do;

	     do arg_index = 1 to dim (prefix_args, 1);
		if arg = prefix_args (arg_index) then go to do_prefix (arg_index);
	     end;
	end;					/* end of processing for first args */
	else do;

check_format:
						/* check for a format option */

	     do arg_index = 1 to dim (format_args, 1);
		if format_sw (arg_index) then if format_args (arg_index) = arg then do;
			arg_index = real_index (arg_index);
			if temp_flag.inc (arg_index) then go to repeated_option;
			temp_flag.inc (arg_index) = "1"b;
		     end;
		     else go to next_format_arg;

		else do;
		     if (substr (arg, 1, min (arglen, 7)) = "-total_") &
		     (after (arg, "-total_") = format_args (arg_index)) then do;
			total_format_flag = "1"b;
			arg_ptr = addr (substr (arg, 8, 1));
			arglen = max (arglen-7, 0);
		     end;
		     else if (substr (arg, 1, min (arglen, 5)) = "-inc_") &
		     (after (arg, "-inc_") = format_args (arg_index)) then do;
			total_format_flag = "0"b;
			arg_ptr = addr (substr (arg, 6, 1));
			arglen = max (arglen-5, 0);
		     end;
		     else go to next_format_arg;

		     arg_index = real_index (arg_index); /* consolidate multiply named options */
		     if total_format_flag then if temp_flag.total (arg_index) then go to repeated_option;
			else do;
			     temp_flag.total (arg_index) = "1"b;
			     temp_total_flag = "1"b;
			end;

		     else if temp_flag.inc (arg_index) then go to repeated_option;
		     else do;
			temp_flag.inc (arg_index) = "1"b;
			temp_inc_flag = "1"b;
		     end;
		end;

		go to do_format (arg_index);
next_format_arg:

	     end;
	end;

/* check for control args */

	do arg_index = 1 to dim (control_args, 1);
	     if arg = control_args (arg_index) then
		if af_flag then do;
		     call err_ (error_table_$badopt, whoami,
			"^a not allowed when active function", arg);
		     return;
		end;
		else goto do_control_arg (arg_index);
	end;

	if incr_string_flag then do;
	     if arglen = 0 then go to read_loop;
	     if substr (arg, 1, 1) ^= "-" then do;
		first_args_flag = "0"b;
		temp_ioa_string = temp_ioa_string || arg;
		go to read_loop;
	     end;
	end;

	if first_args_flag then do;			/* if we haven't checked if arg is a format arg go do it now */
	     first_args_flag = "0"b;
	     go to check_format;
	end;


	call err_ (error_table_$badopt, whoami, "^a.", arg);
EXIT_RETURN:
	return;

/* code to execute each format option */

do_format (11):					/* -vcpu */

	if total_format_flag then temp_argument_ptr = addr (total_vcpu_time);
	else temp_argument_ptr = addr (inc_vcpu_time);
	call add_floating_arg;
	go to read_loop;

do_format (13):					/* mem_units */

	if total_format_flag then temp_argument_ptr = addr (total_mem_units);
	else temp_argument_ptr = addr (inc_mem_units);
	call add_floating_arg;
	go to read_loop;

do_format (16):					/* -level */

	temp_level_flag = "1"b;
	if ^set_level_flag then do;
	incr_string = "^a";
	temp_argument_ptr = addr (level_string);
	temp_argument_descr_ptr = addr (level_descr);
	call add_data_arg;
	set_level_flag = "1"b;
	end;
	go to read_loop;

do_format (17):                                            /* -frame */

	temp_frame_flag = "1"b;
	if ^set_level_flag then do;
	incr_string = "^a";
	temp_argument_ptr = addr (level_string);
	temp_argument_descr_ptr = addr (level_descr);
	call add_data_arg;
	set_level_flag = "1"b;
	end;
	go to read_loop;

do_format (15):					/* pf (page faults) */

	temp_argument_descr_ptr = addr (integer_descr);
	incr_string = " ^d";
	if total_format_flag then do;
	     temp_argument_ptr = addr (ZERO_BS);
	     call add_data_arg;
	     temp_argument_ptr = addr (total_page_faults);
	end;
	else do;
	     temp_argument_ptr = addr (ZERO_BS);
	     call add_data_arg;
	     temp_argument_ptr = addr (inc_page_faults);
	end;

	incr_string = "+^d";
	call add_data_arg;
	go to read_loop;

do_format (18):					/* pft (page faults) */

	temp_argument_descr_ptr = addr (integer_descr);
	if total_format_flag then do;
	     temp_argument_ptr = addr (total_page_faults);
	end;
	else do;
	     temp_argument_ptr = addr (inc_page_faults);
	end;

	incr_string = " ^d";
	call add_data_arg;
	go to read_loop;

do_format (19):					/* sf (segment faults) */

	temp_argument_descr_ptr = addr (integer_descr);
	incr_string = " ^d";
	if total_format_flag then
	     temp_argument_ptr = addr (total_seg_faults);
	else temp_argument_ptr = addr (inc_seg_faults);
	call add_data_arg;
	go to read_loop;

do_format (20):					/* bf (bounds faults) */

	temp_argument_descr_ptr = addr (integer_descr);
	incr_string = " ^d";
	if total_format_flag then
	     temp_argument_ptr = addr (total_bounds_faults);
	else temp_argument_ptr = addr (inc_bounds_faults);
	call add_data_arg;
	go to read_loop;

do_format (21):					/* vr (vtoc reads) */

	temp_argument_descr_ptr = addr (integer_descr);
	incr_string = " ^d";
	if total_format_flag then
	     temp_argument_ptr = addr (total_vtoc_reads);
	else temp_argument_ptr = addr (inc_vtoc_reads);
	call add_data_arg;
	go to read_loop;

do_format (22):					/* vw (vtoc writes) */

	temp_argument_descr_ptr = addr (integer_descr);
	incr_string = " ^d";
	if total_format_flag then
	     temp_argument_ptr = addr (total_vtoc_writes);
	else temp_argument_ptr = addr (inc_vtoc_writes);
	call add_data_arg;
	go to read_loop;

do_format (23):					/* rcpu (real cpu) */

	if total_format_flag then
	     temp_argument_ptr = addr (total_rcpu_time);
	else temp_argument_ptr = addr (inc_rcpu_time);
	call add_floating_arg;
	go to read_loop;

do_format (24):					/* -active_string */

	incr_string = " ^a";
	temp_flag.inc (24) = "0"b;			/* may be repeated */
	temp_n_active_strings = temp_n_active_strings + 1;
	argnumber = argnumber + 1;
	call get_arg_ptr_ (argnumber, arg_ptr, arglen, code);
	if code ^= 0 then do;
	     call err_ (code, whoami, "An active string must be specified following -active_string.");
	     return;
	end;
	call add_active_string;
	go to read_loop;

do_format (12):					/* -dollars */

	if total_format_flag then temp_argument_ptr = addr (total_dollars);
	else temp_argument_ptr = addr (inc_dollars);

	doing_dollars = "1"b;
	call add_floating_arg;
	doing_dollars = "0"b;
	go to read_loop;

do_format (4):					/* -date_time */
	temp_date_time_flag = "1"b;
	temp_argument_ptr = addr (date_time_string);
	go to ADD_DATE;

do_format (7):					/* -date, -dt */
	temp_date_flag = "1"b;
	temp_argument_ptr = addr (date_string);
	go to ADD_DATE;

do_format (1):					/* -time, -tm */
	temp_time_flag = "1"b;
	temp_argument_ptr = addr (time_string);
	go to ADD_DATE;

do_format (2):					/* -hour */
do_format (3):					/* -minute */
do_format (5):					/* -zone */
do_format (6):					/* -day_name */
do_format (8):					/* -month */
do_format (9):					/* -day */
do_format (10):					/* -year */

	temp_argument_ptr = addr (dt_chars (dt_offset (arg_index)));

ADD_DATE:
	dt_offset_index = dt_descr_index (arg_index);
	temp_argument_descr_ptr = addr (dt_descr (dt_offset_index));
	incr_string = dt_incr_string (arg_index);
	call add_data_arg;
	go to read_loop;

do_format (25):					/* -time_format */
	argnumber = argnumber + 1;
	call get_arg_ptr_ (argnumber, arg_ptr, arglen, code);
	if code ^= 0 then do;
	     call err_ (code, whoami, "A time format string must be specified following -time_format.");
	     return;
	end;
	if arglen > length (time_format) then do;
	     call err_ ((0), whoami, "Time format strings must be ^d characters or fewer in length. ^a", length (time_format), arg);
	     return;
	end;
	temp_time_format = arg;
	on sub_error_ begin;
	     call find_condition_info_ (null (), addr (ci), code);
	     if code ^= 0 then
		call err_ ((0), whoami, "Invalid time format string. ^a", temp_time_format);
	     else do;
		sub_error_info_ptr = ci.info_ptr;
		call com_err_ (sub_error_info.status_code, whoami, "^a", sub_error_info.info_string);
	     end;
	     go to EXIT_RETURN;
	end;
	time_format_string = date_time_$format (temp_time_format, clock (), "", "");
	revert sub_error_;
	temp_time_format_flag = "1"b;
	temp_argument_ptr = addr (time_format_string);
	temp_argument_descr_ptr = addr (dt_descr (3));
	incr_string = " ^a";
	call add_data_arg;
	go to read_loop;

/* control arg stuff, not allowed if invoked as active function */

do_control_arg (1):					/* set */
	temp_set_flag = "1"b;
	go to read_loop;

do_control_arg (2):					/* -revert */

	temp_revert_flag = "1"b;
	go to read_loop;

do_control_arg (3):					/* -call */

	argnumber = argnumber +1;
	call get_arg_ptr_ (argnumber, arg_ptr, arglen, code);
	if code ^= 0 then go to no_sub_arg;

	temp_clp = arg_ptr;
	temp_cll = arglen;				/* save ptr and length */
	values_set_flag = "1"b;
	go to read_loop;

do_control_arg (4):					/* -reset */
	temp_reset_flag = "1"b;
	go to read_loop;


/* end of control args */

/* prefix args */

do_prefix (2):					/* -control */

	incr_string_flag = "0"b;

do_prefix (1):					/* -string */

	argnumber = argnumber + 1;
	call get_arg_ptr_ (argnumber, arg_ptr, arglen, code);
	if code ^= 0 then do;
no_sub_arg:
	     call err_ (code, whoami, "no argument to ^a", arg);
	     return;
	end;
	temp_ioa_string = arg;
	values_set_flag = "1"b;
	go to read_loop;

/* end of control arg code */

/* **************************************** */

add_data_arg: proc;
						/* internal procedure to add ptrs to argument_ptr(number_of_data)
						   and argument_descr_ptr(number_of_data) and update
						   num data when temp_argument_descr has been set
						   to proper descr.
						   */
	     number_of_data = number_of_data +1;
	     values_set_flag = "1"b;
	     argument_ptr (number_of_data) = temp_argument_ptr;
	     argument_descr_ptr (number_of_data) = temp_argument_descr_ptr;
	     if incr_string_flag then temp_ioa_string = temp_ioa_string || incr_string;
	end add_data_arg;


/* **************************** */

add_floating_arg: proc;

	     temp_argument_descr_ptr = addr (float_descr);
	     incr_string = " ^.3f";			/* assume default precision for now */
	     argnumber = argnumber +1;
	     call get_arg_ptr_ (argnumber, arg_ptr, arglen, code);
	     if code = 0

	     then if (arglen = 1 & arg >= "1" & arg <= "9") | arglen = 0
		then incr_string = " ^." || arg || "f";
		else go to no_precision;
	     else do;
no_precision:
		if doing_dollars then substr (incr_string, 4, 1) = "2";
		argnumber = argnumber - 1;		/* arg is keyword */
	     end;

	     if doing_dollars then do;
		incr_string = " $" || substr (incr_string, 2);
	     end;
	     call add_data_arg;

	end add_floating_arg;

/* ********************************** */

add_active_string: procedure;			/* this procedure sets up an active string */
	     number_of_data = number_of_data + 1;
	     argument_ptr (number_of_data) = null ();
	     argument_descr_ptr (number_of_data) = null ();
	     values_set_flag = "1"b;
	     if incr_string_flag then temp_ioa_string = temp_ioa_string || incr_string;
	     input_string_length = arglen;
	     if temp_last_active_string_ptr = null () then do;
		allocate active_string set (temp_last_active_string_ptr);
		temp_active_string_ptr = temp_last_active_string_ptr;
	     end;
	     else do;
		allocate active_string set (temp_last_active_string_ptr -> active_string.next_active_string_ptr);
		temp_last_active_string_ptr = temp_last_active_string_ptr -> active_string.next_active_string_ptr;
	     end;
	     temp_last_active_string_ptr -> active_string.descriptor = active_string_descr_const;
	     temp_last_active_string_ptr -> active_string.num_of_data = number_of_data;
	     temp_last_active_string_ptr -> active_string.input_string_len = input_string_length;
	     temp_last_active_string_ptr -> active_string.input_string = arg;
	     temp_last_active_string_ptr -> active_string.next_active_string_ptr = null ();
end add_active_string;

/* ********************************** */

/*  these internal subroutines should be called with arguments and
   via decode_descriptor or directly copying manage to encode
   descriptors for upwards compatibility with desc change.
   */

setup_ready: proc;

	     old.virtual_cpu_time, last.page_faults, last.pd_faults, old.paging_measure, old.page_faults, old.pd_faults,
	     old.cpu_time, old.segment_faults, old.bounds_faults, old.vtoc_reads, old.vtoc_writes = 0;
	     last_dollars, dollars_fudge = 0e0;

	     call user_info_$usage_data ((0), old.virtual_cpu_time, login_time, first_time,
		old.paging_measure);
	     call gr_get_rates_ (vcpu_rate, real_rate, process_hour_rate, kmu_rate, next_shift);
	     vcpu_rate = vcpu_rate/3.6e9;
	     real_rate = real_rate/3.6e9;
	     process_hour_rate = process_hour_rate/3.6e9;;
	     milli_mu_rate = kmu_rate/1e6;
	     online_rate = real_rate + process_hour_rate;
	     last.virtual_cpu_time = old.virtual_cpu_time;	/* make incremental work first time */
	     last.paging_measure = old.paging_measure;
	     old_dollars = float (last.virtual_cpu_time, 20)*vcpu_rate+
		float (last.paging_measure, 20)*milli_mu_rate +
		float (first_time-login_time, 20)*online_rate;
	     last_dollars = old_dollars;
	     dollars_fudge = -old_dollars;
						/* at present there is no way to obtain the value of
						   demand pages
						   for a previous process during same login. Thus these values
						   are zeroed.  Eventually Multics
						   will provide this information and
						   this program can be updated. */

	     old_n_active_strings = 0;
	     old_active_string_ptr, old_last_active_string_ptr = null ();
	     static_arg_list_ptr, arg_list_ptr = addr (ioa_arg_list);
	     temp_set_flag = "1"b;			/* want to set static values */
	     af_flag = "0"b;
	     temp_ioa_string = "r^x" || default_ioa_string;
	     call set_default_arg_list;

	     first_time_flag = "0"b;
	     if next_shift > 0 then call timer_manager_$alarm_call (next_shift, "00"b, change_shift);
	     return;
	end setup_ready;

/* **************************** */

set_default_arg_list: proc;
	     af_offset = 2*fixed (af_flag, 17, 0);
	     number_of_data = 5+af_offset;
	     arg_list_header.twice_arg_count,
		arg_list_header.twice_desc_count = 2*number_of_data;
	     arg_list_header.code = 4;
	     arg_list_header.pad = 0;

	     if temp_set_flag then do;
		ioa_string = temp_ioa_string;
		arg_ptrs (1) = addr (ioa_string);
		descr_ptrs (1) = addr (ioa_string_descr);
		descr_ptrs (1) -> based_descr.size = bit (bin (length (temp_ioa_string), 24), 24);
		old_inc_flag = "1"b;
		old_level_flag = "1"b;
		old_time_flag = "1"b;
	     end;
	     else do;
		arg_ptrs (1) = addr (addr (temp_ioa_string) -> temp_ioa_bvss.string);
		descr_ptrs (1) = addr (temp_ioa_string_descr);
		temp_ioa_string_descr.type = "010101"b;
		temp_ioa_string_descr.packed = "0"b;
		temp_ioa_string_descr.number_dims = "0000"b;
		temp_ioa_string_descr.flag = "1"b;
		string_length = length (temp_ioa_string);
		temp_ioa_string_descr.size = bit (bin (string_length, 24), 24);
		temp_inc_flag = "1"b;
		temp_level_flag = "1"b;
		temp_time_flag = "1"b;
	     end;

	     arg_ptrs (2+af_offset) = addr (time_string);
	     descr_ptrs (2+af_offset) = addr (dt_descr (3));

	     arg_ptrs (3+af_offset) = addr (inc_vcpu_time);
	     descr_ptrs (3+af_offset) = addr (float_descr);
	     arg_ptrs (4+af_offset) = addr (inc_page_faults);
	     descr_ptrs (4+af_offset) = addr (integer_descr);

	     arg_ptrs (5+af_offset) = addr (level_string);
	     descr_ptrs (5+af_offset) = addr (level_descr);

	end set_default_arg_list;

     end general_ready;
