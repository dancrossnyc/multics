/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
     This entry is being made to cover the change made on 85-04-19 by Thanh
     Nguyen. (see mrds #136)
  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
     Set the bit dbcb.dont_check_txn_id to indicate that we will have multiple
     txns across one selection_expression (because of transaction_group_size,
     see mrds #156).
                                                   END HISTORY COMMENTS */


copy_mrds_data: cpmd: procedure ();

/*
   BEGIN_DESCRIPTION:

   This command was written to assist in converting vfile_ databases
   into DMS databases, with the least impact on existing user
   application programs.  It has, however, been generalized so that
   the input and output databases can each be either a vfile_
   database or a DM database.  To copy a database, one must first
   obtain a copy of the create_mrds_db source, using the 
   display_mrds_dm command if neccessary to obtain the needed
   information.  Using a new pathname, use create_mrds_db
   to create a new database.  You now have an "unpopulated" 
   database. To get the old data into the new database, use this
   command, giving the old database pathname first, and the old
   database pathname second.  This program will then retrieve the
   data from the old database, and store it into the new database. 

   END_DESCRIPTION


   COMMAND ARGUMENTS

   input_db_path   -  -  (input)  first argument, the pathname of the old
   database that is to be copied.  

   output_db_path   -  -  (input)  second argument, the pathname of the new
   database.  

   HISTORY:

   Originally written by Donna Woodka, 82-08-23.
   Modified 82-12-20 by PWB to remove restriction of the input having to be a
            vfile_ database and the output having to be a FAMIS database.
   Modified 83-07-20 by PWB to change the opening from exclusive update to:
            input db:  open r, permit r, prevent dms
            output db: open u, permit rs, prevent dms
            and to add -input_prevent_ops, -output_prevent_ops & 
            -transaction_group_size.
   Modified 84-10-17 by PWB in an attempt to make it work with databases that
            have been restructured in a nonstandard fashion.  If this journal
            notice remains, it worked.
*/

/* Area */

	dcl     work_area		 area (sys_info$max_seg_size) based (temp_seg_ptr); /* space for tuple data */

/* Automatic */

	dcl     arg_length		 fixed bin (21);
	dcl     arg_ptr		 ptr;
	dcl     attr_bit_length	 fixed bin (35);
	dcl     data_space_ptr_ptr	 ptr;		/* ptr to array of data space ptrs */
	dcl     error_code		 fixed bin (35);	/* error status encoding */
	dcl     finished		 bit (1);		/* set when no more tuples are to be retrieved */
	dcl     first_retrieval	 bit (1);		/* on => first tuple retrieval for a relation */
	dcl     found		 bit (1);		/* on => relation name in output model found in input model */
	dcl     i			 fixed bin;	/* index thru all relations in output model */
	dcl     input_abs_path	 char (168);	/* absolute version of input database path */
	dcl     input_converted_time	 char (24);	/* character version of date/time */
	dcl     input_db_uid	 bit (36);	/* unique id for input db dir */
	dcl     input_dbi		 fixed bin (35);	/* DB index */
	dcl     input_dm_ptr	 ptr;		/* ptr to data model */
	dcl     input_dmh_ptr	 ptr;		/* points to header info */
	dcl     input_path_len	 fixed bin (21);	/* in characters */
	dcl     input_path_ptr	 ptr;
	dcl     input_rd_ptr	 ptr;		/* pointer to relation description */
	dcl     input_rel_missing	 bit (1);		/* the specified relation is missing in the input model */
	dcl     j			 fixed bin;	/* index thru all relations in input model */
	dcl     k			 fixed bin;	/* relation index for all data moves */
	dcl     l			 fixed bin;	/* index thru all attributes in present input relation */
	dcl     m			 fixed bin;	/* index thru all attributes in present output relation */
	dcl     nargs		 fixed bin;	/* current argument count */
	dcl     n			 fixed bin;	/* general index */
	dcl     n_rels_to_be_copied	 fixed bin;	/* number of relations being copied */
	dcl     op_num		 fixed bin;	/* character position within scope string */
	dcl     output_abs_path	 char (168);	/* absolute version of input database path */
	dcl     output_converted_time	 char (24);	/* character version of date/time */
	dcl     output_db_uid	 bit (36);	/* unique id for output db dir */
	dcl     output_dbcb_ptr	 ptr;		/* ptr to dbcb for output DB */
	dcl     output_dbi		 fixed bin (35);	/* DB index */
	dcl     output_dm_ptr	 ptr;		/* ptr to data model */
	dcl     output_dmh_ptr	 ptr;		/* points to header info */
	dcl     output_path_len	 fixed bin (21);	/* in characters */
	dcl     output_path_ptr	 ptr;
	dcl     output_rd_ptr	 ptr;		/* pointer to relation description */
	dcl     rel_arg_length	 fixed bin (21);	/* length of -rel operand */
	dcl     rel_arg_ptr		 ptr;		/* ptr to -rel operand */
	dcl     retrieve_al_ptr	 ptr;		/* points to arg_list for retrieve */
	dcl     retrieve_desc_index	 fixed bin;	/* array offset of descriptor pointers in arg_list */
	dcl     retrieve_select_expr	 char (53) aligned; /* "select * from relname" */
	dcl     rtbc_ptr		 ptr;		/* ptr to relations_to_be_copied structure */
	dcl     single_relation	 bit (1);		/* copying only one relation */
	dcl     specified_input_prevents
				 fixed bin;	/* prevent ops for input relation */
	dcl     specified_output_prevents
				 fixed bin;	/* prevent ops for output relation */
	dcl     store_al_ptr	 ptr;		/* points to arg_list for store */
	dcl     store_select_expr	 char (32) aligned; /* relation name for doing mrds_dsl_store */
	dcl     temp_seg_ptr	 ptr;		/* points to temp segment */
	dcl     transaction_group_size fixed bin;	/* number of tuple to be in a transaction */
						/* if = 0, don't generate transactions */
	dcl     transaction_tuple_count
				 fixed bin;	/* running count of tuples copied */
	dcl     tuples_retrieved	 fixed bin (35);	/* number of tuples copied for a relation */

/* Based */

	dcl     arg		 char (arg_length) based (arg_ptr);
	dcl     data_space		 bit (attr_bit_length) based; /* space to allocate for attribute data */
	dcl     data_space_ptr	 (input_rd_ptr -> rel_desc.num_attr) ptr based (data_space_ptr_ptr);
	dcl     output_path		 char (output_path_len) based (output_path_ptr); /* pathname of output DB */
	dcl     input_path		 char (input_path_len) based (input_path_ptr); /* pathname of input database */
	dcl     rel_arg		 char (rel_arg_length) based (rel_arg_ptr); /* operand of -rel argument */

	dcl     1 relations_to_be_copied (n_rels_to_be_copied) based (rtbc_ptr),
		2 input_rel_num	 fixed,
		2 output_rel_num	 fixed,
		2 rel_name	 char (32);

/* Builtin */

	dcl     (addr, addrel, empty, fixed, null, substr, rel, rtrim,
	        search, verify)
				 builtin;

/* Condition */

	dcl     (any_other, cleanup, sub_error_, transaction_deadlock)
				 condition;

/* Entry */

	dcl     com_err_		 entry options (variable);
	dcl     cu_$arg_count	 entry (fixed bin);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
	dcl     cu_$generate_call	 entry (entry, ptr);
	dcl     date_time_		 entry (fixed bin (71), char (*));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
	dcl     hcs_$status_long	 entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
	dcl     ioa_		 entry options (variable);
	dcl     mrds_dm_close	 entry (ptr, fixed bin (35));
	dcl     mrds_dm_get_header	 entry (ptr, ptr, ptr, fixed bin (35));
	dcl     mrds_dm_get_attributes entry (ptr, char (32), ptr, ptr, fixed bin (35));
	dcl     mrds_dm_open	 entry (char (168), fixed bin, ptr, fixed bin (35));
	dcl     mrds_dsl_close	 entry options (variable);
	dcl     mrds_dsl_get_version$get_path_info entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
	dcl     mrds_dsl_open	 entry options (variable);
	dcl     mrds_dsl_retrieve	 entry options (variable);
	dcl     mrds_dsl_set_scope$dl_scope
				 entry options (variable);
	dcl     mrds_dsl_set_scope$set_scope
				 entry options (variable);
	dcl     mrds_dsl_store	 entry options (variable);
	dcl     mu_data_class$varying	 entry (ptr) returns (bit (1) aligned);
	dcl     mu_data_length	 entry (bit (36)) returns (fixed bin (35));
	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35),
				 ptr);
	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));

/* External */

	dcl     error_table_$bad_arg	 fixed bin (35) ext;
	dcl     error_table_$badcall	 fixed bin (35) ext static;
	dcl     error_table_$badopt	 fixed bin (35) ext static;
	dcl     error_table_$noarg	 fixed bin (35) ext static;
	dcl     error_table_$sameseg	 fixed bin (35) ext static;
	dcl     mrds_error_$no_database fixed bin (35) ext static;
	dcl     mrds_error_$no_model_submodel fixed bin (35) ext static;
	dcl     mrds_error_$rst_wrong_command fixed bin (35) ext;
	dcl     mrds_error_$tuple_not_found fixed bin (35) ext;
	dcl     mrds_error_$undef_attr fixed bin (35) ext;
	dcl     mrds_error_$unknown_relation_name fixed bin (35) ext;
	dcl     mrds_error_$version_not_supported fixed bin (35) ext static;
	dcl     sys_info$max_seg_size	 fixed bin (35) ext;

/* Internal Static */

	dcl     ANOTHER_RETRIEVAL_SELECT_EXPR char (8) aligned internal static options (constant)
				 init ("-another"); /* for second until EOF retrievals */
	dcl     CALLER_NAME		 char (15) internal static options (constant)
				 init ("copy_mrds_data");
	dcl     CHAR_8_DESCR	 bit (36) internal static options (constant)
				 init ("101010100000000000000000000000001000"b);
	dcl     CHAR_32_DESCR	 bit (36) internal static options (constant)
				 init ("101010100000000000000000000000100000"b);
	dcl     CHAR_53_DESCR	 bit (36) internal static options (constant)
				 init ("101010100000000000000000000000110101"b);
	dcl     FIXED_BIN_35_DESCR	 bit (36) internal static options (constant)
				 init ("100000100000000000000000000000100011"b);
	dcl     ON		 bit (1) internal static options (constant)
				 init ("1"b);
	dcl     OFF		 bit (1) internal static options (constant)
				 init ("0"b);
	dcl     PAREN_SELECT	 char (11) internal static options (constant)
				 init (") -select x");
	dcl     RANGE_PAREN		 char (10) internal static options (constant)
				 init ("-range (x ");
	dcl     RETRIEVAL_MODE	 fixed bin internal static options (constant)
				 init (2);

/* Include */

%include mdbm_arg_list;

%include mdbm_descriptor;

%include mdbm_rm_attr_info;

%include mdbm_rm_db_info;

%include mdbm_rm_domain_info;

%include mdbm_rm_rel_array;

%include mdbm_rm_rel_info;

%include mrds_dbcb;

%include mrds_path_info;

%include mrds_dm_header;

%include mrds_model_relations;

%include mrds_rel_desc;

%include mrds_new_scope_modes;

%include mrds_opening_modes_;

%include status_structures;

/* Program */


/* set up the input and output reference names, and get temp storage */

	call initialize;

	on cleanup call clean_up;			/* establish cleanup handler */

/* make sure the argument list is correct */

	call check_args;

/* check for duplicate pathnames */

	if duplicate_paths ()			/* the pathnames are the same */
	then call error (error_table_$sameseg, "");

/* begin moving the data */

	call copy_database_data ();			/* copy input data into the output database */

	call clean_up;
exit:	return;

check_args: procedure;

/* check_args is called by the main routine */

	call cu_$arg_count (nargs);
	if nargs < 2
	then call error (error_table_$noarg,
		"^/Usage: copy_mrds_data input_db_path output_db_path {-ctl_args}");

/* get the input pathname argument */

	call cu_$arg_ptr (1, input_path_ptr, input_path_len, error_code);
	if error_code ^= 0
	then call error (error_code, "Getting first argument.");

	if substr (input_path, 1, 1) = "-"
	then call error (error_table_$noarg, "^/First argument should be the input pathname.");

/* check for correct input version */

	call mrds_dsl_get_version$get_path_info (input_path, temp_seg_ptr,
	     mrds_path_info_structure_version, mrds_path_info_ptr, error_code);
	if mrds_path_info_ptr = null
	then input_abs_path = input_path;
	else input_abs_path = mrds_path_info.absolute_path;

	if error_code ^= 0
	then do;
		if error_code = mrds_error_$no_model_submodel
		then error_code = mrds_error_$no_database;

		call error (error_code, "^/" || input_abs_path);
	     end;
	if mrds_path_info.mrds_version ^= 4
	then call error (mrds_error_$version_not_supported, "/^The input database must be a version 4 database.");
	if mrds_path_info.type.submodel
	then call error (error_table_$badcall,
		"^/Data submodels are not supported by this command.  " || input_abs_path);

/* get the output pathname argument */

	call cu_$arg_ptr (2, output_path_ptr, output_path_len, error_code);
	if error_code ^= 0
	then call error (error_code, "Getting second argument.");
	if substr (output_path, 1, 1) = "-"
	then call error (error_table_$noarg,
		"^/Second argument should be the output pathname.");

	call mrds_dsl_get_version$get_path_info (output_path, temp_seg_ptr,
	     mrds_path_info_structure_version, mrds_path_info_ptr, error_code);
	if mrds_path_info_ptr = null
	then output_abs_path = output_path;
	else output_abs_path = mrds_path_info.absolute_path;

	if error_code ^= 0
	then do;
		if error_code = mrds_error_$no_model_submodel
		then error_code = mrds_error_$no_database;

		call error (error_code, "^/" || output_abs_path);
	     end;

	if mrds_path_info.type.submodel
	then do;
		call com_err_ (error_table_$badcall, CALLER_NAME,
		     "^/Data submodels are not supported by this command.  ^a", input_abs_path);
		call clean_up ();
		goto exit;
	     end;


	do n = 3 to nargs;


	     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
	     if error_code ^= 0
	     then call error (error_code, "");
	     else if substr (arg, 1, 1) ^= "-"
	     then call error (error_table_$bad_arg, arg);
	     else if arg = "-relation" | arg = "-rel"
	     then do;
		     if n = nargs
		     then do;
			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
			     call clean_up;
			     goto exit;
			end;
		     else n = n + 1;
		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
		     if error_code ^= 0
		     then call error (error_code, "");
		     single_relation = "1"b;
		     rel_arg_ptr = arg_ptr;
		     rel_arg_length = arg_length;
		end;
	     else if arg = "-input_prevent_ops"
	     then do;
		     if n = nargs
		     then do;
			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
			     call clean_up;
			     goto exit;
			end;
		     else n = n + 1;
		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
		     if error_code ^= 0
		     then call error (error_code, "");
		     specified_input_prevents = 0;
		     if arg ^= "n" then do;		/* if non-null op. */
			     op_num = verify (arg, "aursdm");
			     if op_num ^= 0 then do;	/* invalid code */
				     call com_err_ (error_table_$bad_arg, CALLER_NAME,
					"Invalid scope code: ^a. ^/^-Valid codes are: n, r, a or s, d, m, and u = ""a+d+m""",
					substr (arg, op_num, 1));
				     call clean_up;
				     goto exit;
				end;
			     if search (arg, "r") ^= 0
			     then specified_input_prevents =
				     specified_input_prevents + READ_ATTR; /* convert to number */
			     if search (arg, "s") ^= 0 | search (arg, "a") ^= 0
			     then specified_input_prevents =
				     specified_input_prevents + APPEND_TUPLE;
			     if search (arg, "d") ^= 0
			     then specified_input_prevents =
				     specified_input_prevents + DELETE_TUPLE;
			     if search (arg, "m") ^= 0
			     then specified_input_prevents =
				     specified_input_prevents + MODIFY_ATTR;
			     if search (arg, "u") ^= 0
			     then specified_input_prevents =
				     specified_input_prevents + UPDATE_OPS;
			end;
		end;
	     else if arg = "-output_prevent_ops"
	     then do;
		     if n = nargs
		     then do;
			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
			     call clean_up;
			     goto exit;
			end;
		     else n = n + 1;
		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
		     if error_code ^= 0
		     then call error (error_code, "");
		     specified_output_prevents = 0;
		     if arg ^= "n" then do;		/* if non-null op. */
			     op_num = verify (arg, "aursdm");
			     if op_num ^= 0 then do;	/* invalid code */
				     call com_err_ (error_table_$bad_arg, CALLER_NAME,
					"Invalid scope code: ^a. ^/^-Valid codes are: n, r, a or s, d, m, and u = ""a+d+m""",
					substr (arg, op_num, 1));
				     call clean_up;
				     goto exit;
				end;
			     if search (arg, "r") ^= 0
			     then specified_output_prevents =
				     specified_output_prevents + READ_ATTR; /* convert to number */
			     if search (arg, "s") ^= 0 | search (arg, "a") ^= 0
			     then specified_output_prevents =
				     specified_output_prevents + APPEND_TUPLE;
			     if search (arg, "d") ^= 0
			     then specified_output_prevents =
				     specified_output_prevents + DELETE_TUPLE;
			     if search (arg, "m") ^= 0
			     then specified_output_prevents =
				     specified_output_prevents + MODIFY_ATTR;
			     if search (arg, "u") ^= 0
			     then specified_output_prevents =
				     specified_output_prevents + UPDATE_OPS;
			end;
		end;
	     else if arg = "-transaction_group_size"
	     then do;
		     if n = nargs
		     then do;
			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
			     call clean_up;
			     goto exit;
			end;
		     else n = n + 1;
		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
		     if error_code ^= 0
		     then call error (error_code, "");
		     if verify (arg, "1234567890") ^= 0
		     then call com_err_ (error_table_$bad_arg, "The operand to -transaction_group_size must be an integer.");
		     transaction_group_size = fixed (arg);
		end;
	     else call error (error_table_$badopt, arg);
	end;


     end check_args;

duplicate_paths: procedure returns (bit (1));

/* duplicate_paths is called by convert_database */

/* this routine check to see if the input and output input paths
   are to the same database. */

	equal = ON;
	call get_database_uid (output_abs_path, output_db_uid);
	call get_database_uid (input_abs_path, input_db_uid);
	if input_db_uid ^= output_db_uid
	then equal = OFF;

	return (equal);

	dcl     equal		 bit (1);		/* on => same path for both db's */

     end duplicate_paths;

initialize: procedure;

/* called by main routine */

/* initialize variables */

	data_space_ptr_ptr, input_dm_ptr, input_dmh_ptr, output_dm_ptr,
	     output_dmh_ptr, retrieve_al_ptr, rtbc_ptr, status_ptr,
	     store_al_ptr, temp_seg_ptr = null ();

	input_dbi, output_dbi, transaction_group_size = 0;

	single_relation = "0"b;

	specified_input_prevents, specified_output_prevents = UPDATE_OPS;

/* get the temporary storage space */

	call get_temp_segment_ (CALLER_NAME, temp_seg_ptr, error_code);
	if error_code ^= 0
	then call error (error_code, "");

	work_area = empty ();			/* init work area in temp segment */

     end initialize;

copy_database_data: procedure ();

/* copy_database_data is called by main routine */

/* copy data from a input  database, into a output database. */

	on sub_error_ ;				/* ignore subroutine error messages */

/* open the input and output databases and data models */

	call open_input_db ();
	call open_output_db ();

/* make sure we aren't copying apples to oranges */

	call compare_relations ();

/* copy the input database data into the output database,
   one relation at a time, checking for identical attribute
   makeup of the input and output relations. */

	call copy_relation_data ();

	call ioa_ ("^/Update complete, closing data models.");

     end copy_database_data;

open_input_db: procedure ();

/* open the input database and datamodel using the supplied pathname,
   and then output the header information for the datamodel */


	call mrds_dsl_open (input_abs_path, input_dbi, RETRIEVAL, error_code);
	if error_code ^= 0
	then do;
		input_dbi = 0;
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "Unable to open """, input_abs_path, """.");
		call clean_up;
		goto exit;
	     end;
	call mrds_dm_open (input_abs_path, RETRIEVAL_MODE, input_dm_ptr, error_code);
	if error_code ^= 0
	then do;
		input_dm_ptr = null ();
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "Unable to open data model for """, input_abs_path, """.");
		call clean_up;
		goto exit;
	     end;

/* output the header information for each version model */

	call mrds_dm_get_header (input_dm_ptr, temp_seg_ptr, input_dmh_ptr, error_code);
	if error_code ^= 0
	then call error (error_code, input_abs_path);
	call date_time_ (input_dmh_ptr -> dm_header.create_time, input_converted_time);
	call ioa_ ("^/Opening data model: ^a^/^5xCreated: ^a^/^5xVersion: ^d^/^5xBy: ^a",
	     input_abs_path, input_converted_time,
	     input_dmh_ptr -> dm_header.dmd_version, input_dmh_ptr -> dm_header.creator_id);

	if input_dmh_ptr -> dm_header.dmd_version < 4
	then call error (mrds_error_$rst_wrong_command, "The input database must be a version 4 database.");

     end open_input_db;

open_output_db: procedure ();

/* open the output database and datamodel using the supplied pathname,
   and then output the header information for the datamodel */

	call mrds_dsl_open (output_abs_path, output_dbi, UPDATE, error_code);
	if error_code ^= 0
	then do;
		output_dbi = 0;
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "Unable to open """, output_abs_path, """.");
		call clean_up;
		goto exit;
	     end;

	call mrds_dm_open (output_abs_path, RETRIEVAL_MODE, output_dm_ptr, error_code);
	if error_code ^= 0
	then do;
		output_dm_ptr = null ();
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "Unable to open the datamodel for """, output_abs_path, """.");
		call clean_up;
		goto exit;
	     end;

/* output the header information for each version model */

	call mrds_dm_get_header (output_dm_ptr, temp_seg_ptr, output_dmh_ptr, error_code);
	if error_code ^= 0
	then call error (error_code, output_abs_path);

	call date_time_ (output_dmh_ptr -> dm_header.create_time,
	     output_converted_time);
	call ioa_ ("^/Opening data model: ^a^/^5xCreated: ^a^/^5xVersion: ^d^/^5xBy: ^a^/",
	     output_abs_path, output_converted_time,
	     output_dmh_ptr -> dm_header.dmd_version,
	     output_dmh_ptr -> dm_header.creator_id);

     end open_output_db;

compare_relations: procedure ();

/* make sure that the input and output databases have the same relations */

	call mu_database_index$get_resultant_model_pointer (input_dbi, dbcb_ptr);
	call mu_database_index$get_resultant_model_pointer (output_dbi, output_dbcb_ptr);

/* first check that the number of relations match */

	if ^single_relation &
	     (dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels ^=
	     output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels)
	then call error (error_table_$badcall, "^/The 2 databases must have the same number of relations.");

	if single_relation
	then n_rels_to_be_copied = 1;
	else n_rels_to_be_copied = dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels;
	allocate relations_to_be_copied in (work_area);

	call match_relation_names ();			/* check for consistency */

     end compare_relations;

match_relation_names: procedure ();

/* compare the input relation list names to the output names */

	if single_relation
	then do;
		found = OFF;
		do i = 1 to dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (^found);
		     if dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (i) = rel_arg
		     then do;
			     found = ON;
			     relations_to_be_copied.input_rel_num (1) = i;
			end;
		end;

		if ^found
		then do;
			error_code = mrds_error_$unknown_relation_name;
			input_rel_missing = ON;
		     end;

		else do;
			found = OFF;
			do i = 1 to output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (^found);
			     if output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (i) = rel_arg
			     then do;
				     found = ON;
				     relations_to_be_copied.output_rel_num (1) = i;
				     relations_to_be_copied.rel_name (1) = rel_arg;
				end;
			end;
			if ^found
			then do;
				error_code = mrds_error_$unknown_relation_name;
				input_rel_missing = OFF;
			     end;
		     end;
		if ^found
		then do;
			call com_err_ (mrds_error_$unknown_relation_name,
			     CALLER_NAME,
			     "^/The relation ^a was specified but not found in the ^[input^;output^] model.",
			     rel_arg,
			     (input_rel_missing = ON));
			call clean_up;
			goto exit;
		     end;
	     end;
	else do;


		do i = 1 to dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (error_code = 0);

		     found = OFF;

		     do j = 1 to dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (^found & error_code = 0);

			if output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (i) =
			     dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (j)
			then do;
				found = ON;
				relations_to_be_copied.input_rel_num (i) = j;
				relations_to_be_copied.output_rel_num (i) = i;
				relations_to_be_copied.rel_name (i) =
				     output_dbcb_ptr ->
				     dbcb.data.rdbi_ptr ->
				     rm_db_info.data.ra_ptr ->
				     rm_rel_array.rel_data.model_name (i);
			     end;

			else if j = dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels
			then error_code = mrds_error_$unknown_relation_name;
		     end;

		end;

		if error_code ^= 0
		then do;

			call com_err_ (error_code,
			     CALLER_NAME,
			     "^/^a^a^a",
			     "The relation """,
			     output_dbcb_ptr ->
			     dbcb.data.rdbi_ptr ->
			     rm_db_info.data.ra_ptr ->
			     rm_rel_array.rel_data.model_name (i - 1),
			     """ was not found in the input datamodel, but was in the output model.");
			call clean_up;
			goto exit;
		     end;
	     end;
     end match_relation_names;

copy_relation_data: procedure ();

/* for each relation in the database, this routine will go through
   one relation at a time, and copy all tuples for that relation
   from the input database into the output database. */


	do k = 1 to n_rels_to_be_copied while (error_code = 0);

/* get the input and output data model attribute
   descriptions and attribute make up for this relation */

	     call set_scope;

	     call get_relation_attributes ();

/* make sure that the attribute make up of the relations agree */

	     call compare_attributes ();

/* make an argument structure for calls to mrds_dsl_retrieve */

	     call build_retrieve_argument_list;

/* make an argument structure for calls to mrds_dsl_store */

	     call build_store_argument_list ();

/* while their are tuples left, retrieve them from the
   input database and store them into the output database */

	     call copy_tuples ();

/* free the space used for argument lists and attribute data space */

	     call free_arg_lists ();

	     call delete_scope;

	end;

     end copy_relation_data;

set_scope:
     procedure;

/* for this current relation, set scope on both input and output */

	call mrds_dsl_set_scope$set_scope (input_dbi, relations_to_be_copied.rel_name (k), READ_ATTR, specified_input_prevents, error_code);

	if error_code ^= 0
	then do;
		call com_err_ (error_code, CALLER_NAME, "^/Setting scope on relation ^a of input database.", relations_to_be_copied.rel_name (k));
		call clean_up;
		goto exit;
	     end;

	call mrds_dsl_set_scope$set_scope (output_dbi, relations_to_be_copied.rel_name (k), APPEND_TUPLE, specified_output_prevents, error_code);

	if error_code ^= 0
	then do;
		call com_err_ (error_code, CALLER_NAME, "^/Setting scope on relation ^a of output database.", relations_to_be_copied.rel_name (k));
		call clean_up;
		goto exit;
	     end;

     end set_scope;

get_relation_attributes: procedure ();

/* for this current relation, get the attribute make up
   and attribute descriptions for this relation */

	call mrds_dm_get_attributes (input_dm_ptr, relations_to_be_copied.rel_name (k),
	     temp_seg_ptr, input_rd_ptr, error_code);
	if error_code ^= 0
	then do;
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "Getting attribute descriptions for input relation """,
		     relations_to_be_copied.rel_name (k), """.");
		call clean_up;
		goto exit;
	     end;

	call mrds_dm_get_attributes (output_dm_ptr,
	     relations_to_be_copied.rel_name (k),
	     temp_seg_ptr, output_rd_ptr, error_code);
	if error_code ^= 0
	then do;
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "Getting attribute descriptions for output relation """,
		     relations_to_be_copied.rel_name (k), """.");
		call clean_up;
		goto exit;
	     end;

     end get_relation_attributes;

compare_attributes: procedure ();

/* make sure the attribute descriptions still match,
   first checking that attribute counts are equal, as well as key counts. */

	if input_rd_ptr -> rel_desc.num_attr ^= output_rd_ptr -> rel_desc.num_attr |
	     input_rd_ptr -> rel_desc.num_keys ^= output_rd_ptr -> rel_desc.num_keys
	then do;
		error_code = mrds_error_$rst_wrong_command;
		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
		     "The number of attributes, or key attributes, for relation """,
		     relations_to_be_copied.rel_name (k),
		     """ are not the same in the output and input data model.");
		call clean_up;
		goto exit;
	     end;


/* go through all output attributes, making sure there is a corresponding input attribute */

	do l = 1 to output_rd_ptr -> rel_desc.num_attr while (error_code = 0);
	     found = OFF;
	     m = 1;
	     do m = 1 to input_rd_ptr -> rel_desc.num_attr while (^found & error_code = 0);

/* see if this attribute has a matching name */

		if input_rd_ptr -> rel_desc.attributes.attribute_name (m) =
		     output_rd_ptr -> rel_desc.attributes.attribute_name (l)
		then do;

			found = ON;
			if input_rd_ptr -> rel_desc.attributes.key_flag (m) ^=
			     output_rd_ptr -> rel_desc.attributes.key_flag (l) &
			     input_rd_ptr -> rel_desc.attributes.descriptor (m) ^=
			     output_rd_ptr -> rel_desc.attributes.descriptor (l)
			then do;
				call com_err_ (error_code, CALLER_NAME, "^/^a^a^a^a^a^a",
				     " The attribute """,
				     output_rd_ptr -> rel_desc.attributes.attribute_name (l),
				     """ in relation """, relations_to_be_copied.rel_name (k),
				     """ does not agree in input and output datamodels as to being either a",
				     "key attribute or its data type.");
				call clean_up;
				goto exit;
			     end;
		     end;

		else if m = input_rd_ptr -> rel_desc.num_attr /* go on to next attribute */
		then error_code = mrds_error_$undef_attr;
	     end;

/* report non-matching attribute name found, if necessary */

	     if error_code = mrds_error_$undef_attr
	     then do;
		     call com_err_ (error_code, CALLER_NAME, "^/^a^a^a^a",
			"The attribute """, output_rd_ptr -> rel_desc.attributes.attribute_name (l),
			""" is not defined in the input relation """,
			dbcb.data.rdbi_ptr ->
			rm_db_info.data.ra_ptr ->
			rm_rel_array.rel_data.model_name (k),
			""" ");
		     call clean_up;
		     goto exit;
		end;
	end;
     end compare_attributes;

build_retrieve_argument_list:
     proc ();

/* this routine builds up an argument list for a call to mrds_dsl_retrieve
   that makes it look like it was called thusly:

   call mrds_dsl_retrieve (database_index, selection_expression, 
		       value1, value1, ..., valueN, code);
*/

	retrieve_desc_index = input_rd_ptr -> rel_desc.num_attr + 3;

	num_ptrs = retrieve_desc_index * 2;

	allocate arg_list set (retrieve_al_ptr) in (work_area);

	retrieve_al_ptr -> arg_list.code = 4;

	retrieve_al_ptr -> arg_list.arg_count = num_ptrs;

	retrieve_al_ptr -> arg_list.desc_count = num_ptrs;

	retrieve_al_ptr -> arg_des_ptr (1) = addr (input_dbi);

	retrieve_al_ptr -> arg_des_ptr (1 + retrieve_desc_index) = addr (FIXED_BIN_35_DESCR);

	retrieve_select_expr = RANGE_PAREN || relations_to_be_copied.rel_name (k);

	retrieve_select_expr = rtrim (retrieve_select_expr) || PAREN_SELECT;

	retrieve_al_ptr -> arg_des_ptr (2) = addr (retrieve_select_expr);

	retrieve_al_ptr -> arg_des_ptr (2 + retrieve_desc_index) = addr (CHAR_53_DESCR);

	allocate data_space_ptr in (work_area);

	do n = 3 to retrieve_desc_index - 1;
	     attr_bit_length =
		mu_data_length (
		(dbcb.data.rdbi_ptr
		-> rm_db_info.data.ra_ptr
		-> rm_rel_array.rel_data.ri_ptr (relations_to_be_copied.input_rel_num (k))
		-> rm_rel_info.attr_ptrs (n - 2)
		-> rm_attr_info.domain_ptr
		-> rm_domain_info.user_desc));
	     allocate data_space set (data_space_ptr (n - 2)) in (work_area);

	     if mu_data_class$varying (addr
		(dbcb.data.rdbi_ptr
		-> rm_db_info.data.ra_ptr
		-> rm_rel_array.rel_data.ri_ptr (relations_to_be_copied.input_rel_num (k))
		-> rm_rel_info.attr_ptrs (n - 2)
		-> rm_attr_info.domain_ptr
		-> rm_domain_info.user_desc))
	     then retrieve_al_ptr -> arg_des_ptr (n) = addrel (data_space_ptr (n - 2), 1);
	     else retrieve_al_ptr -> arg_des_ptr (n) = data_space_ptr (n - 2);

	     retrieve_al_ptr -> arg_des_ptr (n + retrieve_desc_index) =
		addr (dbcb.data.rdbi_ptr
		-> rm_db_info.data.ra_ptr
		-> rm_rel_array.rel_data.ri_ptr (relations_to_be_copied.input_rel_num (k))
		-> rm_rel_info.attr_ptrs (n - 2)
		-> rm_attr_info.domain_ptr
		-> rm_domain_info.user_desc);		/* whew! */
	end;

	retrieve_al_ptr -> arg_des_ptr (retrieve_desc_index) = addr (error_code);
	retrieve_al_ptr -> arg_des_ptr (2 * retrieve_desc_index) = addr (FIXED_BIN_35_DESCR);
     end build_retrieve_argument_list;

build_store_argument_list: procedure ();

/* this routine builds up an argument list for a call to mrds_dsl_store
   that makes it look like it was called with the arguments
   call mrds_dsl_store(database_index, relation_expression, attribute_1, ..., attribute_n, error_code)
   for all attributes in the current relation, and with relation expression
   being the current relation name, so successive tuples my be stored. */

	allocate arg_list set (store_al_ptr) in (work_area);

	store_al_ptr -> arg_list = retrieve_al_ptr -> arg_list;

/* only the database index, and selection expression arguments differ
   between the retrieve and store argument lists */

	store_al_ptr -> arg_list.arg_des_ptr (1) = addr (output_dbi);

	store_al_ptr -> arg_list.arg_des_ptr (2) = addr (store_select_expr);

	store_al_ptr -> arg_list.arg_des_ptr (retrieve_desc_index + 2) = addr (CHAR_32_DESCR);

	store_select_expr = relations_to_be_copied.rel_name (k);

     end;

copy_tuples: procedure ();

/* this routine uses the argument lists built for the retrieve and store,
   with its use of cu_$generate_call to mrds_dsl_retrieve, and mrds_dsl_store,
   to sucessively retrieve tuples from the input datbase, and store them into 
   the output database, until all tuples for this relation have been copied. */

	tuples_retrieved, mftxn_code = 0;
	first_retrieval = ON;
	finished = OFF;
	transaction_tuple_count = transaction_group_size;
	if transaction_group_size ^= 0		/* user wants us to handle transactions */
	then do;
	          dbcb.data.dont_check_txn_id = "1"b;
		if dbcb.data.transactions_needed	/* see if input db is protected */
		then mstxn_transactions_needed = "1"b;
		else do;				/* if not, check output db */
			call mu_database_index$get_resultant_model_pointer (output_dbi, output_dbcb_ptr);
			mstxn_transactions_needed = output_dbcb_ptr -> dbcb.data.transactions_needed;
		     end;
	     end;

retrieve_tuple:
	if transaction_group_size = 0
	then goto dont_start_the_transaction;
	if transaction_tuple_count < transaction_group_size
	then goto dont_start_the_transaction;
	transaction_tuple_count = 0;
	mstxn_txn_id = "0"b;
	on any_other call mstxn_any_other;
	on cleanup begin;
		call mstxn_cleanup;
		call clean_up;
	     end;
	on transaction_deadlock begin;
		mftxn_code = dm_error_$lock_deadlock;
		mstxn_retries = 100;		/* fake the include file into not retrying */
		goto mftxn_check_code;
	     end;

%include mrds_start_transaction;

	if mstxn_code ^= 0
	then call error (mstxn_code, "Unable to start a transaction.");

	dbcb.user_started_transaction = user_started_transaction;

dont_start_the_transaction:
	call cu_$generate_call (mrds_dsl_retrieve, retrieve_al_ptr);
	if error_code ^= 0
	then finished = ON;
	else do;
		tuples_retrieved = tuples_retrieved + 1;
		transaction_tuple_count = transaction_tuple_count + 1;
		call cu_$generate_call (mrds_dsl_store, store_al_ptr);
		if error_code ^= 0
		then finished = ON;
		if first_retrieval & ^finished
		then do;
			first_retrieval = OFF;
			retrieve_al_ptr -> arg_list.arg_des_ptr (2) = addr (ANOTHER_RETRIEVAL_SELECT_EXPR);
			retrieve_al_ptr -> arg_list.arg_des_ptr (retrieve_desc_index + 2) = addr (CHAR_8_DESCR);
		     end;
	     end;
	if error_code = mrds_error_$tuple_not_found
	then do;
		error_code = 0;
		call ioa_ ("Copied ^4d tuples from relation ^a.",
		     tuples_retrieved, relations_to_be_copied.rel_name (k));
	     end;

	if transaction_group_size = 0
	then goto dont_finish_the_transaction;
	if transaction_tuple_count < transaction_group_size & ^finished
	then goto dont_finish_the_transaction;
	mftxn_code = error_code;

%include mrds_finish_transaction;

	revert any_other;
	revert transaction_deadlock;
	on cleanup call clean_up;
dont_finish_the_transaction:
	if error_code ^= 0
	then call error (error_code, "");
	if mftxn_code ^= 0
	then call error (mftxn_code, "");
	if ^finished
	then goto retrieve_tuple;
should_rollback:
     procedure returns (bit (1));
	return ("0"b);
     end should_rollback;
restore_significant_data:
     procedure;
     end restore_significant_data;

     end copy_tuples;

free_arg_lists: procedure ();

/* this routine frees the existing argument lists, and data space for attributes,
   so that the same space can be reused for each relation */


	if store_al_ptr ^= null
	then free store_al_ptr -> arg_list in (work_area);

	if retrieve_al_ptr ^= null
	then free retrieve_al_ptr -> arg_list in (work_area);

	if data_space_ptr_ptr ^= null
	then do;
		do n = 1 to input_rd_ptr -> rel_desc.num_attr;
		     if data_space_ptr (n) ^= null
		     then free data_space_ptr (n) -> data_space;
		end;
		free data_space_ptr;
	     end;




     end free_arg_lists;

delete_scope:
     procedure;

/* for this current relation, delete scope on both input and output */

	call mrds_dsl_set_scope$dl_scope (input_dbi, relations_to_be_copied.rel_name (k), READ_ATTR, specified_input_prevents, error_code);

	if error_code ^= 0
	then do;
		call com_err_ (error_code, CALLER_NAME, "^/Deleting scope on relation ^a of input database.", relations_to_be_copied.rel_name (k));
		call clean_up;
		goto exit;
	     end;

	call mrds_dsl_set_scope$dl_scope (output_dbi, relations_to_be_copied.rel_name (k), APPEND_TUPLE, specified_output_prevents, error_code);

	if error_code ^= 0
	then do;
		call com_err_ (error_code, CALLER_NAME, "^/Deleting scope on relation ^a of output database.", relations_to_be_copied.rel_name (k));
		call clean_up;
		goto exit;
	     end;
     end;

get_database_uid: procedure (path, db_uid);

/* this routine turns a path into a pointer for comparison purposes */

	call expand_pathname_ (path, dir, entry, error_code);
	if error_code ^= 0
	then call error (error_code, path);

	allocate status_branch set (status_ptr) in (work_area); /* get space for answer */

	call hcs_$status_long (dir, entry, 1, status_ptr, temp_seg_ptr, error_code);

	if error_code ^= 0
	then do;
		free status_ptr -> status_branch in (work_area);
		call error (error_code, path);
	     end;

	db_uid = status_ptr -> status_branch.uid;

	free status_ptr -> status_branch in (work_area);

	declare path		 char (168);	/* absolute path input */
	declare dir		 char (168);	/* direcotry portion */
	declare entry		 char (32);	/* entry portion */
	declare db_uid		 bit (36);	/* unique id of directory given by input path */

     end get_database_uid;

error: procedure (err_code, err_message);

	dcl     err_code		 fixed bin (35);
	dcl     err_message		 char (*);
	dcl     saved_code		 fixed bin (35);

	saved_code = err_code;
	call com_err_ (saved_code, CALLER_NAME, err_message);
	call clean_up;
	go to exit;

     end error;

clean_up: procedure ();

/* get rid of temporary storage, and close any open databases or datamodels */

	if status_ptr ^= null
	then free status_ptr -> status_branch;

	if rtbc_ptr ^= null
	then free relations_to_be_copied;

	call free_arg_lists;
	dbcb.data.dont_check_txn_id = "0"b;
	
	if input_dbi ^= 0
	then do;
		call mrds_dsl_close (input_dbi, error_code);
		if error_code ^= 0
		then call com_err_ (error_code, CALLER_NAME, "^/^a ^d ^a",
			"Unable to close the input database using index", input_dbi, ".");
		input_dbi = 0;
	     end;

	if output_dbi ^= 0
	then do;
		call mrds_dsl_close (output_dbi, error_code);
		if error_code ^= 0
		then call com_err_ (error_code, CALLER_NAME, "^/^a ^d ^a",
			"Unable to close the output database using index", output_dbi, ".");
		output_dbi = 0;
	     end;

	if input_dm_ptr ^= null ()
	then do;
		call mrds_dm_close (input_dm_ptr, error_code);
		if error_code ^= 0
		then call com_err_ (error_code, CALLER_NAME, "^/Unable to close the input datamodel.");
		input_dm_ptr = null ();
	     end;

	if output_dm_ptr ^= null ()
	then do;
		call mrds_dm_close (output_dm_ptr, error_code);
		if error_code ^= 0
		then call com_err_ (error_code, CALLER_NAME, "^/Unable to close the output datamodel.");
		output_dm_ptr = null ();
	     end;

	if temp_seg_ptr ^= null ()
	then do;
		call release_temp_segment_ (CALLER_NAME, temp_seg_ptr, error_code);
		if error_code ^= 0
		then call com_err_ (error_code, CALLER_NAME);
		temp_seg_ptr = null ();
	     end;

     end clean_up;

     end copy_mrds_data;
