/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* DESCRIPTION:

		      BEGIN_DESCRIPTION
   This procedure provides a command interface to the Multics Relational Data Store (MRDS)
   Data Sub Language (DSL).  This interface is not intended to be a true End User Facility, but
   rather is intended to  be used as an instructional tool when introducing new users to the
   MRDS.  Also, mrds_call will be useful to data base application programmers as an experimental
   vehicle during the development of MRDS application programs.
		       END_DESCRIPTION
*/

/* PARAMETERS:

   operation - - (input) the first argument corresponding to the dsl routine
   to be called from command level, such as "open" for mrds_dsl_open

   operation_args - - (input) the second and succeeding arguments, this varies
   depending on the operation called, for example "ready_file database_index file_name file_ready_mode"
   are the arguments needed for ready_file
   most mrds_call operations and their arguments are documented in the MRDS manual AW53

   (output) error messages, ready/open lists, and terminal output of
   command results, such as tuples returned by retrieve
*/

mrds_call: mrc: proc;

/* HISTORY:

   76-08-01 J. A. Weeldreyer: Initially written.

   76-10-01  J.  A.  Weeldreyer:  Modified  to  fix  arg.  aquisition  problem   in
   define_temp_rel operation.

   77-09-01 O. D. Friesen and J. A. Weeldreyer: Modified for MR6.0.

   79-07-01 Jim Gray: Modified to  1)  correct  MR7  version  of  list_dbs  2)  add
   list_files   operation,   and  incorporate  in  ready_file  3)  improve  integer
   conversion error messages  4)  add  set_modes  operation  with  list  and  error
   suboperations 5) add the "-all" option to the close, ready_file, and finish_file
   operations 6) add operations listing to the "no operation given  error"  7)  put
   work area in temp segment, instead of system_free_

   80-01-01 Mary Ward: Modified to eliminate ready_file,  finish_file,  list_files,
   set_fscope,  set_fscope_all,  dl_fscope,  and  dl_fscope_all, to require the old
   open syntax, and to improve error messages.

   80-06-01 Jim Gray: Modified  to  change  method  of  remembering  open  database
   pathnames and opening modes to accommadate new opening order.

   80-12-08 Rickie E. Brinegar: Use of the internal variable mode_list removed  and
   replaced  with the new mrds_dbs_modes_list.incl.pl1 structures. At the same time
   val_str and hd_str were replaced with control strings in the ioa_ calls.

   80-12-11 Jim Gray : added use of mrds_new_scope_modes include file in process of
   changing  from  old  r-u to r-s-m-d type scope modes. Now a is acceptable for s,
   and u now means a+d+m, but with an integer conversion of 14, not 2.

   80-12-12 Jim Gray : Changed declaration of wait_time to fixed bin(35)  from  71,
   the  fact  that mrds_dsl_set_scope expects a fb35 was causing 0 wait times to be
   sent by mrds_call, because the upper (zero) part of  a  fb71  number  was  being
   sent.

   81-1-12 Jim Gray : added get_scope function to interface to dsl_$get_scope.

   81-01-30  Jim  Gray  :   added   get_population   function   to   interface   to
   mrds_dsl_define_temp_rel$get_temp_rel_population.  The  routine  for  permantent
   relations  is  not  yet  available.  It  will  be  part  of  a  common   routine
   dsl_$get_population.

   81-01-30  Jim  Gray  :  changed  open  database  listing  routine  called   from
   mrds_dsl_lsit_dbs$list_dbs_with_modes  to  mrds_dsl_db_openings$list_openings to
   take advantage of the improved interface.

   81-03-25 Jim Gray : extended get_population to call general  dsl_$get_population
   routine that handles perm rels as well as temp rels.

   81-07-19 Jim Gray :  added  a  new  set_modes  option  no_retrieve_output/nro  -
   retreieve_output/ro that turns the output of values from retrieve off and on. If
   the output values are turned off, then -all is forced, and a  number  of  tuples
   retrieved  is  returned instead. Also deleted all commented out code, as removal
   of blocked file stuff makes it unuseable.

   81-09-22 Davids: added code to set the  num_ptrs  variable  right
   after  a  pointer to the arg_list is obtained. Also added code in
   build_arg_list to make sure that the value of num_ptrs is the max
   of  the  number  of  pointers in the arg_list that mrc was called
   with and the arg_list that is generated to call the  dsl_  entry.
   See the comment in build_arg_list

   82-06-14 Mike Kubicar : Rewrote the dashed argument parser for retrieve
   to work the way the manual desribes it.  This fixes TR phx12237.

*/

/* initialize */

	a_ptr, filen_ptr,
	     num_ptr,
	     mode_ptr,
	     pm_ptr,
	     pv_ptr,
	     se_ptr,
	     rmode_ptr,
	     val_ptr = null;
	code = 0;
	ready_cnt = 0;
	on cleanup call cleanup_proc;
	on arg_err_ call arg_err_hndlr;
	if area_initialized then ;
	else do;
		call get_temp_segment_ ("mrds_call", wa_ptr, code);
		if code ^= 0 then do;
			call com_err_ (code, MRC, "Creating temp segment");
			go to Exit;
		     end;
		wa_ptr -> work_area = empty ();
		area_initialized = ON;
	     end;

	call cu_$arg_list_ptr (al_ptr);
	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-22 ********** */
	nargs = divide (arg_list.arg_count, 2, 17);

	on sub_error_
	     begin;
		if ^error_display_flag then ;		/* ignore, dont print extra info */
		else call continue_to_signal_ (handler_found_code);
	     end;

	call cu_$arg_ptr (1, f_ptr, f_len, code);	/* get operation name */

	if code ^= 0 then do;			/* nothing there */
		call com_err_ (code, MRC, " Usage: mrc opname {args} {control_args}.");
		if error_display_flag		/* if more info desired */
		then call com_err_ (0, MRC, "Valid opnames: ^/^- ^a,^/^- ^a,^/^- ^a,^/^- ^a",
			"open, o, close, c, store, s, modify, m, delete, d, retrieve, r",
			"list_dbs, ld, set_scope, ss, set_scope_all, ssa, set_modes, sm",
			"dl_scope, ds, dl_scope_all, dsa, define_temp_rel, dtr",
			"get_scope, gs, get_population, gp, declare, dcl");
	     end;

	else if operation = "o" | operation = "open" then do;

		call open_old_ver;

/* if nargs >= 3 then do;
   call cu_$arg_ptr (3, arg_ptr, arg_len, code); ** is mode present? **
   if code ^= 0 then
   call error (code, "open");
   do i = 1 to 8
   while (arg ^= ms_array (i));
   end;
   end;
   if i > 8 | nargs < 3 then
   call open_new_ver;
   else call open_old_ver;
   */

		al_ptr = a_ptr;
		nargs = divide (arg_list.arg_count, 2, 17);
		arg_list.arg_des_ptr (nargs) = addr (code);
		arg_list.arg_des_ptr (nargs + desc_off_o) = addr (fb_35_desc);

		call cu_$generate_call (mrds_dsl_open$open, al_ptr);

		if code ^= 0 then do;
			call com_err_ (code, MRC, "(From dsl_$open)");
			go to Exit;
		     end;

		free temp_mode_list in (work_area);
		tml_ptr = null ();

		if list_display_flag
		then call print_dbi;		/* tell user what he did */

		free arg_list in (work_area);
		free num in (work_area);
		free mode in (work_area);
	     end;					/* open */

	else if operation = "c" | operation = "close" then do;
		if nargs < 2			/* not enough */
		then call com_err_ (error_table_$wrong_no_of_args, MRC,
			"^/^- Usage: mrc close [dbi1 {... dbiN} | -all]"); /* give user hint */
		else do;
			call cu_$arg_ptr (2, arg_ptr, arg_len, code); /* get 1st arg to close */

			if code ^= 0		/* should never happen */
			then call com_err_ (code, MRC, "Getting second argument");

			else if arg = "-all" | arg = "-a" then do;
				call mrds_dsl_close_all (code); /* go doit toit */
				call free_open_lists; /* free work space */
				if code ^= 0	/* now put out error, if any */
				then call com_err_ (code, MRC, "(From dsl_$close_all)");
			     end;

			else do;
				on conversion begin;/* for certain argument errors */
					if a_ptr ^= null then free a_ptr -> arg_list in (work_area);
					if num_ptr ^= null then free num in (work_area);
					call com_err_ (0, MRC, "No data bases closed"); /* tell user no go */
					goto Exit;
				     end;

				call build_arg_list (nargs);

				open_cnt = nargs - 1;
				allocate num in (work_area);

				do i = 2 to nargs;
				     num (i - 1) = conv_int (i, DBI);
				     a_ptr -> arg_list.arg_des_ptr (i - 1) = addr (num (i - 1));
				     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i - 1) = addr (fb_35_desc);
				end;


				al_ptr = a_ptr;
				arg_list.arg_des_ptr (nargs) = addr (code);
				arg_list.arg_des_ptr (nargs + desc_off_o) = addr (fb_35_desc);

				call cu_$generate_call (mrds_dsl_close$close, al_ptr);

				free arg_list in (work_area);
				free num in (work_area);

				call mrds_dsl_db_openings$list_dbs (wa_ptr, database_list_ptr);
				if database_list_ptr = null () then
				     call free_open_lists (); /* get rid of temp seg */
				else free database_list in (work_area);

				if code ^= 0	/* give out errors, if any */
				then call com_err_ (code, MRC, "(From dsl_$close)");
			     end;
		     end;
	     end;					/* close */

	else if operation = "ld" | operation = "list_dbs" then
	     call print_dbi;


	else if operation = "s" | operation = "store" then
	     call call_mod_fun (mrds_dsl_store$store, 3);


	else if operation = "d" | operation = "delete" | operation = "dl" then
	     call call_mod_fun (mrds_dsl_delete$delete, 1);


	else if operation = "m" | operation = "modify" then
	     call call_mod_fun (mrds_dsl_modify$modify, 2);


	else if operation = "set_modes" | operation = "sm" then do;
		if nargs < 2 then
		     call com_err_ (error_table_$wrong_no_of_args, MRC,
			"^/^- Usage: mrc set_modes {list | no_list} {long_err | short_err}");
		else do;
			do arg_cnt = 2 by 1 to nargs;

			     call cu_$arg_ptr (arg_cnt, mrc_mode_ptr, mrc_mode_len, code);
			     if code ^= 0 then
				call com_err_ (code, MRC, "Getting mode argument.");
			     else do;

				     if mrc_mode = "no_list" then
					list_display_flag = OFF;
				     else if mrc_mode = "list" then
					list_display_flag = ON;
				     else if mrc_mode = "long_err" then
					error_display_flag = ON;
				     else if mrc_mode = "short_err" then
					error_display_flag = OFF;

/* BEGIN CHANGE 81-07-19 ******************************************** */

				     else if mrc_mode = "no_retrieve_output" | mrc_mode = "nro" then
					no_output_mode = ON;
				     else if mrc_mode = "retrieve_output" | mrc_mode = "ro" then
					no_output_mode = "0"b;

/* END CHANGE 81-07-19 ************************************************ */

				     else call com_err_ (error_table_$bad_arg, MRC, "Invalid mode ^a.", mrc_mode);
				end;
			end;
		     end;
	     end;

	else if operation = "r" | operation = "retrieve" then do;

		if nargs < 4
		then call com_err_ (error_table_$wrong_no_of_args, MRC,
			"^/^- Usage: mrc retrieve nvals dbi ^/^2-{selection_expression} {se_values} {-segment path} {-all}");
		else do;
			n_vals = conv_int (2, NVALS);
			dbi = conv_int (3, DBI);
			se_seg_sw = 0;		/* init switches */
			all_sw = "0"b;
			done_scanning = "0"b;
			current_arg = nargs;
			se_path = "";

/* 
*
*  Now check for the possible command argument (all two of them).  They
*  (by the command definition) must appear as the last two control arguments
*  in the command line.  So, we just start at the end and scan backwords.
*  We check for -all, which is a single arg, or -sm which has to be two.
*  If we find the wrong thing or both -all and -sm, we assume we're done
*  and look no farther.  Thus, it is quite possible to have command lines of
*  the form:
*
* mrc retrieve 4 1 a b c d -all -all -sm foo -sm foo.input -all
*
*  since scanning for arguments will stop when it sees -sm foo.input -all.
*  This allows arbitrary and random things to be given for selection
*  expression values.
*
*/

			do while (^done_scanning);
			     call cu_$arg_ptr (current_arg, arg_ptr,
				arg_len, code);
			     if code ^= 0 then do;
				     call com_err_ (code, MRC,
					"^/Could not get command argument.");
				     go to Exit;
				end;
			     if ^all_sw & ((arg = "-all") | (arg = "-a")) /* All is easy, it's a single arg */
			     then if (se_seg_sw = 0) & se_path ^= "" /* Make sure we're not in the middle of a -segment argument */
				then done_scanning = "1"b; /* Impossible arg combination, must be se values */
				else do;		/* Saw a legal -all */
					all_sw = "1"b;
					nargs = nargs - 1;
					done_scanning = all_sw & (se_seg_sw ^= 0);
				     end;
			     else if (se_seg_sw = 0) &
				     ((arg = "-segment") | (arg = "-sm"))
			     then if se_path = "" then do; /* Must have seen pathname */
					call com_err_ (error_table_$noarg,
					     MRC, "^/A pathname must be given with the ^a argument.", arg);
					go to Exit;
				     end;
				else do;		/* Valid -segment arg */
					se_seg_sw = 1;
					call get_se (sea_ptr, sed_ptr);
					nargs = nargs - 1;
					done_scanning = all_sw;
				     end;
			     else if se_path ^= ""	/* End of arg scanning? */
			     then done_scanning = "1"b; /* Yes, two non-recognized args in a row */
			     else do;		/* Assume it's an se_path */
				     if length (arg) > length (se_path) then do;
					     se_path = substr (arg, 1, length (se_path));
					     se_len = length (se_path);
					end;
				     else do;
					     se_path = arg;
					     se_len = arg_len;
					end;
				end;
			     current_arg = current_arg - 1;
			end;

			call build_arg_list (nargs + n_vals - 1);
			allocate values in (work_area);

			if se_seg_sw > 0 then do;	/* if seg se. move in arg and desc. ptrs */
				a_ptr -> arg_list.arg_des_ptr (2) = sea_ptr;
				a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2) = sed_ptr;
			     end;

			do i = 2 to nargs - 2 - se_seg_sw;
			     a_ptr -> arg_list.arg_des_ptr (i + se_seg_sw) = arg_list.arg_des_ptr (i + 2);
			     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + se_seg_sw) =
				true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 2));
			end;

			al_ptr = a_ptr;
			arg_list.arg_des_ptr (1) = addr (dbi);
			arg_list.arg_des_ptr (nargs + n_vals - 1) = addr (code);
			arg_list.arg_des_ptr (desc_off_o + 1),
			     arg_list.arg_des_ptr (desc_off_o + nargs + n_vals - 1) = addr (fb_35_desc);

			do i = nargs - 1 to nargs + n_vals - 2;
			     arg_list.arg_des_ptr (i) = addr (values (i - nargs + 2));
			     arg_list.arg_des_ptr (i + desc_off_o) = addr (char_desc);
			end;

			call cu_$generate_call (mrds_dsl_retrieve$retrieve, al_ptr);

			if code ^= 0 then do;
				call retr_cleanup;
				call com_err_ (code, MRC, "(From dsl_$retrieve)");
				go to Exit;
			     end;

/* BEGIN CHANGE 81-07-19 ******************************************** */

			if ^no_output_mode then do;
				call ioa_ ("^/Value^[ is^;s are^]:^/", (n_vals = 1));

				do i = 1 to n_vals;
				     call ioa_ ("^a", values (i));
				end;
			     end;
			else do;

/* for no_retrieve_output mode, force -all,
   and just prepare a count of the tuples retrieved */

				tuples_retrieved = 1;
				all_sw = "1"b;
			     end;

			if all_sw then do;		/* if auto anothers */
				arg_list.arg_des_ptr (2) = addr (anoth_str); /* change select. expr. to -another */
				arg_list.arg_des_ptr (desc_off_o + 2) = addr (anoth_desc);

				do while (code = 0);/* for as long as we find something */

				     call cu_$generate_call (mrds_dsl_retrieve$retrieve, al_ptr); /* $retrieve (-another) */

				     if code = 0 then do; /* if got something */
					     tuples_retrieved = tuples_retrieved + 1;
					     if ^no_output_mode then do;
						     call ioa_ ("^/******^/"); /* write separator */
						     do i = 1 to n_vals; /* write out all found values */
							call ioa_ ("^a", values (i));
						     end;
						end;
					end;
				end;
				if code = mrds_error_$tuple_not_found then do;
					if no_output_mode then
					     call ioa_ ("^/Tuples retrieved:  ^d^/", tuples_retrieved);
					else call ioa_ ("^/(END)^/"); /* let user know at end */
				     end;
				else call com_err_ (code, MRC, "(From dsl_$retrieve)"); /* otherwise give error */
			     end;			/* if auto anothers */

/* END CHANGE 81-07-19 **************************************************** */


			else call ioa_ ("^/");
			call retr_cleanup;

retr_cleanup: procedure;
	free arg_list in (work_area);
	free values in (work_area);
     end retr_cleanup;

		     end;				/* retrieve */
	     end;

	else if operation = "dtr" | operation = "define_temp_rel" then do;
		if nargs < 4 then do;		/* not enough */
			call com_err_ (error_table_$wrong_no_of_args, MRC,
			     "^/^- Usage: mrc define_temp_rel dbi ^/^2-^a^/^2-^a",
			     "[selection_expression {se_values} rel_index",
			     "| rel_index -sm path]");
			go to Exit;
		     end;

		dbi = conv_int (2, DBI);

		call cu_$arg_ptr (nargs - 1, arg_ptr, arg_len, code); /* see if separate sel. expr. */

		if code ^= 0 then do;
			call com_err_ (code, MRC, "Getting argument ^i", nargs - 1);
			go to Exit;
		     end;
		if arg = "-sm" | arg = "-segment" then do; /* if separate */
			call cu_$arg_ptr (nargs, arg_ptr, arg_len, code); /* get path */
			if code ^= 0 then do;
				call com_err_ (code, MRC, "Pathname for -segment");
				go to Exit;
			     end;

			se_path = arg;
			se_len = arg_len;
			call get_se (sea_ptr, sed_ptr); /* init and set ptrs for sel. expr. */
			nargs = nargs - 1;		/* dont look at ctl arg again */
			se_seg_sw = 1;		/* remember */
		     end;
		else se_seg_sw = 0;			/* if sel. expr in command line */

		rel_ind = conv_int (nargs - se_seg_sw, TRI);

		call build_arg_list (nargs);

		if se_seg_sw > 0 then do;		/* if se. in seg */
			a_ptr -> arg_list.arg_des_ptr (2) = sea_ptr; /* move in arg and desc ptrs */
			a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2) = sed_ptr;
		     end;

		do i = 2 to nargs - 2 - se_seg_sw;
		     a_ptr -> arg_list.arg_des_ptr (i + se_seg_sw) = arg_list.arg_des_ptr (i + 1);
		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + se_seg_sw) =
			true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 1));
		end;

		al_ptr = a_ptr;
		arg_list.arg_des_ptr (1) = addr (dbi);
		arg_list.arg_des_ptr (nargs - 1) = addr (rel_ind);
		arg_list.arg_des_ptr (nargs) = addr (code);
		arg_list.arg_des_ptr (desc_off_o + 1),
		     arg_list.arg_des_ptr (desc_off_o + nargs - 1),
		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);

		call cu_$generate_call (mrds_dsl_define_temp_rel$define_temp_rel, al_ptr);

		free arg_list in (work_area);

		if code ^= 0
		then call com_err_ (code, MRC, "(From dsl_$define_temp_rel)");
		else call ioa_ ("^/Temporary relation index is:  ^d.^/", rel_ind);

	     end;					/* retrieve */

	else if operation = "set_scope" | operation = "ss" then
	     call call_scope_fun (mrds_dsl_set_scope$set_scope, 1);

	else if operation = "ssa" | operation = "set_scope_all" then
	     call call_set_scope_all_fun (mrds_dsl_set_scope$set_scope_all);

	else if operation = "ds" | operation = "dl_scope" then
	     call call_scope_fun (mrds_dsl_set_scope$dl_scope, 2);

	else if operation = "dl_scope_all" | operation = "dsa" then do;
		if nargs ^= 2
		then call com_err_ (error_table_$wrong_no_of_args, MRC, " Usage: mrc dl_scope_all dbi");
		else do;
			dbi = conv_int (2, DBI);
			call mrds_dsl_set_scope$dl_scope_all (dbi, code);
			if code ^= 0
			then call com_err_ (code, MRC, "(From dsl_$dl_scope_all)");
		     end;
	     end;
	else if operation = "get_scope" | operation = "gs" then do;
		if nargs ^= 3 then
		     call com_err_ (error_table_$wrong_no_of_args, MRC, "^/    Usage: mrc get_scope dbi relation_name");
		else do;
			dbi = conv_int (2, DBI);
			call cu_$arg_ptr_rel (3, relation_name_ptr, relation_name_len, code, al_ptr);
			if code ^= 0 then
			     call com_err_ (code, MRC, "^/Cannot get relation name argument.");
			else do;
				call mrds_dsl_get_scope (dbi, relation_name, permits, prevents, scope_version, code);
				if code ^= 0 then
				     call com_err_ (code, MRC, "(From dsl_$get_scope)");
				else do;
					permit_requests_ptr = addr (permits);
					prevent_requests_ptr = addr (prevents);
					if scope_version < 5 then
					     store_scope = "s";
					else store_scope = "a";
					permit_string = "";
					if permit_requests.read_attr then permit_string = permit_string || "r";
					if permit_requests.append_tuple then permit_string = permit_string || store_scope;
					if permit_requests.modify_attr then permit_string = permit_string || "m";
					if permit_requests.delete_tuple then permit_string = permit_string || "d";
					if permit_string = "" then permit_string = "n";
					prevent_string = "";
					if prevent_requests.read_attr then prevent_string = prevent_string || "r";
					if prevent_requests.append_tuple then prevent_string = prevent_string || store_scope;
					if prevent_requests.modify_attr then prevent_string = prevent_string || "m";
					if prevent_requests.delete_tuple then prevent_string = prevent_string || "d";
					if prevent_string = "" then prevent_string = "n";
					call ioa_ ("^/Permits:  ^a ^-Prevents:  ^a^/", permit_string, prevent_string);
				     end;
			     end;
		     end;
	     end;

	else if operation = "get_population" | operation = "gp" then do;
		if nargs ^= 3 then
		     call com_err_ (error_table_$wrong_no_of_args, MRC,
			"^/    Usage: mrc get_population dbi rel_id");
		else do;
			dbi = conv_int (2, DBI);
			call cu_$arg_ptr_rel (3, relation_name_ptr, relation_name_len, code, al_ptr);
			if code ^= 0 then
			     call com_err_ (code, MRC, "^/Cannot get relation name argument.");
			else do;

				call mrds_dsl_get_population (dbi, relation_name, tuple_count, code);

				if code ^= 0 then
				     call com_err_ (code, MRC, "(From dsl_$get_population)");
				else do;

					call ioa_ ("^/Tuple count:  ^d^/", tuple_count);

				     end;

			     end;

		     end;

	     end;

	else if operation = "declare" | operation = "dcl" then do;
		if nargs ^= 3
		then call com_err_ (error_table_$wrong_no_of_args, "^/^- Usage: mrc declare dbi function_name");
		else do;
			dbi = conv_int (2, DBI);

			call cu_$arg_ptr_rel (3, fn_ptr, fn_len, code, al_ptr);

			if code ^= 0
			then call com_err_ (code, MRC, "Cannot get function_name");
			else do;
				call mrds_dsl_declare (dbi, fn_name, code);
				if code ^= 0
				then call com_err_ (code, MRC, "(From dsl_$declare)");
			     end;
		     end;
	     end;

	else call com_err_ (error_table_$bad_arg, MRC, operation);
Exit:
	if se_ptr ^= null				/* if any segment initiated */
	then call hcs_$terminate_noname (se_ptr, discard_code);
	return;

call_mod_fun: proc (dsl_entry, index);
	dcl     dsl_entry		 entry;
	dcl     index		 fixed bin;

	if nargs < 3 then do;			/* not right number */
		if index = 3			/* special call for store */
		then call com_err_ (error_table_$wrong_no_of_args, MRC,
			"^/^- Usage: mrc store dbi [rel_name | -another] new_values");
		else call com_err_ (error_table_$wrong_no_of_args, MRC,
			"^/^- Usage: mrc ^[delete^;modify^] dbi [selection_expression {se_values} ^[^;new_values^] | ^[^;new_values^] -sm path]", index, index, index);
	     end;

	else do;
		dbi = conv_int (2, DBI);
		se_seg_sw = 0;			/* init off */

		if index ^= 3 then do;		/* delete or modify */
			call cu_$arg_ptr (nargs - 1, arg_ptr, arg_len, code); /* see if -sm given */
			if code ^= 0 then do;
				call com_err_ (code, MRC, "Getting argument ^i", nargs - 1);
				go to Exit;
			     end;

			else if arg = "-segment" | arg = "-sm" then do;
				call cu_$arg_ptr (nargs, arg_ptr, arg_len, code);
				if code ^= 0 then do;
					call com_err_ (code, MRC, "Unable to get pathname for -segment");
					go to Exit;
				     end;
				else do;
					se_path = arg;
					se_len = arg_len;
					call get_se (sea_ptr, sed_ptr);
					nargs = nargs - 1;
					se_seg_sw = 1;
				     end;
			     end;
		     end;

		call build_arg_list (nargs);		/* build dsl_ arg list */

		if se_seg_sw > 0 then do;		/* if separate sel. expr. */
			a_ptr -> arg_list.arg_des_ptr (2) = sea_ptr; /* move in sel. expr. ptrs */
			a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2) = sed_ptr;
		     end;
		do i = 2 to nargs - 1 - se_seg_sw;
		     a_ptr -> arg_list.arg_des_ptr (i + se_seg_sw) = arg_list.arg_des_ptr (i + 1);
		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + se_seg_sw) =
			true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 1));
		end;

		al_ptr = a_ptr;
		arg_list.arg_des_ptr (1) = addr (dbi);
		arg_list.arg_des_ptr (nargs) = addr (code);
		arg_list.arg_des_ptr (desc_off_o + 1),
		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);

		call cu_$generate_call (dsl_entry, al_ptr);

		free arg_list in (work_area);

		if code ^= 0
		then call com_err_ (code, MRC,	/* give user error */
			"(From dsl_$^[delete^;modify^;store^])", index);
	     end;

     end call_mod_fun;

call_scope_fun: proc (dsl_entry, index);

	dcl     dsl_entry		 entry;
	dcl     index		 fixed bin;


	if nargs < 5
	then call com_err_ (error_table_$wrong_no_of_args, MRC,
		"^/^- Usage: mrc ^[set^;dl^]_scope dbi ^a ^/^2-^a ^[{wait_sec}^]",
		index,
		"rel_name1 permit_ops1 prevent_ops1",
		"{... rel_nameN permit_opsN prevent_opsN}",
		index);

	else do;
		dbi = conv_int (2, DBI);

		wait_time = mod (nargs - 2, 3);
		if wait_time ^= 0 then wait_time = conv_int (nargs, WT);

		call build_arg_list (nargs);

		scope_cnt = divide (nargs - 2, 3, 17);
		allocate perm_ops in (work_area);
		allocate prev_ops in (work_area);

		do i = 2 to nargs - 2 by 3;

		     a_ptr -> arg_list.arg_des_ptr (i) = arg_list.arg_des_ptr (i + 1);
		     a_ptr -> arg_list.arg_des_ptr (i + desc_off_o) =
			true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 1));
		     perm_ops (divide (i + 1, 3, 17)) = conv_ops (i + 2);
		     prev_ops (divide (i + 1, 3, 17)) = conv_ops (i + 3);
		     a_ptr -> arg_list.arg_des_ptr (i + 1) = addr (perm_ops (divide (i + 1, 3, 17)));
		     a_ptr -> arg_list.arg_des_ptr (i + 2) = addr (prev_ops (divide (i + 1, 3, 17)));
		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + 1),
			a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + 2) = addr (fb_17_desc);

		end;

		al_ptr = a_ptr;
		arg_list.arg_des_ptr (1) = addr (dbi);
		arg_list.arg_des_ptr (nargs) = addr (code);
		if wait_time ^= 0 then do;		/* wait time specified */
			arg_list.arg_des_ptr (nargs - 1) = addr (wait_time);
			arg_list.arg_des_ptr (desc_off_o + nargs - 1) = addr (fb_35_desc);
		     end;
		arg_list.arg_des_ptr (desc_off_o + 1),
		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);

		call cu_$generate_call (dsl_entry, al_ptr); /* call out */

		free perm_ops in (work_area);
		free prev_ops in (work_area);
		free arg_list in (work_area);

		if code ^= 0
		then call com_err_ (code, MRC,	/* give user sad story */
			"(From dsl_$^[set^;dl^]_scope)", index);
	     end;

     end call_scope_fun;

call_set_scope_all_fun: proc (dsl_entry);

	dcl     dsl_entry		 entry;

	if nargs < 4 | nargs > 5
	then call com_err_ (error_table_$wrong_no_of_args, MRC,
		"^/^- Usage: mrc set_scope_all dbi permit_ops prevent_ops {wait_sec}");
	else do;

		dbi = conv_int (2, DBI);

		if nargs = 5 then wait_time = conv_int (nargs, WT);

		call build_arg_list (nargs);

		scope_cnt = 1;
		allocate perm_ops in (work_area);
		allocate prev_ops in (work_area);

		perm_ops (1) = conv_ops (3);
		prev_ops (1) = conv_ops (4);
		a_ptr -> arg_list.arg_des_ptr (2) = addr (perm_ops (1));
		a_ptr -> arg_list.arg_des_ptr (3) = addr (prev_ops (1));
		a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2),
		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + 3) = addr (fb_17_desc);

		al_ptr = a_ptr;
		arg_list.arg_des_ptr (1) = addr (dbi);
		arg_list.arg_des_ptr (nargs) = addr (code);

		if nargs = 5
		then do;
			arg_list.arg_des_ptr (nargs - 1) = addr (wait_time);
			arg_list.arg_des_ptr (desc_off_o + nargs - 1) = addr (fb_35_desc);
		     end;
		arg_list.arg_des_ptr (desc_off_o + 1),
		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);

		call cu_$generate_call (dsl_entry, al_ptr); /* call out */

		free perm_ops in (work_area);
		free prev_ops in (work_area);
		free arg_list in (work_area);

		if code ^= 0 then
		     call com_err_ (code, MRC, "(From dsl_$set_scope_all)");
	     end;

     end call_set_scope_all_fun;

open_old_ver: proc;

	dcl     odd		 fixed bin;	/* to see if odd num of args */
	dcl     al_index		 fixed bin;	/* index for arg_list processing */

	odd = mod (nargs, 2);			/* see if odd num */

	if nargs < 3 | odd = 0 then do;		/* need odd num & at least 3 */
		call com_err_ (error_table_$wrong_no_of_args, MRC,
		     "^/^- Usage: mrc open path1 mode1 {... pathN modeN}");
		go to Exit;
	     end;

	num_open,
	     open_cnt = divide (nargs - 1, 2, 17);
	call build_arg_list (open_cnt * 3 + 1);

	allocate num in (work_area) set (num_ptr);
	allocate mode in (work_area) set (mode_ptr);
	if tml_ptr ^= null then free temp_mode_list in (work_area);
	allocate temp_mode_list set (tml_ptr) in (work_area);

	do i = 1 to (open_cnt);
	     al_index = (i - 1) * 3;

	     a_ptr -> arg_list.arg_des_ptr (al_index + 1) = arg_list.arg_des_ptr (2 * i);
	     a_ptr -> arg_list.arg_des_ptr (al_index + 2) = addr (num (i));
	     a_ptr -> arg_list.arg_des_ptr (al_index + 3) = addr (mode (i));

	     call cu_$arg_ptr (2 * i + 1, ms_ptr, ms_len, code);
	     if code ^= 0 then do;
		     call com_err_ (code, MRC, "Unable to get opening mode.");
		     go to Exit;
		end;

	     do j = 1 to 8 while (mode_string ^= ms_array (j)); /* look for specified mode */
	     end;
	     if j > 8 then do;
		     call com_err_ (code, MRC,
			"Invalid opening mode ^a. ^/^-Valid modes are: r, u, er, and eu", mode_string);
		     go to Exit;
		end;
	     else mode (i) = mv_array (j);		/* if valid, pick up corr. number */
	     a_ptr -> arg_list.arg_des_ptr (desc_off_o + al_index + 1) =
		true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + 2 * i));
	     a_ptr -> arg_list.arg_des_ptr (desc_off_o + al_index + 2),
		a_ptr -> arg_list.arg_des_ptr (desc_off_o + al_index + 3) = addr (fb_35_desc);

	     temp_mode_list (i) = ms_array (2 * mode (i) - 1); /* save expanded opening mode */

	     call cu_$arg_ptr (2 * i, arg_ptr, arg_len, code); /* get and save submodel path */
	     if code ^= 0 then do;			/* not there */
		     call com_err_ (code, MRC, "Unable to get pathname");
		     go to Exit;
		end;

	     if code ^= 0 then do;
		     call com_err_ (code, MRC, arg);	/* let user know */
		     go to Exit;			/* and get out */
		end;

	end;

     end open_old_ver;

build_arg_list: proc (count);

	dcl     count		 fixed bin;
	dcl     old_num_ptrs	 fixed bin;	/* CHANGE 81-09-22 ********** */

	old_num_ptrs = num_ptrs;			/* CHANGE 81-09-22 ********** */

	num_ptrs = 2 * count;
	allocate arg_list in (work_area) set (a_ptr);

	a_ptr -> arg_list.arg_count,
	     a_ptr -> arg_list.desc_count = 2 * count;
	a_ptr -> arg_list.code = 4;

	desc_off_o = count;
	desc_off_i = divide (arg_list.arg_count, 2, 17) + fixed (arg_list.code = 8);

/* BEGIN CHANGE 81-09-22 ******************************

   old_num_ptrs contains the number of pointers in the argument list
   that  mrds_call  was called with. num_ptrs contains the number of
   pointers that the corresponding dsl_ entry will be  called  with.
   Since  only  1 structure is used (arg_list) the value of num_ptrs
   after it leaves this procedure must be  the  larger  of  the  two
   numbers  to  prevent  subscriptrange conditions from occuring, of
   course this means that subscriptrange conditions can occur on the
   other   structure.  Ideally  two  separate  structures  with  two
   separate limits should be used. This has not been  done  at  this
   time becuase while it is a simple change it is also extensive and
   it would be easy to make a mistake at  the  same  time  the  test
   routines  cannot  be  run  becuase  almost  every  routine  has a
   stringrange or subscriptrange condition  in  it.  After  mrds  is
   again running this change should be made. */

	if old_num_ptrs > num_ptrs
	then num_ptrs = old_num_ptrs;

/* END   CHANGE 81-09-22 ****************************** */

     end build_arg_list;

conv_int: proc (index, argument_type) returns (fixed bin (35));

	declare argument_type	 char (*);
	dcl     i			 fixed bin;
	dcl     num_char		 char (nc_len) based (nc_ptr);
	dcl     nc_ptr		 ptr;
	dcl     (nc_len,
	        index)		 fixed bin;

	call cu_$arg_ptr_rel (index, nc_ptr, nc_len, code, al_ptr);

	if code ^= 0 then do;			/* can't find arg */
		call com_err_ (code, MRC, "Unable to get ^a", argument_type);
		go to Exit;			/* not much past this */
	     end;

	if argument_type = TRI
	then i = verify (num_char, "-0123456789");
	else i = verify (num_char, "0123456789");	/* no negatives allowed */

	if i ^= 0 then do;				/* not numeric */
		call com_err_ (error_table_$bad_arg, MRC,
		     "Non-numeric ^a: ^a", argument_type, num_char);
		if operation = "close" | operation = "c"/* special handling for close */
		then signal conversion;		/* so can clean up properly */
		else go to Exit;			/* otherwise, just die */
	     end;
	return (fixed (num_char));

     end conv_int;

conv_ops: proc (index) returns (fixed bin (35));

/* Internal procedure to create an operations number from a given scope operations string */

	dcl     st_ptr		 ptr;		/* points to input string */
	dcl     (st_len,				/* length of input str. */
	        index)		 fixed bin;	/* index of string arg. */
	dcl     string		 char (st_len) based (st_ptr); /* scope ops. string */
	dcl     op_num		 fixed bin (35);	/* scope ops number to be returned */

	call cu_$arg_ptr_rel (index, st_ptr, st_len, code, al_ptr); /* get input string */
	if code ^= 0 then do;
		call com_err_ (code, MRC, "Unable to get scope code");
		go to Exit;
	     end;
	op_num = 0;				/* initialize */

	if string ^= "n" then do;			/* if non-null op. */
		op_num = verify (string, "nrasudm");
		if op_num ^= 0 then do;		/* invalid code */
			call com_err_ (error_table_$bad_arg, MRC,
			     "Invalid scope code: ^a. ^/^-Valid codes are: n, r, a or s, d, m, and u = ""a+d+m""",
			     substr (string, op_num, 1));
			go to Exit;
		     end;
		if search (string, "r") ^= 0 then op_num = op_num + READ_ATTR; /* convert to number */
		if search (string, "s") ^= 0 | search (string, "a") ^= 0 then op_num = op_num + APPEND_TUPLE;
		if search (string, "d") ^= 0 then op_num = op_num + DELETE_TUPLE;
		if search (string, "m") ^= 0 then op_num = op_num + MODIFY_ATTR;
		if search (string, "u") ^= 0 then op_num = op_num + UPDATE_OPS;
	     end;

	return (op_num);

     end conv_ops;

print_dbi: proc;

/* Procedure to print open data bases, modes, and indices */


	call mrds_dsl_db_openings$list_openings (wa_ptr,
	     mrds_database_openings_structure_version, mrds_database_openings_ptr, code);
	if code ^= 0 then
	     call com_err_ (code, MRC, "(From dsl_$list_openings)");
	else do;

		if mrds_database_openings.number_open = 0 then
		     call ioa_ ("^/No data bases open.^/"); /* if we dont have list */

		else do;				/* print out list */
			call ioa_ ("^/Open data base^[ is^;s are^]:",
			     (mrds_database_openings.number_open = 1)); /* write out header */

			do i = 1 to mrds_database_openings.number_open; /* write out index,
						   mode, path of each db curr. open */

			     call ioa_ ("^d^-^a^/^-^a", mrds_database_openings.db.index (i),
				mrds_database_openings.db.path (i),
				mrds_database_openings.db.mode (i));
			end;
			call ioa_ ("^/");
		     end;

	     end;


	if mrds_database_openings_ptr ^= null () then
	     free mrds_database_openings in (work_area);

     end print_dbi;

get_se: proc (a_ptr, d_ptr);

/* Internal procedure to obtain selection expression if user has specified -segment.
   On output, a_ptr will point to the start of the selection expression, and d_ptr will point to a
   descriptor for the selection expression.
*/

	dcl     (a_ptr,				/* place to put arg ptr. for sel.exp. */
	        d_ptr)		 ptr;		/* place to put descr. ptr. for sel. exp. */
	dcl     dname		 char (168);	/* dir name of se. expr. */
	dcl     ename		 char (32);	/* entry name of se. expr. */
	dcl     bcount		 fixed bin (24);	/* se. expr. bit count */
	dcl     1 se_desc		 aligned,		/* descriptor template */
		2 const		 bit (12) unal init ("101010110000"b),
		2 len		 fixed bin (23) unal;

	call expand_path_ (addr (se_path), se_len, addr (dname), addr (ename), code);

	if code ^= 0 then do;
		call com_err_ (code, MRC, se_path);
		go to Exit;			/* can't do anything with it */
	     end;

	call hcs_$initiate_count (dname, ename, "", bcount, 0, se_ptr, code); /* get ptr and length of sel. expr. */

	if se_ptr = null then do;			/* couldn't init segment */
		call com_err_ (code, MRC, "Initiating ^a>^a", dname, ename);
		go to Exit;			/* can't go any farther now */
	     end;

	a_ptr = se_ptr;				/* arg ptr */
	d_ptr = addr (se_desc);			/* point to descriptor */
	se_desc.len = divide (bcount, 9, 17);		/* set length in descriptor */

     end get_se;

true_ptr: proc (a_ptr, d_ptr) returns (ptr);

/* Procedure to insure that descriptor pointers passed to dsl_ are its ptrs, rathher than offsets. */

	dcl     (a_ptr,				/* arg list ptr */
	        d_ptr)		 ptr;		/* descriptor ptr */
	dcl     1 its_wd1		 based (addr (d_ptr)),
		2 offset		 bit (18) unal,
		2 pad		 bit (12) unal,
		2 tag		 bit (6) unal;

	if its_wd1.tag = "100011"b then return (d_ptr);	/* is already its ptr */
	else return (ptr (a_ptr, its_wd1.offset));	/* otherwise make its ptr */

     end true_ptr;

cleanup_proc: proc;

/* cleanup procedure to free any temporary. storage */

	if a_ptr ^= null then free a_ptr -> arg_list in (work_area);
	if num_ptr ^= null then free num in (work_area);
	if mode_ptr ^= null then free mode in (work_area);
	if rmode_ptr ^= null then free rmode in (work_area);
	if val_ptr ^= null then free values in (work_area);
	if pm_ptr ^= null then free perm_ops in (work_area);
	if pv_ptr ^= null then free prev_ops in (work_area);

	if se_ptr ^= null then do;
		call hcs_$terminate_noname (se_ptr, code);
		se_ptr = null ();
	     end;


     end cleanup_proc;

arg_err_hndlr: proc;

	call com_err_ (error_table_$noarg, "mrds_call");
	call cleanup_proc;

     end arg_err_hndlr;

free_open_lists: procedure;

/* this procedure wipes out the temp seg used as a work area.  It is called
   whenever there is an error in open and after all data bases have
   been closed.  By deleting this area, we effectively free everything allocated
   in it. */

	if wa_ptr ^= null then do;			/* got something to get rid of */
		call release_temp_segment_ (MRC, wa_ptr, discard_code);
		area_initialized = OFF;		/* remember that its not there any more */
	     end;

     end free_open_lists;

%include mdbm_arg_list;
%page;
%include mdbm_scope_requests;
%page;
%include mrds_new_scope_modes;
%page;
%include mrds_database_list;
%page;
%include mrds_database_openings;

	dcl     (a_ptr,
	        arg_ptr,				/* ptr to arg. of interest */
	        f_ptr,
	        filen_ptr,
	        fn_ptr,
	        num_ptr,
	        mode_ptr,
	        ms_ptr,				/* ptr to input mode string */
	        pm_ptr,
	        pv_ptr,
	        rmode_ptr,
	        se_ptr,				/* ptr to selection expr to be passed to dsl_ */
	        sea_ptr,				/* arg ptr for seg se. */
	        sed_ptr,				/* desc ptr for seg se. */
	        val_ptr)		 ptr;

	dcl     (arg_len,				/* length of arg of interest */
	        desc_off_i,
	        desc_off_o,
	        f_len,
	        fn_len,
	        i,
	        j,				/* internal index */
	        ms_len,				/* length of mode string */
	        n_vals,
	        nargs,
	        open_cnt,
	        ready_cnt,
	        scope_cnt,
	        se_len,				/* length of se. seg. path */
	        se_seg_sw)		 fixed bin;	/* indicates if seg se. expr. */

	dcl     (code,
	        dbi,
	        rel_ind)		 fixed bin (35);

	dcl     all_sw		 bit (1) unal;	/* on => outo anothers */
	dcl     anoth_desc		 bit (36) aligned int static options (constant) init ("101010100000000000000000000000001000"b);
	dcl     anoth_str		 char (8) aligned int static options (constant) init ("-another");
	dcl     arg		 char (arg_len) based (arg_ptr); /* arg of current interest */
	dcl     current_arg		 fixed bin;	/* Used in retrieve argument scanning */
	dcl     done_scanning	 bit (1);		/* Are we done parsing the dashed args */
	dcl     fn_name		 char (fn_len) based (fn_ptr);
	dcl     mode		 (open_cnt) fixed bin (35) based (mode_ptr);
	dcl     mode_string		 char (ms_len) based (ms_ptr); /* opening mode */
	dcl     num		 (open_cnt) fixed bin (35) based (num_ptr);
	dcl     num_open		 fixed bin int static init (0); /* num. of open data bases */
	dcl     operation		 char (f_len) based (f_ptr);
	dcl     perm_ops		 (scope_cnt) fixed bin (35) based (pm_ptr);
	dcl     prev_ops		 (scope_cnt) fixed bin (35) based (pv_ptr);
	dcl     rmode		 (ready_cnt) fixed bin (35) based (rmode_ptr);
	dcl     se_path		 char (168) aligned;/* path name of selection expr. */
	dcl     values		 (n_vals) char (256) based (val_ptr);
	dcl     wa_ptr		 static pointer init (null); /* ptr to temp seg containing the above */
	dcl     wait_time		 fixed bin (35);	/* optional maximum wait time for scope setting */
						/* NOTE: this MUST be declared fixed bin 35 NOT 71,
						   since mrds_dsl_set_scope expects a fb35 number, and is documented that way for users */

	dcl     ms_array		 (8) char (20) int static options (constant) init (/* allowable opening modes */
				 "retrieval", "r",
				 "update", "u",
				 "exclusive_retrieval", "er",
				 "exclusive_update", "eu");

	dcl     mv_array		 (8) fixed bin int static options (constant) /* corresponding numeric values */
				 init (1, 1, 2, 2, 3, 3, 4, 4);

	dcl     char_desc		 bit (36) aligned init ("101010100000000000000000000100000000"b);
	declare fb_17_desc		 bit (36) aligned init ("100000100000000000000000000000010001"b);
	dcl     fb_35_desc		 bit (36) aligned init ("100000100000000000000000000000100011"b);

	dcl     work_area		 area (sys_info$max_seg_size) based (wa_ptr);

	dcl     (error_table_$bad_arg,
	        error_table_$noarg,
	        mrds_error_$tuple_not_found,
	        sys_info$max_seg_size) fixed bin (35) ext;

	dcl     (addr,
	        divide,
	        empty,
	        fixed,
	        length,
	        mod,
	        null,
	        ptr,
	        search,
	        substr,
	        verify)		 builtin;

	dcl     (arg_err_,
	        cleanup,
	        conversion,
	        sub_error_)		 condition;	/* signaled when sub_error_ called */

	dcl     (com_err_,
	        ioa_,
	        mrds_dsl_close$close,
	        mrds_dsl_define_temp_rel$define_temp_rel,
	        mrds_dsl_delete$delete,
	        mrds_dsl_modify$modify,
	        mrds_dsl_open$open,
	        mrds_dsl_retrieve$retrieve,
	        mrds_dsl_set_scope$dl_scope,
	        mrds_dsl_set_scope$set_scope,
	        mrds_dsl_set_scope$set_scope_all,
	        mrds_dsl_store$store)	 entry options (variable);

	dcl     mrds_dsl_declare	 entry (fixed bin (35), char (*), fixed bin (35));
	declare mrds_dsl_get_scope	 entry (fixed bin (35), char (*), fixed bin, fixed bin, fixed bin, fixed bin (35)); /* gets permits/prevents scope on rel */
	declare relation_name	 char (relation_name_len) based (relation_name_ptr);
	declare relation_name_ptr	 ptr;
	declare relation_name_len	 fixed bin;
	declare (permits, prevents)	 fixed bin;
	declare scope_version	 fixed bin;	/* 5 => r-a-m-d, < 5 => r-s-m-d */
	declare store_scope		 char (1);	/* either "s" or "a" */
	declare (permit_string, prevent_string) char (4) varying; /* for displaying scope */
	declare tuple_count		 fixed bin (35);	/* number of tuples in relation */
	declare mrds_dsl_get_population entry options (variable); /* get population of rels */
	dcl     mrds_dsl_set_scope$dl_scope_all entry (fixed bin (35), fixed bin (35));

	dcl     (DBI		 char (15) init ("data_base_index"),
	        MRC		 char (9) init ("mrds_call"),
	        NVALS		 char (5) init ("nvals"),
	        TRI		 char (14) init ("temp_rel_index"),
	        WT		 char (9) init ("wait_time")) static options (constant);

	dcl     arg_cnt		 fixed bin;	/* number of set_mode arguments + 1 */
	dcl     continue_to_signal_	 entry (fixed bin (35)); /* to keep signaling */
	dcl     error_display_flag	 bit (1) internal static init ("1"b); /* on => output sub error mesg */
	dcl     error_table_$wrong_no_of_args fixed bin (35) ext;
	dcl     handler_found_code	 fixed bin (35);
	dcl     list_display_flag	 bit (1) internal static init ("1"b); /* on => list open dbs, and ready files after open/ready */
	dcl     mrc_mode		 char (mrc_mode_len) based (mrc_mode_ptr); /* set_modes mode arg */
	dcl     mrc_mode_len	 fixed bin;	/* length of set_mode mode arg */
	dcl     mrc_mode_ptr	 ptr;		/* set_mode mode pointer */
	dcl     mrds_dsl_close_all	 entry (fixed bin (35)); /* close all open dbs */
	dcl     NL		 char (1) init ("
");						/* new line character */
	dcl     ON		 bit (1) init ("1"b); /* true value */
	dcl     OFF		 bit (1) init ("0"b); /* false value */

	dcl     area_initialized	 bit (1) internal static init ("0"b); /* on => work area created */
	dcl     discard_code	 fixed bin (35);	/* unused */
	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* gets space for work area */
	dcl     mrds_data_$max_dbs	 fixed bin (35) ext;/* max num of open dbs */
	dcl     mrds_dsl_db_openings$list_dbs entry (ptr, ptr); /* gets list of open dbs */
	declare mrds_dsl_db_openings$list_openings entry (ptr, fixed bin, ptr, fixed bin (35)); /* extended open info */
	declare no_output_mode	 bit (1) int static init ("0"b); /* on => don't return retreived values */
	declare tuples_retrieved	 fixed bin (35);	/* number of values not seen */
	dcl     NA		 char (20) init ("Mode not available");
	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* removes work space */
	dcl     temp_mode_list	 (1:mrds_data_$max_dbs) char (20) based (tml_ptr); /* temp store for opening modes */
	dcl     tml_ptr		 ptr init (null ());/* points to temp_mode_list */

	dcl     cu_$arg_list_ptr	 entry (ptr);
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
	dcl     cu_$arg_ptr_rel	 entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
	dcl     cu_$generate_call	 entry (entry, ptr);
	dcl     expand_path_	 entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
	dcl     hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
	dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));

     end mrds_call;


