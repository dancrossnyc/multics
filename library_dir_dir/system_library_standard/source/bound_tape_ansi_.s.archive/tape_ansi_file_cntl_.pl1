/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */




/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*                                                                    */
/*  tape_ansi_file_cntl_                                              */
/*                                                                    */
/*       Main logic module of tape_ansi_.  See individual entries     */
/*  for details of use and calling sequence.                          */
/*                                                                    */
/*  0) Created:   10/04/74 by Ross E. Klinger                         */
/*  1) Modified:  11/04/76 by Janice B. Phillipps                     */
/*  2) Modified:  04/11/79 by C. D. Tavares for authentication and    */
/*                         resource management                        */
/*  3) Modified:  9/79	by R.J.C. Kissel for new tseg		*/
/*  4) Modified:  4/82 by J. A. Bush for block sizes > 8192 bytes     */
/*		   and to remove tape_ibm_ HDR2 density check     */
/*                                                                    */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


/* format: style3,ind3,dclind6,idind32 */
tape_ansi_file_cntl_:
   procedure;					/* This entry not used */

/* arguments */
dcl   iocbP		        ptr,		/* pointer to iocb */
      open_mode		        fixed bin,		/* opening mode */
      extend_bit		        bit (1) aligned,	/* extend at open time */
      code		        fixed bin (35);	/* error code */

%include iocb;

%include tape_ansi_cseg;

%include tape_ansi_fd;

%include tape_ansi_fl;

%include ansi_vol1;

%include ibm_vol1;

%include ansi_hdr1;

%include ansi_hdr2;

%include ibm_hdr1;

%include ibm_hdr2;

%include rcp_volume_formats;

%include rcp_resource_types;


/* automatic storage */
dcl   answer		        char (128) varying,
      cc			        fixed bin,		/* consistency code */
						/* 0 - invalidate volume position */
						/* 1 - invalidate volume position and current file link */
						/* 2 - invalidate position, current file link, write EOV TM */
      com_text		        char (64) varying,
      (eofs, close_eot, format_override, new_link)
			        bit (1),
      mask		        bit (36) aligned,
      testP		        ptr,
      search_id		        char (17),		/* search file chain/tape for this file id */
      t			        fixed bin,
      t1			        picture "9",
      t2			        picture "99",
      t4			        picture "9999",
      t5			        picture "99999",
      t6			        picture "999999",
      tstring		        char (32) varying,	/* open description temporary */
      vn			        char (32);		/* volume name */

dcl   1 qi		        aligned,		/* query info structure */
        2 version		        fixed bin init (2),
        2 yes_no		        bit (1) unaligned,
        2 suppress_name	        bit (1) unaligned,
        2 scode		        fixed bin (35),
        2 qcode		        fixed bin (35) init (0);

/* internal static */
dcl   ansi_format_chars	        char (4) internal static init ("UFDS"),
      ibm_format_chars	        char (4) internal static init ("UFVV"),
      ibm_block_codes	        char (4) internal static init (" BSR"),
      l1id		        (3) char (4) internal static init ("HDR1", "EOF1", "EOV1"),
      l2id		        (3) char (4) internal static init ("HDR2", "EOF2", "EOV2"),
      tag			        (4) char (12) varying internal static
			        init (" -extend", " -modify", " -generate", " -create");

dcl   dummy_label		        (2) char (76) internal static
			        init (
			        "0000000000000000000000000000000000000000000000000000000000000000000000000000",
						/* IBM dummy HDR1 label */
			        "!!DUMMY FILE ID!!******00010001000100 00000 00000 000000MULTICS ANSI        ");
						/* ANSI dummy HDR1/EOF1 label */

dcl   max_reclen		        (3) fixed bin internal static init (99999, 32756, 32763);
						/* ANSI - OS/VS - DOS/VM */

dcl   UL			        (2) char (3) internal static init ("UHL", "UTL");
						/* user label id's */

dcl   debug		        bit (1) internal static initial ("0"b);
						/* debug switch */

/* based storage */
dcl   label_type		        char (3) based (addr (cseg.lbl_buf));

dcl   sync_buf		        char (80) based (cseg.syncP);
						/* 80 character overlay on synchronous IO buffer */


/* conditions */
dcl   (any_other, area, cleanup, conversion)
			        condition;

/* builtin functions */
dcl   (addr, bit, char, fixed, index, length, ltrim, max, mod, null, prec, substr, verify)
			        builtin;

/* external procedures */
dcl   tape_ansi_lrec_io_$close        ext entry (ptr, fixed bin (35)),
      tape_ansi_lrec_io_$read_record  ext entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      tape_ansi_lrec_io_$write_record ext entry (ptr, ptr, fixed bin (21), fixed bin (35)),
      ascii_to_ebcdic_	        ext entry (char (*), char (*)),
      command_query_	        ext entry options (variable),
      continue_to_signal_	        ext entry (fixed bin (35)),
      tape_ansi_control_	        ext entry (ptr, char (*), ptr, fixed bin (35)),
      tape_ansi_detach_	        ext entry (ptr, fixed bin (35)),
      ebcdic_to_ascii_	        ext entry (char (*), char (*)),
      tape_ansi_file_cntl_$close      ext entry (ptr, fixed bin (35)),
      tape_ansi_file_cntl_$open       ext entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
      hcs_$reset_ips_mask	        ext entry (bit (36) aligned, bit (36) aligned),
      hcs_$set_ips_mask	        ext entry (bit (36) aligned, bit (36) aligned),
      tape_ansi_ibm_lrec_io_$close    ext entry (ptr, fixed bin (35)),
      tape_ansi_ibm_lrec_io_$read_record
			        ext entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      tape_ansi_ibm_lrec_io_$write_record
			        ext entry (ptr, ptr, fixed bin (21), fixed bin (35)),
      ioa_		        ext entry options (variable),
      iox_$propagate	        ext entry (ptr),
      tape_ansi_mount_cntl_$mount     ext entry (ptr, fixed bin, fixed bin (35)),
      tape_ansi_mount_cntl_$remount   ext entry (ptr, fixed bin, fixed bin, fixed bin (35)),
      tape_ansi_position_	        ext entry (ptr, fixed bin, fixed bin (21), fixed bin (35)),
      tape_ansi_read_length_	        ext entry (ptr, fixed bin (21), fixed bin (35)),
      tape_ansi_tape_io_$get_buffer   ext entry (ptr, ptr, fixed bin (35)),
      tape_ansi_tape_io_$open	        ext entry (ptr),
      tape_ansi_tape_io_$order        ext entry (ptr, char (3), fixed bin, fixed bin (35)),
      tape_ansi_tape_io_$sync_read    ext entry (ptr, fixed bin, fixed bin (35)),
      tape_ansi_tape_io_$sync_write   ext entry (ptr, fixed bin, fixed bin (35)),
      terminate_process_	        ext entry (char (*), ptr),
      canon_for_volume_label_	        ext entry (char (*), char (*), char (*), fixed bin, fixed bin (35)),
      authenticate_		        ext entry (char (*)) returns (char (3) aligned);


/* external static */
dcl   (
      error_table_$device_limit_exceeded,
      error_table_$discrepant_block_count,
      error_table_$duplicate_file_id,
      error_table_$eof_record,
      error_table_$end_of_info,
      error_table_$eov_on_write,
      error_table_$file_aborted,
      error_table_$file_busy,
      error_table_$incompatible_attach,
      error_table_$incompatible_encoding_mode,
      error_table_$incompatible_file_attribute,
      error_table_$insufficient_open,
      error_table_$invalid_block_length,
      error_table_$invalid_cseg,
      error_table_$invalid_expiration,
      error_table_$invalid_file_set_format,
      error_table_$invalid_label_format,
      error_table_$invalid_record_length,
      error_table_$invalid_volume_sequence,
      error_table_$noalloc,
      error_table_$no_file,
      error_table_$no_next_volume,
      error_table_$positioned_on_bot,
      error_table_$unable_to_do_io,
      error_table_$unexpired_file,
      error_table_$unexpired_volume,
      error_table_$uninitialized_volume
      )			        fixed bin (35) ext static;

dcl   sys_info$max_seg_size	        fixed bin (35) external static;

open:
   entry (iocbP, open_mode, extend_bit, code);

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to control segment */

      if cseg.invalid
      then
         do;					/* is control segment invalid? */
	  code = error_table_$invalid_cseg;
	  return;
         end;

      if cseg.file_lock
      then
         do;					/* is file in use (by previous invocation)? */
	  code = error_table_$file_busy;
	  return;
         end;
      else
         do;
	  cc = 0;					/* minimal consistency requirement */
	  on cleanup
	     begin;				/* insure file chain <--> tape consistency */
	        call consistent;
	        cseg.file_lock = "0"b;		/* unlock the file */
	     end;
	  cseg.file_lock = "1"b;			/* not in use - now it is */
         end;

      if extend_bit
      then
         do;					/* extend at open time not allowed */
bad_open:
	  code = error_table_$incompatible_attach;
	  go to valid_exit;
         end;

      if open_mode = 4
      then
         do;					/* sequential input */
	  tstring = "sequential_input";		/* set for open description */
	  search_id = fd.file_id;			/* set search identifier */
         end;

      else
         do;					/* sequential output */
	  if cseg.output_mode = 0
	  then go to bad_open;			/* no output mode specified */
	  if open_mode = 5
	  then tstring = "sequential_output";
	  else go to bad_open;
	  tstring = tstring || tag (output_mode);	/* append output mode keyword */
	  if cseg.replace_id ^= ""
	  then search_id = cseg.replace_id;		/* search for the replace name */
	  else search_id = fd.file_id;		/* otherwise, search for -name file_id */
         end;

      cseg.open_mode = open_mode;			/* save open mode in control segment */

      on area
         begin;					/* handle full control segment */
	  code = error_table_$noalloc;
	  go to er_exit;
         end;

      new_link = "0"b;				/* initialize for searching */
      cseg.flP = cseg.fcP;				/* start at beginning of chain */
      do testP = fl.nextP repeat fl.nextP;		/* loop through file chain */

         if testP ^= null
         then cseg.flP = testP;			/* link exists - use it */
         else
	  do;					/* link does not exist - build it */
	     new_link = "1"b;			/* this is a new link */
	     cc = 1;				/* don't leave defective links */
	     call build1 (code);			/* make the link */
	     if code ^= 0
	     then go to er_exit;
	  end;

         if fl.flX = -1
         then
	  do;					/* the link is an end-of-file-set link */
	     if append_file ()
	     then go to create_file;			/* appending file to eofs */
	     else
	        do;				/* not appending, therefore file not found */
		 code = error_table_$no_file;
		 go to valid_exit;
	        end;
	  end;

         if desired_file ()
         then
	  do;					/* found our file */
	     if cseg.open_mode = 4
	     then
	        do;				/* opened for sequential_input */
		 if ^new_link
		 then call desired_check;		/* check chain-tape consistency */
		 go to input;
	        end;
	     else
	        do;				/* opened for sequential_output */
		 if cseg.output_mode = 1
		 then go to extend_chain;		/* -extend - get to last section */
		 else
		    do;				/* -modify, -generate, or -create */
		       if ^new_link
		       then call desired_check;	/* check chain-tape consistency at 1st section */
		       if cseg.output_mode = 2
		       then go to extend_chain;	/* need version # from last section */
		       else
			do;			/* -generate or -create */
			   if fd.expiration > fl.backP -> fl.expiration
			   then
			      do;			/* check expiration */
			         code = error_table_$invalid_expiration;
			         go to valid_exit;
			      end;
			   go to output;
			end;
		    end;
	        end;
	  end;

         if new_link
         then
	  do;					/* new link - only partially built */
	     call build2 (code);
	     if code ^= 0
	     then go to er_exit;
	  end;

      end;

extend_chain:					/* extend file chain to last section */
      if debug
      then call debug_print ("extend_chain");
      if new_link
      then
         do;					/* complete link if just built */
	  call build2 (code);
	  if code ^= 0
	  then go to er_exit;
         end;

      testP = cseg.flP;				/* save pointer to first section's link */
      do while (fl.eox = 2);				/* get to last section */
         if fl.nextP = null
         then
	  do;					/* next link doesn't exist */
	     new_link = "1"b;			/* indicate new links in chain */
	     cc = 1;				/* don't leave defective links */
	     call build1 (code);			/* build it */
	     if code ^= 0
	     then go to er_exit;
	     if fl.flX = -1
	     then
	        do;				/* trouble - need more sections, but eofs */
		 code = error_table_$invalid_file_set_format;
		 go to valid_exit;			/* an error, but all is consistent */
	        end;
	     call build2 (code);
	     if code ^= 0
	     then go to er_exit;
	  end;
         else cseg.flP = fl.nextP;			/* link exists */
      end;

      if cseg.output_mode = 1
      then
         do;					/* extending chain for -extend */
	  if ^new_link
	  then call desired_check;			/* check chain-tape consistency */
	  go to output;
         end;
      else
         do;					/* extended chain for -modify */
	  cseg.flP = testP;				/* restore pointer to first section's link */
	  go to output;
         end;

input:						/* file is to be read */
      if debug
      then call debug_print ("input");
      cc = 0;					/* minimal consistency requirement */
      call setup_for_read;				/* complete file data from file link */
      call lrec_open;				/* perform final checks and initialization */

/* INSERT USER LABEL PROCESSING HERE */

      call move_tape_ (fl.vlX, fl.flX, 1, code);		/* move to 1st data block */
      if code ^= 0
      then go to er_exit;
      go to done;					/* set up iocb and exit */

output:
      if debug
      then call debug_print ("output");			/* extend, modify, generate, or create file */
      cc = 0;					/* minimal consistency requirement */

      if ^cseg.force
      then
         do;					/* check if file is expired */
	  if fl.expiration > fd.creation
	  then
	     do;					/* file is not expired */
	        if ^write_permit ()
	        then
		 do;				/* user said don't overwrite */
		    code = error_table_$unexpired_file;
		    go to valid_exit;
		 end;
	     end;
         end;

      call truncate_chains;				/* truncate file and volume chains */
      call build_eofsl;				/* append an eofs link */
      go to action_type (cseg.output_mode);		/* process the file */

extend_file:
modify_file:
action_type (1):
action_type (2):
      if debug
      then call debug_print ("extend/modify");

/* INSERT USER LABEL PROCESSING TO READ LABELS BEFORE WRITING DATA */

      if cseg.output_mode = 1
      then call move_to_EOD;				/* position to end of data to extend */
      else
         do;					/* modify */
	  call move_tape_ (fl.vlX, fl.flX, 1, code);	/* move to 1st data block */
	  if code ^= 0
	  then go to er_exit;
         end;
      cc = 1;					/* don't leave defective file links */
      call setup_for_extend_modify;			/* load file data from file link */
      call lrec_open;				/* perform final checks and initialization */
      if cseg.output_mode = 1
      then call extend_check;				/* should last block be re-written? */
      go to done;

generate_file:
action_type (3):
      if debug
      then call debug_print ("generate_file");
      cc = 1;					/* don't leave defective file links */
      call setup_for_generate;
      go to common;

create_file:
action_type (4):
      if debug
      then call debug_print ("create");
      cc = 1;					/* don't leave defective file links */
      call setup_for_create;				/* load file link from file data */

common:
      call lrec_open;				/* perform final checks and initialization */
      call move_tape_ (fl.vlX, fl.flX, 0, code);		/* position to write header labels */
      if code ^= 0
      then go to er_exit;
      cc = 2;					/* don't leave defective tape file */
      call write_HDRs (code);				/* write header labels */
      if code ^= 0
      then go to er_exit;				/* trouble */
      call write_TM (1, code);			/* write header TM */
      if code ^= 0
      then if code ^= error_table_$eov_on_write
	 then go to er_exit;			/* trouble - (ignore EOT) */
      call back_TM (1, code);				/* back into headers */
      if code ^= 0
      then go to er_exit;				/* trouble */
      go to done;					/* fill iocb and exit */

done:
      mask = "0"b;					/* ips interrupts not masked yet */
      cseg.open_description.length = length (tstring);	/* prepare open description */
      cseg.open_description.string = tstring;
      revert cleanup;
      on any_other call handler;			/* pick up any condition */
      call hcs_$set_ips_mask ("0"b, mask);		/* mask all ips interrupts */
      iocbP -> iocb.actual_iocb_ptr -> iocb.close = tape_ansi_file_cntl_$close;
      if cseg.open_mode = 5
      then
         do;					/* sequential output */
	  if cseg.standard = 1
	  then iocbP -> iocb.actual_iocb_ptr -> iocb.write_record = tape_ansi_lrec_io_$write_record;
	  else iocbP -> iocb.actual_iocb_ptr -> iocb.write_record = tape_ansi_ibm_lrec_io_$write_record;
         end;
      else
         do;					/* sequential input */
	  if cseg.standard = 1
	  then iocbP -> iocb.actual_iocb_ptr -> iocb.read_record = tape_ansi_lrec_io_$read_record;
	  else iocbP -> iocb.actual_iocb_ptr -> iocb.read_record = tape_ansi_ibm_lrec_io_$read_record;
	  iocbP -> iocb.actual_iocb_ptr -> iocb.read_length = tape_ansi_read_length_;
	  iocbP -> iocb.actual_iocb_ptr -> iocb.position = tape_ansi_position_;
         end;
      iocbP -> iocb.actual_iocb_ptr -> iocb.control = tape_ansi_control_;
      iocbP -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr = addr (cseg.open_description);
      call iox_$propagate (iocbP -> iocb.actual_iocb_ptr);
      call hcs_$reset_ips_mask (mask, mask);		/* permit ips interrupts */
      cseg.file_lock = "0"b;				/* open complete - unlock the file */
      return;

er_exit:
      call consistent;

valid_exit:
      cseg.file_lock = "0"b;				/* open complete - unlock the file */
      return;

abort_file:
   procedure;					/* cleanup after defective file */
      if debug
      then call debug_print ("abort_file");

      vl (fl.vlX).cflX = 0;				/* invalidate volume position */

      qi.yes_no = "1"b;				/* want yes or no answer */
      qi.suppress_name = "0"b;			/*  print module name */
      qi.scode = error_table_$file_aborted;
      qi.qcode = 0;
      call command_query_ (addr (qi), answer, cseg.module,	/* query user */
         "Error while writing labels of file ""^a"", section ^d.
The defective section invalidates the structure of the entire file set.
Do you want to delete the defective section?", fl.file_id, fl.section);

      if answer = "no"
      then
         do;					/* volume format will be invalid */
	  call write_TM (2, 0);			/* try to write 2 TM anyway */
	  go to abort_fail1;
         end;

      cseg.flP = fl.backP;				/* back up to previous section or file */
      call truncate_chains;				/* truncate file and volume chains */
      call build_eofsl;				/* add an end of file set link */

      if fl.flX = 0
      then
         do;					/* bad section was first of file set */
	  call initialize_volume (1, code);		/* initialize the volume */
	  if code ^= 0
	  then go to abort_fail;
         end;
      else
         do;					/* bad section wasn't first of file set */
	  if fl.eox = 1
	  then
	     do;					/* bad section was first section of file */
	        call move_tape_ (fl.vlX, fl.flX + 1, 0, code);
						/* position to write TM after EOF's */
	        if code ^= 0
	        then go to abort_fail;
	     end;
	  else
	     do;					/* bad section wasn't first section of file */
	        call move_tape_ (fl.vlX, fl.flX, 2, code);/* position to re-write trailers */
	        if code ^= 0
	        then go to abort_fail;
	        cseg.blkcnt = fl.blkcnt;		/* set block count to be recorded */
	        call write_EOFs (code);		/* change EOV to EOF */
	        if code ^= 0
	        then go to abort_fail;
	     end;
         end;

      call write_TM (2, code);			/* write the TMs */
      if code ^= 0
      then if code ^= error_table_$eov_on_write
	 then go to abort_fail;

      code = error_table_$file_aborted;
      return;

abort_fail:
      call ioa_ ("^a: Deletion failed: unable to restore valid file set format.", cseg.module);
abort_fail1:
      vl (fl.vlX).cflX = 0;				/* invalidate volume position */
      cseg.flP = cseg.fcP;				/* set pointer to eliminate file and volume chains */
      call truncate_chains;				/* wipe the slate clean */
      code = error_table_$invalid_file_set_format;
      return;

   end abort_file;

another_volume:
   procedure returns (bit (1));			/* queries user for next volume name */

dcl   msg			        char (80) varying;	/* message to user */
dcl   msg1		        char (length (msg)) based (addr (substr (msg, 1)));
						/* char (*) overlay for command_query_ */
dcl   L1			        fixed bin;

      qi.yes_no = "1"b;				/* want yes or no */
      qi.suppress_name = "0"b;			/* don't suppress module name */
      qi.scode = error_table_$no_next_volume;
      qi.qcode = 0;
      msg = "Reached end of volume.  Do you wish to terminate processing of this volume-set?";
      call command_query_ (addr (qi), answer, cseg.module, msg1);
      if answer = "yes"
      then return ("0"b);				/* finito */

      qi.yes_no = "0"b;				/* don't want yes or no */
      qi.suppress_name = "1"b;
ask:
      qi.scode = 0;					/* no scode when asking for name */
      msg = "Enter volume name of next volume (and optional comment).^/";
ask_raw:
      call command_query_ (addr (qi), answer, cseg.module, msg1);
      if answer = ""
      then go to ask;
      com_text = "";				/* initialize comment message */
      L1 = index (answer, " ") - 1;			/* scan for a blank */
      if L1 < 0
      then L1 = length (answer);

      call canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), substr (answer, 1, L1), vn, 0, code);
      if code ^= 0
      then
         do;
	  qi.scode = code;
	  msg = substr (answer, 1, L1) || "^/Enter volume name of next volume (and optional comment).^/";
	  go to ask_raw;
         end;

      answer = ltrim (substr (answer, L1 + 1));

      if substr (answer, 1, 8) = "-comment"
      then
         do;
	  answer = ltrim (substr (answer, 10));
	  go to comment;
         end;
      if substr (answer, 1, 4) = "-com"
      then
         do;
	  answer = ltrim (substr (answer, 6));
comment:
	  if length (answer) = 0
	  then ;					/* no comment */
	  else com_text = answer;
         end;
      else if answer = ""
      then ;
      else
         do;					/* invalid comment */
	  call ioa_ ("Comment is invalid.");
	  go to ask;
         end;
      return ("1"b);				/* volume name is ok - exit */

write_permit:
   entry returns (bit (1));				/* queries user for write permission */

      qi.yes_no = "1"b;				/* user must answer yes or no */
      qi.suppress_name = "0"b;
      qi.scode = error_table_$unexpired_file;
      qi.qcode = 0;
      call command_query_ (addr (qi), answer, cseg.module,	/* ask the user */
         "Do you want to overwrite the unexpired file ""^a""?", fl.file_id);
      if answer = "yes"
      then return ("1"b);
      else return ("0"b);

   end another_volume;

append_file:
   procedure returns (bit (1));			/* determines if a file is an append file */
      if debug
      then call debug_print ("append_file");

/*  If the file is an append file, set its sequence number in file     */
/*  data, and build an eofs link.                                      */
/*                                                                     */
/*  A file is an append file if:                                       */
/*                                                                     */
/*  1) cseg.open_mode = 5 and cseg.output_mode = 4                     */
/*             AND                                                     */
/*  2) fd.sequence =  0 (-number not specified)  or                    */
/*                    last sequence number of file set + 1.            */
/*		AND					*/
/*  3) -replace not specified					*/

      if cseg.open_mode = 4
      then return ("0"b);				/* open mode is input */
      if cseg.output_mode ^= 4
      then return ("0"b);				/* output mode is not create */
      if cseg.replace_id ^= ""
      then return ("0"b);				/* -replace specified therefore cannot append */

      if fd.sequence = 0
      then
         do;					/* -number not specified */
	  if cseg.flP = fd.nextP
	  then fd.sequence = 1;			/* file is 1st of new file set */
	  else fd.sequence = fl.backP -> fl.sequence + 1; /* file is 2, 3, ..... */
         end;

      else
         do;					/* -number specified */
	  if cseg.flP = fd.nextP
	  then
	     do;					/* file must be 1st of new file set */
	        if fd.sequence = 1
	        then go to yes;			/* and it is */
	        else return ("0"b);			/* isn't - error */
	     end;

	  else
	     do;					/* file need not be first, but last + 1 */
	        if fd.sequence = fl.backP -> fl.sequence + 1
	        then go to yes;			/* and it is */
	        else return ("0"b);			/* isn't - error */
	     end;
         end;

yes:
      if debug
      then call debug_print ("yes");
      if fd.expiration > fl.backP -> fl.expiration
      then
         do;					/* requested expiration > file set expiration */
	  code = error_table_$invalid_expiration;
	  go to valid_exit;
         end;
      cc = 1;					/* insure chain consistency */
      call make_eofsl_real;				/* make the eofs link a real link */
      call build_eofsl;				/* add a new eofs link */
      return ("1"b);				/* done! */

   end append_file;

back_TM:
   procedure (n, ecode);				/* backs over 1 or 2 TM adjusting volume link */
      if debug
      then call ioa_ ("back_TM ^d", n);
dcl   n			        fixed bin,
      cnt			        fixed bin,
      ecode		        fixed bin (35);

      do cnt = 1 to n;				/* 1 or 2 */
         call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
						/* backup over a TM */
         if ecode ^= 0
         then return;

         vl (fl.vlX).pos = vl (fl.vlX).pos - 1;
         if vl (fl.vlX).pos < 0
         then
	  do;					/* adjust for mod3 */
	     vl (fl.vlX).pos = vl (fl.vlX).pos + 3;
	     vl (fl.vlX).cflX = vl (fl.vlX).cflX - 1;
	  end;
      end;

      return;

   end back_TM;

build1:
   procedure (ecode);				/* build a file link and initialize */
dcl   ecode		        fixed bin (35);
      if debug
      then call debug_print ("build1");

      call build_fl;				/* build a file link */
      call move_tape_ (fl.vlX, fl.flX, 0, ecode);		/* position to read HDR1 */
      if ecode ^= 0
      then return;
      call read_HDR1 (eofs, ecode);			/* read the header 1 label */
      if ecode ^= 0
      then return;
      if eofs
      then
         do;					/* reached end of file set */
	  fl.flX = -1;				/* make the link an eofs link */
	  vl (fl.vlX).lflX = vl (fl.vlX).lflX - 1;	/* remove eofs link from volume link */
	  return;
         end;
      call fill_fl_from_HDR1 (ecode);			/* validate and store HDR1 data */
      if ecode ^= 0
      then return;
      call read_HDR2 (ecode);				/* try to read HDR2 label */
      if ecode ^= 0
      then return;
      if fl.HDR2
      then
         do;					/* if HDR2, validate and store its data */
	  call fill_fl_from_HDR2 (ecode);
	  if ecode ^= 0
	  then return;
         end;
      return;

   end build1;


build2:
   procedure (ecode);				/* 2nd part of link building */
dcl   ecode		        fixed bin (35);

      if debug
      then call debug_print ("build2");
      call move_tape_ (fl.vlX, fl.flX, 2, ecode);		/* position to trailer labels */
      if ecode ^= 0
      then return;
      call process_EOX (ecode);			/* process the trailer labels */
      return;

   end build2;


build_eofsl:
   procedure;					/* builds an end-of-file-set link */
      if debug
      then call debug_print ("eofsl");

      allocate fl in (chain_area) set (fl.nextP);		/*  build an eofs link */
      fl.nextP -> fl.backP = cseg.flP;
      fl.nextP -> fl.flX = -1;
      return;

   end build_eofsl;

build_fl:
   procedure;					/* build a file link on end of file chain */
      if debug
      then call debug_print ("build_fl");

      allocate fl in (chain_area) set (fl.nextP);		/*  allocate the link */
      fl.nextP -> fl.backP = cseg.flP;			/* set new link's back ptr to current link */
      cseg.flP = fl.nextP;				/* make the new link current */
      go to build_fl1;

make_eofsl_real:
   entry;						/* makes an eofs link a real link */
      if debug
      then call debug_print ("make_eofsl_real");

build_fl1:
      fl.flX = fl.backP -> fl.flX + 1;			/* set the link index */

      if fl.backP -> fl.eox = 2
      then
         do;					/* this link will be 1st on new volume */
	  fl.vlX = fl.backP -> fl.vlX + 1;		/* up volume link index for this file link */
	  vl (fl.vlX).fflX = fl.flX;			/* first file link on new volume is this file link */
	  vl (fl.vlX).lflX = fl.flX;			/* last file link on new volume is this file link */
         end;
      else
         do;					/* this link is not on a new volume */
	  fl.vlX = fl.backP -> fl.vlX;		/* use same volume index as previous link */
	  vl (fl.vlX).lflX = vl (fl.vlX).lflX + 1;	/* one more file link on volume */
         end;

      return;

   end build_fl;

consistent:
   procedure;					/* insures file chain/tape consistency */
      if debug
      then call debug_print ("consistent");

      go to recovery (cc);				/* perform appropriate consistency processing */

recovery (0):
      if cseg.flP ^= null
      then vl (fl.vlX).cflX = 0;			/* invalidate volume position */
      return;

recovery (1):
      if cseg.flP = null
      then return;					/* nothing can be done - exit */
      vl (fl.vlX).cflX = 0;				/* invalidate volume position */
      cseg.flP = fl.backP;				/* set pointer to previous link */
      call truncate_chains;				/* truncate file and volume chains */
      return;

recovery (2):
      if cseg.flP = null
      then return;					/* nothing can be done - exit */
      call abort_file;				/* truncate file and volume chains, write TM */
      return;

   end consistent;

creating_first:
   procedure returns (bit (1));			/* determines if creating 1st file of new file set */

      if debug
      then call debug_print ("creating_first?");
      if cseg.open_mode = 4
      then return ("0"b);
      if cseg.output_mode ^= 4
      then return ("0"b);
      if fd.sequence ^= 1
      then return ("0"b);
      if cseg.replace_id ^= ""
      then return ("0"b);

      return ("1"b);

   end creating_first;

desired_check:
   procedure;					/* insures that tape and file chain are consistent */
dcl   can_retry		        bit (1) initial ("1"b);
						/* permits 1 retry after re-positioning */

      if debug
      then call debug_print ("desired_check");

last_chance:
      call move_tape_ (fl.vlX, fl.flX, 0, code);		/* position to HDR labels */
      if code ^= 0
      then go to er_exit;

      call read_HDR1 (eofs, code);			/* read HDR1 label */
      if code ^= 0
      then go to er_exit;

      if eofs
      then
         do;					/* end of file set - shouldn't happen */
chain_tape_error:
	  if debug
	  then call debug_print ("chain_tape_error");
	  if can_retry
	  then
	     do;					/* re-position and try again */
	        can_retry = "0"b;			/* can only re-try once */
	        vl (fl.vlX).cflX = 0;			/* force rewind and re-position */
	        go to last_chance;			/* try again */
	     end;
	  code = error_table_$invalid_cseg;		/* re-try failed - disaster */
	  cseg.invalid = "1"b;			/* note for eventual deletion of cseg */
	  go to er_exit;
         end;

      if cseg.standard = 1
      then
         do;					/* ANSI */
	  if ansi_hdr1.file_id ^= fl.file_id
	  then go to chain_tape_error;		/* file id's must be identical */
	  on conversion go to chain_tape_error;
	  if fixed (ansi_hdr1.section) ^= fl.section
	  then go to chain_tape_error;		/* and section */
	  revert conversion;
         end;
      else if ibm_hdr1.dataset_id ^= fl.file_id
      then go to chain_tape_error;			/* IBM */

      return;

   end desired_check;

desired_file:
   procedure returns (bit (1));			/* determines if file wanted is current link */
      if debug
      then call debug_print ("desired_file?");

      if fl.section ^= 1
      then
         do;					/* don't investigate non-initial sections */
	  if debug
	  then call debug_print ("sec ne 1");
	  return ("0"b);
         end;

      if fd.sequence ^= 0
      then
         do;					/* -number specified */
	  if search_id = ""
	  then
	     do;					/* -name (or -replace) not specified */
	        if fd.sequence = fl.sequence
	        then go to match;			/* sequences match */
	        else go to no;			/* sequences don't match */
	     end;
	  else
	     do;					/* -name/replace specified */
	        if fd.sequence = fl.sequence
	        then
		 do;				/* -number matches */
		    if cseg.replace_id ^= ""
		    then
		       do;			/* -replace specified? */
			if cseg.replace_id = fl.file_id
			then go to match;		/* found it */
			code = error_table_$no_file;	/* file doesn't exist */
			go to valid_exit;
		       end;
		    if fd.file_id = fl.file_id
		    then go to match;		/* -name specified */
		    if cseg.open_mode = 5 & cseg.output_mode = 4
		    then go to match;		/* creation */
		    code = error_table_$no_file;	/* file doesn't exist */
		    go to valid_exit;
		 end;
	        else go to no;			/* -number doesn't match */
	     end;
         end;
      else
         do;					/* -number not specified */
	  if search_id = fl.file_id
	  then
	     do;					/* names match */
	        fd.sequence = fl.sequence;		/* set sequence in case not specified */
match:
	        if debug
	        then call debug_print ("yes");
	        return ("1"b);
	     end;
no:
	  if debug
	  then call debug_print ("no");
	  if cseg.output_mode = 4
	  then
	     do;					/* if -create specified */
	        if cseg.open_mode = 5
	        then
		 do;				/* and actually opened for output */
		    if fd.file_id = fl.file_id
		    then
		       do;			/* then names cannot be the same */
			code = error_table_$duplicate_file_id;
						/* if not desired file */
			go to valid_exit;
		       end;
		 end;
	     end;
	  return ("0"b);
         end;



   end desired_file;

extend_check:
   procedure;					/* checks if necessary to re-write last block */
dcl   buf			        char (8192) based aligned;
						/* IO buffer overlay */
dcl   (i, j)		        fixed bin;		/* temporaries */

      if debug
      then call debug_print ("extend_check");

      if cseg.blkcnt = 0
      then return;					/* no last blockto re-write */
      if fd.format ^= 2
      then return;					/* only FB format might need re-writing */
      if ^fd.blocked
      then return;

      call tape_ansi_tape_io_$order (cP, "bsr", 0, code);	/* position to read last block */
      if code ^= 0
      then go to er_exit;
      call tape_ansi_tape_io_$sync_read (cP, cseg.offset, code);
      if code ^= 0
      then go to er_exit;

      if cseg.standard = 2
      then
         do;					/* IBM labeled tape */
	  if mod (cseg.offset, fd.reclen) ^= 0
	  then return;				/* ^integral # of records */
	  if cseg.offset >= fd.blklen
	  then return;				/* block is full */
	  else go to rewrite;			/* more records can fit in block */
         end;

      if cseg.offset > fd.blklen
      then cseg.offset = fd.blklen;			/* ANSI - eliminate obvious padding */
      i = mod ((cseg.offset - fd.bo), fd.reclen);		/* # of chars not in complete record */
      if i ^= 0
      then
         do;					/* if any, see if all padding */
	  if verify (substr (cseg.syncP -> buf, cseg.offset - i + 1, i), "^") ^= 0
	  then return;				/* not all padding, irregularity */
	  else cseg.offset = cseg.offset - i;		/* all padding, must continue checking */
         end;

      i = (cseg.offset - fd.bo) / fd.reclen;		/* get # of complete records */
      do j = i to 1 by -1;				/* test each record for all "^" */
         if verify (substr (cseg.syncP -> buf, fd.bo + ((j - 1) * fd.reclen) + 1, fd.reclen), "^") = 0
         then cseg.offset = cseg.offset - fd.reclen;	/* drop padding */
         else go to rewrite_test;			/* not padding - test if block full */
      end;

rewrite_test:
      if cseg.offset >= fd.blklen
      then return;					/* block is full */
rewrite:
      call tape_ansi_tape_io_$order (cP, "bsr", 0, code);	/* position to rewrite */
      if code ^= 0
      then go to er_exit;
      call tape_ansi_tape_io_$get_buffer (cP, cseg.lrec.bufP, code);
						/* getting an IO buffer causes */
      if code ^= 0
      then go to er_exit;				/* iox_$close to call xxx_lrec_io_$close */
      cseg.blkcnt = cseg.blkcnt - 1;			/* so block count must now reflect tape position */
      substr (cseg.lrec.bufP -> buf, 1, cseg.offset) = substr (cseg.syncP -> buf, 1, cseg.offset);
      return;

   end extend_check;

fill_XXX1:
   procedure (x);					/* formats labels for output */
dcl   x			        fixed bin;		/* 1 - HDR | 2 - EOF | 3 - EOV */

      if debug
      then call debug_print ("fill_XXX1");

      ansi_hdr1P, ibm_hdr1P = addr (lbl_buf);		/* ANSI:IBM common - set pointer to label IO buffer */
      ansi_hdr1.label_id = l1id (x);			/* set label identifier */
      ansi_hdr1.file_id = fl.file_id;			/* IBM - dataset_id */
      ansi_hdr1.set_id = fl.canonical_set_id;		/* IBM - dataset_serial */

      if cseg.standard = 1
      then
         do;					/* ANSI */
	  t4 = fl.section;
	  ansi_hdr1.section = t4;
         end;
      else
         do;
	  t4 = fl.vlX;
	  ibm_hdr1.volume_sequence = t4;
         end;
      if fl.generation = 0 & cseg.standard ^= 1
      then
         do;					/* consider ANSI 0000 (=10000) case */
	  ibm_hdr1.generation = "";
	  ibm_hdr1.version = "";
         end;
      else
         do;
	  t4 = fl.generation;
	  ansi_hdr1.generation = t4;
	  t2 = fl.version;
	  ansi_hdr1.version = t2;
         end;
      t4 = fl.sequence;
      ansi_hdr1.sequence = t4;
      ansi_hdr1.creation = " " || fl.creation;
      ansi_hdr1.expiration = " " || fl.expiration;
      ansi_hdr1.access = fl.access;
      if x = 1
      then ansi_hdr1.blkcnt = "000000";
      else
         do;
	  t6 = cseg.lrec.blkcnt;
	  ansi_hdr1.blkcnt = t6;
         end;
      ansi_hdr1.system = fl.system;
      ansi_hdr1.reserved = "";
      return;

   end fill_XXX1;

fill_XXX2:
   procedure (x);					/* formats 2nd header/trailer label for writing */
dcl   x			        fixed bin;

      if debug
      then call debug_print ("fill_XXX2");
      if cseg.standard ^= 1
      then go to IBM_fill_XXX2;

      ansi_hdr2P = addr (lbl_buf);			/* set pointer to label IO buffer */
      ansi_hdr2.label_id = l2id (x);
      ansi_hdr2.format = substr (ansi_format_chars, fl.format, 1);
      t5 = fl.blklen;
      ansi_hdr2.blklen = t5;
      t5 = fl.reclen;
      ansi_hdr2.reclen = t5;
      if fl.system = fd.system
      then
         do;					/* fill these fields only on parochial file */
	  if x = 1
	  then ansi_hdr2.next_volname = "";
	  else ansi_hdr2.next_volname = fl.next_volname;
	  ansi_hdr2.blocked = char (fl.blocked);
	  t1 = fl.mode;
	  ansi_hdr2.mode = t1;
         end;
      else
         do;
	  ansi_hdr2.next_volname = "";
	  ansi_hdr2.blocked = "";
	  ansi_hdr2.mode = "";
         end;
      ansi_hdr2.system_reserved = "";
      t2 = fl.bo;
      ansi_hdr2.buffer_offset = t2;
      ansi_hdr2.reserved = "";
      return;

IBM_fill_XXX2:
      ibm_hdr2P = addr (cseg.lbl_buf);
      ibm_hdr2.label_id = l2id (x);
      ibm_hdr2.format = substr (ibm_format_chars, fl.format, 1);
      t5 = fl.blklen;
      ibm_hdr2.blksize = t5;
      t5 = fl.reclen;
      ibm_hdr2.lrecl = t5;
      t1 = cseg.density;
      ibm_hdr2.density = t1;
      if fl.section > 1
      then ibm_hdr2.dataset_position = "1";
      else ibm_hdr2.dataset_position = "0";
      ibm_hdr2.jobstep_id = "MULTICS /" || fd.creation;
      ibm_hdr2.recording_technique = "";
      ibm_hdr2.control_characters = fl.cc;
      ibm_hdr2.reserved1 = "";
      if ^fl.blocked
      then t = 1;					/* records not blocked */
      else t = 2;					/* records blocked */
      if fl.format = 4
      then t = t + 2;				/* spanned records */
      ibm_hdr2.block_attribute = substr (ibm_block_codes, t, 1);
						/* pick out block code */
      ibm_hdr2.reserved2 = "";
      return;

   end fill_XXX2;

fill_fl_from_HDR1:
   procedure (ecode);				/* fills file link from HDR1 data */
dcl   ecode		        fixed bin (35);
dcl   nv			        fixed bin;

      if debug
      then call debug_print ("fill_fl_from_HDR1");
      on conversion go to bad_hdr1;
      go to re_fill (cseg.standard);			/* processing for ANSI or IBM */

re_fill (1):
      fl.file_id = ansi_hdr1.file_id;
      fl.set_id = cseg.vl (fl.vlX).volname;
      fl.canonical_set_id = ansi_hdr1.set_id;
      fl.section = fixed (ansi_hdr1.section, 17);
      if fl.section = 0
      then go to bad_hdr1;
      fl.sequence = fixed (ansi_hdr1.sequence, 17);
      if fl.sequence = 0
      then go to bad_hdr1;

      if fl.section = 1
      then
         do;					/* check volume sequence validity */
	  if fl.sequence = 1
	  then
	     do;					/* file 1, section 1 */
	        if fl.flX ^= 1
	        then
		 do;				/* must be first link in file chain */
bad_seq:
		    ecode = error_table_$invalid_volume_sequence;
		    return;
		 end;
	     end;
	  else
	     do;					/* file n > 1, section 1 */
	        if fl.flX = 1
	        then
		 do;				/* cannot be first link in file chain */
new_file_set:
		    if ^creating_first ()
		    then go to bad_seq;		/* unless creating 1st file */
		    if substr (ansi_hdr1.expiration, 2, 5) <= fd.creation
		    then go to re_init;
		    if initialize_permitA (fl.vlX)
		    then
		       do;			/* not expired - query user for permission */
re_init:
			call initialize_volume (fl.vlX, ecode);
						/* said ok (or expired) - do it */
			if ecode ^= 0
			then return;
			call move_tape_ (fl.vlX, fl.flX, 0, ecode);
						/* re-position to HDR1 */
			if ecode ^= 0
			then return;
			call read_HDR1 (eofs, ecode); /* read HDR1 - eof can't happen */
			if ecode ^= 0
			then return;
			go to re_fill (cseg.standard);/* processing for ANSI or IBM */
		       end;
		    ecode = error_table_$unexpired_volume;
						/* user said no */
		    return;
		 end;
	        else if fl.backP -> fl.eox = 2
	        then go to bad_seq;			/* previous file section must be last */
	     end;
         end;
      else
         do;					/* file n >_ 1, section n > 1 */
	  if fl.flX = 1
	  then go to new_file_set;			/* cannot be first link in file chain */
	  if fl.section ^= fl.backP -> fl.section + 1
	  then go to bad_seq;			/* section must be 1 more than previous */
         end;

finish_up:
      fl.generation = fixed (ansi_hdr1.generation, 17);
      fl.version = fixed (ansi_hdr1.version, 17);
      fl.creation = substr (ansi_hdr1.creation, 2, 5);
      fl.expiration = substr (ansi_hdr1.expiration, 2, 5);
      fl.access = ansi_hdr1.access;
      fl.blkcnt = fixed (ansi_hdr1.blkcnt, 35);
      fl.system = ansi_hdr1.system;
      return;


re_fill (2):
re_fill (3):
      fl.file_id = ibm_hdr1.dataset_id;
      fl.set_id = cseg.vl (fl.vlX).volname;
      fl.canonical_set_id = ibm_hdr1.dataset_serial;
      nv = fixed (ibm_hdr1.volume_sequence, 17);
      if nv = 0
      then
         do;					/* volume sequence is 0 */
	  if substr (lbl_buf, 5, 76) = dummy_label (1)
	  then
	     do;					/* HDR1 is a dummy */
	        if fl.flX = 1
	        then if ^creating_first ()
		   then
		      do;				/* if so, only creating 1st file */
		         ecode = error_table_$no_file;	/* ...of new file set has meaning */
		         return;
		      end;
	        fl.section = 1;			/* force meaningful values */
	        fl.sequence = 1;
	        go to finish_up;
	     end;
	  else go to bad_hdr1;			/* not dummy HDR1, an error */
         end;
      if fl.flX = 1
      then fl.section = 1;				/* dummy up section number */
      else
         do;					/* tests can be made */
	  if fl.backP -> fl.file_id = fl.file_id
	  then fl.section = fl.backP -> fl.section + 1;
	  else fl.section = 1;
         end;
      fl.sequence = fixed (ibm_hdr1.dataset_sequence, 17);
      if fl.sequence = 0
      then go to bad_hdr1;

      if nv = 1
      then
         do;					/* label says 1st volume */
	  if fl.vlX = 1
	  then ;					/* and so it is */
	  else go to bad_seq;			/* definite error */
         end;
      else if fl.vlX ^= nv
      then go to new_file_set;			/* volume isn't _nth - see why */
      if fl.sequence = 1
      then
         do;					/* check file and volume sequences */
	  if nv = 1
	  then
	     do;					/* file 1 on volume 1 */
	        if fl.flX ^= 1
	        then go to bad_seq;			/* must be 1st file link */
	        else ;				/* it is, fine */
	     end;
	  else
	     do;					/* file 1 on volume nv > 1 */
	        if nv = fl.backP -> fl.vlX + 1
	        then ;				/* fine, volumes in sequence */
	        else go to bad_seq;
	     end;
         end;
      else if fl.flX = 1
      then go to new_file_set;			/* perhaps error - find out */
      go to finish_up;


bad_hdr1:
      ecode = error_table_$invalid_label_format;
      return;


   end fill_fl_from_HDR1;

fill_fl_from_HDR2:
   procedure (ecode);				/* fills file link from HDR2 data */
dcl   ecode		        fixed bin (35);

dcl   canon_std		        (2) fixed bin initial (Volume_ansi_tape, Volume_ibm_tape);

      if debug
      then call debug_print ("fill_fl_from_HDR2");
      on conversion go to bad_hdr2;
      if cseg.standard ^= 1
      then go to IBM_fill_fl_from_HDR2;

      fl.format = index (ansi_format_chars, ansi_hdr2.format);
      if fl.format = 0
      then go to bad_hdr2;
      fl.blklen = fixed (ansi_hdr2.blklen, 17);
      if fl.blklen = 0
      then go to bad_hdr2;
      if fl.blklen > cseg.buf_size
      then
         do;					/* we don't have enough room to read it */
	  fl.blklen = fl.blklen + mod (fl.blklen, 4);	/* make it mod 4 */
	  call
	     ioa_ ("^a^/Reattach with a ""-block ^d"" specification.",
	     "Block size in HDR2 label > block size allowed for this attachment.", fl.blklen);
	  go to bad_hdr2;
         end;
      if fl.format ^= 1
      then fl.reclen = fixed (ansi_hdr2.reclen, 17);	/* reclen only for F, D, and S */
      if fl.system ^= ""
      then
         do;					/* fields may be valid */
	  fl.bo = fixed (ansi_hdr2.buffer_offset, 17);
	  if fl.system = fd.system
	  then
	     do;					/* following is system specific */
	        if old_ansi_hdr2_system_use.system_reserved = ""
	        then
		 do;				/* old-format hdr2 label */
		    fl.blocked = bit (old_ansi_hdr2_system_use.blocked);
		    fl.mode = fixed (old_ansi_hdr2_system_use.mode, 17);
		    fl.canonical_next_volname = old_ansi_hdr2_system_use.canonical_next_volname;
		    fl.next_volname = "";
		 end;
	        else
		 do;
		    fl.blocked = bit (ansi_hdr2.system_use.blocked);
		    fl.mode = fixed (ansi_hdr2.system_use.mode, 17);
		    fl.next_volname = ansi_hdr2.system_use.next_volname;
		    if fl.next_volname ^= ""
		    then
		       do;
			call
			   canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), fl.next_volname,
			   fl.canonical_next_volname, canon_std (cseg.standard), ecode);
			if ecode ^= 0
			then goto bad_hdr2;
		       end;
		    else fl.canonical_next_volname = "";
		 end;
	     end;
         end;
      return;

IBM_fill_fl_from_HDR2:
      fl.format = index (ibm_format_chars, ibm_hdr2.format);
      if fl.format = 0
      then go to bad_hdr2;
      fl.blklen = fixed (ibm_hdr2.blksize, 17);
      if fl.blklen = 0
      then go to bad_hdr2;
      if fl.format ^= 1
      then fl.reclen = fixed (ibm_hdr2.lrecl, 17);	/* reclen only for F and V */

/*      t = fixed (ibm_hdr2.density, 17); This is stupid. Since we are already */
/*      if cseg.density ^= t    reading the tape at the right density, who cares */
/*      then go to bad_hdr2;    what the HDR2 label says the density is. */
      if ibm_hdr2.dataset_position = "1"
      then
         do;					/* should not be 1st volume */
	  if fl.vlX = 1
	  then go to bad_hdr2;			/* cant be 1st vol */
	  if fl.backP -> fl.eox ^= 2
	  then go to bad_hdr2;			/* previous must have EOV labels */
         end;
      if ibm_hdr2.recording_technique ^= ""
      then go to bad_hdr2;
      t = index (ibm_block_codes, ibm_hdr2.block_attribute);
      if t = 0
      then go to bad_hdr2;
      if t > 2
      then
         do;					/* indicated spanned blocks */
	  t = t - 2;
	  if fl.format = 3
	  then /* set it to V spanned only if hdr2.format is "V" */
	       fl.format = 4;
         end;
      if t = 1
      then fl.blocked = "0"b;
      else fl.blocked = "1"b;
      fl.cc = ibm_hdr2.control_characters;
      return;

bad_hdr2:
      ecode = error_table_$invalid_label_format;
      return;

   end fill_fl_from_HDR2;

fill_fdhdr2_from_fl:
   procedure;					/* fills fd hdr2 data from fl if section has HDR2 */
      if debug
      then call debug_print ("fill_fdhdr2_from_fl");

      if fl.HDR2
      then
         do;					/* fill only if HDR2 exists */
	  if fd.format ^= 0
	  then
	     do;					/* -format in attach description */
	        if fd.format ^= fl.format
	        then
		 do;				/* incompatible file attribute specification */
mis_match:
		    code = error_table_$incompatible_file_attribute;
		    go to er_exit;
		 end;
	        else format_override = "1"b;		/* -format's blocking attribute to be used */
	     end;
	  else
	     do;					/* -format not specified */
	        fd.format = fl.format;		/* use value from HDR2 */
	        format_override = "0"b;		/* blocking attribute not specified */
	     end;

	  if fd.blklen ^= 0
	  then
	     do;
	        if fd.blklen ^= fl.blklen
	        then go to mis_match;
	        else ;
	     end;
	  else fd.blklen = fl.blklen;

	  if fd.format ^= 1
	  then
	     do;					/* record length undefined for U format */
	        if fd.reclen ^= 0
	        then
		 do;				/* only test if specified */
		    if fd.reclen <= max_reclen (cseg.standard)
		    then
		       do;			/* fits in HDR2 reclen field */
			if fd.reclen ^= fl.reclen
			then go to mis_match;	/* must match */
			else ;			/* ok */
		       end;
		    else if fl.reclen ^= 0
		    then go to mis_match;		/* doesn't fit - 0 */
		 end;
	        fd.reclen = fl.reclen;
	     end;

	  if cseg.standard = 1
	  then
	     do;					/* ANSI */
	        if fl.system ^= ""
	        then
		 do;				/* certain HDR2 fields are valid */
		    fd.bo = fl.bo;			/* CANNOT BE USER-SPECIFIED */
		    if fl.system = fd.system
		    then
		       do;			/* system-defined data is valid */
			if format_override
			then
			   do;			/* blocking attributes must match */
			      if fd.blocked ^= fl.blocked
			      then go to mis_match;
			      else ;
			   end;
			else fd.blocked = fl.blocked;
			if fd.mode ^= 0
			then
			   do;
			      if fd.mode ^= fl.mode
			      then go to mis_match;
			      else ;
			   end;
			else fd.mode = fl.mode;
		       end;
		 end;
	        else fd.bo = 0;			/* must be 0 if fl.system = "" */
	     end;
	  else
	     do;					/* IBM */
	        if format_override
	        then
		 do;
		    if fd.blocked ^= fl.blocked
		    then go to mis_match;
		    else ;
		 end;
	        else fd.blocked = fl.blocked;
	        fd.cc = fl.cc;			/* CANNOT BE USER-SPECIFIED */
	     end;
         end;
      return;

   end fill_fdhdr2_from_fl;

fill_flhdr2_from_fd:
   procedure;					/* fill fl hdr2 data from fd and defaults */
      if debug
      then call debug_print ("fill_flhdr2_from_fd");

      if fd.format = 0
      then
         do;					/* apply defaults */
	  if cseg.output_mode ^= 4
	  then
	     do;					/* defaults permitted only for create */
no_defaults:
	        code = error_table_$insufficient_open;
	        go to er_exit;
	     end;
	  fd.format = 3;				/* D or V format */
	  fd.blocked = "1"b;			/* blocked */
         end;
      fl.format = fd.format;
      fl.blocked = fd.blocked;

      if fd.blklen = 0
      then
         do;					/* apply defaults */
	  if cseg.output_mode ^= 4
	  then go to no_defaults;
	  if cseg.standard = 1
	  then fd.blklen = 2048;			/* ANSI */
	  else fd.blklen = 8192;			/* IBM */
         end;
      fl.blklen = fd.blklen;

      if fd.reclen = 0
      then
         do;					/* apply defaults */

	  if cseg.output_mode ^= 4
	  then go to no_defaults;
	  go to default_reclen (fd.format);		/* perform appropriate reclen default action */

default_reclen (2):
	  fd.reclen = fd.blklen;			/* F format */
	  go to set_fl_reclen;

default_reclen (3):
	  if cseg.standard = 1
	  then fd.reclen = fd.blklen;			/* D format */
	  else fd.reclen = fd.blklen - 4;		/* V format */
	  go to set_fl_reclen;

default_reclen (4):
	  fd.reclen = prec (sys_info$max_seg_size * 4, 21);
						/* S or VS format */

         end;

default_reclen (1):					/* U format - 0 is correct */
set_fl_reclen:
      if fd.reclen > max_reclen (cseg.standard)
      then fl.reclen = 0;
      else fl.reclen = fd.reclen;

      if fd.mode = 0
      then
         do;					/* apply defaults */
	  if cseg.standard = 1
	  then fd.mode = 1;				/* ANSI - ASCII */
	  else fd.mode = 2;				/* IBM - EBCDIC */
         end;
      fl.mode = fd.mode;

      fl.cc = fd.cc;
      fl.bo = 0;
      fl.next_volname, fl.canonical_next_volname = "";
      return;

   end fill_flhdr2_from_fd;

fill_new_section_fl:
   procedure;					/* initializes new file section link */
      if debug
      then call debug_print ("fill_new_section_fl");

      fl.file_id = fl.backP -> fl.file_id;		/* copy from previous link */
      fl.set_id = fl.backP -> fl.set_id;
      fl.canonical_set_id = fl.backP -> fl.canonical_set_id;
      fl.section = fl.backP -> fl.section + 1;		/* increment section number */
      fl.sequence = fl.backP -> fl.sequence;
      fl.generation = fl.backP -> fl.generation;
      fl.version = fl.backP -> fl.version;
      fl.creation = fl.backP -> fl.creation;
      fl.expiration = fl.backP -> fl.expiration;
      fl.access = fl.backP -> fl.access;
      fl.blkcnt = 0;
      fl.system = fd.system;

      fl.hdr2 = fl.backP -> fl.hdr2;
      fl.next_volname, fl.canonical_next_volname = "";	/* initialize */

      return;

   end fill_new_section_fl;


handler:
   procedure;					/* intercept any faults during iocb manipulation */
dcl   1 ti		        aligned,
        2 version		        fixed bin init (0),
        2 code		        fixed bin (35);

      if mask ^= "0"b
      then
         do;					/* IPS interrupts masked */
	  ti.code = error_table_$unable_to_do_io;	/* very bad trouble */
	  call terminate_process_ ("fatal_error", addr (ti));
						/* kill the process */
         end;
      call continue_to_signal_ (0);
      return;
   end handler;

initialize_permit:
   procedure (vX) returns (bit (1));			/* query for permission to write VOL1 label */
dcl   vX			        fixed bin;
dcl   msg			        char (120) varying;
dcl   (extra1, extra2)	        char (12) varying initial ("");

      qi.scode = error_table_$uninitialized_volume;	/* set status code */
      go to query (vl (vX).write_VOL1);			/* issue appropriate query */


initialize_permitA:
   entry (vX) returns (bit (1));			/* query to initialize an unexpired volume */
      qi.qcode = 0;
      qi.scode = error_table_$unexpired_volume;
      msg = "Volume ^a requires initialization, but contains an unexpired file.^/Do you want to initialize it?";
      go to ip_com;


query (2):
      qi.qcode = 1;					/* unreadable 1st block */
      msg = "Volume ^a requires initialization: first block is unreadable.^/Do you want to initialize it?";
      go to ip_com;


query (3):
      qi.qcode = 2;					/* first block isn't VOL1 label */
      msg = "Volume ^a requires initialization: first block is not VOL1 label.^/Do you want to initialize it?";
      go to ip_com;


query (4):
      qi.qcode = 3;					/* VOL1 label has wrong volid */
      extra1 = substr (cseg.lbl_buf, 5, 6);		/* volid encountered */
      extra2 = vl (vX).canonical_volname;		/* volid expected */
      msg = "Warning: Label for volume ^a contains identifier ^a instead of ^a.^/";
      if cseg.open_mode = 4
      then /* Volume is read-only */
	 msg = msg || "Do you really want to continue processing?";
      else msg = msg || "Do you want to reinitialize it as the desired volume?";
						/* can write to the tape */
      go to ip_com;


query (5):
      qi.qcode = 4;					/* VOL1 label correct, but wrong density */
      msg = "Volume ^a requires initialization: recorded at incorrect density.^/Do you want to re-initialize it?";
      go to ip_com;

query (6):
      qi.qcode = 5;					/* VOL1 label correct, but invalid file-set format */
      msg =
         "Volume ^a requires initialization: recorded in an invalid file-set format.^/Do you want to re-initialize it?";


ip_com:
      qi.yes_no = "1"b;
      qi.suppress_name = "0"b;

      call command_query_ (addr (qi), answer, cseg.module, (msg), vl (vX).volname, extra1, extra2);

      if answer = "yes"
      then return ("1"b);
      else return ("0"b);

   end initialize_permit;

initialize_volume:
   procedure (vX, ecode);				/* initializes a volume with VOL1 label and 1 dummy file */
dcl   vX			        fixed bin,		/* volume link index */
      ecode		        fixed bin (35);	/* error code */
dcl   (i, j, k)		        fixed bin;		/* temporary indices */

      if debug
      then call debug_print ("initialize_volume");

      vl (vX).auth_code = authenticate_ (vl (vX).volname);

      vl (vX).cflX = 0;
      call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);	/* get to beginning of tape */
      if ecode ^= 0
      then return;

      ansi_vol1P, ibm_vol1P = addr (cseg.lbl_buf);	/* get pointer to label buffer */
      ansi_vol1.label_id = "VOL1";			/* initialize VOL1 label */
      ansi_vol1.volume_id = vl (vX).canonical_volname;

      if cseg.standard = 1
      then
         do;					/* ANSI */
	  ansi_vol1.access = " ";
	  ansi_vol1.reserved1 = " ";
	  ansi_vol1.owner_id = vl (vX).auth_code;
	  ansi_vol1.reserved2 = " ";
	  ansi_vol1.label_version = "3";
	  k = 2;					/* set HDR loop limit */
         end;
      else
         do;					/* IBM */
	  ibm_vol1.reserved1 = "0";
	  ibm_vol1.VTOC_pointer = " ";
	  ibm_vol1.reserved2 = " ";
	  ibm_vol1.owner_id = vl (vX).auth_code;
	  ibm_vol1.reserved3 = " ";
	  k = 1;					/* set HDR loop limit */
         end;

      call write_label (ecode);			/* write VOL1 label */
      if ecode ^= 0
      then return;

      do i = 1 to k;
         cseg.lbl_buf = l1id (i) || dummy_label (k);
         call write_label (ecode);			/* write HDR1 / EOF1 label */
         if ecode ^= 0
         then return;
         do j = 1 to 2;
	  call tape_ansi_tape_io_$order (cP, "eof", 0, ecode);
						/* write 2 TM */
	  if ecode ^= 0
	  then return;
         end;
      end;

      return;

   end initialize_volume;

lrec_open:
   procedure;					/* logical record IO initialization and final checks */
      if debug
      then call debug_print ("lrec_open");
dcl   i			        fixed bin;

      if cseg.open_mode > 4
      then if fd.blklen < 18
	 then go to inv_blk;			/* can't write < 18 chars */
      if fd.mode = 3
      then cseg.mode = 0;				/* binary encoding   */
      else cseg.mode = 1;				/* ascii, ebcdic 9 mode hardware */
      if cseg.standard > 1
      then go to ibm_open;

      i = fd.blklen - fd.bo;				/* get usable portion of block */
      go to test (fd.format);				/* test the blocking */
test (2):
      if ^fd.blocked
      then if i ^= fd.reclen
	 then go to inv_rec;			/* F unblocked */
	 else go to ok;
      else if mod (i, fd.reclen) ^= 0
      then go to inv_rec;				/* F blocked */
      else go to ok;
test (3):
      if ^fd.blocked
      then if i ^= fd.reclen
	 then go to inv_rec;			/* D unblocked */
	 else go to ok;
      else if fd.reclen > i
      then go to inv_rec;				/* D blocked */
      else go to ok;
test (4):
match (4):
      if fd.reclen > sys_info$max_seg_size * 4
      then go to inv_rec;				/* S format */

test (1):
match (1):
ok:
      cseg.rlN = -1;				/* invalidate anything in rl segment */
      cseg.lrec.bufP = null;				/* no active buffer */
      if cseg.open_mode = 4
      then cseg.lrec.blkcnt = 0;			/* input - no blocks processed */
      else cseg.lrec.blkcnt = fl.blkcnt;		/* output - set to 0 or EOX blkcnt for extend */
      cseg.lrec.reccnt = 0;				/* not currently used */
      cseg.lrec.code = 0;				/* no errors encountered */
      call tape_ansi_tape_io_$open (cP);		/* initialize call to tape_ansi_tape_io_ */
      return;					/* exit */

inv_rec:
      code = error_table_$invalid_record_length;
      go to er_exit;
inv_blk:
      code = error_table_$invalid_block_length;		/* set error code */
      go to er_exit;

ibm_open:
      if cseg.open_mode > 4
      then if mod (fd.blklen, 4) ^= 0
	 then go to inv_blk;			/* can only write words */


      go to match (fd.format);			/* match the blocking */
match (2):
      if ^fd.blocked
      then if fd.blklen ^= fd.reclen
	 then go to inv_rec;			/* F unblocked */
	 else go to ok;
      else if mod (fd.blklen, fd.reclen) ^= 0
      then go to inv_rec;				/* F blocked */
      else go to ok;
match (3):
      if ^fd.blocked
      then if fd.blklen - 4 ^= fd.reclen
	 then go to inv_rec;
	 else go to ok;
      else if fd.reclen > fd.blklen - 4
      then go to inv_rec;				/* V blocked */
      else go to ok;

   end lrec_open;

move_to_EOD:
   procedure;					/* position after last data block of last section */

      if debug
      then call debug_print ("move_to_EOD");
      do cseg.flP = cseg.flP repeat fl.nextP while (fl.eox = 2);
						/* set link pointer to last section */
      end;

      call move_tape_ (fl.vlX, fl.flX, 2, code);		/* move to trailers */
      if code ^= 0
      then go to er_exit;

      call back_TM (1, code);				/* move back into data */
      if code ^= 0
      then go to er_exit;

      return;

   end move_to_EOD;

move_tape_:
   procedure (vX, fX, posit, ecode);			/* positions to file section and intra-section position */
dcl   vX			        fixed bin,		/* volume link index of desired volume */
      fX			        fixed bin,		/* file link index of desired file */
      posit		        fixed bin,		/* position within file section */
      ecode		        fixed bin (35);	/* error code */
dcl   (i, j)		        fixed bin,
      can_retry		        bit (1) init ("0"b);
dcl   uninit_msg		        (6) char (40)
			        init ("is blank", "is unreadable", "is not formatted according to standard",
			        "has volume identifier of", "is recorded at incorrect density",
			        "is recorded in invalid file-set format");

      if debug
      then call debug_print ("move_tape_");
      if vl (vX).rcp_id = 0
      then
         do;					/* volume is not mounted */
	  if cseg.nactive < cseg.ndrives
	  then
	     do;					/* more drives available */
	        call tape_ansi_mount_cntl_$mount (cP, vX, ecode);
						/* mount the volume */
	        if ecode ^= 0
	        then
		 do;				/* maybe trouble */
		    if ecode = error_table_$device_limit_exceeded
		    then
		       do;
			cseg.ndrives = cseg.ndrives - 1;
						/* decrement maximum device count */
			go to switch;
		       end;
		    else go to error;		/* true trouble */
		 end;
	     end;
	  else
	     do;					/* no drive available */
switch:
	        call find_candidate;			/* get index (i) of volume to dismount */
	        call tape_ansi_mount_cntl_$remount (cP, i, vX, ecode);
						/* remount the volume */
	        if ecode ^= 0
	        then go to error;			/* trouble */
	     end;
         end;

      cseg.tseg.drive_name = vl (vX).tape_drive;
      cseg.tseg.ev_chan = vl (vX).event_chan;

      if cseg.open_mode = 4
      then /* open for read only */
	 vl (vX).write_VOL1 = max (vl (vX).write_VOL1, 0);/* bide time; don't try to update label now */

      if vl (vX).write_VOL1 ^= 0
      then
         do;					/* VOL1 label missing or bad */
	  if (cseg.open_mode = 4) /* mounted read-only */ & (vl (vX).write_VOL1 ^= 4)
						/* and not just mismatched volid */
	  then
	     do;					/* volume needs relabeling and can't */
uninit_error:
	        call ioa_ ("^a: Volume ^a ^a.", cseg.module, vl (vX).volname, uninit_msg (vl (vX).write_VOL1));
	        ecode = error_table_$uninitialized_volume;
	        go to error;
	     end;

	  if vX = 1 & ^creating_first ()
	  then if vl (vX).write_VOL1 < 0
	       then vl (vX).write_VOL1 = 0;		/* bide time, etc. */
	       else go to uninit_error;		/* don't init 1st vol if not creating 1st file */

	  if vl (vX).write_VOL1 > 1
	  then if ^initialize_permit (vX)
	       then
		do;				/* tape isn't blank - no permission */
		   ecode = error_table_$uninitialized_volume;
		   go to error;
		end;

	  if vl (vX).write_VOL1 ^= 0
	  then /* needs better VOL1 label */
	       if cseg.open_mode ^= 4
	       then
		do;				/* don't do if read only-- if we're here, */
						/* problem is insignificant anyway */
		   call initialize_volume (vX, ecode);
		   if ecode ^= 0
		   then go to error;
		end;

	  vl (vX).write_VOL1 = 0;			/* VOL1 written - cflX = 0 */
         end;

      can_retry = "1"b;				/* one retry permitted */
      if vl (vX).cflX = 0
      then
         do;					/* volume position unknown or in VOL/UVL set */
retry:
	  call move_to_first_HDR;			/* position tape to 1st_HDR HDR group */
	  vl (vX).cflX = vl (vX).fflX;		/* volume positioned to 1st file section */
	  vl (vX).pos = 0;
         end;

      if vl (vX).cflX < fX
      then
         do;					/* volume positioned before desired file */
	  j = (fX - vl (vX).cflX) * 3;		/* move over TM's */
	  j = j - vl (vX).pos + posit;		/* adjust for intra-file offsets */
	  call move_forward;			/* move j TM */
         end;

      else if vl (vX).cflX > fX
      then
         do;					/* volume positioned after desired file */
	  j = ((vl (vX).cflX - fX) * 3) + 1;		/* move over TM's */
	  j = j + vl (vX).pos - posit;		/* adjust for intra-file offsets */
	  call move_backward;			/* move j TM */
         end;

      else
         do;					/* volume positioned at desired file */
	  if vl (vX).pos = posit
	  then
	     do;					/* and at desired offset */
	        j = 1;				/* really positions to 1st block after this TM */
	        call move_backward;			/* really positions to beginning of TM group */
	     end;
	  else if vl (vX).pos < posit
	  then
	     do;					/* before desired offset */
	        j = posit - vl (vX).pos;
	        call move_forward;			/* move j TM */
	     end;
	  else
	     do;					/* after desired section */
	        j = vl (vX).pos - posit + 1;		/* move over TM's */
	        call move_backward;			/* move j TM */
	     end;
         end;

ok_exit:
      vl (vX).cflX = fX;				/* new position info */
      vl (vX).pos = posit;
      return;

error:
      vl (vX).cflX = 0;				/* we don't know where we are */
      if can_retry
      then
         do;					/* can we retry the move? */
	  can_retry = "0"b;				/* yes - but only once */
	  go to retry;
         end;
      return;

find_candidate:
   procedure;					/* find a volume to dismount */
      if debug
      then call debug_print ("find_candidate");

      do i = 1 to vX - 1;				/* search up to desired volume */
         if vl (i).rcp_id ^= 0
         then return;				/* got one active */
      end;					/* none preceding current link */
      do i = cseg.vcN to vX + 1 by -1;			/* search down to desired volume */
         if vl (i).rcp_id ^= 0
         then return;				/* got one active */
      end;
      ecode = error_table_$invalid_cseg;		/* something very wrong if no volume found */
      go to error;

   end find_candidate;

move_to_first_HDR:
   procedure;					/* positions volume to 1st HDR label */
      if debug
      then call debug_print ("move_to_first_HDR");

      call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);	/* rewind the volume */
      if ecode ^= 0
      then go to error;
HDR_search:
      call read_label (ecode);			/* read a label */
      if ecode ^= 0
      then
         do;					/* trouble */
	  if ecode = error_table_$eof_record
	  then ecode = error_table_$invalid_file_set_format;
	  go to error;
         end;
      if label_type ^= "HDR"
      then go to HDR_search;				/* read until 1st HDR */
      call tape_ansi_tape_io_$order (cP, "bsr", 0, ecode);	/* get back to beginning of HDR */
      if ecode ^= 0
      then go to error;
      return;

move_forward:
   entry;						/* position j TM sections forward */
      do i = 1 to j;
         call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);
						/* move forward 1 TM */
         if ecode ^= 0
         then go to error;
      end;
      return;

move_backward:
   entry;						/* position j TM sections backward */
      do i = 1 to j - 1;				/* do all but last */
         call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
						/* backspace 1 TM */
         if ecode ^= 0
         then go to error;
      end;

      call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);	/* do last */
      if ecode = error_table_$positioned_on_bot
      then go to HDR_search;
      else if ecode ^= 0
      then go to error;
      call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);	/* position to record after TM */
      if ecode ^= 0
      then go to error;
      return;

move_to_first_UHL:
   entry;						/* position to 1st UHL */
      i = 1;
      go to UL_search;
move_to_first_UTL:
   entry;						/* position to 1st UTL */
      i = 2;
UL_search:
      call read_label (ecode);			/* read a label */
      if ecode = error_table_$eof_record
      then call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
						/* EOF */
      else if ecode ^= 0
      then go to error;
      else if label_type ^= UL (i)
      then go to UL_search;				/* not a user label */
      else call tape_ansi_tape_io_$order (cP, "bsr", 0, ecode);
						/* got it */
      if ecode ^= 0
      then go to error;
      return;

   end move_to_first_HDR;

   end move_tape_;

next_volume:
   procedure returns (bit (1));			/* determines if volume switch possible */

dcl   canon_std		        (2) fixed bin initial (Volume_ansi_tape, Volume_ibm_tape);

      if debug
      then call debug_print ("next_volume");

      if fl.vlX < cseg.vcN
      then return ("1"b);				/* if current vlX < vcN then next exists */

      if fl.vlX = 63
      then
         do;					/* volume chain full */
	  call ioa_ ("^a: Implementation limit of 63 volumes exceeded.", cseg.module);
	  return ("0"b);
         end;

      if fl.system = fd.system
      then
         do;					/* trailers could have next reel id */
	  if fl.next_volname ^= ""
	  then
	     do;					/* they do */
	        vn = fl.next_volname;			/* copy it */
	        go to got_volname;			/* use it */
	     end;
         end;

      if another_volume ()
      then vl (cseg.vcN + 1).comment = com_text;		/* yes */
      else return ("0"b);				/* no */

got_volname:
      cseg.vcN = cseg.vcN + 1;			/* increment volume link count */
      call vl_init (cseg.vcN);
      vl (cseg.vcN).volname = vn;			/* set reel id in volume link */
      call
         canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), vl (cseg.vcN).volname, vl (cseg.vcN).canonical_volname,
         canon_std (cseg.standard), code);
      if code ^= 0
      then return ("0"b);

      return ("1"b);

   end next_volume;

process_EOX:
   procedure (ecode);				/* processes trailer labels for file chain */
dcl   ecode		        fixed bin (35);

dcl   canon_std		        (2) fixed bin initial (Volume_ansi_tape, Volume_ibm_tape);

      if debug
      then call debug_print ("process_EOX");
      on conversion go to bad_EOX;
      fl.eox = 0;					/* trailers not yet processed */
      ansi_hdr1P, ansi_hdr2P = addr (lbl_buf);		/* set pointers to label IO buffer */

      call read_label (ecode);			/* read EOX1 label */

      if ecode ^= 0
      then
         do;					/* trouble */
	  if ecode = error_table_$eof_record
	  then /* label missing */
bad:
	     ecode = error_table_$invalid_file_set_format;
	  return;
         end;

      if ansi_hdr1.label_id = "EOV1"
      then fl.eox = 2;				/* indicate volume switch */
      else if ansi_hdr1.label_id = "EOF1"
      then fl.eox = 1;				/* no volume switch */
      else go to bad;				/* error if not EOF or EOV */

      fl.creation = substr (ansi_hdr1.creation, 2, 5);	/* update creation date to latest */

      fl.version = fixed (ansi_hdr1.version, 17);		/* update version to latest */

      fl.blkcnt = fixed (ansi_hdr1.blkcnt, 35);		/* save block count */

      call read_label (ecode);			/* read next label (EOX2 or otherwise) */

      if ecode ^= 0
      then
         do;					/* investigate */
	  if ecode = error_table_$eof_record
	  then
	     do;					/* no EOX2 label */
	        call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
						/* backspace into trailer set */
	        if ecode ^= 0
	        then return;
no_EOX2:
	        if fl.eox = 2
	        then
		 do;				/* EOV label */
		    if next_volume ()
		    then fl.next_volname = vl (fl.vlX + 1).volname;
						/* have volume */
		    else ecode = error_table_$no_next_volume;
		 end;
	     end;
	  return;
         end;

      if label_type = "UTL"
      then go to no_EOX2;				/* user label - no EOX2 */
      if ansi_hdr2.label_id ^= l2id (fl.eox + 1)
      then go to bad;				/* label not EOF2 or EOV2 */

      if fl.eox = 2
      then
         do;					/* EOV labels */
	  if cseg.standard = 1
	  then if fl.system = fd.system
	       then if old_ansi_hdr2_system_use.system_reserved ^= ""
		  then
		     do;
		        fl.next_volname = ansi_hdr2.next_volname;
		        call
			 canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), fl.next_volname,
			 fl.canonical_next_volname, canon_std (cseg.standard), ecode);
		        if ecode ^= 0
		        then goto bad_EOX;
		     end;

	  if next_volume ()
	  then
	     do;					/* allow for -volume override */
	        fl.next_volname = vl (fl.vlX + 1).volname;
	        fl.canonical_next_volname = vl (fl.vlX + 1).canonical_volname;
	     end;
	  else ecode = error_table_$no_next_volume;
         end;

      return;

bad_EOX:
      ecode = error_table_$invalid_label_format;
      return;

   end process_EOX;

read_HDR1:
   procedure (eofsw, ecode);				/* read HDR1 label (if any) */
dcl   eofsw		        bit (1);		/* end-of-file-set bit */
dcl   ecode		        fixed bin (35);

      if debug
      then call debug_print ("read_HDR1");
      eofsw = "0"b;					/* initialize */
      ansi_hdr1P, ibm_hdr1P = addr (cseg.lbl_buf);	/* set pointer to label */

      call read_label (ecode);			/* read it */

      if ecode = 0
      then
         do;					/* read something ok */
	  if ansi_hdr1.label_id ^= "HDR1"
	  then
	     do;					/* the something wasn't what we wanted */
	        ecode = error_table_$invalid_file_set_format;
	        return;
	     end;
         end;

      else if ecode = error_table_$eof_record
      then
         do;					/* read a TM */
	  vl (fl.vlX).pos = vl (fl.vlX).pos + 1;	/* increment position count */
	  call back_TM (1, ecode);			/* backup over it */
	  if ecode = 0
	  then eofsw = "1"b;			/* set the eofs bit */
         end;

      return;

   end read_HDR1;


read_HDR2:
   procedure (ecode);				/* read HDR2 label (if any) */
dcl   ecode		        fixed bin (35);

      if debug
      then call debug_print ("read_HDR2");
      fl.HDR2 = "0"b;				/* HDR2 not yet processed */
      ansi_hdr2P, ibm_hdr2P = addr (cseg.lbl_buf);	/* get pointer to label */

      call read_label (ecode);			/* read it */

      if ecode = 0
      then
         do;					/* read something ok */
	  if ansi_hdr2.label_id = "HDR2"
	  then fl.HDR2 = "1"b;			/* something was HDR2 */
	  else ;					/* something wasn't */
         end;

      else if ecode = error_table_$eof_record
      then
         do;					/* went over TM */
	  vl (fl.vlX).pos = vl (fl.vlX).pos + 1;	/*  increment position count */
	  call back_TM (1, ecode);			/* backup over it */
         end;

      return;

   end read_HDR2;

read_label:
   procedure (ecode);				/* reads an 80 character label synchronously */
dcl   ecode		        fixed bin (35),
      nchar		        fixed bin;

      call tape_ansi_tape_io_$sync_read (cP, nchar, ecode); /* read a block */

      if ecode = 0
      then
         do;					/* read was uneventful */
	  if nchar < 80
	  then
	     do;					/* definitely not a label */
	        ecode = error_table_$invalid_label_format;
	        return;
	     end;
	  else
	     do;					/* probably a label */
	        if cseg.standard = 1
	        then cseg.lbl_buf = sync_buf;		/* move into label buffer */
	        else call ebcdic_to_ascii_ (sync_buf, cseg.lbl_buf);
						/* convert to ascii and move */
	     end;
         end;

      if debug
      then
         do;
	  if ecode = 0
	  then call ioa_ ("^80a", lbl_buf);
	  else call ioa_ ("^d", ecode);
         end;
      return;					/* with ecode = 0, EOF, or error */


write_label:
   entry (ecode);

      if cseg.standard = 1
      then sync_buf = cseg.lbl_buf;			/* ascii - move it */
      else call ascii_to_ebcdic_ (cseg.lbl_buf, sync_buf);	/* ebcdic - convert and move */

      call tape_ansi_tape_io_$sync_write (cP, 80, ecode);	/* write it */

      if debug
      then call ioa_ ("^d^-^80a", ecode, lbl_buf);
      return;					/* with ecode = 0, EOT, or error */

   end read_label;

setup_for_create:
   procedure;					/* fills file link from file data (mostly) */
      if debug
      then call debug_print ("setup_for_create");

      fl.file_id = fd.file_id;			/* use creation name */
      fl.set_id = fl.backP -> fl.set_id;
      fl.canonical_set_id = fl.backP -> fl.canonical_set_id;
      fl.section = 1;
      fl.sequence = fd.sequence;
      if cseg.standard = 1
      then fl.generation = 1;
      else fl.generation = 0;
      fl.version = 0;
      fl.creation = fd.creation;
      fl.expiration = fd.expiration;
      fl.access = fd.access;
      fl.blkcnt = 0;
      fl.system = fd.system;

      call fill_flhdr2_from_fd;			/* fill fl HDR2 from fd and defaults */

      return;

   end setup_for_create;


setup_for_extend_modify:
   procedure;					/* fills file data from file link */
      if debug
      then call ioa_ ("setup_for_extend_modify");

      fd.file_id = fl.file_id;			/* copy HDR1 data */
      fd.sequence = fl.sequence;
      if cseg.standard = 1
      then fl.version = mod (fl.version + 1, 100);	/* if ANSI, up version */
      fl.creation = fd.creation;
      if cseg.output_mode = 2
      then fl.blkcnt = 0;				/* zero block count for modify */
      else ;					/* maintain block count for extend */

      call fill_fdhdr2_from_fl;			/* put hdr2 data from fl, if any, into fd */
      call fill_flhdr2_from_fd;			/* put fd hdr2 data into fl, _n_o defaults */

      return;

   end setup_for_extend_modify;

setup_for_read:
   procedure;					/* tries to complete file data from file link on input */
      if debug
      then call debug_print ("setup_for_read");

      fd.file_id = fl.file_id;			/* copy HDR1 data */
      fd.sequence = fl.sequence;

      if fd.format = 0
      then
         do;					/* no explicit format */
	  fd.format = fl.format;
	  if fd.format = 0
	  then
	     do;
not_enough:
	        code = error_table_$insufficient_open;
	        go to er_exit;
	     end;
	  format_override = "0"b;			/* file data does not override link data */
         end;
      else format_override = "1"b;			/* explicit format */

      if fd.blklen = 0
      then fd.blklen = fl.blklen;
      if fd.blklen = 0
      then go to not_enough;

      if fd.reclen = 0
      then fd.reclen = fl.reclen;
      if fd.reclen = 0
      then
         do;					/* this may be valid */
	  if fd.format = 4
	  then fd.reclen = sys_info$max_seg_size * 4;	/* S or V(B)S */
	  else if fd.format = 1
	  then ;					/* U format - reclen undefined */
	  else go to not_enough;
         end;

      if cseg.standard = 1
      then
         do;					/* ANSI */
	  if fl.system ^= ""
	  then fd.bo = fl.bo;			/* set buffer offset if HDR1 has it */
	  if fl.system = fd.system
	  then
	     do;					/* file written by this system? */
	        if ^format_override
	        then fd.blocked = fl.blocked;		/* set blocked attribute from labels */
	        if fd.mode = 0
	        then fd.mode = fl.mode;		/* set encoding mode from labels */
	     end;
	  else
	     do;					/* system-defined fields are invalid - apply defaults */
	        if ^format_override
	        then fd.blocked = "1"b;		/* blocked */
	        if fd.mode = 0
	        then fd.mode = 1;			/* ascii */
	     end;
         end;
      else
         do;					/* IBM */
	  if ^format_override
	  then fd.blocked = fl.blocked;
	  if fd.mode = 0
	  then fd.mode = 2;				/* EBCDIC */
         end;

      return;

   end setup_for_read;

setup_for_generate:
   procedure;					/* updates file link and fills file data */
      if debug
      then call debug_print ("setup_for_generate");

      fd.file_id = fl.file_id;
      fd.sequence = fl.sequence;

      fl.generation = mod (fl.generation + 1, 10000);	/* increment generation number */
      fl.version = 0;
      fl.creation = fd.creation;			/* use today's date */
      fl.expiration = fd.expiration;			/* use specified expiration date */
      fl.access = fd.access;
      fl.blkcnt = 0;

      call fill_fdhdr2_from_fl;			/* put fl hdr2 data, if any, into fd */
      call fill_flhdr2_from_fd;			/* put fd hdr2 data into fl, _n_o defaults */

      fl.system = fd.system;				/* set now to use system-defined HDR2 fields */

      return;

   end setup_for_generate;

truncate_chains:
   procedure;					/* eliminate chain references to overwritten files */
      if debug
      then call debug_print ("truncate_chains");

dcl   i			        fixed bin,		/* temporary index into volume chain */
      saveP		        ptr,		/* holds pointer to desired file link */
      zaP			        ptr;		/* file chain truncation pointer */

      if fl.nextP = null
      then return;					/* nothing to truncate */

      on cleanup
         begin;					/* don't leave chains inconsistent */
	  cseg.fcP -> fl.nextP = null;		/* truncate file chain entirely (leave dummy) */
	  do i = 1 to cseg.vcN;			/* wipe the volume chain clean of file link references */
	     vl (i).fflX = 0;
	     vl (i).cflX = 0;
	     vl (i).lflX = 0;
	  end;
         end;

      saveP = cseg.flP;				/* save pointer to desired file link */
      cseg.flP = fl.nextP;				/* begin truncation after current link */
      fl.backP -> fl.nextP = null;			/* step 1 - file chain logically truncated */
      if fl.flX = -1
      then go to free;				/* only truncate an eofsl */

      if vl (fl.vlX).fflX = fl.flX
      then
         do;					/* truncated files start a volume */
	  vl (fl.vlX).fflX = 0;			/* wipe that volume clean */
	  vl (fl.vlX).cflX = 0;
	  vl (fl.vlX).lflX = 0;
         end;
      else vl (fl.vlX).lflX = fl.flX - 1;		/* or, last valid reference is before truncation point */

      do i = fl.vlX + 1 to cseg.vcN;			/* all subsequent volumes must be emptied */
         vl (i).fflX = 0;
         vl (i).cflX = 0;
         vl (i).lflX = 0;
      end;					/* step 2 - volume chain adjusted */

      revert cleanup;				/* drastic measures no longer needed */

free:
      zaP = cseg.flP;				/* set pointer to truncation point */
      do cseg.flP = cseg.flP repeat zaP while (zaP ^= null);/* step 3 - free file chain storage */
         zaP = fl.nextP;				/* set pointer to next truncation point */
         free fl in (chain_area);			/* free link at current truncation point */
      end;

exit:
      cseg.flP = saveP;				/* restore pointer to last valid link */

      return;

   end truncate_chains;

vl_init:
   procedure (n);					/* initialize a volume link */
dcl   n			        fixed bin;		/* link index */
      vl (n).fflX = 0;
      vl (n).cflX = 0;
      vl (n).pos = 0;
      vl (n).lflX = 0;
      vl (n).tracks = 0;
      vl (n).density = 0;
      vl (n).label_type = 0;
      vl (n).usage_count = 0;
      vl (n).read_errors = 0;
      vl (n).write_errors = 0;
      vl (n).rcp_id = 0;
      vl (n).event_chan = 0;
      vl (n).tape_drive = "";
      vl (n).write_VOL1 = 0;
      vl (n).ioi_index = 0;
      return;
   end vl_init;

write_HDRs:
   procedure (ecode);				/* formats and writes HDR1 and HDR2 */
      if debug
      then call debug_print ("write_HDRs");

dcl   ecode		        fixed bin (35);	/* error code */
dcl   x			        fixed bin;		/* entry index */

      fl.eox = 0;					/* trailers not yet written */
      x = 1;
      go to write_labels;

write_EOFs:
   entry (ecode);					/* formats and writes EOF1 and EOF2 */
      if debug
      then call debug_print ("write_EOFs");
      fl.blkcnt = cseg.blkcnt;			/* update block count */
      fl.eox = 1;					/* no volume switch */
      x = 2;
      go to write_labels;

write_EOVs:
   entry (ecode);					/* formats and writes EOV1 and EOV2 */
      if debug
      then call debug_print ("write_EOVs");
      fl.blkcnt = cseg.blkcnt;			/* update block count */
      fl.eox = 2;					/* volume switch */
      x = 3;

write_labels:
      call fill_XXX1 (x);				/* format label as HDR1, EOF1, or EOV1 */
      call write_label (ecode);			/* write it */
      if ecode ^= 0
      then if ecode ^= error_table_$eov_on_write
	 then return;				/* check error code */

      if x = 1
      then fl.HDR2 = "1"b;				/* request is for headers, so HDR2 exists */
      else
         do;					/* request is for trailers */
	  if ^fl.HDR2
	  then
	     do;					/* no HDR2 label */
	        ecode = 0;				/* therefore, no EOX2 label */
	        return;
	     end;
         end;

      call fill_XXX2 (x);				/* format label as HDR2, EOF2, or EOV2 */
      call write_label (ecode);			/* write it */
      if ecode = error_table_$eov_on_write
      then ecode = 0;				/* ignore EOT */

      return;					/* with ecode = 0 or an error code */

   end write_HDRs;

write_TM:
   procedure (n, ecode);				/* writes 1 or 2 TM and adjusts volume link */
dcl   n			        fixed bin,		/* number of TM - 1 or 2 */
      cnt			        fixed bin,
      ecode		        fixed bin (35);

      if debug
      then call ioa_ ("write_TM ^d", n);
      do cnt = 1 to n;				/* 1 or 2 */
         call tape_ansi_tape_io_$order (cP, "eof", 0, ecode);
						/* write a TM */
         if ecode ^= 0
         then if ecode ^= error_table_$eov_on_write
	    then return;				/* error exit */

         vl (fl.vlX).pos = vl (fl.vlX).pos + 1;		/* increment for each TM */
         if vl (fl.vlX).pos > 2
         then
	  do;					/* adjust mod3 */
	     vl (fl.vlX).pos = vl (fl.vlX).pos - 3;
	     vl (fl.vlX).cflX = vl (fl.vlX).cflX + 1;
	  end;
      end;

      return;

   end write_TM;

write_new_section:
   procedure (ecode);				/* writes new section headers */
dcl   ecode		        fixed bin (35);

      if debug
      then call debug_print ("write_new_section");
      cseg.flP = fl.nextP;				/* set pointer to next (eofs) link */
      call make_eofsl_real;				/* make it a real link */

      call build_eofsl;				/* add a new end-of-file-set link */

      call move_tape_ (fl.vlX, fl.flX, 0, ecode);		/* position to write headers */
      if ecode ^= 0
      then return;					/* trouble */

      ansi_hdr1P = addr (cseg.lbl_buf);			/* set pointer to label buffer - move_tape_ read HDR1 */
      if substr (ansi_hdr1.expiration, 2, 5) > fd.creation
      then
         do;					/* volume has unexpired data */
	  if initialize_permitA (fl.vlX)
	  then
	     do;					/* user said can re-initialize */
	        call initialize_volume (fl.vlX, ecode);	/* do it */
	        if ecode ^= 0
	        then return;
	        call move_tape_ (fl.vlX, fl.flX, 0, ecode);
						/* re-position to HDR1 */
	        if ecode ^= 0
	        then return;
	     end;
	  else
	     do;					/* user said can't */
	        ecode = error_table_$unexpired_volume;
	        return;
	     end;
         end;

      call fill_new_section_fl;			/* initialize the link */

      call write_HDRs (ecode);			/* write HDR labels */
      if ecode ^= 0
      then return;

/* if cseg.user_labels then call write_UHL; */

      call write_TM (1, ecode);			/* write header set TM */

      return;

   end write_new_section;

data_eof:
   entry (iocbP, code);				/* called by lrec IO when encounters EOF */

      if debug
      then call debug_print ("data_eof");
      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get control segment pointer */

      cc = 0;					/* minimal consistency requirement */
      on cleanup go to data_eof_fail;
      on area
         begin;					/* handle the condition */
	  code = error_table_$noalloc;
	  go to data_eof_fail;
         end;

      vl (fl.vlX).pos = vl (fl.vlX).pos + 1;		/* have moved over a TM - update position info */

      if cseg.standard = 1
      then call tape_ansi_lrec_io_$close (cP, code);	/* close logical record IO */
      else call tape_ansi_ibm_lrec_io_$close (cP, code);
      if code ^= 0
      then
         do;
data_eof_fail:
	  call consistent;
	  go to close_exit;
         end;

      if fl.eox = 0
      then
         do;					/* trailer labels have not been processed */
	  call process_EOX (code);			/* process them */
	  if code ^= 0
	  then go to data_eof_fail;
         end;

      if cseg.blkcnt ^= -1
      then
         do;					/* block count is valid */
	  if cseg.blkcnt ^= fl.blkcnt
	  then
	     do;					/* read and recorded don't agree */
	        code = error_table_$discrepant_block_count;
	        return;
	     end;
         end;

/* if cseg.user_labels then call read_UTL */

      if fl.eox = 1
      then
         do;					/* last (or only) section */
	  code = error_table_$end_of_info;
	  return;
         end;

      if fl.nextP ^= null
      then cseg.flP = fl.nextP;			/* next link exists - use it */
      else
         do;					/* link doesn't exist - make it */
	  cc = 1;					/* insure chain consistency */
	  call build1 (code);			/* process HDR labels */
	  if code ^= 0
	  then go to data_eof_fail;
	  cc = 0;					/* minimal consistency requirement */
         end;

      if fl.flX = -1
      then
         do;					/* link is eofsl */
	  code = error_table_$invalid_file_set_format;
	  cseg.flP = fl.backP;			/* get back to last valid link */
	  go to data_eof_fail;
         end;

      if fl.file_id ^= fl.backP -> fl.file_id | /* file id's must be identical */ fl.section ^= fl.backP -> fl.section + 1
      then
         do;					/* section must be 1 > than previous */
	  code = error_table_$invalid_volume_sequence;
	  cseg.flP = fl.backP;
	  go to data_eof_fail;
         end;

/* if cseg.user_labels then call read_UHL */

      call move_tape_ (fl.vlX, fl.flX, 1, code);		/* move to data of new section */
      if code ^= 0
      then go to data_eof_fail;

      cseg.blkcnt = 0;				/* re-initialize block count for new section */

      return;

data_eot:
   entry (iocbP, code);				/* called by lrec IO when encounters EOT */

      if debug
      then call debug_print ("data_eot");
      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to control segment */

      cc = 2;					/* don't leave defective tape file */
      on cleanup go to write_data_fail;

eot_not_while_closing:
      close_eot = "0"b;				/* eot doing data or positioning for output */
      go to any_eot;
eot_while_closing:
      close_eot = "1"b;				/* eot writing HDR TM for null file */

any_eot:
      on area
         begin;					/* common code - EOT doing data or HDR TM */
	  code = error_table_$noalloc;
	  go to write_data_fail;
         end;

      if ^next_volume ()
      then
         do;					/* no next volume available */
	  code = error_table_$no_next_volume;
	  if ^close_eot
	  then return;				/* exit gracefully */
	  else go to write_data_fail;			/* abort the file fragment */
         end;
      else
         do;					/* volume available - set reel id in trailers */
	  fl.next_volname = vl (fl.vlX + 1).volname;
	  fl.canonical_next_volname = vl (fl.vlX + 1).canonical_volname;
         end;

/* finish current volume, switch to new file section on new volume */

      call write_TM (1, code);			/* write end-of-data TM */
      if code ^= 0
      then if code ^= error_table_$eov_on_write
	 then
	    do;
write_data_fail:
	       call consistent;
	       go to close_exit;			/* force close */
	    end;

      call write_EOVs (code);				/* write EOV labels */
      if code ^= 0
      then go to write_data_fail;

/* if cseg.user_labels then call write_UTL; */

      call write_TM (2, code);			/* write trailer and end of volume TMs */
      if code ^= 0
      then if code ^= error_table_$eov_on_write
	 then go to write_data_fail;

      call write_new_section (code);			/* begin new file section */
      if code ^= 0
      then go to write_data_fail;

      cseg.lrec.blkcnt = 0;				/* initialize block count for new section */

      if close_eot
      then go to continue_close;			/* finish the close operation */
      else return;

position_for_output:
   entry (iocbP, code);				/* called by 1st write_record to write HDR TM */

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to control segment */
      if debug
      then call debug_print ("position_for_output");

      cc = 2;					/* don't leave defective tape file */
      on cleanup go to write_data_fail;

/* if cseg.user_labels then call write_UHL; */

      call write_TM (1, code);			/* write HDR TM */

      if code = 0
      then return;					/* fine - not even end-of-tape */
      if code = error_table_$eov_on_write
      then go to eot_not_while_closing;			/* end-of-tape */
      go to write_data_fail;				/* trouble */



beginning_of_file:
   entry (iocbP, code);				/* positions to beginning of file */

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to control segment */

      cc = 0;					/* minimal consistency requirement */
      on cleanup go to bof_fail;

      if cseg.standard = 1
      then call tape_ansi_lrec_io_$close (cP, code);	/* close logical record I/O */
      else call tape_ansi_ibm_lrec_io_$close (cP, code);
      if code ^= 0
      then go to bof_fail;

      do cseg.flP = cseg.flP repeat fl.backP while (fl.section ^= 1);
						/* get back to first file section */
      end;

      call move_tape_ (fl.vlX, fl.flX, 1, code);		/* position to 1st data record */
      if code ^= 0
      then
         do;					/* trouble - maintain consistency */
bof_fail:
	  call consistent;
	  go to close_exit;
         end;

      call lrec_open;				/* open logical record I/O */
						/* note: no error can occur */

      return;

end_of_file:
   entry (iocbP, code);				/* positions to end of file */

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get control segment pointer */

      cc = 0;					/* minimal consistency requirement */
      on cleanup go to eof_fail;
      on area go to eof_fail;

      if cseg.standard = 1
      then call tape_ansi_lrec_io_$close (cP, code);	/* close logical record IO */
      else call tape_ansi_ibm_lrec_io_$close (cP, code);
      if code ^= 0
      then
         do;
eof_fail:
	  call consistent;
	  go to close_exit;
         end;

      cseg.rlN = -1;				/* invalidate read_length buffer */
      cseg.blkcnt = -1;				/* invalidate block count */

eof_loop:
      if fl.eox = 0
      then
         do;					/* trailer labels have not been processed */
	  call build2 (code);			/* process them */
	  if code ^= 0
	  then go to eof_fail;
         end;

      if fl.eox = 1
      then
         do;					/* last (or only) section */
	  call move_tape_ (fl.vlX, fl.flX, 2, code);	/* position to trailers */
	  if code ^= 0
	  then go to eof_fail;
	  call back_TM (1, code);			/* get back into data */
	  if code ^= 0
	  then go to eof_fail;
	  return;
         end;

      if fl.nextP ^= null
      then cseg.flP = fl.nextP;			/* next link exists - use it */
      else
         do;					/* link doesn't exist - make it */
	  cc = 1;					/* insure chain consistency */
	  call build1 (code);			/* process HDR labels */
	  if code ^= 0
	  then go to eof_fail;
	  cc = 0;					/* minimal consistency requirement */
         end;

      if fl.flX = -1
      then
         do;					/* link is eofsl */
	  code = error_table_$invalid_file_set_format;
	  cseg.flP = fl.backP;			/* get back to last valid link */
	  go to eof_fail;
         end;

      if fl.file_id ^= fl.backP -> fl.file_id | /* file id's must be identical */ fl.section ^= fl.backP -> fl.section + 1
      then
         do;					/* section must be 1 > previous */
	  code = error_table_$invalid_volume_sequence;
	  cseg.flP = fl.backP;
	  go to eof_fail;
         end;
      go to eof_loop;

close:
   entry (iocbP, code);				/* iox_$close entry */

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get control segment pointer */

      if cseg.file_lock
      then
         do;					/* file in use? */
	  code = error_table_$file_busy;
	  return;
         end;
      else
         do;
	  on cleanup cseg.file_lock = "0"b;
	  cseg.file_lock = "1"b;
         end;

      if cseg.invalid
      then
         do;
	  code = error_table_$invalid_cseg;
	  on cleanup go to close_exit1;
	  go to close_exit1;
         end;

      if cseg.open_mode = 4
      then
         do;					/* input mode */
	  cc = 0;					/* minimal consistency requirement */
	  on cleanup go to close_fail;
	  if cseg.standard = 1
	  then call tape_ansi_lrec_io_$close (cP, code);	/*  close logical record IO */
	  else call tape_ansi_ibm_lrec_io_$close (cP, code);
	  if code ^= 0
	  then call consistent;
	  go to close_exit;
         end;
      else
         do;					/* output mode */
	  cc = 2;					/* don't leave defective tape file */
	  on cleanup go to close_fail;
	  if vl (fl.vlX).pos = 0
	  then
	     do;					/* still in HDRs, never wrote data */
	        call write_TM (1, code);		/* re-write HDR TM (should be after last HDR label) */
	        if code ^= 0
	        then
		 do;				/* maybe trouble */
		    if code = error_table_$eov_on_write
		    then go to eot_while_closing;	/* return to continue_close */
		    else go to close_fail;		/* real error, abort the file */
		 end;
	     end;
continue_close:
	  if cseg.standard = 1
	  then call tape_ansi_lrec_io_$close (cP, code);	/* close logical IO */
	  else call tape_ansi_ibm_lrec_io_$close (cP, code);
	  if code ^= 0
	  then
	     do;					/* maybe trouble */
	        if code ^= error_table_$eov_on_write
	        then
		 do;				/* EOT is ok */
close_fail:
		    call consistent;		/* delete the file */
		    go to close_exit;
		 end;
	     end;

	  call write_TM (1, code);			/* write the end-of-data TM */
	  if code ^= 0
	  then if code ^= error_table_$eov_on_write
	       then go to close_fail;			/* bad - ignore EOT */
	  call write_EOFs (code);			/* write trailer labels */
	  if code ^= 0
	  then go to close_fail;			/* trouble */

/* if cseg.user_labels then call write_UTL; */

	  call write_TM (2, code);			/* write trailer and end-of-volume TMs */
	  if code ^= 0
	  then
	     do;
	        if code = error_table_$eov_on_write
	        then code = 0;
	        else go to close_fail;
	     end;
         end;

close_exit:
      if cseg.close_rewind
      then
         do;					/* rewind volume at close time */
	  vl (fl.vlX).cflX = 0;			/* invalidate volume position */
	  call tape_ansi_tape_io_$order (cP, "rew", 0, 0);/* issue the order */
	  cseg.close_rewind = "0"b;			/* this is a one time switch */
         end;
close_exit1:
      mask = "0"b;
      revert cleanup;
      on any_other call handler;
      call hcs_$set_ips_mask ("0"b, mask);
      iocbP -> iocb.actual_iocb_ptr -> iocb.detach_iocb = tape_ansi_detach_;
      iocbP -> iocb.actual_iocb_ptr -> iocb.open = tape_ansi_file_cntl_$open;
      iocbP -> iocb.actual_iocb_ptr -> iocb.control = tape_ansi_control_;
      iocbP -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr = null;
      call iox_$propagate (iocbP -> iocb.actual_iocb_ptr);
      call hcs_$reset_ips_mask (mask, mask);
      cseg.file_lock = "0"b;
      return;

debug_on:
   entry;						/* turns debug switch on */
      debug = "1"b;
      return;

debug_off:
   entry;						/* truns debug switch off */
      debug = "0"b;
      return;

debug_print:
   procedure (text);				/* prints debug text */
dcl   text		        char (*);

      call ioa_ (text);
      return;

   end debug_print;


   end tape_ansi_file_cntl_;
