/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */





/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*                                                                    */
/*  tape_ansi_nl_file_cntl_                                                     */
/*                                                                    */
/*       Main logic module of tape_ansi_ for unlabeled volumes.  See  */
/*  individual entries for details of use and calling sequence.       */
/*                                                                    */
/*  0) Created:   10/04/74 by Ross E. Klinger                         */
/*  1) Modified:  10/04/74 by C. D. Tavares for resource management   */
/*  2) Modified: 06/29/79 by Rick Riley                               */
/*               (to allow reading/writing unlabeled ibm file sets    */
/*  3) Modified:  9/79	by R.J.C. Kissel for new tseg.	*/
/*  4) Modified:  4/82 by J. A. Bush for block sizes > 8192 bytes     */
/*                                                                    */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


/* format: style3,ind3,dclind6,idind32 */
tape_ansi_nl_file_cntl_:
   procedure;					/* This entry not used */

/* arguments */
dcl   iocbP		        ptr,		/* pointer to iocb */
      open_mode		        fixed bin,		/* opening mode */
      extend_bit		        bit (1) aligned,	/* extend at open time */
      code		        fixed bin (35);	/* error code */

%include iocb;

%include tape_ansi_cseg;

%include tape_ansi_fd;

%include ibm_hdr1;

%include rcp_volume_formats;

%include rcp_resource_types;


/* automatic storage */
dcl   answer		        char (128) varying,
      com_text		        char (64) varying,
      vn			        char (32),
      cc			        fixed bin,		/* consistency code */
						/* 0 - invalidate volume position */
						/* 1 - invalidate volume position and current file link */
						/* 2 - invalidate position, current file link, write EOV TM */
      mask		        bit (36) aligned,
      tstring		        char (32) varying;	/* open description temporary */

dcl   1 qi		        aligned,		/* query info structure */
        2 version		        fixed bin init (2),
        2 yes_no		        bit (1) unaligned,
        2 suppress_name	        bit (1) unaligned,
        2 scode		        fixed bin (35),
        2 qcode		        fixed bin (35) init (0);

/* internal static */
dcl   debug		        bit (1) internal static initial ("0"b);
						/* debug switch */


/* conditions */
dcl   (any_other, cleanup)	        condition;

/* builtin functions */
dcl   (addr, index, length, ltrim, mod, null, substr)
			        builtin;

/* external procedures */
dcl   canon_for_volume_label_	        ext entry (char (*), char (*), char (*), fixed bin, fixed bin (35)),
      command_query_	        ext entry options (variable),
      continue_to_signal_	        ext entry (fixed bin (35)),
      tape_ansi_control_	        ext entry (ptr, char (*), ptr, fixed bin (35)),
      tape_ansi_detach_	        ext entry (ptr, fixed bin (35)),
      tape_ansi_nl_file_cntl_$close   ext entry (ptr, fixed bin (35)),
      tape_ansi_nl_file_cntl_$open    ext entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
      hcs_$reset_ips_mask	        ext entry (bit (36) aligned, bit (36) aligned),
      hcs_$set_ips_mask	        ext entry (bit (36) aligned, bit (36) aligned),
      tape_ansi_ibm_lrec_io_$close    ext entry (ptr, fixed bin (35)),
      tape_ansi_ibm_lrec_io_$read_record
			        ext entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      tape_ansi_ibm_lrec_io_$write_record
			        ext entry (ptr, ptr, fixed bin (21), fixed bin (35)),
      ioa_		        ext entry options (variable),
      iox_$propagate	        ext entry (ptr),
      tape_ansi_mount_cntl_$mount     ext entry (ptr, fixed bin, fixed bin (35)),
      tape_ansi_mount_cntl_$remount   ext entry (ptr, fixed bin, fixed bin, fixed bin (35)),
      tape_ansi_position_	        ext entry (ptr, fixed bin, fixed bin (21), fixed bin (35)),
      tape_ansi_read_length_	        ext entry (ptr, fixed bin (21), fixed bin (35)),
      tape_ansi_tape_io_$open	        ext entry (ptr),
      tape_ansi_tape_io_$order        ext entry (ptr, char (3), fixed bin, fixed bin (35)),
      terminate_process_	        ext entry (char (*), ptr);


/* external static */
dcl   (
      error_table_$blank_tape,
      error_table_$device_limit_exceeded,
      error_table_$end_of_info,
      error_table_$eov_on_write,
      error_table_$file_aborted,
      error_table_$file_busy,
      error_table_$incompatible_attach,
      error_table_$incompatible_encoding_mode,
      error_table_$insufficient_open,
      error_table_$invalid_block_length,
      error_table_$invalid_cseg,
      error_table_$invalid_file_set_format,
      error_table_$invalid_record_length,
      error_table_$no_file,
      error_table_$no_next_volume,
      error_table_$positioned_on_bot,
      error_table_$unable_to_do_io,
      error_table_$uninitialized_volume
      )			        fixed bin (35) ext static;

dcl   sys_info$max_seg_size	        fixed bin (35) external static;

open:
   entry (iocbP, open_mode, extend_bit, code);

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to control segment */

      if cseg.invalid
      then
         do;					/* is control segment invalid? */
	  code = error_table_$invalid_cseg;
	  return;
         end;

      if cseg.file_lock
      then
         do;					/* is file in use (by previous invocation)? */
	  code = error_table_$file_busy;
	  return;
         end;
      else
         do;
	  cc = 0;					/* minimal consistency requirement */
	  on cleanup
	     begin;				/* insure file chain <--> tape consistency */
	        call consistent;
	        cseg.file_lock = "0"b;		/* unlock the file */
	     end;
	  cseg.file_lock = "1"b;			/* not in use - now it is */
         end;

      if extend_bit
      then
         do;					/* extend at open time not allowed */
bad_open:
	  code = error_table_$incompatible_attach;
	  go to valid_exit;
         end;

      if open_mode = 4
      then tstring = "sequential_input";		/* set for sequential input */
      else
         do;					/* sequential output or input_output */
	  if cseg.output_mode = 0
	  then go to bad_open;			/* no output mode specified */
	  if open_mode = 5
	  then tstring = "sequential_output -create";
	  else go to bad_open;
         end;

      cseg.open_mode = open_mode;			/* save open mode in control segment */

/*  OLD  */
      cseg.flP = null;
      fd.vlX = 1;

/*  OLD  */
/*  NEW  * /
      cseg.flP = null;				/*  set the file index pointer no there are none * /
      if fd.vlX = 0
      then
         do;					/* if the vol index not set then set it * /
	  fd.vlX = 1;				/* set to initial vol and first file * /
	  vl (1).fflX = 1;
	  go to found_it;
         end;

      if append_file ()
      then
         do;					/* when writeing a file we need to find the file * /
	  do i = 1 to cseg.vcN;			/* search forward for the file * /
	     if vl (i).fflX ^= 0
	     then /* only searching vols that have files * /
		if (fd.sequence >= vl (i).fflX & (fd.sequence <= vl (i).lflX + 1 | vl (i).lflX = 0))
		then
		   do;				/* then test for a file fit on the volume * /
		      fd.vlX = i;
		      if vl (i).lflX = 0 | fd.sequence <= vl (i).lflX
		      then go to found_it;		/* if a new file keep looking * /
		      else
		         do j = i to cseg.vcN;	/* look until you find the volume.
						   New files can only be 1+ the last written * /
			  if vl (j).fflX ^= 0
			  then if (fd.sequence >= vl (j).fflX & (fd.sequence <= vl (j).lflX + 1 | vl (j).lflX = 0))
			       then fd.vlX = j;
		         end;
		      go to found_it;
		   end;
	  end;
	  code = error_table_$no_file;
	  go to er_exit;
         end;

      else
         do i = 1 to cseg.vcN;			/* check for the desired file in the volume index list
						   and first and last of the vols * /
	  if vl (i).fflX = 0
	  then go to no_find;
	  if (fd.sequence >= vl (i).fflX & fd.sequence <= vl (i).lflX) | (fd.sequence >= vl (i).fflX & vl (i).lflX = 0)
	  then
	     do;					/* want volume file first appears on * /
	        fd.vlX = i;
	        go to found_it;
	     end;

         end;
no_find:
      code = error_table_$no_file;
      go to er_exit;

found_it:
/*  NEW  */
      if cseg.open_mode = 4
      then
         do;					/* input */
	  if fd.format = 0
	  then
	     do;
not_enough:
	        code = error_table_$insufficient_open;
	        go to valid_exit;
	     end;
	  if fd.blklen = 0
	  then go to not_enough;
	  if fd.reclen = 0
	  then
	     do;
	        if fd.format = 1
	        then ;
	        else go to not_enough;
	     end;
	  if fd.mode = 0
	  then fd.mode = 2;


	  call move (fd.vlX, fd.sequence, code);	/* move to the file */
	  if code ^= 0
	  then go to er_exit;
	  call lrec_open;
         end;

      else
         do;					/* output */
	  if fd.format = 0
	  then
	     do;
	        fd.format = 3;
	        fd.blocked = "1"b;
	     end;
	  if fd.blklen = 0
	  then fd.blklen = 8192;
	  if fd.reclen = 0
	  then
	     do;
	        if fd.format = 1
	        then ;
	        else if fd.format = 2
	        then fd.reclen = fd.blklen;
	        else if fd.format = 3
	        then fd.reclen = 8188;
	        else fd.reclen = sys_info$max_seg_size * 4;
	     end;
	  if fd.mode = 0
	  then fd.mode = 2;

	  call move (fd.vlX, fd.sequence, code);	/* move to the file */
	  if code ^= 0
	  then go to er_exit;			/*  NEW  * /

	  do i = fd.vlX + 1 to cseg.vcN;		/* reinit the vol indexes above this last file * /
	     call vl_init (i);
	  end;
/*  NEW  */
	  call lrec_open;
         end;

done:
      mask = "0"b;					/* ips interrupts not masked yet */
      cseg.open_description.length = length (tstring);	/* prepare open description */
      cseg.open_description.string = tstring;
      revert cleanup;
      on any_other call handler;			/* pick up any condition */
      call hcs_$set_ips_mask ("0"b, mask);		/* mask all ips interrupts */
      iocbP -> iocb.actual_iocb_ptr -> iocb.close = tape_ansi_nl_file_cntl_$close;
      if cseg.open_mode = 5
      then iocbP -> iocb.actual_iocb_ptr -> iocb.write_record = tape_ansi_ibm_lrec_io_$write_record;
      else
         do;					/* sequential input */
	  iocbP -> iocb.actual_iocb_ptr -> iocb.read_record = tape_ansi_ibm_lrec_io_$read_record;
	  iocbP -> iocb.actual_iocb_ptr -> iocb.read_length = tape_ansi_read_length_;
	  iocbP -> iocb.actual_iocb_ptr -> iocb.position = tape_ansi_position_;
         end;
      iocbP -> iocb.actual_iocb_ptr -> iocb.control = tape_ansi_control_;
      iocbP -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr = addr (cseg.open_description);
      call iox_$propagate (iocbP -> iocb.actual_iocb_ptr);
      call hcs_$reset_ips_mask (mask, mask);		/* permit ips interrupts */
      cseg.file_lock = "0"b;				/* open complete - unlock the file */
      return;

er_exit:
      call consistent;
      go to valid_exit;


no_next_volume:
      code = error_table_$no_next_volume;


valid_exit:
      cseg.file_lock = "0"b;				/* open complete - unlock the file */
      return;					/*  NEW  * /

append_file:
   procedure returns (bit (1));

      if debug
      then call debug_print ("append_file");
      if cseg.open_mode ^= 5
      then return ("0"b);
      if cseg.output_mode ^= 4
      then return ("0"b);

      return ("1"b);

   end append_file;

/*  NEW  */
abort_file:
   procedure;					/* cleanup after defective file */
      if debug
      then call debug_print ("abort_file");

      vl (fd.vlX).cflX = 0;				/* invalidate volume position */

/*  OLD  */
      call write_TM (2, code);			/* write the TMs */
						/*  OLD  */
						/*  NEW  * /
      call write_TM (3, code);			/* write the TMs * /
/*  NEW  */
      if code ^= 0
      then if code ^= error_table_$eov_on_write
	 then go to abort_fail;

/*  OLD  */
      call ioa_ ("^a: Unrecoverable error while writing file; double TM written.", cseg.module);
						/*  OLD  */
						/*  NEW  * /
      call ioa_ ("^a: Unrecoverable error while writing file; triple TM written.", cseg.module);
						/*  NEW  */
      code = error_table_$file_aborted;
      return;

abort_fail:
      call ioa_ ("^a: Unrecoverable error while writing file; unable to write double TM.", cseg.module);
      code = error_table_$invalid_file_set_format;
      return;

   end abort_file;

consistent:
   procedure;					/* insures file chain/tape consistency */
      if debug
      then call debug_print ("consistent");

      go to recovery (cc);				/* perform appropriate consistency processing */

recovery (0):
      return;


recovery (1):
      if fd.vlX ^= 0
      then vl (fd.vlX).cflX = 0;			/* invalidate volume position */
      return;

recovery (2):
      if fd.vlX = 0
      then return;					/* nothing can be done - exit */
      call abort_file;				/* write end of volume TMs */
      return;

   end consistent;

handler:
   procedure;					/* intercept any faults during iocb manipulation */
dcl   1 ti		        aligned,
        2 version		        fixed bin init (0),
        2 code		        fixed bin (35);

      if mask ^= "0"b
      then
         do;					/* IPS interrupts masked */
	  ti.code = error_table_$unable_to_do_io;	/* very bad trouble */
	  call terminate_process_ ("fatal_error", addr (ti));
						/* kill the process */
         end;
      call continue_to_signal_ (0);
      return;
   end handler;

initialize_permitA:
   procedure (vX) returns (bit (1));			/* query to initialize unexpired volume */

dcl   vX			        fixed bin;
dcl   msg			        char (120) varying;
dcl   msg1		        char (length (msg)) based (addr (substr (msg, 1)));

      msg = "Volume ^a has a valid VOL1 label.^/Do you want to use this volume for unlabeled output?";
      go to ip_com;


initialize_permitB:
   entry (vX) returns (bit (1));			/* query to initialize an unreadable volume */

      msg = "Cannot determine if volume ^a has a VOL1 label.^/Do you want to use this volume for unlabeled output?";

ip_com:
      qi.yes_no = "1"b;
      qi.suppress_name = "0"b;
      qi.scode = error_table_$uninitialized_volume;

      call command_query_ (addr (qi), answer, cseg.module, msg1, vl (vX).volname);

      if answer = "yes"
      then return ("1"b);
      else return ("0"b);

   end initialize_permitA;

lrec_open:
   procedure;					/* logical record IO initialization and final checks */
      if debug
      then call debug_print ("lrec_open");

      if cseg.open_mode > 4
      then if fd.blklen < 18
	 then go to inv_blk;			/* can't write < 18 chars */

      if cseg.open_mode > 4
      then if mod (fd.blklen, 4) ^= 0
	 then go to inv_blk;			/* can only write words */
      if fd.mode = 3
      then cseg.mode = 0;				/* binary mode is set */
      else cseg.mode = 1;				/* ascii, ebcdic encoding 9 mode */

      go to match (fd.format);			/* match the blocking */
match (2):
      if ^fd.blocked
      then if fd.blklen ^= fd.reclen
	 then go to inv_rec;			/* F unblocked */
	 else go to ok;
      else if mod (fd.blklen, fd.reclen) ^= 0
      then go to inv_rec;				/* F blocked */
      else go to ok;

match (3):
      if ^fd.blocked
      then if fd.blklen - 4 ^= fd.reclen
	 then go to inv_rec;
	 else go to ok;
      else if fd.reclen > fd.blklen - 4
      then go to inv_rec;				/* V blocked */
      else go to ok;

match (4):
      if fd.reclen > sys_info$max_seg_size * 4
      then go to inv_rec;				/* S format */

match (1):
ok:
      cseg.rlN = -1;				/* invalidate anything in rl segment */
      cseg.lrec.bufP = null;				/* no active buffer */
      cseg.blkcnt = 0;
      cseg.lrec.reccnt = 0;				/* not currently used */
      cseg.lrec.code = 0;				/* no errors encountered */
      call tape_ansi_tape_io_$open (cP);		/* initialize call to tape_ansi_tape_io_ */
      return;					/* exit */

inv_rec:
      code = error_table_$invalid_record_length;
      go to er_exit;
inv_blk:
      code = error_table_$invalid_block_length;
      go to er_exit;
bad_mode:
      code = error_table_$incompatible_encoding_mode;
      go to er_exit;

   end lrec_open;

move:
   procedure (vX, fX, ecode);
      if debug
      then call debug_print ("move");
dcl   vX			        fixed bin,		/* volume link index of desired volume */
      fX			        fixed bin,		/* sequence number of desired file */
      ecode		        fixed bin (35);	/* error code */
dcl   i			        fixed bin,
      uninit_msg		        char (28) varying;
      cc = 0;
      if vl (vX).rcp_id = 0
      then
         do;					/* volume is not mounted */
	  if cseg.nactive < cseg.ndrives
	  then
	     do;					/* more drives available */
	        call tape_ansi_mount_cntl_$mount (cP, vX, ecode);
						/* mount the volume */
	        if ecode ^= 0
	        then
		 do;				/* maybe trouble */
		    if ecode = error_table_$device_limit_exceeded
		    then
		       do;
			cseg.ndrives = cseg.ndrives - 1;
						/* decrement maximum device count */
			go to switch;
		       end;
		    else go to error;		/* true trouble */
		 end;
	     end;
	  else
	     do;					/* no drive available */
switch:
	        do i = 1 to vX - 1;			/* search up to desired volume */
		 if vl (i).rcp_id ^= 0
		 then go to got_one;		/* got one active */
	        end;
	        do i = cseg.vcN to vX + 1 by -1;	/* search down to desired volume */
		 if vl (i).rcp_id ^= 0
		 then go to got_one;		/* got one active */
	        end;
	        ecode = error_table_$invalid_cseg;	/* something very wrong if no volume found */
	        go to error;
got_one:
	        call tape_ansi_mount_cntl_$remount (cP, i, vX, ecode);
						/* remount the volume */
	        if ecode ^= 0
	        then go to error;			/* trouble */
	     end;
         end;

      cseg.tseg.drive_name = vl (vX).tape_drive;
      cseg.tseg.ev_chan = vl (vX).event_chan;
      fd.vlX = vX;

      if cseg.open_mode = 5
      then
         do;					/* check for VOL1 only if output */
	  if vl (vX).write_VOL1 = 1
	  then ;					/* tape is blank */
	  else if vl (vX).write_VOL1 = 3
	  then ;					/* no VOL1 label */
	  else
	     do;					/* has VOL1 label, or can't tell */
	        if fX ^= 1
	        then
		 do;				/* can't initialize if not first file on volume */
		    if vl (vX).write_VOL1 = 2
		    then uninit_msg = "is unreadable";
		    else uninit_msg = "is not an unlabeled volume";
		    call ioa_ ("^a: Volume ^a ^a.", cseg.module, vl (vX).volname, uninit_msg);
uninit:
		    code = error_table_$uninitialized_volume;
		    go to error;
		 end;
	        go to iq (vl (vX).write_VOL1);
iq (6):
iq (0):
iq (4):
iq (5):
iq (-1):
	        if initialize_permitA (vX)
	        then go to ok;
	        else go to uninit;
iq (2):
	        if ^initialize_permitB (vX)
	        then go to uninit;
ok:
	        call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);
	        if ecode ^= 0
	        then go to error;			/*  OLD  */
	        call write_TM (2, ecode);		/*  OLD  */
						/*  NEW  * /
	        call write_TM (3, ecode);		/* write the init end of vol set TMs * /
/*  NEW  */
	        if ecode ^= 0
	        then if ecode ^= error_table_$eov_on_write
		   then go to error;		/*  OLD  */
	        vl (vX).cflX = 3;			/*  OLD  */
						/*  NEW  * /
	        vl (vX).cflX = vl (vX).fflX + 3;	/* set current to three after the first file   * /
/*  NEW  */
	        vl (vX).write_VOL1 = 3;
	     end;
         end;

      if vl (vX).cflX = 0
      then
         do;					/* volume position unknown */
	  call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);
	  if ecode ^= 0
	  then go to error;				/*  OLD  */
	  vl (vX).cflX = 1;				/*  OLD  */
						/*  NEW  * /
	  vl (vX).cflX = vl (vX).fflX;		/* after rewind set file index to first file on volume * /
	  if fX = vl (vX).cflX
	  then go to ok_exit;			/* if we are where we want to be at the beginning go on * /
/*  NEW  */
         end;

      if vl (vX).cflX < fX
      then
         do;					/* volume positioned before desired file */
	  do i = 1 to fX - vl (vX).cflX;
	     call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);
	     if ecode ^= 0
	     then
	        do;
		 if ecode = error_table_$blank_tape
		 then ecode = error_table_$no_file;
		 go to error;
	        end;				/*  OLD  */
	  end;					/*  OLD  */
						/*  NEW  * /

/* when searching forward and the volume indexes
   are not set then need to read a record looking for
   eov or eov_set * /


	     if vl (fd.vlX).lflX = 0
	     then
	        do;				/* check for index not set * /
		 call tape_ansi_tape_io_$sync_read (cP, nchar, ecode);
						/* read a record * /
		 if ecode ^= 0
		 then
		    do;				/* not eof error then error return * /
		       if ecode ^= error_table_$eof_record
		       then go to error;
		       else call tape_ansi_tape_io_$sync_read (cP, nchar, ecode);
						/* read again hope its a label * /

		       if ecode ^= 0
		       then
			do;
			   if ecode = error_table_$eof_record
			   then
			      do;			/* if a third eof then we know endofvolset * /
			         ecode = error_table_$no_file;
						/* set the erorror mseg * /
			         vl (fd.vlX).lflX = vl (fd.vlX).cflX + i - 1;
						/* set the vol index * /
			         vl (fd.vlX).cflX = vl (fd.vlX).lflX + 3;
			         if append_file ()
			         then
				  do;		/* check if appending to the last file * /
				     if fX ^= vl (fd.vlX).lflX + 1
				     then return;	/* its okay for last +1 * /
				     else ecode = 0;
				     go to appending;
				  end;

			         else return;
			      end;

			   else go to error;
			end;

		       if cseg.standard = 1
		       then cseg.lbl_buf = sync_buf;	/* convert ebcdic label * /
		       else call ebcdic_to_ascii_ (sync_buf, cseg.lbl_buf);

		       if substr (lbl_buf, 1, 4) ^= "EOV1"
		       then
			do;			/* is this a label or not * /
			   ecode = error_table_$invalid_file_set_format;
						/* maybe messed up * /
			   return;
			end;

		       if debug
		       then call ioa_ ("^80a", lbl_buf);

/* mount the next volume * /
/* set the volume indexes as you know them * /
		       vl (fd.vlX).lflX = vl (fd.vlX).cflX + i - 1;

		       if ^next_volume ()
		       then
			do;
			   ecode = error_table_$no_next_volume;
			   return;
			end;

		       fd.vlX = fd.vlX + 1;
		       vl (fd.vlX).cflX = vl (fd.vlX - 1).lflX;
		       vl (fd.vlX).fflX = vl (fd.vlX - 1).lflX;
		       vl (fd.vlX - 1).cflX = 0;
appending:
		       call move (fd.vlX, fd.sequence, ecode);
						/* find the file now * /
		       if ecode ^= 0
		       then go to error;
		       else go to move_done;
		    end;
	        end;

	  end;
move_done:
	  call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
	  if ecode ^= 0
	  then go to error;
	  call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);
	  if ecode ^= 0
	  then go to error;


/*  NEW  */
         end;

      else if vl (vX).cflX > fX
      then
         do;					/* volume positioned after desired file */
	  do i = 1 to vl (vX).cflX - fX;
	     call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
	     if ecode ^= 0
	     then go to error;
	  end;
	  call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
	  if ecode = 0
	  then
	     do;
	        call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);
	        if ecode ^= 0
	        then go to error;
	     end;
	  else if ecode = error_table_$positioned_on_bot
	  then ecode = 0;
	  else go to error;
         end;

      else
         do;					/* volume positioned at desired file */
	  if fX = 1
	  then
	     do;
	        call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);
	        if ecode ^= 0
	        then go to error;
	     end;
	  else
	     do;
	        call tape_ansi_tape_io_$order (cP, "bsf", 0, ecode);
	        if ecode ^= 0
	        then go to error;
	        call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);
	        if ecode ^= 0
	        then go to error;
	     end;
         end;

ok_exit:
      vl (vX).cflX = fX;				/* new position info */
      return;

error:
      vl (vX).cflX = 0;				/* we don't know where we are */
      return;
   end move;

next_volume:
   procedure returns (bit (1));			/* determines if volume switch possible */

dcl   canon_std		        (2) fixed bin initial (Volume_ansi_tape, Volume_ibm_tape);
dcl   ecode		        fixed bin (35);

      if debug
      then call debug_print ("next_volume");

      if fd.vlX < cseg.vcN
      then return ("1"b);				/* if current vlX < vcN then next exists */

      if fd.vlX = 63
      then
         do;					/* volume chain full */
	  call ioa_ ("^a: Implementation limit of 63 volumes has been reached.", cseg.module);
	  return ("0"b);
         end;

      if another_volume ()
      then vl (cseg.vcN + 1).comment = com_text;		/* yes  */
      else return ("0"b);				/* user said terminate */

got_reelid:
      cseg.vcN = cseg.vcN + 1;			/* increment volume link count */
      call vl_init (cseg.vcN);
      vl (cseg.vcN).volname = vn;			/* set volume name in volume link */
      call
         canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), vn, vl (cseg.vcN).canonical_volname,
         canon_std (cseg.standard), ecode);
      if ecode ^= 0
      then return (""b);

      return ("1"b);

   end next_volume;

vl_init:
   procedure (n);					/* initialize a volume link */
dcl   n			        fixed bin;		/* link index */
      vl (n).fflX = 0;
      vl (n).cflX = 0;
      vl (n).pos = 0;
      vl (n).lflX = 0;
      vl (n).tracks = 0;
      vl (n).density = 0;
      vl (n).label_type = 0;
      vl (n).usage_count = 0;
      vl (n).read_errors = 0;
      vl (n).write_errors = 0;
      vl (n).rcp_id = 0;
      vl (n).event_chan = 0;
      vl (n).tape_drive = "";
      vl (n).write_VOL1 = 0;
      vl (n).ioi_index = 0;
      return;
   end vl_init;

another_volume:
   procedure returns (bit (1));			/* queries user for next volume name */

dcl   msg			        char (80) varying;	/* message to user */
dcl   msg1		        char (length (msg)) based (addr (substr (msg, 1)));
						/* char (*) overlay for command_query_ */
dcl   L1			        fixed bin;

      qi.yes_no = "1"b;				/* want yes or no */
      qi.suppress_name = "0"b;			/* don't suppress module name */
      qi.scode = error_table_$no_next_volume;
      msg = "Reached end of volume.  Do you wish to terminate processing of this volume-set?";
      call command_query_ (addr (qi), answer, cseg.module, msg1);

      if answer = "yes"
      then return ("0"b);				/* finito */

      qi.yes_no = "0"b;				/* don't want yes or no */
      qi.suppress_name = "1"b;
ask:
      qi.scode = 0;					/* no scode when asking for name */
      msg = "Enter volume name of next volume (and optional comment).^/";
ask_raw:
      call command_query_ (addr (qi), answer, cseg.module, msg1);
      if answer = ""
      then go to ask;
      com_text = "";				/* initialize comment message */
      L1 = index (answer, " ") - 1;			/* scan for a blank */
      if L1 < 0
      then L1 = length (answer);

      call canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), substr (answer, 1, L1), vn, 0, code);
      if code ^= 0
      then
         do;
	  qi.scode = code;
	  msg = substr (answer, 1, L1) || "^/Enter volume name of next volume (and optional comment).^/";
	  go to ask_raw;
         end;

      answer = ltrim (substr (answer, L1 + 1));
      if substr (answer, 1, 8) = "-comment"
      then
         do;
	  answer = ltrim (substr (answer, 10));
	  go to comment;
         end;
      if substr (answer, 1, 4) = "-com"
      then
         do;
	  answer = ltrim (substr (answer, 6));
comment:
	  if length (answer) = 0
	  then ;					/* no comment */
	  else com_text = answer;
         end;
      else
         do;					/* invalid comment */
	  call ioa_ ("Comment is invalid.");

	  go to ask;
         end;

      return ("1"b);				/* volume name is ok - exit */

   end another_volume;

write_TM:
   procedure (n, ecode);				/* writes 1 or 2 TM and adjusts volume link */
dcl   n			        fixed bin,		/* number of TM - 1 or 2 */
      cnt			        fixed bin,
      ecode		        fixed bin (35);

      if debug
      then call ioa_ ("write_TM ^d", n);
      do cnt = 1 to n;				/* 1 or 2 */
         call tape_ansi_tape_io_$order (cP, "eof", 0, ecode);
						/* write a TM */
         if ecode ^= 0
         then if ecode ^= error_table_$eov_on_write
	    then return;				/* error exit */
         vl (fd.vlX).cflX = vl (fd.vlX).cflX + 1;
      end;

      return;

   end write_TM;

beginning_of_file:
   entry (iocbP, code);				/* positions to beginning of file */

      if debug
      then call debug_print ("bof");
      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to cseg */

      cc = 0;
      on cleanup go to bof_fail;

      call tape_ansi_ibm_lrec_io_$close (cP, code);	/* close logical record I/O */
      if code ^= 0
      then go to bof_fail;

/*  OLD  */
      call move (1, fd.sequence, code);			/* move the tape */
						/*  OLD  */
						/*  NEW  * /
	  do i = 1 to cseg.vcN;			/* determine where the file begins and have that vol mounted * /
         if fd.sequence >= vl (i).fflX & fd.sequence <= vl (i).lflX
         then
	  do;
	     fd.vlX = i;
	     go to got_vol;
	  end;
      end;					/* if not found in loop then it is the current volume * /

got_vol:						/* if no volume found use the current one * /
      call move (fd.vlX, fd.sequence, code);		/* move the tape * /
/*  NEW  */
      if code ^= 0
      then
         do;
bof_fail:
	  call consistent;
	  go to close_exit;
         end;

      call lrec_open;				/* re-initialize to open logical record I/O */
						/* note - no error can occur in this call */

      return;

end_of_file:
   entry (iocbP, code);				/* positions to end of file */

      if debug
      then call debug_print ("end_of_file");
      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get pointer to cseg */

      cc = 0;
      on cleanup go to eof_fail;

      if cseg.lrec.code = error_table_$end_of_info
      then
         do;					/* passed eof */
	  call tape_ansi_tape_io_$order (cP, "bsf", 0, code);
	  if code ^= 0
	  then go to eof_fail;
	  else vl (fd.vlX).cflX = vl (fd.vlX).cflX - 1;
	  return;
         end;

      cseg.rlN = -1;				/* invalidate any record in real_length buffer */
      cseg.blkcnt = -1;				/* invalidate the block count */

      call tape_ansi_ibm_lrec_io_$close (cP, code);	/* close logical record io */
      if code ^= 0
      then
         do;
eof_fail:
	  call consistent;
	  go to close_exit;
         end;

/*  OLD  */
      if fd.vlX ^= cseg.vcN
      then
         do;					/* not at last volume of file */
	  call move (cseg.vcN, 1, code);
	  if code ^= 0
	  then go to eof_fail;
         end;

      call tape_ansi_tape_io_$order (cP, "fsf", 0, code);
      if code ^= 0
      then go to eof_fail;				/*  OLD  */
						/*  NEW  * /
	     do i = 1 to cseg.vcN;			/* search forward for the next file * /
         if vl (i).fflX ^= 0
         then /* only searching vols that have files * /
	    if (fd.sequence + 1 >= vl (i).fflX & (fd.sequence + 1 <= vl (i).lflX + 1 | vl (i).lflX = 0))
	    then
	       do;				/* then test for a file fit on the volume * /
		fd.vlX = i;
		if vl (i).lflX = 0 | fd.sequence + 1 <= vl (i).lflX
		then go to got_tape;		/* it may be after the last file in the file set * /
		else
		   do j = i to cseg.vcN;		/* look until you find the volume.
						   New files can only be 1+ the last written * /
		      if vl (j).fflX ^= 0
		      then if (fd.sequence + 1 >= vl (j).fflX & (fd.sequence + 1 <= vl (j).lflX + 1 | vl (j).lflX = 0))
			 then fd.vlX = j;
		   end;
		go to got_tape;
	       end;
      end;					/* if we fall through search on from where we are * /
got_tape:						/* move to the next sequential file then back up
						   to be at end of desired file  * /
      call move (fd.vlX, fd.sequence + 1, code);
      if code ^= 0
      then go to eof_fail;

/*  NEW  */
      call tape_ansi_tape_io_$order (cP, "bsf", 0, code);
      if code ^= 0
      then go to eof_fail;				/*  NEW  * /
	        else vl (fd.vlX).cflX = vl (fd.vlX).cflX - 1;


	        call lrec_open;			/* re-initialize to open record io * /

/*  NEW  */
      return;					/*       */
data_eof:
   entry (iocbP, code);				/* called by ibm_lrec io when
						   read returns an eof_record */
      if debug
      then call debug_print ("data_eof");
      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get control segment pointer */

      cc = 0;					/* minimal consistency requirement */
      on cleanup go to data_eof_fail;

      vl (fd.vlX).cflX = vl (fd.vlX).cflX + 1;		/* have moved over a TM - update position info */


      call tape_ansi_ibm_lrec_io_$close (cP, code);
      if code ^= 0
      then
         do;
data_eof_fail:
	  call consistent;
	  go to close_exit;
         end;

/*  OLD  */
      if fd.vlX = cseg.vcN
      then
         do;					/* last (or only) section */
						/*  OLD  */
						/*  NEW  * /
		    call tape_ansi_tape_io_$sync_read (cP, nchar, code);
						/* read the next 80 chars looking for eov label * /

      if code ^= 0
      then
         do;

	  if code = error_table_$eof_record
	  then
	     do;					/* if another eof then this maybe end of vol set * /
	        vl (fd.vlX).cflX = vl (fd.vlX).cflX + 1;
	        call tape_ansi_tape_io_$sync_read (cP, nchar, code);
						/* read again to see if another eof * /
	        if code = error_table_$eof_record
	        then
		 do;				/* if another eof then end of vol set emit end_of_info * /
		    vl (fd.vlX).cflX = vl (fd.vlX).cflX + 1;
						/* update volume positions * /
		    vl (fd.vlX).lflX = vl (fd.vlX).cflX - 3;
		    code = error_table_$end_of_info;
		    return;
		 end;
	        else if code ^= 0
	        then go to data_eof_fail;

	        if cseg.standard = 1
	        then cseg.lbl_buf = sync_buf;
	        else call ebcdic_to_ascii_ (sync_buf, cseg.lbl_buf);
						/* convert the  ebcdic label buffer  * /


	        if substr (lbl_buf, 1, 4) ^= "EOV1"
	        then
		 do;				/* if not a label then just end of file and go on * /
		    code = error_table_$end_of_info;
		    return;
		 end;

	     end;

	  else go to data_eof_fail;			/* if error then go to error handle * /
         end;

      else
         do;					/* this is simple end of file case go back * /
/*  NEW  */
	  code = error_table_$end_of_info;
	  return;
         end;

/*  OLD  */
      call move (fd.vlX + 1, 1, code);			/* move to next volume */
						/*  OLD  */
						/*  NEW  * /


	        if debug
	        then call ioa_ ("^80a", lbl_buf);


/* this is end of volume prepare to mount
   the next volume in the set * /

      if ^next_volume ()
      then
         do;
	  code = error_table_$no_next_volume;
	  return;
         end;

      if vl (fd.vlX).lflX = 0
      then vl (fd.vlX).lflX = vl (fd.vlX).cflX - 2;	/* check last file index * /
      else if vl (fd.vlX).lflX ^= vl (fd.vlX).cflX - 2
      then
         do;					/* if not set set it right if set check it * /
	  code = error_table_$invalid_file_set_format;
	  go to data_eof_fail;
         end;

      vl (fd.vlX).cflX = 0;				/* invalidate this volume position  * /
      fd.vlX = fd.vlX + 1;				/* increment to next volume   * /
      vl (fd.vlX).cflX = vl (fd.vlX - 1).lflX;		/* update volume index info * /
      vl (fd.vlX).fflX = vl (fd.vlX - 1).lflX;
      call move (fd.vlX, fd.sequence, code);
/*  NEW  */
      if code ^= 0
      then go to data_eof_fail;

      return;

data_eot:
   entry (iocbP, code);				/* called by lrec IO when  a write encounters EOT */

      if debug
      then call debug_print ("data_eot");
      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/*  get pointer to control segment */

      if ^next_volume ()
      then
         do;					/* no next volume available */
	  code = error_table_$no_next_volume;
	  return;
         end;

      cc = 2;					/* don't leave defective tape file */
      on cleanup go to data_eot_fail;

/*  OLD  */
      call write_TM (1, code);			/* write end-of-data TM */
						/*  OLD  */
						/*  NEW  * /
	        vl (fd.vlX).lflX = vl (fd.vlX).cflX;	/* set the last file index counter * /

      call write_EOV1 (code);				/* call write_EOV to write  end of vol trail...
						   two tape marks, an eov label, and a tape mark * /
/*  NEW  */
      if code ^= 0
      then if code ^= error_table_$eov_on_write
	 then
	    do;					/* trouble - ignore EOT) */
data_eot_fail:
	       call consistent;
	       go to close_exit;			/* force close */
	    end;
      cc = 0;

/*  OLD  */
      call move (fd.vlX + 1, 1, code);			/* move to beginning of next volume */
						/*  OLD  */
						/*  NEW  * /
						/* set up for mounting the next volume * /
      vl (fd.vlX).cflX = 0;				/* invalidate this volume position  * /
      fd.vlX = fd.vlX + 1;				/* increment to next volume   * /
      vl (fd.vlX).cflX = vl (fd.vlX - 1).lflX;		/* update volume indexes * /
      vl (fd.vlX).fflX = vl (fd.vlX - 1).lflX;
      call move (fd.vlX, fd.sequence, code);
/*  NEW  */
      if code ^= 0
      then go to data_eot_fail;

      return;

/*  NEW  * /
write_EOV1:
   procedure (ecode);

dcl   ecode		        fixed bin (35);
dcl   t4			        picture "9999",
      t6			        picture "999999";	/* write the end_of_volume trail
						   2 tape marks an EOV1 label and then another tape mark    * /

      call write_TM (2, ecode);
      if ecode ^= 0
      then if ecode ^= error_table_$eov_on_write
	 then return;

      fd.dummy_blkcnt = cseg.blkcnt;			/* set up the end of volume label * /
      fd.eox = 2;					/* much of the label is not important * /
						/* the header and the volume id are distinctive * /
      if debug
      then call debug_print ("write_EOV");

      ibm_hdr1P = addr (lbl_buf);
      ibm_hdr1.label_id = "EOV1";
      ibm_hdr1.dataset_id = fd.file_id;
      ibm_hdr1.dataset_serial = fd.set_id;
      t4 = fd.flX;
      ibm_hdr1.volume_sequence = t4;
      t4 = fd.sequence;
      ibm_hdr1.dataset_sequence = t4;
      ibm_hdr1.generation = "";
      ibm_hdr1.version = "";
      ibm_hdr1.creation = " " || fd.creation;
      ibm_hdr1.expiration = " " || fd.expiration;
      ibm_hdr1.security = fd.access;
      t6 = cseg.lrec.blkcnt;
      ibm_hdr1.blkcnt = t6;
      ibm_hdr1.system = fd.system;
      ibm_hdr1.reserved = "";

      if cseg.standard = 1
      then sync_buf = cseg.lbl_buf;			/* ascii buffer for label  * /
      else call ascii_to_ebcdic_ (cseg.lbl_buf, sync_buf);	/* ebcidic convert and write * /


      call tape_ansi_tape_io_$sync_write (cP, 80, ecode);	/*   write it  * /

      if ecode ^= 0
      then if ecode ^= error_table_$eov_on_write
	 then return;

      call write_TM (1, ecode);			/* last tape mark written after label * /

      return;					/* with error ecode = 0 eot or error  * /


   end write_EOV1;

/*  NEW  */
close:
   entry (iocbP, code);				/* iox_$close entry */

      cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
						/* get control segment pointer */

      if cseg.file_lock
      then
         do;					/* file in use? */
	  code = error_table_$file_busy;
	  return;
         end;
      else
         do;
	  on cleanup cseg.file_lock = "0"b;
	  cseg.file_lock = "1"b;
         end;

      if cseg.invalid
      then
         do;
	  code = error_table_$invalid_cseg;
	  on cleanup go to close_exit1;
	  go to close_exit1;
         end;

      if cseg.open_mode = 4
      then
         do;					/* input mode */
	  cc = 0;					/* minimal consistency requirement */
	  on cleanup go to close_fail;
	  call tape_ansi_ibm_lrec_io_$close (cP, code);
	  if code ^= 0
	  then call consistent;
	  go to close_exit;
         end;

      else
         do;					/* output mode */
	  cc = 2;					/* don't leave defective tape file */
	  on cleanup go to close_fail;
	  call tape_ansi_ibm_lrec_io_$close (cP, code);
	  if code ^= 0
	  then
	     do;					/* maybe trouble */
	        if code ^= error_table_$eov_on_write
	        then
		 do;				/* EOT is ok */
close_fail:
		    call consistent;
		    go to close_exit;
		 end;
	     end;

/*  OLD  */
	  call write_TM (2, code);			/* write trailer and end-of-volume TMs */
						/*  OLD  */
						/*  NEW  * /
	  if cseg.blkcnt = 0
	  then
	     do;					/* if no blocks written empty file * /
	        vl (fd.vlX).lflX = vl (fd.vlX).cflX - 1;	/* set the last position and issue error * /
	        code = error_table_$empty_file;
	     end;

	  else vl (fd.vlX).lflX = vl (fd.vlX).cflX;	/* update the volume indexes after a write * /

	  call write_TM (3, code);			/* write trailer and the 2 end-of-volume TMs * /
/*  NEW  */
	  if code ^= 0
	  then
	     do;
	        if code = error_table_$eov_on_write
	        then code = 0;
	        else go to close_fail;
	     end;
	  cc = 0;

         end;

close_exit:
      if cseg.close_rewind
      then
         do;					/* rewind volume at close time */
	  vl (fd.vlX).cflX = 0;			/* invalidate volume position */
	  call tape_ansi_tape_io_$order (cP, "rew", 0, 0);/* issue the order */
	  cseg.close_rewind = "0"b;			/* this is a one time switch */
         end;
close_exit1:
      mask = "0"b;
      revert cleanup;
      on any_other call handler;
      call hcs_$set_ips_mask ("0"b, mask);
      iocbP -> iocb.actual_iocb_ptr -> iocb.detach_iocb = tape_ansi_detach_;
      iocbP -> iocb.actual_iocb_ptr -> iocb.open = tape_ansi_nl_file_cntl_$open;
      iocbP -> iocb.actual_iocb_ptr -> iocb.control = tape_ansi_control_;
      iocbP -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr = null;
      call iox_$propagate (iocbP -> iocb.actual_iocb_ptr);
      call hcs_$reset_ips_mask (mask, mask);
      cseg.file_lock = "0"b;
      return;

debug_on:
   entry;						/* turns debug switch on */
      debug = "1"b;
      return;

debug_off:
   entry;						/* truns debug switch off */
      debug = "0"b;
      return;

debug_print:
   procedure (text);				/* prints debug text */
dcl   text		        char (*);

      call ioa_ (text);
      return;

   end debug_print;


   end tape_ansi_nl_file_cntl_;
