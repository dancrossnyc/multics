/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *                                                         *
   *********************************************************** */

/* format: off */

/* Address management for the Multics Mail System */

/* Created:  May 1981 by G. Palter */
/* Recoded:  July 1983 by G. Palter as part of the new mail system interface */
/* Modified: March 1984 by G. Palter to fix the following mail system errors:
      #0420 -- the mail system doesn't translate error_table_$no_component into mlsys_et_$no_address_list
      #0428 -- during initialization, the mail system extracts the user's full name from the default default value segment
         (>udd>Project>Person>Person.value) rather than the current default value segment as set by value_set_path
      #0429 -- mail_system_$create_savebox_address should not create a logbox address when given the pathname of the
         user's logbox.  Similarly, mail_system_$create_mailbox_address should not create a savebox address when given
         the pathname of a savebox
      #0436 -- if a forum meeting is not found in the "forum" search list, the mail system will treat it as a version 1
         meeting in the working directory */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


mlsys_address_mgr_:
     procedure () options (rename ((alloc_, mlsys_storage_mgr_$allocate)));

	return;					/* not an entrypoint */


/* Parameters */

dcl  P_address_ptr pointer parameter;
dcl  P_code fixed binary (35) parameter;

dcl  P_default_mailbox_address pointer parameter;		/* values returned by the get_address_constants entrypoint */
dcl  P_mail_table_address pointer parameter;		/* ... */
dcl  P_logbox_address pointer parameter;		/* ... */

dcl  P_address_name character (*) varying parameter;	/* the address name of the address */
dcl  P_address_comment character (*) varying parameter;	/* the address comment */

dcl  P_address_string character (*) varying parameter;	/* the string portion of an address (User_id, etc.) */

dcl  P_address_dirname character (*) parameter;		/* an address pathname's component parts ... */
dcl  P_address_ename character (*) parameter;		/* ... */
dcl  P_address_component character (*) parameter;		/* ... */

dcl  P_foreign_system character (256) varying parameter;	/* the foreign system on which the address resides */
dcl  P_address_route_ptr pointer parameter;		/* -> an explicit/implicit route associated with an address */

dcl  P_address_list_ptr pointer parameter;		/* -> the address list which is the address expansion */
dcl  P_display_list bit (1) aligned parameter;		/* ON => show the list in printed representation of address */

dcl  P_address_type fixed binary parameter;		/* set to the type of the given address */

dcl  P_address_route_version character (8) parameter;	/* version of address_route structure expected by caller */

dcl  P_address_1_ptr pointer parameter;			/* -> an address to be compared */
dcl  P_address_2_ptr pointer parameter;			/* ... */

dcl  P_mail_table_address_ptr pointer parameter;		/* set -> address found in the mail table */

dcl  P_address_list_version character (8) parameter;	/* version of address_list structure desired when expanding */


/* Local copies of parameters */

dcl  code fixed binary (35);

dcl  (address_1_ptr, address_2_ptr) pointer;

dcl  mail_table_address_ptr pointer;


/* Remaining declarations */

dcl  mls_text character (mls_lth) unaligned based (mls_ptr);
dcl  mls_ptr pointer;
dcl  mls_bitcount fixed binary (24);
dcl  mls_lth fixed binary (21);

dcl  comparison_result bit (1) aligned;
dcl  (address_1_dirname, address_2_dirname) character (168);
dcl  (address_1_ename, address_2_ename) character (32);
dcl  suffixless_forum_ename character (26);		/* longest valid meeting name */
dcl  (address_1_mte_address_ptr, address_2_mte_address_ptr) pointer;
dcl  (address_1_route_ptr, address_2_route_ptr) pointer;
dcl  (address_1_mls_ptr, address_2_mls_ptr) pointer;
dcl  (address_list_1_ptr, address_list_2_ptr) pointer;
dcl  (mailbox_1_uid, mailbox_2_uid) bit (36) aligned;
dcl  partial_comparison_result bit (1) aligned;
dcl  (code_1, code_2) fixed binary (35);
dcl  (forum_1_index, forum_2_index) fixed binary;
dcl  (idx, jdx) fixed binary;

dcl  current_mtle_ptr pointer;			/* used to resolve recusive mail table entries */

dcl  ANONYMOUS character (9) static options (constant) initial ("anonymous");

dcl  NULL_STRING character (1) static options (constant) initial ("");

/* format: off */
dcl (LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"),
     UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
	character (26) static options (constant);

dcl (error_table_$entlong, error_table_$id_not_found, error_table_$no_component, error_table_$noentry,
     error_table_$smallarg, error_table_$unimplemented_version, mlsys_et_$circular_mtes, mlsys_et_$incorrect_suffix,
     mlsys_et_$mte_not_found, mlsys_et_$no_address_pathname, mlsys_et_$no_address_route, mlsys_et_$no_address_string,
     mlsys_et_$no_mailing_list, mlsys_et_$not_address, mlsys_et_$not_foreign_address, mlsys_et_$not_list_address,
     mlsys_et_$not_mail_table_address, mlsys_et_$not_named_group_address, mlsys_et_$null_foreign_address,
     mlsys_et_$null_named_group_name, mlsys_et_$unknown_system)
	fixed binary (35) external;
/* format: on */

dcl  forum_$close_forum entry (fixed binary, fixed binary (35));
dcl  forum_$open_forum entry (character (*), character (*), fixed binary, fixed binary (35));
dcl  initiate_file_$component
	entry (character (*), character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35));
dcl  mail_table_$get entry (character (*) varying, pointer, character (*), fixed binary (35));
dcl  mailbox_$get_uid_file entry (character (*), character (*), bit (36) aligned, fixed binary (35));
dcl  mlsys_address_list_mgr_$create_user_freeable_address_list entry (character (8), pointer, fixed binary (35));
dcl  mlsys_address_list_mgr_$decrement_reference_count entry (pointer);
dcl  mlsys_address_list_mgr_$free_address_list entry (pointer, fixed binary (35));
dcl  mlsys_address_list_mgr_$increment_reference_count entry (pointer);
dcl  mlsys_address_list_mgr_$verify_address_list entry (pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mlsys_address_route_mgr_$compute_optimum_route entry (pointer, pointer, fixed binary (35));
dcl  mlsys_address_route_mgr_$create_address_route entry ((*) character (256) varying, pointer);
dcl  mlsys_address_route_mgr_$decrement_reference_count entry (pointer);
dcl  mlsys_address_route_mgr_$free_address_route entry (pointer);
dcl  mlsys_address_route_mgr_$increment_reference_count entry (pointer);
dcl  mlsys_nit_interface_$get_fully_qualified_name entry (character (256) varying) returns (character (256) varying);
dcl  mlsys_parse_text_$parse_address_text entry (character (*), pointer, fixed binary (35));
dcl  mlsys_parse_text_$parse_mailing_list_text entry (character (*), character (8), pointer, fixed binary (35));
dcl  mlsys_psp_$forum_not_available entry () returns (bit (1) aligned);
dcl  mlsys_user_mte_syntax_$validate_mte_name entry (character (*) varying, fixed binary (35));
dcl  mlsys_user_mte_syntax_$validate_person_id entry (character (*) varying, fixed binary (35));
dcl  mlsys_user_mte_syntax_$validate_user_id
	entry (character (*) varying, character (*) varying, character (*) varying, fixed binary (35));
dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));

dcl  cleanup condition;

dcl  (addr, baseno, binary, divide, index, length, maxlength, null, reverse, rtrim, size, string, translate) builtin;
%page;
/* Definitions of the various types of addresses used by the Multics mail system */

dcl  address_ptr pointer;				/* all following structures are based on this pointer */

%include mlsys_address_types;

dcl  WAS_FOREIGN_ADDRESS initial (-1)			/* identifies an address which was a foreign address but was
						   converted into a local address during validation */
	fixed binary static options (constant);


/* Standard header present in all addresses */

dcl  1 address_header aligned based (address_ptr),
       2 version character (8) unaligned,
       2 type fixed binary,				/* type of address (see above) */
       2 reference_count fixed binary,			/* # of address lists and messages referencing this address */
       2 name,					/* the address name */
         3 name_ptr pointer,
         3 name_lth fixed binary (21),
       2 comment,					/* the address comment */
         3 comment_ptr pointer,
         3 comment_lth fixed binary (21),
       2 flags,
         3 never_free bit (1) unaligned,		/* ON => don't free this address even if ref count is zero */
         3 free_name bit (1) unaligned,			/* ON => free the address name when freeing the address */
         3 free_comment bit (1) unaligned,		/* ON => free the address comment when freeing the address */
         3 pad bit (33) unaligned;

dcl  ADDRESS_VERSION_2 character (8) static options (constant) initial ("mlsaddr2");

dcl  address_name character (address_header.name_lth) unaligned based (address_header.name_ptr);

dcl  address_comment character (address_header.comment_lth) unaligned based (address_header.comment_ptr);
%page;
/* Address comparison dispatch table: referenced by both address types */

/* format: off */
dcl  COMPARISON_OPERATIONS (0:9, 0:9) fixed binary static options (constant) initial (
	 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,		/* invalid address */
	-1,  1,  1,  1,  1, -1, -1, -1, -1, -1,		/* user mailbox address */
	-1,  1,  1,  1,  1, -1, -1, -1, -1, -1,		/* logbox address */
	-1,  1,  1,  1,  1, -1, -1, -1, -1, -1,		/* savebox address */
	-1,  1,  1,  1,  1, -1, -1, -1, -1, -1,		/* mailbox address */
	-1, -1, -1, -1, -1,  2, -1, -1, -1, -1,		/* forum address */
	-1, -1, -1, -1, -1, -1,  3, -1, -1, -1,		/* foreign address */
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,		/* mail table address (never used) */
	-1, -1, -1, -1, -1, -1, -1, -1,  4,  5,		/* mailing list address */
	-1, -1, -1, -1, -1, -1, -1, -1,  5,  5);	/* named group address */
/* format: on */
%page;
/* format: ^indcomtxt */

/* WAS_FOREGIN_ADDRESS:  When a foreign address is created, the mail system does not actually validate that the address
   is, indeed, an off-site address.  Therefore, it is possible to create a "foreign" address for what is, in fact, a local
   address.  When the address is finally validated, the mail system will create the proper address and convert the foreign
   address into a was-foreign address.	The was-foreign address serves as a place holder in the various messages, address
   lists, etc. that already had a pointer to the foreign address */

dcl  1 was_foreign_address aligned based (address_ptr),
       2 header like address_header,
       2 actual_address_ptr pointer,			/* -> the actual local address into which it was converted */
       2 unused (size (foreign_address) - size (address_header) - size (address_ptr)) bit (36);


/* INVALID_ADDRESS: is used by the mail system to represent a text string which could not be converted into one of the
   other, standard addresses.	 It is used when parsing old-style ring-1 messages and, optionally, when requested by
   user-ring applications which allow users to create message headers (eg: "qedx -header" in send_mail) */

dcl  1 invalid_address aligned based (address_ptr),
       2 header like address_header,
       2 text,					/* the text which could not be parsed */
         3 text_ptr pointer,
         3 text_lth fixed binary (21),
       2 flags,
         3 free_text bit (1) unaligned,			/* ON => free the invalid text when freeing this address */
         3 pad bit (35) unaligned;

dcl  invalid_address_text character (invalid_address.text_lth) unaligned based (invalid_address.text_ptr);


/* Common portion of all addresses which reference one of a specific user's mailboxes (default mailbox/logbox/savebox) */

dcl  1 user_address_template aligned based (address_ptr),
       2 header like address_header,
       2 person_id character (32) varying,		/* the user's Person_id ... */
       2 project_id character (32) varying,		/* ... and Project_id */
       2 flags,
         3 is_anonymous bit (1) unaligned,		/* ON => this is the address of an anonymous user's mailbox */
         3 pad bit (35) unaligned;


/* USER_MAILBOX_ADDRESS: identifies a user's default mailbox.  The pathname of a user's default mailbox is:
	>udd>Project_id>Person_id>Person_id.mbx */

dcl  1 user_mailbox_address aligned based (address_ptr),
       2 user like user_address_template;


/* LOGBOX_ADDRESS: identifies a user's logbox.  The pathname of a user's logbox is:
	>udd>Project_id>Person_id>Person_id.sv.mbx */

dcl  1 logbox_address aligned based (address_ptr),
       2 user like user_address_template;


/* SAVEBOX_ADDRESS: identifies one of a user's saveboxes by pathname */

dcl  1 savebox_address aligned based (address_ptr),
       2 user like user_address_template,
       2 mbx_dirname character (168) unaligned,		/* pathname of directory containing the savebox */
       2 mbx_ename character (32) unaligned;		/* entryname of the savebox including "sv.mbx" suffix */


/* MAILBOX_ADDRESS: identifies an arbitrary mailbox by pathname */

dcl  1 mailbox_address aligned based (address_ptr),
       2 header like address_header,
       2 mbx_dirname character (168) unaligned,		/* pathname of directory containing the mailbox */
       2 mbx_ename character (32) unaligned;		/* entryname of the mailbox including "mbx" suffix */


/* FORUM_ADDRESS: identifies an arbitrary forum meeting by pathname */

dcl  1 forum_address aligned based (address_ptr),
       2 header like address_header,
       2 forum_dirname character (168) unaligned,		/* pathname of directory containing the meeting */
       2 forum_ename character (32) unaligned;		/* entryname of meeting including "control"/"forum" suffix */


/* FOREIGN_ADDRESS: identifies a user (or group of user) on another computer system */

dcl  1 foreign_address aligned based (address_ptr),
       2 header like address_header,
       2 local_part,				/* the name of the user/entity on the foreign system */
         3 local_part_ptr pointer,
         3 local_part_lth fixed binary (21),
       2 foreign_system character (256) varying,		/* the name of the foreign system */
       2 explicit_route pointer,			/* -> optional explicit route given by a user */
       2 implicit_route pointer,			/* -> an implicit route also associated with this address */
       2 flags,
         3 free_local_part bit (1) unaligned,		/* ON => free the local part text when freeing the address */
         3 pad bit (35) unaligned;

dcl  foreign_address_local_part character (foreign_address.local_part_lth) unaligned
	based (foreign_address.local_part_ptr);


/* MAIL_TABLE_ADDRESS: identifies an entry in the system-wide mail table which provides a translation between an arbitrary
   character string (usually a user's Person_id) and a mail system address */

dcl  1 mail_table_address aligned based (address_ptr),
       2 header like address_header,
       2 mte_name character (32) varying;		/* the name of the entry in the mail table */


/* MAILING_LIST_ADDRESS: identifies an arbitrary mailing list by pathname.  A mailing list may be an archive component in
   addition to a segment and is an ASCII file containing the printed representations of one or more addresses to which
   mail is to be sent whenever mail is sent to the mailing list */

dcl  1 mailing_list_address aligned based (address_ptr),
       2 header like address_header,
       2 mls_dirname character (168) unaligned,		/* pathname of the directory containing the mailing list */
       2 mls_ename character (32) unaligned,		/* entryname of the mailing list or containing archive */
       2 mls_component character (32) unaligned;		/* component name of the list including "mls" suffix */


/* NAMED_GROUP_ADDRESS: identifies a named group of addresses.  A named group is different from a mailing list in that it
   is intended to be a temporary grouping and, as such, does not have a permanent form (eg: segment/archive component) */

dcl  1 named_group_address aligned based (address_ptr),
       2 header like address_header,
       2 address_list pointer,			/* -> to the address list itself */
       2 flags,
         3 display_list bit (1) unaligned,		/* ON => include actual list in the printed representation */
         3 pad bit (35) unaligned;

/* format: indcomtxt */
%page;
/* Protect the supplied address from being accidentaly freed (used for the mlsys_data_$*_address variables) */

protect_address:
     entry (P_address_ptr);

	P_address_ptr -> address_header.never_free = "1"b;

	return;



/* Return the three address constants created in the mail system's ring to the caller:  These "constants" represent the
   user's default mailbox, mail table, and logbox addresses */

get_users_addresses:
     entry (P_default_mailbox_address, P_mail_table_address, P_logbox_address);

	P_default_mailbox_address = mlsys_data_$user_default_mailbox_address;

	P_mail_table_address = mlsys_data_$user_mail_table_address;

	P_logbox_address = mlsys_data_$user_logbox_address;

	return;



/* Set the full name for the user's default mailbox and mail table addresses */

set_users_full_name:
     entry (P_address_name);

	if mlsys_data_$user_default_mailbox_address -> user_mailbox_address.name_lth = 0 then
	     call set_address_variable_string (P_address_name,
		mlsys_data_$user_default_mailbox_address -> user_mailbox_address.name,
		mlsys_data_$user_default_mailbox_address -> user_mailbox_address.free_name);

	if mlsys_data_$user_mail_table_address -> mail_table_address.name_lth = 0 then
	     call set_address_variable_string (P_address_name,
		mlsys_data_$user_mail_table_address -> mail_table_address.name,
		mlsys_data_$user_mail_table_address -> mail_table_address.free_name);

	return;
%page;
/* Create an invalid address */

create_invalid_address:
     entry (P_address_string, P_address_name, P_address_comment, P_address_ptr, P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (INVALID_ADDRESS);

	call set_address_variable_string (P_address_string, invalid_address.text, invalid_address.free_text);

	call set_address_variable_string (P_address_name, invalid_address.name, invalid_address.free_name);
	call set_address_variable_string (P_address_comment, invalid_address.comment, invalid_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a user default mailbox address */

create_user_mailbox_address:
     entry (P_address_string, P_address_name, P_address_comment, P_address_ptr, P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (USER_MAILBOX_ADDRESS);

	call mlsys_user_mte_syntax_$validate_user_id (P_address_string, user_mailbox_address.person_id,
	     user_mailbox_address.project_id, code);
	if code ^= 0 then do;			/* invalid syntax */
BAD_USER_MAILBOX_ADDRESS:
	     call free_address (address_ptr, (0));
	     P_code = code;
	     return;
	end;

	if user_mailbox_address.person_id = ANONYMOUS then do;
	     user_mailbox_address.is_anonymous = "1"b;
	     if P_address_name ^= "" then do;		/* this must be the anonymous user's Person_id */
		call mlsys_user_mte_syntax_$validate_person_id (P_address_name, code);
		if code ^= 0 then go to BAD_USER_MAILBOX_ADDRESS;
		user_mailbox_address.person_id = P_address_name;
	     end;
	end;

	else if (user_mailbox_address.person_id = mlsys_data_$person_id)
		& (user_mailbox_address.project_id = mlsys_data_$project_id) & mlsys_data_$user_is_anonymous then
	     user_mailbox_address.is_anonymous = "1"b;

	else call set_address_variable_string (P_address_name, user_mailbox_address.name,
		user_mailbox_address.free_name);

	call set_address_variable_string (P_address_comment, user_mailbox_address.comment,
	     user_mailbox_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a logbox address */

create_logbox_address:
     entry (P_address_string, P_address_name, P_address_comment, P_address_ptr, P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (LOGBOX_ADDRESS);

	call mlsys_user_mte_syntax_$validate_user_id (P_address_string, logbox_address.person_id,
	     logbox_address.project_id, code);
	if code ^= 0 then do;			/* invalid syntax */
BAD_LOGBOX_ADDRESS:
	     call free_address (address_ptr, (0));
	     P_code = code;
	     return;
	end;

	if logbox_address.person_id = ANONYMOUS then do;
	     logbox_address.is_anonymous = "1"b;
	     if P_address_name ^= "" then do;		/* this must be the anonymous user's Person_id */
		call mlsys_user_mte_syntax_$validate_person_id (P_address_name, code);
		if code ^= 0 then go to BAD_LOGBOX_ADDRESS;
		logbox_address.person_id = P_address_name;
	     end;
	end;

	else if (logbox_address.person_id = mlsys_data_$person_id)
		& (logbox_address.project_id = mlsys_data_$project_id) & mlsys_data_$user_is_anonymous then
	     logbox_address.is_anonymous = "1"b;

	else call set_address_variable_string (P_address_name, logbox_address.name, logbox_address.free_name);

	call set_address_variable_string (P_address_comment, logbox_address.comment, logbox_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a savebox address */

create_savebox_address:
     entry (P_address_string, P_address_dirname, P_address_ename, P_address_name, P_address_comment, P_address_ptr,
	P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (SAVEBOX_ADDRESS);

	call mlsys_user_mte_syntax_$validate_user_id (P_address_string, savebox_address.person_id,
	     savebox_address.project_id, code);
	if code ^= 0 then do;			/* invalid syntax */
BAD_SAVEBOX_ADDRESS:
	     call free_address (address_ptr, (0));
	     P_code = code;
	     return;
	end;

	savebox_address.mbx_dirname = P_address_dirname;

	if validate_entryname (P_address_ename, ".sv.mbx", savebox_address.mbx_ename, code) then
	     savebox_address.mbx_ename = P_address_ename;
	else go to BAD_SAVEBOX_ADDRESS;

	if savebox_address.person_id = ANONYMOUS then do;
	     savebox_address.is_anonymous = "1"b;
	     if P_address_name ^= "" then do;		/* this must be the anonymous user's Person_id */
		call mlsys_user_mte_syntax_$validate_person_id (P_address_name, code);
		if code ^= 0 then go to BAD_SAVEBOX_ADDRESS;
		savebox_address.person_id = P_address_name;
	     end;
	end;

	else if (savebox_address.person_id = mlsys_data_$person_id)
		& (savebox_address.project_id = mlsys_data_$project_id) & mlsys_data_$user_is_anonymous then
	     savebox_address.is_anonymous = "1"b;

	else call set_address_variable_string (P_address_name, savebox_address.name, savebox_address.free_name);

	call set_address_variable_string (P_address_comment, savebox_address.comment, savebox_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a mailbox address */

create_mailbox_address:
     entry (P_address_dirname, P_address_ename, P_address_name, P_address_comment, P_address_ptr, P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (MAILBOX_ADDRESS);

	mailbox_address.mbx_dirname = P_address_dirname;

	if validate_entryname (P_address_ename, ".mbx", mailbox_address.mbx_ename, code) then
	     mailbox_address.mbx_ename = P_address_ename;
	else do;					/* something's wrong with the entry name */
	     call free_address (address_ptr, (0));
	     P_code = code;
	     return;
	end;

	call set_address_variable_string (P_address_name, mailbox_address.name, mailbox_address.free_name);
	call set_address_variable_string (P_address_comment, mailbox_address.comment, mailbox_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a forum address */

create_forum_address:
     entry (P_address_dirname, P_address_ename, P_address_name, P_address_comment, P_address_ptr, P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (FORUM_ADDRESS);

	forum_address.forum_dirname = P_address_dirname;

	if validate_entryname (P_address_ename, ".control", forum_address.forum_ename, code)
	     | validate_entryname (P_address_ename, ".forum", forum_address.forum_ename, code) then
	     forum_address.forum_ename = P_address_ename;

	else if mlsys_psp_$forum_not_available () | (forum_address.forum_dirname = "") then
	     /*** no Forum PSP or making an address for a meeting not found in the search list ... */
	     if validate_entryname (P_address_ename, "", suffixless_forum_ename, code) then
		forum_address.forum_ename = P_address_ename;
	     else go to BAD_FORUM_ADDRESS;

	else do;					/* something's wrong with the entry name */
	     if validate_entryname (P_address_ename, "", suffixless_forum_ename, code) then
		code = mlsys_et_$incorrect_suffix;
BAD_FORUM_ADDRESS:
	     call free_address (address_ptr, (0));
	     P_code = code;
	     return;
	end;

	call set_address_variable_string (P_address_name, forum_address.name, forum_address.free_name);
	call set_address_variable_string (P_address_comment, forum_address.comment, forum_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a foreign address */

create_foreign_address:
     entry (P_address_string, P_foreign_system, P_address_route_ptr, P_address_name, P_address_comment, P_address_ptr,
	P_code);

	if P_address_string = "" then do;		/* can't allow a null local part */
	     P_code = mlsys_et_$null_foreign_address;
	     return;
	end;

	if P_foreign_system = "" then do;		/* can't allow a null system name */
	     P_code = mlsys_et_$unknown_system;
	     return;
	end;

	if P_address_route_ptr ^= null () then		/* check for proper version ... */
	     if P_address_route_ptr -> address_route.version ^= ADDRESS_ROUTE_VERSION_1 then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (FOREIGN_ADDRESS);

	call set_address_variable_string (P_address_string, foreign_address.local_part, foreign_address.free_local_part)
	     ;

	if P_address_route_ptr = null () then		/* we should know the foreign system name */
	     foreign_address.foreign_system = mlsys_nit_interface_$get_fully_qualified_name (P_foreign_system);
	else foreign_address.foreign_system = translate (P_foreign_system, UPPERCASE, LOWERCASE);

	if P_address_route_ptr ^= null () then do;	/* user has supplied an explicit route ... */
	     address_route_ptr = copy_ptr (P_address_route_ptr);
						/* ... for following call to work ... */
	     call mlsys_address_route_mgr_$create_address_route (address_route.relays, foreign_address.explicit_route);
	     call mlsys_address_route_mgr_$increment_reference_count (foreign_address.explicit_route);
	end;

	call set_address_variable_string (P_address_name, foreign_address.name, foreign_address.free_name);
	call set_address_variable_string (P_address_comment, foreign_address.comment, foreign_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a mail table address */

create_mail_table_address:
     entry (P_address_string, P_address_name, P_address_comment, P_address_ptr, P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (MAIL_TABLE_ADDRESS);

	call mlsys_user_mte_syntax_$validate_mte_name (P_address_string, code);
	if code ^= 0 then do;
	     call free_address (address_ptr, (0));
	     P_code = code;
	     return;
	end;

	mail_table_address.mte_name = P_address_string;
	call set_address_variable_string (P_address_name, mail_table_address.name, mail_table_address.free_name);
	call set_address_variable_string (P_address_comment, mail_table_address.comment,
	     mail_table_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a mailing list address */

create_mailing_list_address:
     entry (P_address_dirname, P_address_ename, P_address_component, P_address_name, P_address_comment, P_address_ptr,
	P_code);

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (MAILING_LIST_ADDRESS);	/* sets mls_component to a null string */

	mailing_list_address.mls_dirname = P_address_dirname;

	if P_address_component = "" then		/* mailing list is in a segment */
	     if validate_entryname (P_address_ename, ".mls", mailing_list_address.mls_ename, code) then
		mailing_list_address.mls_ename = P_address_ename;
	     else do;				/* something's wrong with the entry/component name */
BAD_MAILING_LIST_ADDRESS:
		call free_address (address_ptr, (0));
		P_code = code;
		return;
	     end;

	else do;					/* mailing list is in an archive component */
	     if validate_entryname (P_address_ename, ".archive", mailing_list_address.mls_ename, code) then do;
		mailing_list_address.mls_ename = P_address_ename;
		if validate_entryname (P_address_component, ".mls", mailing_list_address.mls_component, code) then
		     mailing_list_address.mls_component = P_address_component;
	     end;
	     if code ^= 0 then go to BAD_MAILING_LIST_ADDRESS;
	end;

	call set_address_variable_string (P_address_name, mailing_list_address.name, mailing_list_address.free_name);
	call set_address_variable_string (P_address_comment, mailing_list_address.comment,
	     mailing_list_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Create a named group address */

create_named_group_address:
     entry (P_address_name, P_address_list_ptr, P_display_list, P_address_comment, P_address_ptr, P_code);

	if ^mlsys_address_list_mgr_$verify_address_list (P_address_list_ptr, P_code) then return;

	if P_address_name = "" then do;		/* can't be a blank name */
	     P_code = mlsys_et_$null_named_group_name;
	     return;
	end;

	address_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if address_ptr ^= null () then call free_address (address_ptr, (0));
	     end;

	call initialize_address (NAMED_GROUP_ADDRESS);

	named_group_address.address_list = copy_ptr (P_address_list_ptr);
	call mlsys_address_list_mgr_$increment_reference_count (named_group_address.address_list);

	named_group_address.display_list = P_display_list;

	call set_address_variable_string (P_address_name, named_group_address.name, named_group_address.free_name);
	call set_address_variable_string (P_address_comment, named_group_address.comment,
	     named_group_address.free_comment);

	P_address_ptr = address_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Free an address if its reference count is zero (ie: if no other mail system object has a pointer to this address) */

free_address:
     entry (P_address_ptr, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	address_ptr = copy_ptr (P_address_ptr);
	P_address_ptr = null ();			/* insure that the caller doesn't use it anymore */

	P_code = 0;				/* indicates that this call has succeeded */

	if address_header.never_free | (address_header.reference_count > 0) then return;
						/* someone's still using it */

	if address_header.free_name then		/* the address name was allocated simultaneously */
	     free address_name in (mlsys_area);
	if address_header.free_comment then free address_comment in (mlsys_area);

	go to FREE_ADDRESS (address_header.type);

FREE_ADDRESS (-1):					/* was-foreign address */
	call decrement_reference_count (was_foreign_address.actual_address_ptr);
	free was_foreign_address in (mlsys_area);	/* above call probably will free the real address */
	return;

FREE_ADDRESS (0):					/* invalid address */
	if invalid_address.free_text then		/* we allocated this text when we created the address */
	     free invalid_address_text in (mlsys_area);
	free invalid_address in (mlsys_area);
	return;

FREE_ADDRESS (1):					/* user mailbox address */
	free user_mailbox_address in (mlsys_area);
	return;

FREE_ADDRESS (2):					/* logbox address */
	free logbox_address in (mlsys_area);
	return;

FREE_ADDRESS (3):					/* savebox address */
	free savebox_address in (mlsys_area);
	return;

FREE_ADDRESS (4):					/* mailbox address */
	free mailbox_address in (mlsys_area);
	return;

FREE_ADDRESS (5):					/* forum address */
	free forum_address in (mlsys_area);
	return;

FREE_ADDRESS (6):					/* foreign address */
	if foreign_address.free_local_part then		/* the local part was allocated simultaneously */
	     free foreign_address_local_part in (mlsys_area);
	if foreign_address.explicit_route ^= null () then
	     call mlsys_address_route_mgr_$decrement_reference_count (foreign_address.explicit_route);
	if foreign_address.implicit_route ^= null () then
	     call mlsys_address_route_mgr_$decrement_reference_count (foreign_address.implicit_route);
	free foreign_address in (mlsys_area);
	return;

FREE_ADDRESS (7):					/* mail table address */
	free mail_table_address in (mlsys_area);
	return;

FREE_ADDRESS (8):					/* mailing list address */
	free mailing_list_address in (mlsys_area);
	return;

FREE_ADDRESS (9):					/* named group address */
	call mlsys_address_list_mgr_$decrement_reference_count (named_group_address.address_list);
	free named_group_address in (mlsys_area);
	return;
%page;
/* Increment the reference count of an address: to avoid the user accidently freeing an address which is in use by other
   parts of the mail system (eg: references within a message, an address list, or another address) */

increment_reference_count:
     entry (P_address_ptr);

	P_address_ptr -> address_header.reference_count = P_address_ptr -> address_header.reference_count + 1;

	return;



/* Decrement the reference count of an address:  If the reference count reaches zero, nothing in the mail system is using
   this address any longer and its storage is released */

decrement_reference_count:
     entry (P_address_ptr);

	P_address_ptr -> address_header.reference_count = P_address_ptr -> address_header.reference_count - 1;

	if (P_address_ptr -> address_header.reference_count <= 0) & ^P_address_ptr -> address_header.never_free then
	     call free_address (P_address_ptr, (0));

	P_address_ptr = null ();			/* keep the caller from using it anymore */

	return;



/* Decrement the reference count of an address but do not free it when the reference count reaches zero */

decrement_reference_count_no_free:
     entry (P_address_ptr);

	P_address_ptr -> address_header.reference_count = P_address_ptr -> address_header.reference_count - 1;

	P_address_ptr = null ();			/* keep the caller from using it anymore */

	return;
%page;
/* Return the type of the given address */

get_address_type:
     entry (P_address_ptr, P_address_type, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	P_address_type = address_header.type;
	P_code = 0;				/* success */

	return;



/* Return the character string associated with the given address, if any:  The address string has various interpretations
   dependent on the address type (eg: User_id, foreign user/entity name, etc.) */

get_address_string:
     entry (P_address_ptr, P_address_string, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	go to GET_ADDRESS_STRING (address_header.type);

GET_ADDRESS_STRING (0):				/* invalid address */
	call set_output_variable (invalid_address_text, P_address_string, P_code);
	return;

GET_ADDRESS_STRING (1):				/* user mailbox address */
GET_ADDRESS_STRING (2):				/* logbox address */
GET_ADDRESS_STRING (3):				/* savebox address */
	if user_address_template.is_anonymous then
	     call set_output_variable ((ANONYMOUS || "." || user_address_template.project_id), P_address_string, P_code)
		;
	else call set_output_variable ((user_address_template.person_id || "." || user_address_template.project_id),
		P_address_string, P_code);
	return;

GET_ADDRESS_STRING (4):				/* mailbox address */
GET_ADDRESS_STRING (5):				/* forum address */
	P_code = mlsys_et_$no_address_string;
	return;

GET_ADDRESS_STRING (6):				/* foreign address */
	call set_output_variable (foreign_address_local_part, P_address_string, P_code);
	return;

GET_ADDRESS_STRING (7):				/* mail table address */
	call set_output_variable ((mail_table_address.mte_name), P_address_string, P_code);
	return;

GET_ADDRESS_STRING (8):				/* mailing list address */
GET_ADDRESS_STRING (9):				/* named group address */
	P_code = mlsys_et_$no_address_string;
	return;
%page;
/* Return the pathname associated with the given address, if any */

get_address_pathname:
     entry (P_address_ptr, P_address_dirname, P_address_ename, P_address_component, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	go to GET_ADDRESS_PATHNAME (address_header.type);

GET_ADDRESS_PATHNAME (0):				/* invalid address */
	P_code = mlsys_et_$no_address_pathname;
	return;

GET_ADDRESS_PATHNAME (1):				/* user mailbox address */
	P_address_dirname = ">udd>" || user_mailbox_address.project_id || ">" || user_mailbox_address.person_id;
	P_address_ename = user_mailbox_address.person_id || ".mbx";
	P_address_component = "";
	P_code = 0;
	return;

GET_ADDRESS_PATHNAME (2):				/* logbox address */
	P_address_dirname = ">udd>" || logbox_address.project_id || ">" || logbox_address.person_id;
	P_address_ename = logbox_address.person_id || ".sv.mbx";
	P_address_component = "";
	P_code = 0;
	return;

GET_ADDRESS_PATHNAME (3):				/* savebox address */
	P_address_dirname = savebox_address.mbx_dirname;
	P_address_ename = savebox_address.mbx_ename;
	P_address_component = "";
	P_code = 0;
	return;

GET_ADDRESS_PATHNAME (4):				/* mailbox address */
	P_address_dirname = mailbox_address.mbx_dirname;
	P_address_ename = mailbox_address.mbx_ename;
	P_address_component = "";
	P_code = 0;
	return;

GET_ADDRESS_PATHNAME (5):				/* forum address */
	P_address_dirname = forum_address.forum_dirname;
	P_address_ename = forum_address.forum_ename;
	P_address_component = "";
	P_code = 0;
	return;

GET_ADDRESS_PATHNAME (6):				/* foreign address */
GET_ADDRESS_PATHNAME (7):				/* mail table address */
	P_code = mlsys_et_$no_address_pathname;
	return;

GET_ADDRESS_PATHNAME (8):				/* mailing list address */
	P_address_dirname = mailing_list_address.mls_dirname;
	P_address_ename = mailing_list_address.mls_ename;
	P_address_component = mailing_list_address.mls_component;
	P_code = 0;
	return;

GET_ADDRESS_PATHNAME (9):				/* named group address */
	P_code = mlsys_et_$no_address_pathname;
	return;
%page;
/* Return the explicit route to be used to send mail to the given address which must be a foreign address:  The explicit
   route is a route supplied by a user (either local or foreign) and is always used even though the mail system could
   compute a shorter route to the foreign system if permitted */

get_address_explicit_route:
     entry (P_address_ptr, P_address_route_version, P_address_route_ptr, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	if address_header.type = FOREIGN_ADDRESS then
	     if foreign_address.explicit_route ^= null () then
		if P_address_route_version = ADDRESS_ROUTE_VERSION_1 then do;
		     P_address_route_ptr = foreign_address.explicit_route;
		     P_code = 0;			/* ... success */
		end;
		else P_code = error_table_$unimplemented_version;

	     else P_code = mlsys_et_$no_address_route;	/* no route at this time */

	else P_code = mlsys_et_$not_foreign_address;

	return;



/* Return the name of the foreign system associated with the given address which must be a foreign address */

get_address_system:
     entry (P_address_ptr, P_foreign_system, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	if address_header.type = FOREIGN_ADDRESS then do;
	     P_foreign_system = foreign_address.foreign_system;
	     P_code = 0;
	end;

	else P_code = mlsys_et_$not_foreign_address;

	return;
%page;
/* Set the implicit route associated with the given address which must be a foreign address:  The implicit route is a
   route associated with all the addresses in a message that is used by the mail system to send mail to the given address
   if it can not compute a route on its own */

set_address_implicit_route:
     entry (P_address_ptr, P_address_route_ptr, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADRESS type */

	if address_header.type = FOREIGN_ADDRESS then
	     if P_address_route_ptr -> address_route.version = ADDRESS_ROUTE_VERSION_1 then do;
		address_route_ptr = copy_ptr (P_address_route_ptr);
		if foreign_address.implicit_route ^= null () then
		     call mlsys_address_route_mgr_$decrement_reference_count (foreign_address.implicit_route);
		if mlsys_data_$valid_segments (binary (baseno (address_route_ptr), 18, 0)) then
		     foreign_address.implicit_route = address_route_ptr;
		else call mlsys_address_route_mgr_$create_address_route (address_route.relays,
			foreign_address.implicit_route);
		call mlsys_address_route_mgr_$increment_reference_count (foreign_address.implicit_route);
		P_code = 0;			/* success */
	     end;
	     else P_code = error_table_$unimplemented_version;

	else P_code = mlsys_et_$not_foreign_address;

	return;



/* Return the implicit route associated with the given address which must be a foreign address */

get_address_implicit_route:
     entry (P_address_ptr, P_address_route_version, P_address_route_ptr, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	if address_header.type = FOREIGN_ADDRESS then
	     if foreign_address.implicit_route ^= null () then
		if P_address_route_version = ADDRESS_ROUTE_VERSION_1 then do;
		     P_address_route_ptr = foreign_address.implicit_route;
		     P_code = 0;			/* ... success */
		end;
		else P_code = error_table_$unimplemented_version;

	     else P_code = mlsys_et_$no_address_route;	/* no route at this time */

	else P_code = mlsys_et_$not_foreign_address;

	return;
%page;
/* Return the setting of the display_list flag of the given address which must be a named group address */

get_named_group_display_flag:
     entry (P_address_ptr, P_display_list, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	if address_header.type = NAMED_GROUP_ADDRESS then do;
	     P_display_list = named_group_address.display_list;
	     P_code = 0;
	end;

	else P_code = mlsys_et_$not_named_group_address;

	return;



/* Return the address name of the given address */

get_address_name:
     entry (P_address_ptr, P_address_name, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();

	if (address_header.type = USER_MAILBOX_ADDRESS) | (address_header.type = LOGBOX_ADDRESS)
	     | (address_header.type = SAVEBOX_ADDRESS) then
	     if user_address_template.is_anonymous then	/* the address name for anonymous users is their Person_id */
		call set_output_variable ((user_address_template.person_id), P_address_name, P_code);
	     else call set_output_variable (address_name, P_address_name, P_code);
	else call set_output_variable (address_name, P_address_name, P_code);

	return;



/* Return the address comment of the given address */

get_address_comment:
     entry (P_address_ptr, P_address_comment, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	call set_output_variable (address_comment, P_address_comment, P_code);

	return;
%page;
/* Compares two addresses for equality:  Two addresses are equal if mail transmitted to either address will be delivered
   to the same set of recipients */

compare_addresses:
     entry (P_address_1_ptr, P_address_2_ptr, P_code) returns (bit (1) aligned);

	if ^verify_address (P_address_1_ptr, P_code) then return ("0"b);
	if ^verify_address (P_address_2_ptr, P_code) then return ("0"b);

	P_code = 0;				/* the comparison will succeed */

	if P_address_1_ptr = P_address_2_ptr then	/* they are the same physical structure */
	     return ("1"b);

	address_1_mte_address_ptr,			/* for cleanup handler */
	     address_2_mte_address_ptr, address_1_route_ptr, address_2_route_ptr, address_1_mls_ptr, address_2_mls_ptr,
	     address_list_1_ptr, address_list_2_ptr, address_list_ptr = null ();
	forum_1_index, forum_2_index = 0;

	on condition (cleanup) call cleanup_address_comparison ();

	address_1_ptr = copy_ptr (P_address_1_ptr);	/* copy inputs and check for was-foreign addresses */
	if address_1_ptr -> address_header.type = FOREIGN_ADDRESS then call check_if_actually_local (address_1_ptr);
						/* ... might not really be a foreign address */
	if address_1_ptr -> address_header.type = WAS_FOREIGN_ADDRESS then
	     address_1_ptr = address_1_ptr -> was_foreign_address.actual_address_ptr;

	address_2_ptr = copy_ptr (P_address_2_ptr);
	if address_2_ptr -> address_header.type = FOREIGN_ADDRESS then call check_if_actually_local (address_2_ptr);
	if address_2_ptr -> address_header.type = WAS_FOREIGN_ADDRESS then
	     address_2_ptr = address_2_ptr -> was_foreign_address.actual_address_ptr;


/* Lookup any mail table addresses before proceeeding:  If both addresses are mail table addresses, check if they have the
   same mail table name right now.  If only one is a mail table address or the names do not match and one or both can not
   be found in the mail table, then we can guarentee that the addresses aren't equal */

	if (address_1_ptr -> address_header.type = MAIL_TABLE_ADDRESS)
	     & (address_2_ptr -> address_header.type = MAIL_TABLE_ADDRESS) then
	     if address_1_ptr -> mail_table_address.mte_name = address_2_ptr -> mail_table_address.mte_name then
		call return_comparison_result ("1"b);

	if address_1_ptr -> address_header.type = MAIL_TABLE_ADDRESS then do;
	     call get_mail_table_address (address_1_ptr, address_1_mte_address_ptr, code);
	     if code ^= 0 then call return_comparison_result ("0"b);
	     address_1_ptr = address_1_mte_address_ptr;	/* need 2nd copy as address_1_ptr may get changed */
	     if address_1_ptr -> address_header.type = FOREIGN_ADDRESS then
		call check_if_actually_local (address_1_ptr);
	     if address_1_ptr -> address_header.type = WAS_FOREIGN_ADDRESS then
		address_1_ptr = address_1_ptr -> was_foreign_address.actual_address_ptr;
	end;

	if address_2_ptr -> address_header.type = MAIL_TABLE_ADDRESS then do;
	     call get_mail_table_address (address_2_ptr, address_2_mte_address_ptr, code);
	     if code ^= 0 then call return_comparison_result ("0"b);
	     address_2_ptr = address_2_mte_address_ptr;	/* need 2nd copy as address_2_ptr may get changed */
	     if address_2_ptr -> address_header.type = FOREIGN_ADDRESS then
		call check_if_actually_local (address_2_ptr);
	     if address_2_ptr -> address_header.type = WAS_FOREIGN_ADDRESS then
		address_2_ptr = address_2_ptr -> was_foreign_address.actual_address_ptr;
	end;


/* If one of the addresses is a mailing list or named group but the other is not, expand the list address and compare the
   expansion with the other address -- all addresses in the expansion must equal the other address */

	if (is_list_address (address_1_ptr) & ^is_list_address (address_2_ptr))
	     | (is_list_address (address_2_ptr) & ^is_list_address (address_1_ptr)) then do;

	     if is_list_address (address_1_ptr) then	/* we know that only one is a list address */
		call expand_list_address (address_1_ptr, ADDRESS_LIST_VERSION_2, address_list_ptr, code);
	     else do;
		call expand_list_address (address_2_ptr, ADDRESS_LIST_VERSION_2, address_list_ptr, code);
		address_2_ptr = address_1_ptr;	/* "swap" the two addresses */
	     end;
	     if code ^= 0 then call return_comparison_result ("0"b);
						/* couldn't expand: can't be equal */

	     if address_list.n_addresses = 0 then	/* the address list is empty: can't be equal */
		comparison_result = "0"b;
	     else do;
		comparison_result = "1"b;		/* really need do until here ... */
		do idx = 1 to address_list.n_addresses while (comparison_result);
		     comparison_result = compare_addresses (address_list.addresses (idx), address_2_ptr, (0));
		end;
	     end;

	     call return_comparison_result (comparison_result);
	end;


/* Both addresses are simple or both are list addresses */

	go to COMPARE_ADDRESSES (
	     COMPARISON_OPERATIONS (address_1_ptr -> address_header.type, address_2_ptr -> address_header.type));

COMPARE_ADDRESSES (-1):				/* incompatible types */
	call return_comparison_result ("0"b);


COMPARE_ADDRESSES (0):				/* two invalid addresses: do a string comparison */
	begin;
dcl  address_1_text char (address_1_ptr -> invalid_address.text_lth) based (address_1_ptr -> invalid_address.text_ptr);
dcl  address_2_text char (address_2_ptr -> invalid_address.text_lth) based (address_2_ptr -> invalid_address.text_ptr);
	     call return_comparison_result (address_1_text = address_2_text);
	end;


/* Both are addresses of mailboxes: check the pathnames before actually trying to find their UIDs */

COMPARE_ADDRESSES (1):
	call get_address_pathname (address_1_ptr, address_1_dirname, address_1_ename, ((32)" "), (0));
	call get_address_pathname (address_2_ptr, address_2_dirname, address_2_ename, ((32)" "), (0));

	if (address_1_dirname = address_2_dirname) & (address_1_ename = address_2_ename) then
	     call return_comparison_result ("1"b);	/* pathname strings match (whew) */

	call mailbox_$get_uid_file (address_1_dirname, address_1_ename, mailbox_1_uid, code_1);
	call mailbox_$get_uid_file (address_2_dirname, address_2_ename, mailbox_2_uid, code_2);

	if (code_1 = 0) & (code_2 = 0) then		/* got both UIDs */
	     comparison_result = (mailbox_1_uid = mailbox_2_uid);
	else comparison_result = "0"b;		/* got only one UID (or none): can't be equal */

	call return_comparison_result (comparison_result);


/* Both are addresses of forum meetings: check the pathnames before actually trying to access the meetings */

COMPARE_ADDRESSES (2):
	call get_address_pathname (address_1_ptr, address_1_dirname, address_1_ename, ((32)" "), (0));
	call get_address_pathname (address_2_ptr, address_2_dirname, address_2_ename, ((32)" "), (0));

	if (address_1_dirname = address_2_dirname) & (address_1_ename = address_2_ename) then
	     call return_comparison_result ("1"b);	/* pathname strings match (whew) */

	if mlsys_psp_$forum_not_available () then	/* if no forum on system ... */
	     call return_comparison_result ("0"b);	/* ... they can't be equal as pathnames don't match */

	if (address_1_dirname = "") | (address_2_dirname = "") then call return_comparison_result ("0"b);
						/* at least one of the forums doesn't exist */

	call forum_$open_forum (address_1_dirname, address_1_ename, forum_1_index, code_1);
	call forum_$open_forum (address_2_dirname, address_2_ename, forum_2_index, code_2);

	if (code_1 = 0) & (code_2 = 0) then		/* were able to open both */
	     comparison_result = (forum_1_index = forum_2_index);
	else comparison_result = "0"b;		/* couldn't open one or both: can't be equal */

	call return_comparison_result (comparison_result);


/* Both are foreign addresses */

COMPARE_ADDRESSES (3):
	begin;
dcl  address_1_local_part character (address_1_ptr -> foreign_address.local_part_lth)
	based (address_1_ptr -> foreign_address.local_part_ptr);
dcl  address_2_local_part character (address_2_ptr -> foreign_address.local_part_lth)
	based (address_2_ptr -> foreign_address.local_part_ptr);
	     if address_1_local_part ^= address_2_local_part then call return_comparison_result ("0"b);
	end;					/* can't be equal if local parts differ */

	/*** check system names and routes */
	call mlsys_address_route_mgr_$compute_optimum_route (address_1_ptr, address_1_route_ptr, code_1);
	call mlsys_address_route_mgr_$compute_optimum_route (address_2_ptr, address_2_route_ptr, code_2);
						/* these routes includes the actual target system */

	if (code_1 = 0) & (code_2 = 0) then		/* have a way to get to both systems */
	     if address_1_route_ptr -> address_route.n_relays = address_2_route_ptr -> address_route.n_relays then do;
		comparison_result = "1"b;		/* ... need do until */
		do idx = 1 to address_1_route_ptr -> address_route.n_relays while (comparison_result);
		     comparison_result =
			(translate (address_1_route_ptr -> address_route.relays (idx), UPPERCASE, LOWERCASE)
			= translate (address_2_route_ptr -> address_route.relays (idx), UPPERCASE, LOWERCASE));
		end;
	     end;
	     else comparison_result = "0"b;		/* ... not the same number of hops */
	else comparison_result = "0"b;		/* ... can't get to one or both */

	call return_comparison_result (comparison_result);


/* Both are mailing list addresses: check for the same segment/archive components before checking the actual addresses in
   the two lists */

COMPARE_ADDRESSES (4):
	if (address_1_ptr -> mailing_list_address.mls_dirname = address_2_ptr -> mailing_list_address.mls_dirname)
	     & (address_1_ptr -> mailing_list_address.mls_ename = address_2_ptr -> mailing_list_address.mls_ename)
	     & (address_1_ptr -> mailing_list_address.mls_component
	     = address_2_ptr -> mailing_list_address.mls_component) then
	     call return_comparison_result ("1"b);	/* pathnames match */

	call initiate_file_$component (address_1_ptr -> mailing_list_address.mls_dirname,
	     address_1_ptr -> mailing_list_address.mls_ename, address_1_ptr -> mailing_list_address.mls_component,
	     R_ACCESS, address_1_mls_ptr, (0), code_1);
	call initiate_file_$component (address_2_ptr -> mailing_list_address.mls_dirname,
	     address_2_ptr -> mailing_list_address.mls_ename, address_2_ptr -> mailing_list_address.mls_component,
	     R_ACCESS, address_2_mls_ptr, (0), code_2);

	if (code_1 = 0) & (code_2 = 0) then		/* got them both: are they the same? */
	     comparison_result = (address_1_mls_ptr = address_2_mls_ptr);
	else comparison_result = "0"b;		/* couldn't initiate both: this will fail again later */

	if comparison_result then			/* they match */
	     call return_comparison_result ("1"b);
	/*** not the same mailing list: fall through and check their contents */


/* Both are list addresses: check the individual addresses within the two lists */

COMPARE_ADDRESSES (5):
	call expand_list_address (address_1_ptr, ADDRESS_LIST_VERSION_2, address_list_1_ptr, code_1);
	call expand_list_address (address_2_ptr, ADDRESS_LIST_VERSION_2, address_list_2_ptr, code_2);

	if (code_1 ^= 0) | (code_2 ^= 0) then		/* couldn't expand both: can't be equal */
	     call return_comparison_result ("0"b);

	if (address_list_1_ptr -> address_list.n_addresses = 0) & (address_list_2_ptr -> address_list.n_addresses = 0)
	then comparison_result = "1"b;		/* both lists are empty */

	else if (address_list_1_ptr -> address_list.n_addresses = 0)
		| (address_list_2_ptr -> address_list.n_addresses = 0) then
	     comparison_result = "0"b;		/* one is empty and the other isn't: can't be equal */

	else do;					/* must check each address in both lists */
	     comparison_result = "1"b;		/* ... need do until again */
	     do idx = 1 to address_list_1_ptr -> address_list.n_addresses while (comparison_result);
		partial_comparison_result = "0"b;
		do jdx = 1 to address_list_2_ptr -> address_list.n_addresses while (^partial_comparison_result);
		     partial_comparison_result =
			compare_addresses (address_list_1_ptr -> address_list.addresses (idx),
			address_list_2_ptr -> address_list.addresses (jdx), (0));
		end;
		comparison_result = partial_comparison_result;
	     end;					/* ... stop as soon as we find one not in the other list */
	     do idx = 1 to address_list_2_ptr -> address_list.n_addresses while (comparison_result);
		partial_comparison_result = "0"b;
		do jdx = 1 to address_list_2_ptr -> address_list.n_addresses while (^partial_comparison_result);
		     partial_comparison_result =
			compare_addresses (address_list_2_ptr -> address_list.addresses (idx),
			address_list_1_ptr -> address_list.addresses (jdx), (0));
		end;
		comparison_result = partial_comparison_result;
	     end;					/* ... stop as soon as we find one not in the other list */
	end;

	call return_comparison_result (comparison_result);



/* Return the result of the address comparison (after proper cleanup, of course) */

return_comparison_result:
     procedure (p_result);

dcl  p_result bit (1) aligned;

	call cleanup_address_comparison ();

	comparison_result = p_result;			/* set the result in the caller's stack frame */

	go to RETURN_FROM_COMPARE_ADDRESSES;

     end return_comparison_result;

RETURN_FROM_COMPARE_ADDRESSES:			/* actually return point for mail_system_$compare_addresses */
	return (comparison_result);



/* Cleanup after an address comparison operation */

cleanup_address_comparison:
     procedure ();

	if address_1_mte_address_ptr ^= null () then call free_address (address_1_mte_address_ptr, (0));
	if address_2_mte_address_ptr ^= null () then call free_address (address_2_mte_address_ptr, (0));

	if address_list_ptr ^= null () then call mlsys_address_list_mgr_$free_address_list (address_list_ptr, (0));

	if forum_1_index ^= 0 then call forum_$close_forum (forum_1_index, (0));
	if forum_2_index ^= 0 then call forum_$close_forum (forum_2_index, (0));
	forum_1_index, forum_2_index = 0;

	if address_1_route_ptr ^= null () then call mlsys_address_route_mgr_$free_address_route (address_1_route_ptr);
	if address_2_route_ptr ^= null () then call mlsys_address_route_mgr_$free_address_route (address_2_route_ptr);

	if address_1_mls_ptr ^= null () then call terminate_file_ (address_1_mls_ptr, 0, TERM_FILE_TERM, (0));
	if address_2_mls_ptr ^= null () then call terminate_file_ (address_2_mls_ptr, 0, TERM_FILE_TERM, (0));
	address_1_mls_ptr, address_2_mls_ptr = null ();

	if address_list_1_ptr ^= null () then call mlsys_address_list_mgr_$free_address_list (address_list_1_ptr, (0));
	if address_list_2_ptr ^= null () then call mlsys_address_list_mgr_$free_address_list (address_list_2_ptr, (0));

	return;

     end cleanup_address_comparison;
%page;
/* Return the actual address in the system's mail table corresponding to the given address */

get_mail_table_address:
     entry (P_address_ptr, P_mail_table_address_ptr, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	if address_header.type ^= MAIL_TABLE_ADDRESS then do;
	     P_code = mlsys_et_$not_mail_table_address;
	     return;
	end;

	current_mtle_ptr = null ();			/* this is the top of the list */
	call lookup_mail_table_entry (mail_table_address.mte_name);

	P_mail_table_address_ptr = mail_table_address_ptr;
	code = 0;					/* success */

RETURN_FROM_GET_MAIL_TABLE_ADDRESS:
	P_code = code;

	return;



/* Searches the mail table for the given name:  If found, a check is made for a circular definition as the mail table
   software does not prevent recursive entries */

lookup_mail_table_entry:
     procedure (p_mte_name);

dcl  p_mte_name character (32) varying parameter;

dcl  1 mtle aligned based (mtle_ptr),
       2 previous_mtle_ptr pointer,
       2 name character (32) varying;
dcl  mtle_ptr pointer;

dcl  1 local_mtle aligned like mtle;
dcl  next_mte_name character (32) varying;

	call mail_table_$get (p_mte_name, mail_table_address_ptr, ((168)" "), code);
	if code = error_table_$id_not_found then code = mlsys_et_$mte_not_found;
	if code ^= 0 then go to RETURN_FROM_GET_MAIL_TABLE_ADDRESS;

	if mail_table_address_ptr -> address_header.type ^= MAIL_TABLE_ADDRESS then return;
						/* target isn't another mail table entry: this is it */

	next_mte_name = mail_table_address_ptr -> mail_table_address.mte_name;
	call free_address (mail_table_address_ptr, (0));	/* we don't need this address anymore */

	local_mtle.name = p_mte_name;			/* put it onto the stack */
	local_mtle.previous_mtle_ptr = current_mtle_ptr;
	current_mtle_ptr = addr (local_mtle);

	do mtle_ptr = current_mtle_ptr repeat (mtle.previous_mtle_ptr) while (mtle_ptr ^= null ());
	     if next_mte_name = mtle.name then do;	/* the name is circular ... */
		code = mlsys_et_$circular_mtes;
		go to RETURN_FROM_GET_MAIL_TABLE_ADDRESS;
	     end;
	end;

	call lookup_mail_table_entry (next_mte_name);	/* recurse */

     end lookup_mail_table_entry;
%page;
/* Returns the address list which is the expansion of a list address (mailing list/named group) */

expand_list_address:
     entry (P_address_ptr, P_address_list_version, P_address_list_ptr, P_code);

	if ^verify_address (P_address_ptr, P_code) then return;

	call set_address_ptr ();			/* bypass the infamous WAS_FOREIGN_ADDRESS type */

	if ^is_list_address (address_ptr) then do;	/* must be a mailing list or a named group */
	     P_code = mlsys_et_$not_list_address;
	     return;
	end;

	if P_address_list_version ^= ADDRESS_LIST_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if address_header.type = NAMED_GROUP_ADDRESS then
	     if named_group_address.address_list = null () then
		/*** no address list: return an empty list to the caller */
		call mlsys_address_list_mgr_$create_user_freeable_address_list (P_address_list_version,
		     P_address_list_ptr, P_code);
	     else do;				/* there is a list present */
		P_address_list_ptr = named_group_address.address_list;
		P_code = 0;
	     end;

	else /*** if address_header.type = MAILING_LIST_ADDRESS then */
	     do;
	     /*** Mailing list: initiate the segment/archive component and then parse its content */
	     mls_ptr = null ();			/* for cleanup handler */
	     on condition (cleanup)
		begin;
		     if mls_ptr ^= null () then call terminate_file_ (mls_ptr, 0, TERM_FILE_TERM, (0));
		end;
	     call initiate_file_$component (mailing_list_address.mls_dirname, mailing_list_address.mls_ename,
		mailing_list_address.mls_component, R_ACCESS, mls_ptr, mls_bitcount, code);
	     if (code = error_table_$noentry) | (code = error_table_$no_component) then
		code = mlsys_et_$no_mailing_list;
	     if code = 0 then do;			/* it's there and we have access ... */
		mls_lth = divide ((mls_bitcount + 8), 9, 21, 0);
		call mlsys_parse_text_$parse_mailing_list_text (mls_text, P_address_list_version, address_list_ptr,
		     code);
	     end;
	     else address_list_ptr = null ();		/* ... no luck */
	     if mls_ptr ^= null () then call terminate_file_ (mls_ptr, 0, TERM_FILE_TERM, (0));
	     P_address_list_ptr = address_list_ptr;
	     P_code = code;
	end;

	return;



/*  Return "1"b if the supplied address is a list address (ie: either a mailing list or a named group address) */

is_list_address:
     procedure (p_address_ptr) returns (bit (1) aligned);

dcl  p_address_ptr pointer parameter;

	return ((p_address_ptr -> address_header.type = MAILING_LIST_ADDRESS)
	     | (p_address_ptr -> address_header.type = NAMED_GROUP_ADDRESS));

     end is_list_address;
%page;
/* Checks if the supplied address is actually a local address by computing the optimum route to reach said address:  If
   the route shows that the address is local, this entrypoint will convert it into its proper representation */

check_if_actually_local:
     entry (P_address_ptr);

	if P_address_ptr -> address_header.type = FOREIGN_ADDRESS then call check_if_actually_local (P_address_ptr);

	return;



/* Acutally checks if a foreign address is really local (called by several entrypoints) */

check_if_actually_local:
     procedure (p_address_ptr);

dcl  p_address_ptr pointer parameter;

dcl  foreign_local_part character (old_address_ptr -> foreign_address.local_part_lth) unaligned
	based (old_address_ptr -> foreign_address.local_part_ptr);
dcl  new_address_name character (new_address_ptr -> address_header.name_lth) unaligned
	based (new_address_ptr -> address_header.name_ptr);
dcl  new_address_comment character (new_address_ptr -> address_header.comment_lth) unaligned
	based (new_address_ptr -> address_header.comment_ptr);
dcl  (old_address_ptr, new_address_ptr, new_new_address_ptr) pointer;


	old_address_ptr = copy_ptr (p_address_ptr);

	address_route_ptr = null ();			/* not set by following procedure if there were errors */
	call mlsys_address_route_mgr_$compute_optimum_route (old_address_ptr, address_route_ptr, code);

	if (address_route_ptr ^= null ()) | (code ^= 0) then do;
	     if address_route_ptr ^= null () then call mlsys_address_route_mgr_$free_address_route (address_route_ptr);
	     return;				/* got a route or an error: it's really foreign */
	end;

	call mlsys_parse_text_$parse_address_text (foreign_local_part, new_address_ptr, code);
	if code ^= 0 then				/* won't parse: create an invalid address */
	     call create_invalid_address ((foreign_local_part), "", "", new_address_ptr, (0));

	if new_address_ptr -> address_header.type = FOREIGN_ADDRESS then do;
	     /*** New address is still foreign: check again to see if it's really local */
	     call check_if_actually_local (new_address_ptr);
	     if new_address_ptr -> address_header.type = WAS_FOREIGN_ADDRESS then do;
		/*** Eliminate an extra level of indirection: increment the real target's (new_new) reference count
		     now; otherwise, it will be freed when the middle address (new) is freed */
		new_new_address_ptr = new_address_ptr -> was_foreign_address.actual_address_ptr;
		call increment_reference_count (new_new_address_ptr);
		call free_address (new_address_ptr, (0));
		new_address_ptr = new_new_address_ptr;
	     end;
	     else new_new_address_ptr = null ();	/* used as a flag to indicated whether reference count ... */
	end;
	else new_new_address_ptr = null ();		/* ... has already been incremented for the target */

	if old_address_ptr -> foreign_address.free_local_part then free foreign_local_part in (mlsys_area);

	old_address_ptr -> address_header.type = WAS_FOREIGN_ADDRESS;

	old_address_ptr -> was_foreign_address.actual_address_ptr = new_address_ptr;
	if new_new_address_ptr = null () then		/* we didn't increment the target's refcount above ... */
	     call increment_reference_count (new_address_ptr);

	if new_address_ptr -> address_header.free_name then free new_address_name in (mlsys_area);
	if new_address_ptr -> address_header.free_comment then free new_address_comment in (mlsys_area);
						/* the address will use the original name and comment */

	new_address_ptr -> address_header.name = old_address_ptr -> address_header.name;
	new_address_ptr -> address_header.comment = old_address_ptr -> address_header.comment;
	new_address_ptr -> address_header.free_name,	/* the name and comment will be freed (if needed) ... */
	     new_address_ptr -> address_header.free_comment = "0"b;
						/* ... when the original address is freed */

	return;

     end check_if_actually_local;
%page;
/* Verify that the caller supplied a pointer to a mail system address */

verify_address:
     entry (P_address_ptr, P_code) returns (bit (1) aligned);

	return (verify_address (P_address_ptr, P_code));	/* just a transfer to the internal procedure */



/* Actually verify the supplied pointer */

verify_address:
     procedure (p_address_ptr, p_code) returns (bit (1) aligned);

dcl  p_address_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	if p_address_ptr = null () then p_code = mlsys_et_$not_address;

	else if ^mlsys_data_$valid_segments (binary (baseno (p_address_ptr), 18, 0)) then
	     p_code = mlsys_et_$not_address;		/* supplied "address" wasn't allocated by us */

	else if p_address_ptr -> address_header.version ^= ADDRESS_VERSION_2 then p_code = mlsys_et_$not_address;
						/* supplied "address" is some other type of structure */

	else p_code = 0;				/* it's an address */

	return ((p_code = 0));

     end verify_address;



/* Sets the local address_ptr variable from the caller's P_address_ptr parameter */

set_address_ptr:
     procedure ();

	address_ptr = copy_ptr (P_address_ptr);

	if address_header.type = WAS_FOREIGN_ADDRESS then /* bypass this place-holder address */
	     address_ptr = was_foreign_address.actual_address_ptr;

	return;

     end set_address_ptr;
%page;
/* Sets the specified string in an address to the supplied value */

set_address_variable_string:
     procedure (p_input_value, p_address_variable, p_free_address_variable);

dcl  p_input_value character (*) parameter varying;
dcl  1 p_address_variable aligned parameter,
       2 text_ptr pointer,
       2 text_lth fixed binary (21);
dcl  p_free_address_variable bit (1) unaligned parameter;

dcl  address_variable character (p_address_variable.text_lth) unaligned based (p_address_variable.text_ptr);

	if p_input_value = "" then do;		/* nothing supplied here */
	     p_address_variable.text_ptr = addr (NULL_STRING);
	     p_address_variable.text_lth = 0;
	     p_free_address_variable = "0"b;
	end;

	else do;
	     p_address_variable.text_lth = length (p_input_value);
	     allocate address_variable in (mlsys_area) set (p_address_variable.text_ptr);
	     address_variable = p_input_value;
	     p_free_address_variable = "1"b;
	end;

	return;

     end set_address_variable_string;



/* Sets the given output parameter to the supplied string while checking for truncation of the string */

set_output_variable:
     procedure (p_output_value, p_output_parameter, p_code);

dcl  p_output_value character (*) parameter;		/* the value to be returned */
dcl  p_output_parameter character (*) varying parameter;	/* the caller's output parameter */
dcl  p_code fixed binary (35) parameter;

	if length (p_output_value) > maxlength (p_output_parameter) then
	     p_code = error_table_$smallarg;		/* it's too long */

	else do;					/* it fits */
	     p_output_parameter = p_output_value;
	     p_code = 0;
	end;

	return;

     end set_output_variable;
%page;
/* Validates that the given entry name ends in the proper suffix and is also not overlength */

validate_entryname:
     procedure (p_ename, p_suffix, p_actual_ename, p_code) returns (bit (1) aligned);

dcl  (p_ename, p_suffix, p_actual_ename) character (*) parameter;
dcl  p_code fixed binary (35) parameter;

	p_code = 0;				/* assume success */

	if p_suffix ^= "" then			/* caller has a suffix to check ... */
	     if index (reverse (rtrim (p_ename)), reverse (p_suffix)) ^= 1 then p_code = mlsys_et_$incorrect_suffix;

	if p_code = 0 then				/* check length if the suffix is OK */
	     if length (rtrim (p_ename)) > length (p_actual_ename) then p_code = error_table_$entlong;

	return ((p_code = 0));			/* let caller know if it's OK */

     end validate_entryname;
%page;
/* Allocates and initializes an address of the requested type */

initialize_address:
     procedure (p_address_type);

dcl  p_address_type fixed binary parameter;

	go to INITIALIZE_ADDRESS (p_address_type);

INITIALIZE_ADDRESS (0):				/* invalid address */
	allocate invalid_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	invalid_address.text_ptr = addr (NULL_STRING);	/* haven't got the text yet */
	invalid_address.text_lth = 0;
	string (invalid_address.flags) = ""b;		/* nothing to free yet */
	return;

INITIALIZE_USER_MAILBOX_COMMON:			/* shared code for user mailboxes (default/logbox/savebox) */
	call initialize_header ();
	user_address_template.person_id, user_address_template.project_id = "";
	string (user_address_template.flags) = ""b;	/* don't know yet if it's anonymous */
	return;

INITIALIZE_ADDRESS (1):				/* user mailbox address */
	allocate user_mailbox_address in (mlsys_area) set (address_ptr);
	go to INITIALIZE_USER_MAILBOX_COMMON;

INITIALIZE_ADDRESS (2):				/* logbox address */
	allocate logbox_address in (mlsys_area) set (address_ptr);
	go to INITIALIZE_USER_MAILBOX_COMMON;

INITIALIZE_ADDRESS (3):				/* savebox address */
	allocate savebox_address in (mlsys_area) set (address_ptr);
	savebox_address.mbx_dirname, savebox_address.mbx_ename = "";
	go to INITIALIZE_USER_MAILBOX_COMMON;

INITIALIZE_ADDRESS (4):				/* mailbox address */
	allocate mailbox_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	mailbox_address.mbx_dirname, mailbox_address.mbx_ename = "";
	return;

INITIALIZE_ADDRESS (5):				/* forum address */
	allocate forum_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	forum_address.forum_dirname, forum_address.forum_ename = "";
	return;

INITIALIZE_ADDRESS (6):				/* foreign address */
	allocate foreign_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	foreign_address.local_part_ptr = addr (NULL_STRING);
						/* no local part yet */
	foreign_address.local_part_lth = 0;
	foreign_address.foreign_system = "";		/* no system name */
	foreign_address.explicit_route,		/* no explicit/implicit route */
	     foreign_address.implicit_route = null ();
	string (foreign_address.flags) = ""b;		/* nothing to free yet */
	return;

INITIALIZE_ADDRESS (7):				/* mail table address */
	allocate mail_table_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	mail_table_address.mte_name = "";
	return;

INITIALIZE_ADDRESS (8):				/* mailing list address */
	allocate mailing_list_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	mailing_list_address.mls_dirname, mailing_list_address.mls_ename, mailing_list_address.mls_component = "";
	return;

INITIALIZE_ADDRESS (9):				/* named group address */
	allocate named_group_address in (mlsys_area) set (address_ptr);
	call initialize_header ();
	named_group_address.address_list = null ();	/* nothing in the group yet */
	string (named_group_address.flags) = ""b;	/* don't know whether or not to display the addresses */
	return;



/* Internal to initialize_address: initializes the address header */

initialize_header:
	procedure ();

	     address_header.version = ADDRESS_VERSION_2;

	     address_header.type = p_address_type;	/* as requested by the caller */

	     address_header.reference_count = 0;	/* nothing else in the mail system knows about it */

	     address_header.name_ptr = addr (NULL_STRING);/* no name ... */
	     address_header.name_lth = 0;

	     address_header.comment_ptr = addr (NULL_STRING);
	     address_header.comment_lth = 0;		/* ... and no comment */

	     string (address_header.flags) = ""b;	/* nothing to free and it's OK to free it */

	     return;

	end initialize_header;

     end initialize_address;
%page;
%include mlsys_copy_ptr;
%page;
%include mlsys_data;
%page;
%include mlsys_internal_data;
%page;
%include mlsys_address_route;
%page;
%include mlsys_address_list;
%page;
%include access_mode_values;
%page;
%include terminate_file;

     end mlsys_address_mgr_;
