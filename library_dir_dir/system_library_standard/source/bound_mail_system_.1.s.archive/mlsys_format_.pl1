/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1983-07-01,Palter), approve(), audit(), install():
     Pre-hcom comments:
     Created:  July 1983 by G. Palter
     Modified: March 1984 by G. Palter to fix the following mail system errors:
        #0426 -- when formatting an address comment, if the comment has to be quoted, the formatter leaves off the closing
           quote character
        #0434 -- when a message is mailed to a forum, the mail system formats the header using the brief formatting mode.
           As a result, most of the header fields, including user-defined fields, are omitted from the copy in the forum
           making replies, etc. difficult
        #0436 -- if a forum meeting is not found in the "forum" search list, the mail system will treat it as a version 1
           forum in the working directory
  2) change(1987-04-09,Lippard), approve(1986-11-24,MCR7576),
     audit(1987-04-21,Dickson), install(1987-04-26,MR12.1-1026):
     Modified to use time_names.incl.pl1 instead of time_zones_.incl.pl1.
  3) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: off */

/* Mail System Utilities which convert the internal form of various mail system objects (messages, addresses, etc.) into
   their printed representations */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen,^indcomtxt */


mlsys_format_:
     procedure ();

	return;					/* not an entrypoint */


/* Parameters */

dcl  P_fieldname character (*) varying parameter;		/* name of the field being printed */

dcl  P_line_length fixed binary parameter;		/* line length for folding; -1 => no folding */

dcl  P_buffer_ptr pointer parameter;			/* -> user's output buffer for formatting entries */
dcl  P_buffer_size fixed binary (21) parameter;		/* size of user's buffer */
dcl  P_buffer_used fixed binary (21) parameter;		/* amount of said buffer in use at any time (input/output) */

dcl  P_output_switch pointer parameter;			/* -> IOCB on which to print results */

dcl  P_code fixed binary (35) parameter;

dcl  P_message_ptr pointer parameter;			/* *_message, format_message_canonical_form,
						   format_message_for_*, format_canon_redistributed_msg:
						      -> the message to be formatted or printed;
						   *_message_envelope, *_message_header,
						   *_redistributions_list, *_message_body: -> message
						      containing the specified part to be printed/formatted */

dcl  P_format_message_options_ptr pointer parameter;	/* format_message, print_message,
						   format_message_canonical_form: -> options describing how to
						      format the message */

dcl  P_buffer_size_words fixed binary (19) parameter;	/* format_message_for_mailbox, format_canon_redistributed_msg:
						      size of available buffer in words */
dcl  P_buffer_used_words fixed binary (19) parameter;	/* format_message_for_mailbox, format_canon_redistributed_msg:
						      set to # of words occupied by message text and data
						      structures */

dcl  P_original_mf_ptr pointer parameter;		/* format_canon_redistributed_msg: -> mail_format structure of
						      original message */
dcl  P_original_mf_extension_ptr pointer parameter;	/* format_canon_redistributed_msg: -> mf_extension strucutre
						      of original message */

dcl  P_formatting_mode fixed binary parameter;		/* *_message_envelope, *_message_header,
						   *_redistributions_list: controls how the specified part
						      will be printed/formatted */

dcl  P_message_trace_ptr pointer parameter;		/* *_message_trace: -> the message trace to format/print */
dcl  P_format_redistribution_trace bit (1) aligned parameter;
						/* *_message_trace: ON => include "Redistributed-" prefix in
						      the trace field names */

dcl  P_access_class bit (72) aligned parameter;		/* *_access_class_field: the access class to format/print */

dcl  P_address_ptr pointer parameter;			/* *_address_field: -> the address to format/print */

dcl  P_address_list_ptr pointer parameter;		/* *_address_list_field: -> address list to format/print */

dcl  P_date_time fixed binary (71) parameter;		/* *_date_time_field: the date/time to format/print */
dcl  P_include_dow bit (1) aligned parameter;		/* *_date_time_field: ON => include day of week in output */

dcl  P_message_id bit (72) aligned parameter;		/* *_message_id_field: the Message-ID to format/print */

dcl  P_message_references_list_ptr pointer parameter;	/* *_references_list_field: -> the list of references to
						      format/print */

dcl  P_text character (*) parameter;			/* *_text_field: the text to format/print */
dcl  P_multiline_text bit (1) aligned parameter;		/* *_text_field: ON => format the text as a multiline field */

dcl  P_message_body_section_parameter_ptr pointer parameter;/* *_body_section: -> the body section to format/print */

dcl  P_address_string character (*) varying parameter;	/* format_address_for_ism: the actual address on the foreign
						      system to which the message will be sent */
dcl  P_address_route_ptr pointer parameter;		/* format_address_for_ism: -> the route to be used to send the
						      message */
dcl  P_user_name character (*) varying parameter;		/* format_address_for_ism: set to the "user name" to be
						      supplied to the inter-system mailer */
dcl  P_host_name character (*) varying parameter;		/* format_address_for_ism: set to the host name to be supplied
						      to the inter-system mailer */
/**** format: indcomtxt */


/* Local copies of parameters */

dcl  buffer character (buffer_size) unaligned based (buffer_ptr);
dcl  buffer_ptr pointer;
dcl  (buffer_size, buffer_used) fixed binary (21);

dcl  output_switch pointer;

dcl  original_mf_ptr pointer;
dcl  original_mf_extension_ptr pointer;

dcl  code fixed binary (35);


/* Remaining declarations */

dcl  printing bit (1) aligned;			/* ON => print the results; OFF => returns them to caller */

/* format: ^indcomtxt */
dcl  1 ifo aligned,					/* internal formatting options */
       2 buffer_overflow entry () variable,		/* ... procedure to be invoked when output buffer overflows */
       2 line_length fixed binary,			/* ... line length to use for folding (if enabled) */
       2 indentation fixed binary,			/* ... continuation lines are indented by this # of spaces */
       2 flags aligned,
         3 rfc822_format bit (1),			/* ... ON => use RFC822 formatting rules; OFF => use ours */
         3 forum_format bit (1),			/* ... ON => formatting for inclusion in a forum */
         3 include_local_system_name bit (1),		/* ... ON => put local system name on all local addresses */
         3 dont_canonicalize_system_names bit (1),	/* ... ON => don't convert system names to canonical form */
         3 dont_show_logsave bit (1),			/* ... ON => don't use {logbox} / {save path} format */
         3 wrap bit (1),				/* ... ON => fold overly long lines to the requested length */
         3 count_lines bit (1),			/* ... ON => count the # of lines formatted/printed */
         3 include_message_id bit (1),			/* ... ON => always include the Message-ID */
         3 include_trace bit (1),			/* ... ON => always include message/redistribution traces */
         3 reverse_redistributions bit (1),		/* ... ON => put redistributions before envelope/header and
							   in reverse chronological order (newest first) */
         3 use_canonical_fieldnames bit (1),		/* ... ON => use canonical names of cc/bcc fields */
         3 build_mf_extension bit (1),			/* ... ON => construct list of text fragments to be examined
							   by subsequent string searches */
         3 include_forum_suffix bit (1);		/* ... ON => include suffix of forum meeting when formatting
							   addresses as it will have to be parsed later */

dcl  1 mail_format_header aligned like mail_format.header based (mail_format_ptr);
dcl  mail_format_header_lth fixed binary (21);

dcl  original_mf_text character (original_mf_ptr -> mail_format.text_len) unaligned
	based (addr (original_mf_ptr -> mail_format.text));
dcl  new_mf_extension_ptr pointer;

dcl  last_column_used fixed binary;			/* last character of formatted text is in this column */
dcl  line_count fixed binary;				/* # of lines printed/formatted */

dcl  local_buffer character (256);			/* buffer used by the print_* entrypoints */

dcl  full_fieldname character (64) varying;

dcl  need_separator bit (1) aligned;

dcl  (idx, jdx) fixed binary;

/* format: off */
dcl (CANONICAL_BCC_FIELDNAME		initial ("Bcc"),
     CANONICAL_CC_FIELDNAME		initial ("Cc"),
     RESENT_PREFIX			initial ("Resent-"),
     RECIPIENTS_FIELDNAME		initial ("Recipients"),
     COMMENT_FIELDNAME		initial ("Comment"),
     LAST_RESENT_FIELDNAME		initial ("Last-Resent"),
     LAST_REDISTRIBUTED_FIELDNAME	initial ("Last-Redistributed"))
	character (32) varying static options (constant);
/* format: on */

dcl  MAX_MULTILINE_INDENTATION fixed binary static options (constant) initial (15);
dcl  STANDARD_MULTILINE_INDENTATION fixed binary static options (constant) initial (10);
dcl  MULTILINE_BLANK_LINE_DESIGNATOR character (2) static options (constant) initial ("--");

dcl  STACK_EXTENSION fixed binary (18) static options (constant) initial (128);

dcl  FIELDNAME_SUFFIX character (3) static options (constant) initial (":  ");

dcl  SPACES character (32) static options (constant) initial ((32)" ");

dcl  SINGLE_WIDTH_CHARACTERS character (95) static options (constant)
	initial (" !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");

dcl  ONE_MINUTE fixed binary (71) static options (constant) initial (60000000);
dcl  ONE_HOUR fixed binary static options (constant) initial (60);

/* format: off */
dcl (UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
     LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"))
	character (26) static options (constant);

dcl  MONTHS (12) character (12) varying static options (constant) initial (
	"January",     "February",	"March",		"April",		"May",	     "June",
	"July",	     "August",	"September",	"October",	"November",    "December");
dcl  RFC822_MONTHS (12) character (3) static options (constant) initial (
	"Jan",	     "Feb",	"Mar",		"Apr",		"May",	     "Jun",
	"Jul",	     "Aug",	"Sep",		"Oct",		"Nov",	     "Dec");

dcl  DAY_OF_WEEKS (7) character (12) varying static options (constant) initial (
	"Monday",	     "Tuesday",	"Wednesday",	"Thursday",	"Friday",	     "Saturday",    "Sunday");
dcl  RFC822_DAY_OF_WEEKS (7) character (3) static options (constant) initial (
	"Mon",	     "Tue",	"Wed",		"Thu",		"Fri",	     "Sat",	"Sun");

dcl  RFC822_ZONES (35) character (4) static options (constant) initial (
	"GMT",	"UT",	"EST",	"EDT",	"CST",	"CDT",	"MST",	"MDT",	"PST",	"PDT",
	"Z",	"A",	"B",	"C",	"D",	"E",	"F",	"G",	"H",	"I",
	"K",	"L",	"M",	"N",	"O",	"P",	"Q",	"R",	"S",	"T",
	"U",	"V",	"W",	"X",	"Y");
dcl  RFC822_ZONE_OFFSETS (35) fixed binary static options (constant) initial (
	   0,	   0,	-300,	-240,	-360,	-300,	-420,	-360,	-480,	-420,
	   0,	 -60,	-120,	-180,	-240,	-300,	-360,	-420,	-480,	-540,
	-600,	-660,	-720,	  60,	 120,	 180,	 240,	 300,	 360,	 420,
	 480,	 540,	 600,	 660,	 720);
/* format: on */

dcl  time_data_$time_delta fixed binary (71) external;

dcl  sys_info$access_class_ceiling bit (72) aligned external;

dcl  iox_$user_output pointer external;

/* format: off */
dcl  (error_table_$bad_subr_arg, error_table_$inconsistent, error_table_$smallarg, error_table_$unimplemented_version,
      mlsys_et_$foreign_address_too_long, mlsys_et_$not_address_list, mlsys_et_$not_message, mlsys_et_$not_message_trace,
      mlsys_et_$unknown_body_section_type)
	fixed binary (35) external;
/* format: on */

dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  convert_authorization_$to_string_short entry (bit (72) aligned, character (*), fixed binary (35));
dcl  cu_$grow_stack_frame entry (fixed binary (18), pointer, fixed binary (35));
dcl  decode_clock_value_$date_time
	entry (fixed binary (71), fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary,
	fixed binary (71), fixed binary, character (4), fixed binary (35));
dcl  get_authorization_ entry () returns (bit (72) aligned);
dcl  get_line_length_$switch entry (pointer, fixed binary (35)) returns (fixed binary);
dcl  ioa_$rsnnl entry () options (variable);
dcl  iox_$put_chars entry (pointer, pointer, fixed binary (21), fixed binary (35));
dcl  mail_system_$compare_addresses entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mail_system_$decode_message_id
	entry (bit (72) aligned, character (*) varying, character (256) varying, bit (1) aligned, fixed binary (35));
dcl  mail_system_$expand_list_address entry (pointer, character (8), pointer, fixed binary (35));
dcl  mail_system_$get_address_comment entry (pointer, character (*) varying, fixed binary (35));
dcl  mail_system_$get_address_name entry (pointer, character (*) varying, fixed binary (35));
dcl  mail_system_$get_address_pathname entry (pointer, character (*), character (*), character (*), fixed binary (35));
dcl  mail_system_$get_address_route entry (pointer, character (8), pointer, fixed binary (35));
dcl  mail_system_$get_address_string entry (pointer, character (*) varying, fixed binary (35));
dcl  mail_system_$get_address_system entry (pointer, character (256) varying, fixed binary (35));
dcl  mail_system_$get_address_type entry (pointer, fixed binary, fixed binary (35));
dcl  mail_system_$get_named_group_display_flag entry (pointer, bit (1) aligned, fixed binary (35));
dcl  mail_system_$get_user_field_name entry (bit (36) aligned, character (*) varying, fixed binary (35));
dcl  mlsys_misc_utils_$get_best_address_name entry (pointer, character (*) varying, fixed binary (35));
dcl  mlsys_nit_interface_$canonicalize_system_name entry (character (256) varying) returns (character (256) varying);
dcl  mlsys_nit_interface_$get_local_system_name entry () returns (character (256) varying);
dcl  mlsys_nit_interface_$is_local_system entry (character (256) varying) returns (bit (1) aligned);
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  pathname_$component entry (character (*), character (*), character (*)) returns (character (194));

dcl  (abs, addcharno, addr, addwordno, after, binary, bit, clock, convert, currentsize, divide, hbound, index, lbound,
     length, ltrim, max, maxlength, min, mod, null, reverse, rtrim, search, size, string, substr, translate, unspec,
     verify) builtin;
%page;
/* Convert a message into its printed representation */

format_message:					/* ... into the caller's buffer */
     entry (P_message_ptr, P_format_message_options_ptr, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_COMMON;


print_message:					/* ... and print it on the given output switch */
     entry (P_message_ptr, P_format_message_options_ptr, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_COMMON:
	message_ptr = P_message_ptr;
	format_message_options_ptr = P_format_message_options_ptr;

	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	if format_message_options.version ^= FORMAT_MESSAGE_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if (format_message_options.envelope_formatting_mode < NONE_FORMATTING_MODE)
	     | (format_message_options.envelope_formatting_mode > LONG_FORMATTING_MODE)
	     | (format_message_options.envelope_formatting_mode = BRIEF_FORMATTING_MODE)
	     | (format_message_options.header_formatting_mode < NONE_FORMATTING_MODE)
	     | (format_message_options.header_formatting_mode > LONG_FORMATTING_MODE)
	     | (format_message_options.redistributions_list_formatting_mode < NONE_FORMATTING_MODE)
	     | (format_message_options.redistributions_list_formatting_mode > LONG_FORMATTING_MODE) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	if (format_message_options.envelope_formatting_mode = NONE_FORMATTING_MODE)
	     & (format_message_options.header_formatting_mode = NONE_FORMATTING_MODE)
	     & (format_message_options.redistributions_list_formatting_mode = NONE_FORMATTING_MODE)
	     & ^format_message_options.include_body then do;
	     P_code = error_table_$inconsistent;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = format_message_options.line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (format_message_options.line_length = 0) then ;
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	need_separator =
	     (format_message_options.envelope_formatting_mode ^= NONE_FORMATTING_MODE)
	     | (format_message_options.header_formatting_mode ^= NONE_FORMATTING_MODE)
	     | (format_message_options.redistributions_list_formatting_mode ^= NONE_FORMATTING_MODE);

	if format_message_options.envelope_formatting_mode ^= NONE_FORMATTING_MODE then
	     call format_envelope (addr (message.envelope), "0"b, message.date_time_created, message.from,
		format_message_options.envelope_formatting_mode);

	if format_message_options.header_formatting_mode ^= NONE_FORMATTING_MODE then
	     call format_header (format_message_options.header_formatting_mode);

	if format_message_options.redistributions_list_formatting_mode ^= NONE_FORMATTING_MODE then
	     call format_redistributions_list_internal (format_message_options.redistributions_list_formatting_mode);

	if format_message_options.include_body then do;	/* and now the body ... */
	     if need_separator then call add_to_buffer_fixed (NL);
	     call format_body ();
	end;

	if printing then				/* dump the last part */
	     call print_buffer ();
	else P_buffer_used = buffer_used;

	P_code = 0;

	return;
%page;
/* Convert a message into its canonical form:  The canonical form of a message is the text used by the mail system when it
   stores the message in a mailbox */

format_message_canonical_form:
     entry (P_message_ptr, P_format_message_options_ptr, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;	/* simple validity check */
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	format_message_options_ptr = P_format_message_options_ptr;
	if format_message_options.version ^= FORMAT_MESSAGE_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if format_message_options.line_length ^= -1 then do;
	     P_code = error_table_$bad_subr_arg;	/* canonical form is not allowed to have wrapped fields */
	     return;
	end;

	if ((format_message_options.envelope_formatting_mode ^= NONE_FORMATTING_MODE)
	     & (format_message_options.envelope_formatting_mode ^= DEFAULT_FORMATTING_MODE))
	     | ((format_message_options.header_formatting_mode ^= NONE_FORMATTING_MODE)
	     & (format_message_options.header_formatting_mode ^= DEFAULT_FORMATTING_MODE))
	     | ((format_message_options.redistributions_list_formatting_mode ^= NONE_FORMATTING_MODE)
	     & (format_message_options.redistributions_list_formatting_mode ^= DEFAULT_FORMATTING_MODE)) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	if (format_message_options.envelope_formatting_mode = NONE_FORMATTING_MODE)
	     & (format_message_options.header_formatting_mode = NONE_FORMATTING_MODE)
	     & (format_message_options.redistributions_list_formatting_mode = NONE_FORMATTING_MODE)
	     & ^format_message_options.include_body then do;
	     P_code = error_table_$inconsistent;
	     return;
	end;

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	string (ifo.flags) = ""b;			/* standard formatting options, but ... */
	ifo.rfc822_format = "0"b;			/* ... standard Multics format */
	ifo.forum_format = "0"b;			/* ... never suppress anything important */
	ifo.include_message_id = "1"b;		/* ... always include the Message-ID fields */
	ifo.include_trace = "1"b;			/* ... always include the message/redistribution traces */
	ifo.reverse_redistributions = "1"b;		/* ... put redistributions list first */
	ifo.use_canonical_fieldnames = "1"b;		/* ... use the canonical names of the cc/bcc fields */
	ifo.include_forum_suffix = "1"b;		/* ... need to distinguish forum versions later */

	ifo.line_length = -1;			/* ... don't wrap */

	need_separator =
	     (format_message_options.envelope_formatting_mode ^= NONE_FORMATTING_MODE)
	     | (format_message_options.header_formatting_mode ^= NONE_FORMATTING_MODE)
	     | (format_message_options.redistributions_list_formatting_mode ^= NONE_FORMATTING_MODE);

	if format_message_options.redistributions_list_formatting_mode ^= NONE_FORMATTING_MODE then
	     call format_redistributions_list_internal (format_message_options.redistributions_list_formatting_mode);

	if format_message_options.envelope_formatting_mode ^= NONE_FORMATTING_MODE then
	     call format_envelope (addr (message.envelope), "0"b, message.date_time_created, message.from,
		format_message_options.envelope_formatting_mode);

	if format_message_options.header_formatting_mode ^= NONE_FORMATTING_MODE then
	     call format_header (format_message_options.header_formatting_mode);

	if format_message_options.include_body then do;	/* and now the body ... */
	     if need_separator then call add_to_buffer_fixed (NL);
	     call format_body ();
	end;

	P_buffer_used = buffer_used;			/* success */
	P_code = 0;

	return;
%page;
/* Convert a message into the appropriate text and data structures for subsequent delivery to a mailbox:  The text used is
   the canonical form as described in message_format.gi.info; the text is then enclosed in a mail_format structure.  In
   addition, a mf_extension structure is placed after the mail_format; the mf_extension identifies the start and length in
   the text of the message body, subject, any redistribution comments, and any user-defined text fields.  This information
   will be needed in future releases to insure reasonable performance for context searching of the messages in a mailbox
   */

format_message_for_mailbox:
     entry (P_message_ptr, P_buffer_ptr, P_buffer_size_words, P_buffer_used_words, P_code);

	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;	/* a simple validity check */
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	mail_format_ptr, buffer_ptr = P_buffer_ptr;

	buffer_size = 4 * P_buffer_size_words;
	mail_format_header_lth, buffer_used = 4 * currentsize (mail_format_header);
	line_count = 0;

	printing = "0"b;
	output_switch = null ();			/* shouldn't be used, but ... */

	ifo.buffer_overflow = report_smallarg;
	ifo.line_length = -1;			/* don't bother wrapping in a mailbox */

	string (ifo.flags) = ""b;
	ifo.rfc822_format = "0"b;			/* ... standard Multics format */
	ifo.forum_format = "0"b;			/* ... never suppress anything important */
	ifo.dont_show_logsave = "1"b;			/* ... don't use {logbox}/{save PATH} form of addresses */
	ifo.count_lines = "1"b;			/* ... need the line count */
	ifo.include_message_id = "1"b;		/* ... always include the Message-ID fields */
	ifo.include_trace = "1"b;			/* ... always include the message/redistribution traces */
	ifo.reverse_redistributions = "1"b;		/* ... put redistributions list first */
	ifo.use_canonical_fieldnames = "1"b;		/* ... use the canonical names of the cc/bcc fields */
	ifo.build_mf_extension = "1"b;		/* ... record location of fields for string search */
	ifo.include_forum_suffix = "1"b;		/* ... need to distinguish forum versions later */

	mf_extension_n_text_fragments = 1		/** the body */
	     + 1					/** the subject */
	     + message.n_user_fields + message.n_redistributions;
	call cu_$grow_stack_frame (size (mf_extension), mf_extension_ptr, (0));
	mf_extension.n_text_fragments = 0;		/* nothing recorded yet */


/* Create the canonical form of the message */

	call format_redistributions_list_internal (DEFAULT_FORMATTING_MODE);

	call format_envelope (addr (message.envelope), "0"b, message.date_time_created, message.from,
	     DEFAULT_FORMATTING_MODE);

	call format_header (DEFAULT_FORMATTING_MODE);

	call add_to_buffer_fixed (NL);

	call format_body ();

	mail_format.lines = line_count;
	mail_format.text_len = buffer_used - mail_format_header_lth;


/* Add the mf_extension to the buffer */

	if (currentsize (mail_format) + currentsize (mf_extension)) > P_buffer_size_words then call report_smallarg ();

	new_mf_extension_ptr = addwordno (mail_format_ptr, currentsize (mail_format));
	new_mf_extension_ptr -> mf_extension.n_text_fragments = mf_extension.n_text_fragments;
	new_mf_extension_ptr -> mf_extension.text_fragments = mf_extension.text_fragments;

	mf_extension_ptr = new_mf_extension_ptr;	/* switch to the one in the buffer */
	do idx = 1 to mf_extension.n_text_fragments;
	     mf_extension.text_fragments (idx).start = mf_extension.text_fragments (idx).start - mail_format_header_lth;
	end;					/* compensate for the mail_format.header structure */


/* Success */

	P_buffer_used_words = currentsize (mail_format) + currentsize (mf_extension);
	P_code = 0;

	return;
%page;
/* Convert a message into the appropriate text and data structures for subsequent delivery to a mailbox: used only for
   canonical in-mailbox messages which are being redistributed.  This entrypoint will format the new redistribution, add
   Delivery-Date and Delivery-By fields, if needed, and then use the canonical text and mf_extension structures of the
   original message to avoid extra formatting and computation */

format_canon_redistributed_msg:
     entry (P_message_ptr, P_original_mf_ptr, P_original_mf_extension_ptr, P_buffer_ptr, P_buffer_size_words,
	P_buffer_used_words, P_code);

	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;	/* a simple validity check */
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	original_mf_ptr = P_original_mf_ptr;
	original_mf_extension_ptr = P_original_mf_extension_ptr;
	mail_format_ptr, buffer_ptr = P_buffer_ptr;

	buffer_size = 4 * P_buffer_size_words;
	mail_format_header_lth, buffer_used = 4 * currentsize (mail_format_header);
	line_count = 0;

	printing = "0"b;
	output_switch = null ();			/* shouldn't be used, but ... */

	ifo.buffer_overflow = report_smallarg;
	ifo.line_length = -1;			/* don't bother wrapping in a mailbox */

	string (ifo.flags) = ""b;
	ifo.rfc822_format = "0"b;			/* ... standard Multics format */
	ifo.forum_format = "0"b;			/* ... never suppress anything important */
	ifo.dont_show_logsave = "1"b;			/* ... don't use {logbox}/{save PATH} form of addresses */
	ifo.count_lines = "1"b;			/* ... need the line count */
	ifo.include_message_id = "1"b;		/* ... always include the Message-ID fields */
	ifo.include_trace = "1"b;			/* ... always include the message/redistribution traces */
	ifo.reverse_redistributions = "1"b;		/* ... put redistributions list first */
	ifo.use_canonical_fieldnames = "1"b;		/* ... use the canonical names of the cc/bcc fields */
	ifo.build_mf_extension = "1"b;		/* ... record location of fields for string search */
	ifo.include_forum_suffix = "1"b;		/* ... need to distinguish forum versions later */

	mf_extension_n_text_fragments =		/* all prior text fragments plus the new redistribution */
	     original_mf_extension_ptr -> mf_extension.n_text_fragments + 1;
	call cu_$grow_stack_frame (size (mf_extension), mf_extension_ptr, (0));
	mf_extension.n_text_fragments = original_mf_extension_ptr -> mf_extension.n_text_fragments;
	mf_extension.text_fragments = original_mf_extension_ptr -> mf_extension.text_fragments;


/* Format the new redistribution */

	message_redistribution_ptr =
	     addr (message_redistributions_list.redistributions (message_redistributions_list.n_redistributions));
	call format_redistribution (DEFAULT_FORMATTING_MODE);


/* Add Delivery-Date and Delivery-By fields for the original mailing or previous redistribution if they differ from the
   Posted-Date and Sender fields, respectively */

	if message_redistributions_list.n_redistributions > 1 then do;
	     message_redistribution_ptr =		/* look at last redistribution actually in the mailbox */
		addr (message_redistributions_list
		.redistributions (message_redistributions_list.n_redistributions - 1));
	     full_fieldname = REDISTRIBUTED_PREFIX || DATE_TIME_DELIVERED_FIELDNAME;
	     if ^date_time_equal (message_redistribution.date_time_delivered, message_redistribution.date_time_mailed)
		then
		call format_date_time_field_internal (full_fieldname, message_redistribution.date_time_delivered,
		     "0"b, "1"b);
	     full_fieldname = REDISTRIBUTED_PREFIX || DELIVERED_BY_FIELDNAME;
	     if message_redistribution.delivered_by ^= null () then
		call format_address_field_internal (full_fieldname, message_redistribution.delivered_by, "1"b);
	end;

	else do;					/* use the original mailing */
	     if ^date_time_equal (message.date_time_delivered, message.date_time_mailed) then
		call format_date_time_field_internal (DATE_TIME_DELIVERED_FIELDNAME, message.date_time_delivered,
		     "0"b, "1"b);
	     if message.delivered_by ^= null () then	/* ... guarenteed non-null only if not equal to Sender */
		call format_address_field_internal (DELIVERED_BY_FIELDNAME, message.delivered_by, "1"b);
	end;


/* Relocate the text fragments of the original message to compensate for the text just added above */

	do idx = 1 to original_mf_extension_ptr -> mf_extension.n_text_fragments;
	     mf_extension.text_fragments (idx).start = mf_extension.text_fragments (idx).start + buffer_used;
	end;


/* Add the canonical form of the original message */

	call add_to_buffer_fixed (original_mf_text);

	mail_format.lines = line_count;
	mail_format.text_len = buffer_used - mail_format_header_lth;


/* Add the mf_extension to the buffer */

	if (currentsize (mail_format) + currentsize (mf_extension)) > P_buffer_size_words then call report_smallarg ();

	new_mf_extension_ptr = addwordno (mail_format_ptr, currentsize (mail_format));
	new_mf_extension_ptr -> mf_extension.n_text_fragments = mf_extension.n_text_fragments;
	new_mf_extension_ptr -> mf_extension.text_fragments = mf_extension.text_fragments;

	mf_extension_ptr = new_mf_extension_ptr;	/* switch to the one in the buffer */
	do idx = 1 to mf_extension.n_text_fragments;
	     mf_extension.text_fragments (idx).start = mf_extension.text_fragments (idx).start - mail_format_header_lth;
	end;					/* compensate for the mail_format.header structure */


/* Success */

	P_buffer_used_words = currentsize (mail_format) + currentsize (mf_extension);
	P_code = 0;

	return;
%page;
/* Convert a message into the appropriate text for subsequent delivery to a forum meeting or foreign address */

format_message_for_forum:				/* ... for delivery to a forum meeting */
     entry (P_message_ptr, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	string (ifo.flags) = ""b;			/* setup entry-specific flags ... */
	ifo.rfc822_format = "0"b;			/* ... standard Multics format */
	ifo.forum_format = "1"b;			/* ... exclude Date/From if redundant */
	ifo.include_message_id, ifo.include_trace = "0"b; /* ... never include Message-ID or message traces */

	go to FORMAT_MESSAGE_FOR_FORUM_OR_NETWORK;


format_message_for_rfc822_network:			/* ... for delivery to a foreign user */
     entry (P_message_ptr, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	string (ifo.flags) = ""b;			/* setup entry-specific flags ... */
	ifo.rfc822_format = "1"b;			/* ... ARPA network standard format */
	ifo.forum_format = "0"b;			/* ... never suppress anything important */
	ifo.include_local_system_name = "1"b;		/* ... all addresses must have host names */
	ifo.dont_canonicalize_system_names = "1"b;	/* ... all system names must be fully qualified */
	ifo.include_message_id = "1"b;		/* ... always include Mesage-ID fields */
	ifo.include_trace = "0"b;			/* ... never include message/redistribution traces */
	ifo.include_forum_suffix = "1"b;		/* ... need to distinguish forum versions later */


FORMAT_MESSAGE_FOR_FORUM_OR_NETWORK:
	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = 0;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	ifo.line_length = 72;			/* wrap the header */
	ifo.wrap = "1"b;

	ifo.dont_show_logsave = "1"b;			/* don't use {logbox}/{save PATH} form of addresses */

	if ^ifo.forum_format then			/* no envelope for forum meetings */
	     call format_envelope (addr (message.envelope), "0"b, message.date_time_created, message.from,
		DEFAULT_FORMATTING_MODE);

	call format_header (DEFAULT_FORMATTING_MODE);

	call format_redistributions_list_internal (DEFAULT_FORMATTING_MODE);

	call add_to_buffer_fixed (NL);		/* separator before the body */

	call format_body ();

	P_buffer_used = buffer_used;			/* tell the caller what was formatted */

	P_code = 0;

	return;
%page;
/* Convert the envelope of a given message into its printed representation */

format_message_envelope:				/* ... into the caller's buffer */
     entry (P_message_ptr, P_formatting_mode, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_ENVELOPE_COMMON;


print_message_envelope:				/* ... and print it on the given output switch */
     entry (P_message_ptr, P_formatting_mode, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_ENVELOPE_COMMON:
	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	if (P_formatting_mode ^= DEFAULT_FORMATTING_MODE) & (P_formatting_mode ^= LONG_FORMATTING_MODE) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_envelope (addr (message.envelope), "0"b, message.date_time_created, message.from, P_formatting_mode)
	     ;

	if printing then				/* dump the last part */
	     call print_buffer ();
	else P_buffer_used = buffer_used;

	P_code = 0;

	return;
%page;
/* Convert the header of a given message into its printed representation */

format_message_header:				/* ... into the caller's buffer */
     entry (P_message_ptr, P_formatting_mode, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_HEADER_COMMON;


print_message_header:				/* ... and print it on the given output switch */
     entry (P_message_ptr, P_formatting_mode, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_HEADER_COMMON:
	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	if (P_formatting_mode < BRIEF_FORMATTING_MODE) | (P_formatting_mode > LONG_FORMATTING_MODE) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_header (P_formatting_mode);

	if printing then				/* dump the last part */
	     call print_buffer ();
	else P_buffer_used = buffer_used;

	P_code = 0;

	return;
%page;
/* Convert the redistributions list of a given message into its printed representation */

format_redistributions_list:				/* ... into the caller's buffer */
     entry (P_message_ptr, P_formatting_mode, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_REDISTRIBUTIONS_LIST_COMMON;


print_redistributions_list:				/* ... and print it on the given output switch */
     entry (P_message_ptr, P_formatting_mode, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_REDISTRIBUTIONS_LIST_COMMON:
	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	if (P_formatting_mode < BRIEF_FORMATTING_MODE) | (P_formatting_mode > LONG_FORMATTING_MODE) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_redistributions_list_internal (P_formatting_mode);

	if printing then				/* dump the last part */
	     call print_buffer ();
	else P_buffer_used = buffer_used;

	P_code = 0;

	return;
%page;
/* Convert the body of a given message into its printed representation */

format_message_body:				/* ... into the caller's buffer */
     entry (P_message_ptr, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_BODY_COMMON;


print_message_body:					/* ... and print it on the given output switch */
     entry (P_message_ptr, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_BODY_COMMON:
	message_ptr = P_message_ptr;
	if message.version ^= MESSAGE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_body ();

	if printing then				/* dump the last part */
	     call print_buffer ();
	else P_buffer_used = buffer_used;

	P_code = 0;

	return;
%page;
/* Convert the given message trace into its printed representation */

format_message_trace:				/* ... into the caller's buffer */
     entry (P_message_trace_ptr, P_format_redistribution_trace, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used,
	P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_TRACE_COMMON;


print_message_trace:				/* ... and print it on the given output switch */
     entry (P_message_trace_ptr, P_format_redistribution_trace, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_TRACE_COMMON:
	message_trace_ptr = P_message_trace_ptr;
	if message_trace.version ^= MESSAGE_TRACE_VERSION_2 then do;
	     P_code = mlsys_et_$not_message_trace;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_trace (message_trace_ptr, P_format_redistribution_trace);

	if printing then				/* dump the last part */
	     call print_buffer ();
	else P_buffer_used = buffer_used;

	P_code = 0;

	return;
%page;
/* Convert an AIM access class field into its printed representation */

format_access_class_field:				/* ... into the caller's buffer */
     entry (P_fieldname, P_access_class, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_ACCESS_CLASS_FIELD_COMMON;


print_access_class_field:				/* ... and print it on the given switch */
     entry (P_fieldname, P_access_class, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_ACCESS_CLASS_FIELD_COMMON:
	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_access_class_field_internal (P_fieldname, P_access_class, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats an access class field (called by several entrypoints) */

format_access_class_field_internal:
     procedure (p_fieldname, p_access_class, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_access_class bit (72) aligned parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	call format_access_class (p_access_class);

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_access_class_field_internal;
%page;
/* Convert an address field into its printed representation */

format_address_field:				/* ... into the caller's buffer */
     entry (P_fieldname, P_address_ptr, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_ADDRESS_FIELD_COMMON;


print_address_field:				/* ... and print it on the given switch */
     entry (P_fieldname, P_address_ptr, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_ADDRESS_FIELD_COMMON:
	call mail_system_$get_address_type (P_address_ptr, (0), code);
	if code ^= 0 then do;			/* not a valid address */
	     P_code = code;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_address_field_internal (P_fieldname, P_address_ptr, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats an address field (called by several entrypoints) */

format_address_field_internal:
     procedure (p_fieldname, p_address_ptr, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_address_ptr pointer parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	call format_address (p_address_ptr, "");

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_address_field_internal;
%page;
/* Convert an address list field into its printed representation */

format_address_list_field:				/* ... into the caller's buffer */
     entry (P_fieldname, P_address_list_ptr, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_ADDRESS_LIST_FIELD_COMMON;


print_address_list_field:				/* ... and print it on the given switch */
     entry (P_fieldname, P_address_list_ptr, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_ADDRESS_LIST_FIELD_COMMON:
	if P_address_list_ptr -> address_list.version ^= ADDRESS_LIST_VERSION_2 then do;
	     P_code = mlsys_et_$not_address_list;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_address_list_field_internal (P_fieldname, P_address_list_ptr, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats an address list field (called by several entrypoints) */

format_address_list_field_internal:
     procedure (p_fieldname, p_address_list_ptr, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_address_list_ptr pointer parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	call format_address_list (p_address_list_ptr);

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_address_list_field_internal;
%page;
/* Convert a date/time field into its printed representation */

format_date_time_field:				/* ... into the caller's buffer */
     entry (P_fieldname, P_date_time, P_include_dow, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_DATE_TIME_FIELD_COMMON;


print_date_time_field:				/* ... and print it on the given switch */
     entry (P_fieldname, P_date_time, P_include_dow, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_DATE_TIME_FIELD_COMMON:
	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_date_time_field_internal (P_fieldname, P_date_time, P_include_dow, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats a date/time field (called by several entrypoints) */

format_date_time_field_internal:
     procedure (p_fieldname, p_date_time, p_include_dow, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_date_time fixed binary (71) parameter;
dcl  p_include_dow bit (1) aligned parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	call format_date_time (p_date_time, p_include_dow);

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_date_time_field_internal;
%page;
/* Convert a Message-ID field into its printed representation */

format_message_id_field:				/* ... into the caller's buffer */
     entry (P_fieldname, P_message_id, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_MESSAGE_ID_FIELD_COMMON;


print_message_id_field:				/* ... and print it on the given switch */
     entry (P_fieldname, P_message_id, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_MESSAGE_ID_FIELD_COMMON:
	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_message_id_field_internal (P_fieldname, P_message_id, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats a Message-ID field (called by several entrypoints) */

format_message_id_field_internal:
     procedure (p_fieldname, p_message_id, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_message_id bit (72) aligned parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	call format_message_id (p_message_id);

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_message_id_field_internal;
%page;
/* Convert a header/envelope/redistribution field which is a list of message references into its printed representation */

format_references_list_field:				/* ... into the caller's buffer */
     entry (P_fieldname, P_message_references_list_ptr, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code)
	;

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_REFERENCES_LIST_FIELD_COMMON;


print_references_list_field:				/* ... and print it on the given switch */
     entry (P_fieldname, P_message_references_list_ptr, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_REFERENCES_LIST_FIELD_COMMON:
	if P_message_references_list_ptr -> message_references_list.version ^= MESSAGE_REFERENCES_LIST_VERSION_2
	then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_references_list_field_internal (P_fieldname, P_message_references_list_ptr, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats a field which is a list of message references (called by several entrypoints) */

format_references_list_field_internal:
     procedure (p_fieldname, p_message_references_list_ptr, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_message_references_list_ptr pointer parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	call format_references_list (p_message_references_list_ptr);

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_references_list_field_internal;
%page;
/* Convert a text field into its printed representation */

format_text_field:					/* ... into the caller's buffer */
     entry (P_fieldname, P_text, P_multiline_text, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_TEXT_FIELD_COMMON;


print_text_field:					/* ... and print it on the given switch */
     entry (P_fieldname, P_text, P_multiline_text, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_TEXT_FIELD_COMMON:
	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);

	call format_text_field_internal (P_fieldname, P_text, P_multiline_text, printing);

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	P_code = 0;				/* success */

	return;



/* Actually formats a text field (called by several entrypoints) */

format_text_field_internal:
     procedure (p_fieldname, p_text, p_multiline_text, p_add_trailing_NL);

dcl  p_fieldname character (*) varying parameter;
dcl  p_text character (*) parameter;
dcl  p_multiline_text bit (1) aligned parameter;
dcl  p_add_trailing_NL bit (1) aligned parameter;

	last_column_used = 0;			/* nothing printed/formatted yet */

	if length (p_fieldname) > 0 then do;		/* a non-blank fieldname should be output first */
	     call add_to_buffer_varying (p_fieldname);
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	end;

	ifo.indentation = last_column_used;		/* indent additional lines by this amount */

	if ifo.build_mf_extension then do;		/* subsequent string searches will examine this field ... */
	     mf_extension.n_text_fragments = mf_extension.n_text_fragments + 1;
	     mf_extension.text_fragments (mf_extension.n_text_fragments).start = buffer_used + 1;
	end;

	call format_text (p_text, p_multiline_text);

	if ifo.build_mf_extension then		/* also record the field's length */
	     mf_extension.text_fragments (mf_extension.n_text_fragments).lth =
		buffer_used - mf_extension.text_fragments (mf_extension.n_text_fragments).start + 1;

	if p_add_trailing_NL then call add_to_buffer_fixed (NL);

	return;

     end format_text_field_internal;
%page;
/* Convert a section of the message body into its printed representation */

format_body_section:				/* ... into the caller's buffer */
     entry (P_message_body_section_parameter_ptr, P_line_length, P_buffer_ptr, P_buffer_size, P_buffer_used, P_code);

	buffer_ptr = P_buffer_ptr;			/* use the caller's buffer */
	buffer_size = P_buffer_size;
	buffer_used = P_buffer_used;

	printing = "0"b;
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_smallarg;

	go to FORMAT_BODY_SECTION_COMMON;


print_body_section:					/* ... and print it on the given switch */
     entry (P_message_body_section_parameter_ptr, P_line_length, P_output_switch, P_code);

	buffer_ptr = addr (local_buffer);		/* format it into our automatic buffer */
	buffer_size = length (local_buffer);
	buffer_used = 0;

	printing = "1"b;				/* need to know this when we're done formatting */
	output_switch = P_output_switch;
	if output_switch = null () then output_switch = iox_$user_output;

	ifo.buffer_overflow = print_buffer;


FORMAT_BODY_SECTION_COMMON:
	message_body_section_parameter_ptr = P_message_body_section_parameter_ptr;
	if message_body_section_parameter.version ^= MESSAGE_BODY_SECTION_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;
	if (message_body_section_parameter.section_type < MESSAGE_PREFORMATTED_BODY_SECTION)
	     | (message_body_section_parameter.section_type > MESSAGE_BIT_STRING_BODY_SECTION) then do;
	     P_code = mlsys_et_$unknown_body_section_type;
	     return;
	end;

	string (ifo.flags) = ""b;			/* standard formatting options */

	ifo.line_length = P_line_length;

	if printing & (ifo.line_length = 0) then	/* default to line length of the output switch */
	     ifo.line_length = get_line_length_$switch (output_switch, (0));

	if printing & (P_line_length = 0) then ;	/* don't check line length if we set it */
	else if (ifo.line_length ^= -1) & (ifo.line_length ^> 30) then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	ifo.wrap = (ifo.line_length ^= -1);
	ifo.count_lines = "1"b;			/* we need to return the line count */
	line_count = 0;

	call format_body_section_internal (addr (message_body_section_parameter.section));

	if printing then				/* make sure the last part gets out to the switch */
	     call print_buffer ();
	else P_buffer_used = buffer_used;		/* reflect what's been used to the caller */

	message_body_section_parameter.section.section_n_lines = line_count;

	P_code = 0;				/* success */

	return;
%page;
/* format: ^indcomtxt */
/* Formats an address for use by the interim inter-system mailer (mlsys_mailer_):  The format used by mlsys_mailer_ is a
   variant of the Multics standard format for a local address.  In particular, RFC822 quoting is used and the keywords
   "at" and "via" are both replaced by commerical at-signs (@).  In addition, the formatted address is broken into two
   parts -- the "user name" and "host name".  The "user name" consists of the actual foreign address and, if any relay
   systems are needed to send the message, the name of the foreign system and all but the first relay system.  The "host
   name" is either the name of the foreign system if there are no relays or the name of the first relay system.  For
   example, the address:
	GMP at MIT-MC via MIT-MULTICS.ARPA via CISL-SERVICE-MULTICS.ARPA
   is formatted for mlsys_mailer_ as:
	GMP@MIT-MC@MIT-MULTICS.ARPA   and   CISL-SERVICE-MULTICS.ARPA */
/* format: indcomtxt */

format_address_for_ism:
     entry (P_address_string, P_address_route_ptr, P_user_name, P_host_name, P_code);

	printing = "0"b;				/* formatting data to be returned to the caller */
	output_switch = null ();			/* shouldn't get used, but ... */

	ifo.buffer_overflow = report_foreign_address_too_long;
	ifo.line_length = -1;			/* don't wrap */
	ifo.indentation = 0;
	string (ifo.flags) = ""b;			/* setup entry-specific flags ... */
	ifo.rfc822_format = "1"b;			/* ... ARPA network standard format */

	address_route_ptr = P_address_route_ptr;

	begin;
dcl  user_name_buffer character (maxlength (P_user_name));
dcl  host_name_buffer character (maxlength (P_host_name));

	     /*** Format the "user name" */
	     buffer_ptr = addr (user_name_buffer);
	     buffer_size = length (user_name_buffer);
	     buffer_used = 0;			/* nothing in it yet */
	     call format_top_level_string (P_address_string);
						/* the actual address on the foreign system ... */
	     do idx = address_route.n_relays to 2 by -1;
		/*** ... plus the names of all but the first relay system */
		call add_to_buffer_fixed (ATSIGN);
		call format_top_level_string (address_route.relays (idx));
	     end;
	     P_user_name = substr (user_name_buffer, 1, buffer_used);

	     /*** Format the "host name" */
	     buffer_ptr = addr (host_name_buffer);
	     buffer_size = length (host_name_buffer);
	     buffer_used = 0;
	     call format_top_level_string (address_route.relays (1));
	     P_host_name = substr (host_name_buffer, 1, buffer_used);
	end;

	P_code = 0;				/* can only get here if OK */

	return;
%page;
/* Format/print the contents of a message/redistribution envelope */

format_envelope:
     procedure (p_envelope_ptr, p_is_redistribution, p_date_time_created, p_from, p_formatting_mode);

dcl  p_envelope_ptr pointer parameter;
dcl  p_is_redistribution bit (1) aligned parameter;
dcl  p_date_time_created fixed binary (71) parameter;
dcl  p_from pointer parameter;
dcl  p_formatting_mode fixed binary parameter;

dcl  1 p_envelope aligned based (p_envelope_ptr) like message_envelope;

dcl  (delivered_by, sender) pointer;
dcl  full_fieldname character (64) varying;
dcl  fieldname_prefix character (32) varying;
dcl  (sender_is_different, delivered_by_is_different) bit (1) aligned;


	if p_envelope.date_time_mailed = 0 then		/* can't display the envelope if it has never been mailed */
	     return;

	if p_is_redistribution then			/* setup fieldname prefix */
	     if ifo.rfc822_format then
		fieldname_prefix = RESENT_PREFIX;
	     else fieldname_prefix = REDISTRIBUTED_PREFIX;
	else fieldname_prefix = "";

	sender = p_envelope.sender;			/* get a value for the Sender field */
	if sender = null () then do;			/* ... From field is guarenteed to have 1 address */
	     sender = p_from -> address_list.addresses (1);
	     sender_is_different = "0"b;
	end;
	else if p_from -> address_list.n_addresses = 1	/* Sender and From field may be identical */
	     then
	     sender_is_different = ^mail_system_$compare_addresses (sender, p_from -> address_list.addresses (1), (0));
	else sender_is_different = "1"b;		/* multiple authors */

	delivered_by = p_envelope.delivered_by;		/* get a value for the Delivery-By field */
	if delivered_by = null () then do;
	     delivered_by = sender;
	     delivered_by_is_different = "0"b;
	end;
	else delivered_by_is_different = ^mail_system_$compare_addresses (delivered_by, sender, (0));

	full_fieldname = fieldname_prefix || DATE_TIME_DELIVERED_FIELDNAME;
	if p_envelope.date_time_delivered > 0 then	/* it's been delivered ... */
	     if (p_formatting_mode = LONG_FORMATTING_MODE)
		| ^date_time_equal (p_envelope.date_time_delivered, p_envelope.date_time_mailed) then
		call format_date_time_field_internal (full_fieldname, p_envelope.date_time_delivered, "0"b, "1"b);

	full_fieldname = fieldname_prefix || DELIVERED_BY_FIELDNAME;
	if (p_formatting_mode = LONG_FORMATTING_MODE) | delivered_by_is_different then
	     call format_address_field_internal (full_fieldname, delivered_by, "1"b);

	full_fieldname = fieldname_prefix || DATE_TIME_MAILED_FIELDNAME;
	if (p_formatting_mode = LONG_FORMATTING_MODE)
	     | ^date_time_equal (p_envelope.date_time_mailed, p_date_time_created) then
	     call format_date_time_field_internal (full_fieldname, p_envelope.date_time_mailed, "0"b, "1"b);

	full_fieldname = fieldname_prefix || SENDER_FIELDNAME;
	if (p_formatting_mode = LONG_FORMATTING_MODE) | sender_is_different then
	     call format_address_field_internal (full_fieldname, sender, "1"b);

	if (ifo.include_trace | (p_formatting_mode = LONG_FORMATTING_MODE)) & (p_envelope.trace ^= null ()) then
	     call format_trace (p_envelope.trace, p_is_redistribution);

	full_fieldname = fieldname_prefix || ACKNOWLEDGE_TO_FIELDNAME;
	if p_envelope.acknowledge_to ^= null () then	/* only if it's present */
	     call format_address_field_internal (full_fieldname, p_envelope.acknowledge_to, "1"b);

	return;

     end format_envelope;
%page;
/* Actually format the header of a message (called by several entrypoints):  Contrary to the documentation, the Date and
   From fields can be ommitted from the printed representation; however, this only occurs when formatting a new message as
   a new message's Date field is not available to the caller to avoid problems with "qedx -header" like uses of the
   printed representation and the From field is empty unless the user has set it to a non-default value as the default is
   supplied at message delivery time */

format_header:
     procedure (p_formatting_mode);

dcl  p_formatting_mode fixed binary parameter;

dcl  user_fieldname character (256) varying;		/* should be big enough for any conceivable field name */
dcl  value_picture picture "-----------9v";
dcl  six_digits_picture picture "zzzzz9";
dcl  user_is_recipient bit (1) aligned;
dcl  (n_recipients, idx) fixed binary;


	if message.date_time_created > 0 then		/* there's a Date field ... */
	     if ifo.forum_format & date_time_equal (message.date_time_created, clock ()) then
		;				/* ... but not if the same as what forum will display */
	     else call format_date_time_field_internal (DATE_TIME_CREATED_FIELDNAME, message.date_time_created, "1"b,
		     "1"b);

	if message.from ^= null () then		/* always show the From it it's not empty ... */
	     if message.from -> address_list.n_addresses > 0 then
		if ifo.forum_format & (message.from -> address_list.n_addresses = 1) then
		     if mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address,
			message.from -> address_list.addresses (1), (0))
			|
			mail_system_$compare_addresses (mlsys_data_$user_mail_table_address,
			message.from -> address_list.addresses (1), (0)) then
			;			/* ... unless it's the same as what forum will display */
		     else call format_address_list_field_internal (FROM_FIELDNAME, message.from, "1"b);
		else call format_address_list_field_internal (FROM_FIELDNAME, message.from, "1"b);

	if ^ifo.forum_format & (message.subject.text_lth > 0) then
						/* always show Subject if present and not going to a forum */
	     call format_text_field_internal (SUBJECT_FIELDNAME, message_subject, "0"b, "1"b);

	if p_formatting_mode > BRIEF_FORMATTING_MODE then
	     if message.reply_to ^= null () then	/* only display the Reply-To field if not -brief_header */
		if message.reply_to -> address_list.n_addresses > 0 then
		     call format_address_list_field_internal (REPLY_TO_FIELDNAME, message.reply_to, "1"b);

	if p_formatting_mode > BRIEF_FORMATTING_MODE then
	     if message.to ^= null () then		/* only display the To field if not -brief_header */
		if message.to -> address_list.n_addresses > 0 then
		     call format_address_list_field_internal (TO_FIELDNAME, message.to, "1"b);

	if p_formatting_mode > BRIEF_FORMATTING_MODE then
	     if message.cc ^= null () then		/* only display the cc field if not -brief_header */
		if message.cc -> address_list.n_addresses > 0 then
		     if ifo.use_canonical_fieldnames then
			call format_address_list_field_internal (CANONICAL_CC_FIELDNAME, message.cc, "1"b);
		     else call format_address_list_field_internal (CC_FIELDNAME, message.cc, "1"b);

	if p_formatting_mode > BRIEF_FORMATTING_MODE then
	     if message.bcc ^= null () then		/* only display the bcc field if not -brief_header */
		if message.bcc -> address_list.n_addresses > 0 then
		     if ifo.use_canonical_fieldnames then
			call format_address_list_field_internal (CANONICAL_BCC_FIELDNAME, message.bcc, "1"b);
		     else call format_address_list_field_internal (BCC_FIELDNAME, message.bcc, "1"b);

	if p_formatting_mode = BRIEF_FORMATTING_MODE then do;
	     /*** Check for multiple recipients and/or the user not being the recipient */
	     user_is_recipient = "0"b;
	     n_recipients = 0;
	     do address_list_ptr = message.to, message.cc, message.bcc;
		if address_list_ptr ^= null () then do; /* ... there are some addresses on this list */
		     n_recipients = n_recipients + address_list.n_addresses;
		     do idx = 1 to address_list.n_addresses while (^user_is_recipient);
			if mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address,
			     address_list.addresses (idx), (0)) then
			     user_is_recipient = "1"b;
			else if
			     mail_system_$compare_addresses (mlsys_data_$user_mail_table_address,
			     address_list.addresses (idx), (0)) then
			     user_is_recipient = "1"b;
		     end;
		end;
	     end;
	     if (^user_is_recipient & (n_recipients > 0)) | (n_recipients > 1) then do;
		call add_to_buffer_varying (RECIPIENTS_FIELDNAME);
		call add_to_buffer_fixed (FIELDNAME_SUFFIX);
		if user_is_recipient then do;		/* must be others beside this person */
		     call add_to_buffer_fixed ("Yourself and ");
		     n_recipients = n_recipients - 1;	/* ... don't count ourselves twice */
		end;
		call add_to_buffer_fixed (ltrim (convert (six_digits_picture, n_recipients)));
		if n_recipients = 1 then
		     call add_to_buffer_fixed (" other");
		else call add_to_buffer_fixed (" others");
		call add_to_buffer_fixed (NL);
	     end;
	end;

	if p_formatting_mode > BRIEF_FORMATTING_MODE then
	     if message.reply_references ^= null () then	/* include the In-Reply-To field only if not -brief_header */
		if message.reply_references -> message_references_list.n_references > 0 then
		     call format_references_list_field_internal (REPLY_REFERENCES_FIELDNAME, message.reply_references,
			"1"b);

	if (p_formatting_mode = LONG_FORMATTING_MODE)
	     | ((p_formatting_mode = DEFAULT_FORMATTING_MODE)
	     & ^aim_check_$equal (message.access_class, get_authorization_ ())) then
	     call format_access_class_field_internal (ACCESS_CLASS_FIELDNAME, message.access_class, "1"b);

	if ifo.include_message_id | (p_formatting_mode = LONG_FORMATTING_MODE) then
						/* always display Message-ID when asked or in long form ... */
	     if message.message_id ^= ""b then		/* ... but not for new messages (they don't have one) */
		call format_message_id_field_internal (MESSAGE_ID_FIELDNAME, message.message_id, "1"b);

	/*** Finally, process the user-defined fields */
	if p_formatting_mode > BRIEF_FORMATTING_MODE then /* ... but only if not -brief_header */
	     if message.user_fields_list ^= null () then do;
		do idx = 1 to message_user_fields_list.n_user_fields;
		     message_user_field_ptr = addr (message_user_fields_list.user_fields (idx));
		     call mail_system_$get_user_field_name (message_user_field.field_id, user_fieldname, code);
		     if code = 0 then do;		/* ... I'd be real suprised if it isn't */
			if message_user_field.field_type = MESSAGE_TEXT_USER_FIELD then do;
			     if (message_text_user_field.text_ptr ^= null ())
				& (message_text_user_field.text_lth ^= 0) then
				call format_text_field_internal (user_fieldname, message_text_user_field_text,
				     (message_text_user_field.multiline_text), "1"b);
			end;
			else if message_user_field.field_type = MESSAGE_ADDRESS_LIST_USER_FIELD then do;
			     if message_address_list_user_field.address_list_ptr ^= null () then
				if message_address_list_user_field.address_list_ptr -> address_list.n_addresses
				     > 0 then
				     call format_address_list_field_internal (user_fieldname,
					message_address_list_user_field.address_list_ptr, "1"b);
			end;
			else if message_user_field.field_type = MESSAGE_DATE_USER_FIELD then do;
			     call format_date_time_field_internal (user_fieldname,
				message_date_user_field.date_time, "0"b, "1"b);
			end;
			else /*** if message_user_field.field_type = MESSAGE_INTEGER_USER_FIELD then */
			     do;
			     call add_to_buffer_varying (user_fieldname);
			     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
			     call add_to_buffer_fixed (
				ltrim (convert (value_picture, message_integer_user_field.value)));
			     call add_to_buffer_fixed (NL);
			end;
		     end;
		end;
	     end;

	return;

     end format_header;
%page;
/* Actually formats the redistributions list of a message (called by several entrypoints) */

format_redistributions_list_internal:
     procedure (p_formatting_mode);

dcl  p_formatting_mode fixed binary parameter;
dcl  (first_idx, last_idx, idx_increment, idx) fixed binary;

	if message.redistributions_list = null () then return;

	if ifo.reverse_redistributions then do;		/* format most recent redistribution first */
	     first_idx = message_redistributions_list.n_redistributions;
	     last_idx = 1;
	     idx_increment = -1;
	end;
	else do;					/* format oldest redistribution first */
	     first_idx = 1;
	     last_idx = message_redistributions_list.n_redistributions;
	     idx_increment = 1;
	end;

	if ifo.reverse_redistributions then		/* display Last-Redistributed field at very top */
	     call format_last_redistributed_if_needed ();

	do idx = first_idx to last_idx by idx_increment;
	     message_redistribution_ptr = addr (message_redistributions_list.redistributions (idx));
	     if (p_formatting_mode > BRIEF_FORMATTING_MODE) | (message_redistribution.comment.text_lth > 0) then
		call format_redistribution (p_formatting_mode);
	end;					/* only if there's a comment when brief ... */

	if ^ifo.reverse_redistributions then		/* display Last-Redistributed at the end if chronological */
	     call format_last_redistributed_if_needed ();

	return;



/* Internal to format_redistributions_list_internal: includes a "Last-Redistributed" field if the last redistributions
   does not have a comment and brief formatting is in effect */

format_last_redistributed_if_needed:
	procedure ();

	     if (p_formatting_mode ^= BRIEF_FORMATTING_MODE) | (message_redistributions_list.n_redistributions = 0) then
		return;

	     message_redistribution_ptr =
		addr (message_redistributions_list.redistributions (message_redistributions_list.n_redistributions));

	     if message_redistribution.comment.text_lth = 0 then do;
		last_column_used = 0;		/* starting a new line of output here ... */
		if ifo.rfc822_format then
		     call add_to_buffer_varying (LAST_RESENT_FIELDNAME);
		else call add_to_buffer_varying (LAST_REDISTRIBUTED_FIELDNAME);
		call add_to_buffer_fixed (FIELDNAME_SUFFIX);
		ifo.indentation = last_column_used;	/* ... and we need to know where to indent things */
		call format_date_time (message_redistribution.date_time_created, "0"b);
		call add_to_buffer_fixed (" by ");
		call format_address_list (message_redistribution.from);
		call add_to_buffer_fixed (NL);
	     end;

	     return;

	end format_last_redistributed_if_needed;

     end format_redistributions_list_internal;
%page;
/* Actually formats the body of a message (called by several entrypoints) */

format_body:
     procedure ();

dcl  idx fixed binary;

	if ifo.build_mf_extension then do;		/* subsequent string searches will examine the body ... */
	     mf_extension.n_text_fragments = mf_extension.n_text_fragments + 1;
	     mf_extension.text_fragments (mf_extension.n_text_fragments).start = buffer_used + 1;
	end;

	do idx = 1 to message.n_body_sections;

	     if idx > 1 then			/* separate it from the previous part */
		call add_to_buffer_fixed (NL);

	     call format_body_section_internal (addr (message.body_sections (idx)));
	end;

	if ifo.build_mf_extension then		/* also record the body's length */
	     mf_extension.text_fragments (mf_extension.n_text_fragments).lth =
		buffer_used - mf_extension.text_fragments (mf_extension.n_text_fragments).start + 1;

	return;

     end format_body;
%page;
/* Actually formats a message trace (called by several entrypoints) */

format_trace:
     procedure (p_trace_ptr, p_is_redistribution);

dcl  p_trace_ptr pointer parameter;
dcl  p_is_redistribution bit (1) aligned parameter;

dcl  1 the_relay aligned like message_trace.relays based (the_relay_ptr);
dcl  the_relay_ptr pointer;

dcl  fieldname_prefix character (32) varying;
dcl  canonicalize bit (1) aligned;
dcl  idx fixed binary;


	if ifo.rfc822_format then return;		/* can't allow old trace into RFC822 messages as SMTP will add
						   new fields which would be indistinguishable from the old
						   ones */

	message_trace_ptr = p_trace_ptr;		/* can't use like because of refer-extents */

	if p_is_redistribution then
	     fieldname_prefix = REDISTRIBUTED_PREFIX;
	else fieldname_prefix = "";

	if message_trace.implicit_route ^= null () then do;
	     address_route_ptr = message_trace.implicit_route;
	     last_column_used = 0;			/* will need this for proper formatting */
	     call add_to_buffer_varying ((fieldname_prefix || IMPLICIT_ROUTE_FIELDNAME));
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	     ifo.indentation = last_column_used;
	     do idx = address_route.n_relays to 1 by -1;
		if ifo.wrap then			/* check if we should start a continuation line ... */
		     if last_column_used > ifo.indentation then
			if (idx = 1) & ^ifo.dont_canonicalize_system_names then
			     if (last_column_used + length (SP_VIA_SP)
				+
				top_level_length (
				mlsys_nit_interface_$canonicalize_system_name (address_route.relays (idx))))
				> ifo.line_length then
				call new_line ();
			     else ;
			else if (last_column_used + length (SP_VIA_SP)
			     + top_level_length (address_route.relays (idx))) > ifo.line_length then
			     call new_line ();
		call add_to_buffer_fixed (SP_VIA_SP);
		if (idx = 1) & ^ifo.dont_canonicalize_system_names then
		     call format_top_level_string (
			mlsys_nit_interface_$canonicalize_system_name (address_route.relays (idx)));
		else call format_top_level_string (address_route.relays (idx));
	     end;
	     call add_to_buffer_fixed (NL);		/* end of that field */
	end;

	do idx = 1 to message_trace.n_relays;
	     the_relay_ptr = addr (message_trace.relays (idx));
	     last_column_used = 0;			/* need the indentation point again */
	     call add_to_buffer_varying ((fieldname_prefix || RELAY_FIELDNAME));
	     call add_to_buffer_fixed (FIELDNAME_SUFFIX);
	     ifo.indentation = last_column_used;
	     canonicalize =
		^ifo.dont_canonicalize_system_names & mlsys_nit_interface_$is_local_system (the_relay.receiving_host);
	     call add_to_buffer_fixed ("from ");
	     if canonicalize then
		call add_to_buffer_varying (mlsys_nit_interface_$canonicalize_system_name (the_relay.sending_host));
	     else call add_to_buffer_varying (the_relay.sending_host);
	     if canonicalize then
		call add_phrase ("to", mlsys_nit_interface_$canonicalize_system_name (the_relay.receiving_host));
	     else call add_phrase ("to", the_relay.receiving_host);
	     if the_relay.mail_protocol ^= "" then call add_phrase ("using", rtrim (the_relay.mail_protocol));
	     if the_relay.communications_protocol ^= "" then
		call add_phrase ("with", rtrim (the_relay.communications_protocol));
	     if the_relay.communications_media ^= "" then
		call add_phrase ("via", rtrim (the_relay.communications_media));
	     if the_relay.relay_id ^= ""b then do;
		if ifo.wrap then			/* ... perform a simple check to insure there's some room */
		     if last_column_used > ifo.indentation then
			if (last_column_used + length ("ID") + 12) > ifo.line_length then call new_line ();
		call add_to_buffer_fixed (" ID ");
		call format_message_id (the_relay.relay_id);
	     end;
	     if the_relay.relay_recipient ^= null () then do;
		if ifo.wrap then			/* ... perform a simple check to insure there's some room */
		     if last_column_used > ifo.indentation then
			if (last_column_used + length ("for") + 12) > ifo.line_length then call new_line ();
		call add_to_buffer_fixed (" for ");
		call format_address (the_relay.relay_recipient, "");
	     end;
	     call add_to_buffer_fixed (SEMICOLON);
	     call add_to_buffer_fixed (SP);
	     call format_date_time (the_relay.date_time_relayed, "0"b);
	     call add_to_buffer_fixed (NL);
	end;

	return;



/* Internal to format_trace: adds a phrase to the current Relayed field */

add_phrase:
	procedure (p_phrase_prefix, p_phrase);

dcl  p_phrase_prefix character (*) parameter;
dcl  p_phrase character (*) varying parameter;

	     if ifo.wrap then			/* try no to overflow the line */
		if last_column_used > ifo.indentation then
		     if (last_column_used + length (p_phrase_prefix) + 2 + top_level_length (p_phrase))
			> ifo.line_length then
			call new_line ();

	     call add_to_buffer_fixed (SP);
	     call add_to_buffer_fixed (p_phrase_prefix);
	     call add_to_buffer_fixed (SP);

	     call format_top_level_string (p_phrase);

	     return;

	end add_phrase;

     end format_trace;
%page;
/* Actually formats a single redistribution (called directly by one entrypoint) */

format_redistribution:
     procedure (p_formatting_mode);

dcl  p_formatting_mode fixed binary parameter;
dcl  full_fieldname character (64) varying;
dcl  fieldname_prefix character (32) varying;
dcl  six_digits_picture picture "zzzzz9";
dcl  user_is_recipient bit (1) aligned;
dcl  (n_recipients, idx) fixed binary;

	if ifo.rfc822_format then
	     fieldname_prefix = RESENT_PREFIX;
	else fieldname_prefix = REDISTRIBUTED_PREFIX;

	if ^ifo.forum_format & (p_formatting_mode > BRIEF_FORMATTING_MODE) then
	     call format_envelope (addr (message_redistribution.envelope), "1"b,
		message_redistribution.date_time_created, message_redistribution.from, p_formatting_mode);

	if message_redistribution.date_time_created > 0 then do;
	     full_fieldname = fieldname_prefix || DATE_TIME_CREATED_FIELDNAME;
	     call format_date_time_field_internal (full_fieldname, message_redistribution.date_time_created, "0"b, "1"b)
		;
	end;					/* always show the Redistributed-Date if it's present */

	if message_redistribution.from ^= null () then
	     if message_redistribution.from -> address_list.n_addresses > 0 then do;
		full_fieldname = fieldname_prefix || FROM_FIELDNAME;
		call format_address_list_field_internal (full_fieldname, message_redistribution.from, "1"b);
	     end;					/* always show the Redistributed-From it it's not empty ... */

	if p_formatting_mode > BRIEF_FORMATTING_MODE then
	     if message_redistribution.to ^= null () then
		if message_redistribution.to -> address_list.n_addresses > 0 then do;
		     full_fieldname = fieldname_prefix || TO_FIELDNAME;
		     call format_address_list_field_internal (full_fieldname, message_redistribution.to, "1"b);
		end;				/* only display the Redistributed-To field if not -bfhe */

	if p_formatting_mode = BRIEF_FORMATTING_MODE then do;
	     /*** Check for multiple recipients and/or the user not being the recipient */
	     user_is_recipient = "0"b;
	     n_recipients = 0;
	     address_list_ptr = message_redistribution.to;
	     if address_list_ptr ^= null () then do;	/* ... there are some addresses on this list */
		n_recipients = n_recipients + address_list.n_addresses;
		do idx = 1 to address_list.n_addresses while (^user_is_recipient);
		     if mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address,
			address_list.addresses (idx), (0)) then
			user_is_recipient = "1"b;
		     else if
			mail_system_$compare_addresses (mlsys_data_$user_mail_table_address,
			address_list.addresses (idx), (0)) then
			user_is_recipient = "1"b;
		end;
	     end;
	     if (^user_is_recipient & (n_recipients > 0)) | (n_recipients > 1) then do;
		full_fieldname = fieldname_prefix || RECIPIENTS_FIELDNAME;
		call add_to_buffer_varying (full_fieldname);
		call add_to_buffer_fixed (FIELDNAME_SUFFIX);
		if user_is_recipient then do;		/* must be others beside this person */
		     call add_to_buffer_fixed ("Yourself and ");
		     n_recipients = n_recipients - 1;
		end;				/* ... don't count ourselves twice */
		call add_to_buffer_fixed (ltrim (convert (six_digits_picture, n_recipients)));
		if n_recipients = 1 then
		     call add_to_buffer_fixed (" other");
		else call add_to_buffer_fixed (" others");
		call add_to_buffer_fixed (NL);
	     end;
	end;

	if message_redistribution.comment.text_lth > 0 then do;
	     full_fieldname = fieldname_prefix || COMMENT_FIELDNAME;
	     call format_text_field_internal (full_fieldname, message_redistribution_comment, "1"b, "1"b);
						/* always display the Redistributed-Comment */
	end;

	if ifo.include_message_id | (p_formatting_mode = LONG_FORMATTING_MODE) then
	     if message_redistribution.message_id ^= ""b then do;
		full_fieldname = fieldname_prefix || MESSAGE_ID_FIELDNAME;
		call format_message_id_field_internal (full_fieldname, message_redistribution.message_id, "1"b);
	     end;					/* only display Redistributed-Message-ID in long mode */

	return;

     end format_redistribution;
%page;
/* Actually formats an access class (called by numerous entrypoints) */

format_access_class:
     procedure (p_access_class);

dcl  p_access_class bit (72) aligned parameter;

dcl  short_string character (200);
dcl  (string_lth, comma_lth, used, idx) fixed binary;

	call convert_authorization_$to_string_short (p_access_class, short_string, (0));
						/* above string is large enough for any access class */

	if short_string = "" then			/* special case it so it will say something */
	     short_string = "system_low";
	else if aim_check_$equal (p_access_class, sys_info$access_class_ceiling) then short_string = "system_high";
						/* make's it easier to read */

	string_lth = length (rtrim (short_string));
	used = 0;					/* haven't examined any of it yet */

	do while (used < string_lth);
	     begin;
dcl  rest_of_string character (string_lth - used) unaligned defined (short_string) position (used + 1);
		idx = index (rest_of_string, COMMA);
		if idx = 0 then idx = length (rest_of_string) + 1;
	     end;

	     begin;
dcl  next_word character (idx - 1) unaligned defined (short_string) position (used + 1);
		if (length (next_word) + used + 1) > string_lth then
		     comma_lth = 0;
		else comma_lth = length (COMMA_SP);

		if ifo.wrap then			/* check for overflow */
		     if last_column_used > ifo.indentation then
			if (last_column_used + length (next_word) + comma_lth) > ifo.line_length then
			     call new_line ();

		call add_to_buffer_fixed (next_word);
		if comma_lth > 0 then call add_to_buffer_fixed (COMMA_SP);

		used = used + idx;			/* to the next word */
	     end;
	end;

	return;

     end format_access_class;
%page;
/* Actually formats an address (called by numerous entrypoints) */

format_address:
     procedure (p_address_ptr, p_address_suffix) options (non_quick);

dcl  p_address_ptr pointer parameter;
dcl  p_address_suffix character (*) varying parameter;

dcl  address_string character (address_string_max_lth) varying based (address_string_ptr);
dcl  address_name character (address_name_max_lth) varying based (address_name_ptr);
dcl  address_comment character (address_comment_max_lth) varying based (address_comment_ptr);
dcl  (address_string_ptr, address_name_ptr, address_comment_ptr) pointer;
dcl  (address_string_max_lth, address_name_max_lth, address_comment_max_lth) fixed binary (21);

dcl  (local_address_string, local_address_name, local_address_comment) character (256) varying;

dcl  saved_indentation fixed binary;
dcl  (have_address_data, display_list) bit (1) aligned;

dcl  address_pathname character (204);			/* pathname associated with the address */
dcl  (address_pathname_varying, address_system) character (256) varying;
dcl  address_dirname character (168);
dcl  (address_ename, address_component) character (32);

dcl  address_representation_lth fixed binary (21);
dcl  address_type fixed binary;


	call mail_system_$get_address_type (p_address_ptr, address_type, (0));

	call get_address_variable (local_address_name, address_name_ptr, address_name_max_lth,
	     mail_system_$get_address_name);

	call get_address_variable (local_address_comment, address_comment_ptr, address_comment_max_lth,
	     mail_system_$get_address_comment);

	have_address_data = "0"b;

	if ^ifo.wrap then go to BEGIN_TO_FORMAT;	/* if we don't care about line wrapping ... */

	have_address_data = "1"b;			/* don't bother to fetch things twice */

	address_representation_lth = length (p_address_suffix);

	if length (address_name) > 0 then		/* there's a name: compute how long it will be */
	     address_representation_lth =
		address_representation_lth + phrase_length (address_name) + length (SP_LEFT_ANGLE_BRACKET)
		+ length (RIGHT_ANGLE_BRACKET);

	if length (address_comment) > 0 then		/* there's a comment: compute how long it will be */
	     address_representation_lth =
		address_representation_lth + comment_length (address_comment) + length (SP_OPEN_PAREN)
		+ length (CLOSE_PAREN);

	go to COMPUTE_ADDRESS_WIDTH (address_type);

COMPUTE_ADDRESS_WIDTH (0):				/* invalid address */
	call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
	     mail_system_$get_address_string);
	address_representation_lth =
	     address_representation_lth + structured_length (address_string) + length ("{invalid }")
	     + quotes_if_rfc822 ();
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (1):				/* user mailbox address */
	call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
	     mail_system_$get_address_string);
	address_representation_lth = address_representation_lth + top_level_length (address_string);
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (2):				/* logbox address */
	call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
	     mail_system_$get_address_string);
	if ifo.dont_show_logsave | (address_string ^= mlsys_data_$user_id) then
	     address_representation_lth = address_representation_lth + top_level_length (address_string);
	else address_representation_lth = address_representation_lth + length ("{logbox}") + quotes_if_rfc822 ();
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (3):				/* savebox address */
	call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
	     mail_system_$get_address_string);
	call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0));
	if ifo.dont_show_logsave | (address_string ^= mlsys_data_$user_id) then do;
	     address_representation_lth = address_representation_lth + top_level_length (address_string);
	     address_pathname_varying = reverse (after (reverse (address_ename), reverse (".sv.mbx")));
	     address_representation_lth =
		address_representation_lth + comment_length (address_pathname_varying) + length (SP_OPEN_PAREN)
		+ length (CLOSE_PAREN);
	end;
	else do;
	     address_pathname = pathname_ (address_dirname, address_ename);
	     address_pathname_varying = reverse (after (reverse (address_pathname), reverse (".sv.mbx")));
	     address_representation_lth =
		address_representation_lth + structured_length (address_pathname_varying) + length ("{save }")
		+ quotes_if_rfc822 ();
	end;
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (4):				/* mailbox address */
	call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0));
	address_pathname = pathname_ (address_dirname, address_ename);
	address_pathname_varying = reverse (after (reverse (address_pathname), reverse (".mbx")));
	address_representation_lth =
	     address_representation_lth + structured_length (address_pathname_varying) + length ("{mbx }")
	     + quotes_if_rfc822 ();
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (5):				/* forum address */
	call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0));
	if address_dirname = "" then			/* ... null dirname => not found in "forum" search list */
	     address_pathname_varying = rtrim (address_ename);
	else address_pathname_varying = rtrim (pathname_ (address_dirname, address_ename));
	if ^ifo.include_forum_suffix then		/* ... caller doesn't need the suffix for later use */
	     if index (reverse (address_pathname_varying), reverse (".forum")) = 1 then
		address_pathname_varying =
		     substr (address_pathname_varying, 1, (length (address_pathname_varying) - length (".forum")));
	     else if index (reverse (address_pathname_varying), reverse (".control")) = 1 then
		address_pathname_varying =
		     substr (address_pathname_varying, 1, (length (address_pathname_varying) - length (".control")));
	address_representation_lth =
	     address_representation_lth + structured_length (address_pathname_varying) + length ("{forum }")
	     + quotes_if_rfc822 ();
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (6):				/* foreign address */
	call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
	     mail_system_$get_address_string);
	call mail_system_$get_address_system (p_address_ptr, address_system, (0));
	address_route_ptr = null ();			/* ... assume no route initially */
	call mail_system_$get_address_route (p_address_ptr, ADDRESS_ROUTE_VERSION_1, address_route_ptr, (0));
	address_representation_lth = address_representation_lth + top_level_length (address_string);
	if ifo.rfc822_format then
	     address_representation_lth = address_representation_lth + length (ATSIGN);
	else address_representation_lth = address_representation_lth + length (SP_AT_SP);
	if address_route_ptr ^= null () then		/* ... have a route: system name may not be known to us */
	     address_representation_lth = address_representation_lth + top_level_length (address_system);
	else if ifo.dont_canonicalize_system_names then	/* ... can't use partial names across top-level domains */
	     address_representation_lth = address_representation_lth + top_level_length (address_system);
	else address_representation_lth =
		address_representation_lth
		+ top_level_length (mlsys_nit_interface_$canonicalize_system_name (address_system));
	if address_route_ptr ^= null () then do;	/* ... include the explicit route */
	     do idx = 1 to address_route.n_relays;
		if ifo.rfc822_format then		/* ... RFC 822 form is:  <@HOST,...,@HOST:LOCAL@HOST> */
		     address_representation_lth = address_representation_lth + length (ATSIGN) + length (COMMA);
		else address_representation_lth = address_representation_lth + length (SP_VIA_SP);
		if idx = 1 then			/* ... only the first relay name is in our NIT */
		     if ifo.dont_canonicalize_system_names then
			address_representation_lth =
			     address_representation_lth + top_level_length (address_route.relays (1));
		     else address_representation_lth =
			     address_representation_lth
			     +
			     top_level_length (
			     mlsys_nit_interface_$canonicalize_system_name (address_route.relays (1)));
		else address_representation_lth =
			address_representation_lth + top_level_length (address_route.relays (idx));
	     end;
	     if ifo.rfc822_format & (length (address_name) = 0) then
		address_representation_lth = address_representation_lth + length (ANGLE_BRACKETS);
	end;
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (7):				/* mail table address */
	call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
	     mail_system_$get_address_string);
	address_representation_lth = address_representation_lth + top_level_length (address_string);
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (8):				/* mailing list address */
	call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, address_component, (0));
	address_pathname = pathname_$component (address_dirname, address_ename, address_component);
	address_pathname_varying = reverse (after (reverse (address_pathname), reverse (".mls")));
	address_representation_lth =
	     address_representation_lth + structured_length (address_pathname_varying) + length ("{list }")
	     + quotes_if_rfc822 ();
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;

COMPUTE_ADDRESS_WIDTH (9):				/* named group address */
	call mail_system_$get_named_group_display_flag (p_address_ptr, display_list, (0));
	go to END_COMPUTE_ADDRESS_WIDTH_CASE;		/* ... is treated quite differently */

END_COMPUTE_ADDRESS_WIDTH_CASE:
	if ifo.include_local_system_name & ((address_type ^= FOREIGN_ADDRESS) & (address_type ^= NAMED_GROUP_ADDRESS))
	then do;
	     if ifo.dont_canonicalize_system_names then
		address_representation_lth =
		     address_representation_lth + top_level_length (mlsys_nit_interface_$get_local_system_name ());
	     else address_representation_lth =
		     address_representation_lth
		     +
		     top_level_length (
		     mlsys_nit_interface_$canonicalize_system_name (mlsys_nit_interface_$get_local_system_name ()));
	     if ifo.rfc822_format then
		address_representation_lth = address_representation_lth + length (ATSIGN);
	     else address_representation_lth = address_representation_lth + length (SP_AT_SP);
	end;

	if address_type = NAMED_GROUP_ADDRESS then	/* special case: start a newline if it's not first */
	     if display_list then			/* ... but only if the list is going to be displayed */
		if (last_column_used > ifo.indentation) then
		     call new_line ();
		else ;
	     else go to STANDARD_WRAP_CRITERIA;		/* ... otherwise treat it as a normal address */

	else
STANDARD_WRAP_CRITERIA:
	     if (last_column_used > ifo.indentation)	/* never output a newline if the line's still empty */
	     & ((last_column_used + address_representation_lth) > ifo.line_length) then
	     call new_line ();


BEGIN_TO_FORMAT:
	if length (address_name) > 0 then do;		/* put out the address_name */
	     call format_phrase_string (address_name);
	     if address_type = NAMED_GROUP_ADDRESS then
		call add_to_buffer_fixed (COLON_SP);
	     else call add_to_buffer_fixed (SP_LEFT_ANGLE_BRACKET);
	end;

	go to FORMAT_ADDRESS (address_type);

FORMAT_ADDRESS (0):					/* invalid address */
	if ^have_address_data then
	     call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
		mail_system_$get_address_string);
	call format_structured_string ("invalid", address_string);
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (1):					/* user mailbox address */
	if ^have_address_data then
	     call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
		mail_system_$get_address_string);
	call format_top_level_string (address_string);
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (2):					/* logbox address */
	if ^have_address_data then
	     call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
		mail_system_$get_address_string);
	if ifo.dont_show_logsave | (address_string ^= mlsys_data_$user_id) then
	     call format_top_level_string (address_string);
	else call format_structured_string ("logbox", "");
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (3):					/* savebox address */
	if ^have_address_data then do;
	     call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
		mail_system_$get_address_string);
	     call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0));
	     address_pathname = pathname_ (address_dirname, address_ename);
	end;
	if ifo.dont_show_logsave | (address_string ^= mlsys_data_$user_id) then do;
	     call format_top_level_string (address_string);
	     address_pathname_varying = reverse (after (reverse (address_ename), reverse (".sv.mbx")));
	     call format_comment_string (address_pathname_varying);
	end;
	else do;
	     address_pathname_varying = reverse (after (reverse (address_pathname), reverse (".sv.mbx")));
	     call format_structured_string ("save", address_pathname_varying);
	end;
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (4):					/* mailbox address */
	if ^have_address_data then do;
	     call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0));
	     address_pathname = pathname_ (address_dirname, address_ename);
	end;
	address_pathname_varying = reverse (after (reverse (address_pathname), reverse (".mbx")));
	call format_structured_string ("mbx", address_pathname_varying);
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (5):					/* forum address */
	if ^have_address_data then do;
	     call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, ((32)" "), (0));
	     if address_dirname = "" then		/* ... null dirname => not found in "forum" search list */
		address_pathname_varying = rtrim (address_ename);
	     else address_pathname_varying = rtrim (pathname_ (address_dirname, address_ename));
	end;
	if ^ifo.include_forum_suffix then		/* ... caller doesn't need the suffix for later use */
	     if index (reverse (address_pathname_varying), reverse (".forum")) = 1 then
		address_pathname_varying =
		     substr (address_pathname_varying, 1, (length (address_pathname_varying) - length (".forum")));
	     else if index (reverse (address_pathname_varying), reverse (".control")) = 1 then
		address_pathname_varying =
		     substr (address_pathname_varying, 1, (length (address_pathname_varying) - length (".control")));
	call format_structured_string ("forum", address_pathname_varying);
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (6):					/* foreign address */
	if ^have_address_data then do;
	     call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
		mail_system_$get_address_string);
	     call mail_system_$get_address_system (p_address_ptr, address_system, (0));
	     address_route_ptr = null ();		/* ... in case there is no route */
	     call mail_system_$get_address_route (p_address_ptr, ADDRESS_ROUTE_VERSION_1, address_route_ptr, (0));
	end;
	if ifo.rfc822_format then do;			/* ... RFC 822 format */
	     if address_route_ptr ^= null () then do;	/* ... ... we'll be creating a "path": add "<" if nameless */
		if length (address_name) = 0 then call add_to_buffer_fixed (LEFT_ANGLE_BRACKET);
		do idx = 1 to address_route.n_relays;
		     if idx > 1 then call add_to_buffer_fixed (COMMA);
		     call add_to_buffer_fixed (ATSIGN);
		     if idx = 1 then		/* ... only the first relay name is in our tables */
			if ifo.dont_canonicalize_system_names then
			     call format_top_level_string (address_route.relays (1));
			else call format_top_level_string (
				mlsys_nit_interface_$canonicalize_system_name (address_route.relays (1)));
		     else call format_top_level_string (address_route.relays (idx));
		end;
		call add_to_buffer_fixed (COLON);
	     end;
	     call format_top_level_string (address_string);
	     call add_to_buffer_fixed (ATSIGN);
	     if address_route_ptr ^= null () then	/* ... if there's a route, this name may not be in NIT */
		call format_top_level_string (address_system);
	     else if ifo.dont_canonicalize_system_names then call format_top_level_string (address_system);
	     else call format_top_level_string (mlsys_nit_interface_$canonicalize_system_name (address_system));
	     if (address_route_ptr ^= null ()) & (length (address_name) = 0) then
		call add_to_buffer_fixed (RIGHT_ANGLE_BRACKET);
	end;
	else do;					/* ... Multics format */
	     call format_top_level_string (address_string);
	     call add_to_buffer_fixed (SP_AT_SP);
	     if address_route_ptr ^= null () then	/* ... if there's a route, this name may not be in NIT */
		call format_top_level_string (address_system);
	     else if ifo.dont_canonicalize_system_names then call format_top_level_string (address_system);
	     else call format_top_level_string (mlsys_nit_interface_$canonicalize_system_name (address_system));
	     if address_route_ptr ^= null () then	/* Multics routes come out "backwards" */
		do idx = address_route.n_relays to 1 by -1;
		call add_to_buffer_fixed (SP_VIA_SP);
		if idx = 1 then			/* ... only the first relay name is in our tables */
		     if ifo.dont_canonicalize_system_names then
			call format_top_level_string (address_route.relays (1));
		     else call format_top_level_string (
			     mlsys_nit_interface_$canonicalize_system_name (address_route.relays (1)));
		else call format_top_level_string (address_route.relays (idx));
	     end;
	end;
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (7):					/* mail table address */
	if ^have_address_data then
	     call get_address_variable (local_address_string, address_string_ptr, address_string_max_lth,
		mail_system_$get_address_string);
	call format_top_level_string (address_string);
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (8):					/* mailing list address */
	if ^have_address_data then do;
	     call mail_system_$get_address_pathname (p_address_ptr, address_dirname, address_ename, address_component,
		(0));
	     address_pathname = pathname_$component (address_dirname, address_ename, address_component);
	end;
	address_pathname_varying = reverse (after (reverse (address_pathname), reverse (".mls")));
	call format_structured_string ("list", address_pathname_varying);
	go to END_FORMAT_ADDRESS_CASE;

FORMAT_ADDRESS (9):					/* named group address */
	if ^have_address_data then call mail_system_$get_named_group_display_flag (p_address_ptr, display_list, (0));
	if display_list then do;			/* ... show the list */
	     saved_indentation = ifo.indentation;
	     ifo.indentation = last_column_used;	/* ... make the address in the list line up */
	     call mail_system_$expand_list_address (p_address_ptr, ADDRESS_LIST_VERSION_2, address_list_ptr, (0));
	     call format_address_list (address_list_ptr);
	     ifo.indentation = saved_indentation;
	end;

END_FORMAT_ADDRESS_CASE:
	if ifo.include_local_system_name & ((address_type ^= FOREIGN_ADDRESS) & (address_type ^= NAMED_GROUP_ADDRESS))
	then do;
	     if ifo.rfc822_format then
		call add_to_buffer_fixed (ATSIGN);
	     else call add_to_buffer_fixed (SP_AT_SP);
	     if ifo.dont_canonicalize_system_names then
		call format_top_level_string (mlsys_nit_interface_$get_local_system_name ());
	     else call format_top_level_string (
		     mlsys_nit_interface_$canonicalize_system_name (mlsys_nit_interface_$get_local_system_name ()));
	end;

	if length (address_name) > 0 then		/* close off the address */
	     if address_type = NAMED_GROUP_ADDRESS then
		call add_to_buffer_fixed (SEMICOLON);
	     else call add_to_buffer_fixed (RIGHT_ANGLE_BRACKET);

	if length (address_comment) > 0 then call format_comment_string (address_comment);

	if length (p_address_suffix) > 0 then call add_to_buffer_varying (p_address_suffix);

	return;



/* Internal to format_address: gets one of the variables (string, name, comment) associated with an address; it will grow
   the format_address stack frame as necessary */

get_address_variable:
	procedure (p_local_variable, p_variable_ptr, p_variable_max_lth, p_get_primitive);

dcl  p_local_variable character (256) varying parameter;
dcl  p_variable_ptr pointer parameter;
dcl  p_variable_max_lth fixed binary (21) parameter;
dcl  p_get_primitive entry (pointer, character (*) varying, fixed binary (35));

dcl  p_variable character (p_variable_max_lth) varying based (p_variable_ptr);
dcl  code fixed binary (35);

	     p_variable_ptr = addr (p_local_variable);	/* assume it will fit in the preallocated space */
	     p_variable_max_lth = maxlength (p_local_variable);

	     call p_get_primitive (p_address_ptr, p_variable, code);

	     if code = error_table_$smallarg then do;	/* too large for the preallocated space ... */
		call cu_$grow_stack_frame (STACK_EXTENSION, p_variable_ptr, (0));
		p_variable_max_lth = 4 * (STACK_EXTENSION - 1);

		call p_get_primitive (p_address_ptr, p_variable, code);
						/* try again using space at the end of the stack ... */

		do while (code = error_table_$smallarg);/* ... and keep trying 'till it fits */
		     call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		     p_variable_max_lth = p_variable_max_lth + (4 * STACK_EXTENSION);
		     call p_get_primitive (p_address_ptr, p_variable, code);
		end;
	     end;

	     return;

	end get_address_variable;

     end format_address;
%page;
/* Actually formats an address list (called by numerous entrypoints) */

format_address_list:
     procedure (p_address_list_ptr);

dcl  p_address_list_ptr pointer parameter;
dcl  idx fixed binary;

	if p_address_list_ptr -> address_list.n_addresses = 0 then return;

	do idx = 1 to (p_address_list_ptr -> address_list.n_addresses - 1);
	     call format_address (p_address_list_ptr -> address_list.addresses (idx), (COMMA_SP));
	end;

	call format_address (p_address_list_ptr
	     -> address_list.addresses (p_address_list_ptr -> address_list.n_addresses), "");

	return;

     end format_address_list;
%page;
/* Actually formats a date/time (called by numerous entrypoints) */

format_date_time:
     procedure (p_date_time, p_include_dow);

dcl  p_date_time fixed binary (71) parameter;
dcl  p_include_dow bit (1) aligned parameter;

dcl  four_digits_picture picture "9999";
dcl  two_digits_picture picture "99";
dcl  time_zone character (4);
dcl  recognized_zone bit (1) aligned;
dcl  code fixed binary (35);
dcl  (month, day_of_month, year, hour, minute, day_of_week, offset, hours, minutes, process_zone_offset, idx) fixed
	binary;


	time_zone = "";				/* use the time zone of this process */

	call decode_clock_value_$date_time (p_date_time, month, day_of_month, year, hour, minute, (0), (0), day_of_week,
	     time_zone, code);
	if code ^= 0 then do;			/* shouldn't happen: provide some output anyway */
	     month, day_of_month = 1;			/* ... use the base time for Multics clocks */
	     day_of_week = 2;			/* ... which was a Tuesday */
	     year = 1901;
	     hour, minute = 0;
	     time_zone = "gmt";
	end;

	if ifo.rfc822_format then			/* networks use uppercase zones; Multics uses lowercase */
	     time_zone = translate (time_zone, UPPERCASE, LOWERCASE);
	else time_zone = translate (time_zone, LOWERCASE, UPPERCASE);

	if printing then				/* always use the process time-zone if displaying the date */
	     recognized_zone = "1"b;
	else do;					/* check if other processes/systems will understand it */
	     recognized_zone = "0"b;
	     if ifo.rfc822_format then do;		/* ... formatting for the network (ie: other systems) */
		process_zone_offset = divide ((-time_data_$time_delta), ONE_MINUTE, 17, 0);
		do idx = lbound (RFC822_ZONES, 1) to hbound (RFC822_ZONES, 1) while (^recognized_zone);
		     if (time_zone = RFC822_ZONES (idx)) & (process_zone_offset = RFC822_ZONE_OFFSETS (idx)) then
			recognized_zone = "1"b;
		end;
	     end;
	     else do;				/* ... formatting for this Multics system */
		do idx = 1 to ti_zone.number_lang while (^recognized_zone);
		     do jdx = 1 to ti_zone.number_zone while (^recognized_zone);
			if (time_zone = translate (ti_zone.short (idx, jdx), LOWERCASE, UPPERCASE))
			     & (time_data_$time_delta = ti_zone.delta (idx, jdx)) then
			     recognized_zone = "1"b;
		     end;
		end;
	     end;
	end;

	if p_include_dow then do;			/* callers wants the day of the week */
	     if ifo.rfc822_format then		/* ... networks use short names; Multics uses long names */
		call add_to_buffer_fixed (RFC822_DAY_OF_WEEKS (day_of_week));
	     else call add_to_buffer_varying (DAY_OF_WEEKS (day_of_week));
	     call add_to_buffer_fixed (COMMA_SP);
	end;

	call add_to_buffer_fixed (ltrim (convert (two_digits_picture, day_of_month), "0"));
	call add_to_buffer_fixed (SP);

	if ifo.rfc822_format then			/* networks use short names; Multics uses long names */
	     call add_to_buffer_fixed (RFC822_MONTHS (month));
	else call add_to_buffer_varying (MONTHS (month));
	call add_to_buffer_fixed (SP);

	if ifo.rfc822_format then			/* networks use 2 digit years; Multics uses four digits */
	     call add_to_buffer_fixed (convert (two_digits_picture, mod (year, 100)));
	else call add_to_buffer_fixed (convert (four_digits_picture, year));
	call add_to_buffer_fixed (SP);

	call add_to_buffer_fixed (convert (two_digits_picture, hour));
	call add_to_buffer_fixed (COLON);

	call add_to_buffer_fixed (convert (two_digits_picture, minute));

	if recognized_zone then do;			/* we recognize the time zone */
	     call add_to_buffer_fixed (SP);
	     call add_to_buffer_fixed (rtrim (time_zone));
	end;
	else do;					/* non-standard zone: record its offset instead */
	     if time_data_$time_delta > 0 then		/* ... Multics uses negative of the ISO offset */
		call add_to_buffer_fixed (HYPHEN);
	     else call add_to_buffer_fixed (PLUS);
	     offset = divide (abs (time_data_$time_delta), ONE_MINUTE, 35, 0);
	     hours = divide (offset, ONE_HOUR, 17, 0);	/* ... convert into HHMM */
	     minutes = mod (offset, ONE_HOUR);
	     call add_to_buffer_fixed (convert (two_digits_picture, hours));
	     call add_to_buffer_fixed (convert (two_digits_picture, minutes));
	end;

	return;

     end format_date_time;
%page;
/* Actually formats a Message-ID */

format_message_id:
     procedure (p_message_id) options (non_quick);

dcl  p_message_id bit (72) aligned parameter;

dcl  message_id_string character (message_id_string_max_lth) varying based (message_id_string_ptr);
dcl  message_id_string_ptr pointer;
dcl  message_id_string_max_lth fixed binary (21);

dcl  local_message_id_string character (256) varying;
dcl  message_id_system character (256) varying;
dcl  is_local_system bit (1) aligned;
dcl  code fixed binary (35);


	message_id_string_ptr = addr (local_message_id_string);
	message_id_string_max_lth = maxlength (local_message_id_string);
						/* assume it will fit in the preallocated space */

	call mail_system_$decode_message_id (p_message_id, message_id_string, message_id_system, is_local_system, code);

	if code = error_table_$smallarg then do;	/* too large for the preallocated space ... */
	     call cu_$grow_stack_frame (STACK_EXTENSION, message_id_string_ptr, (0));
	     message_id_string_max_lth = 4 * (STACK_EXTENSION - 1);

	     call mail_system_$decode_message_id (p_message_id, message_id_string, message_id_system, is_local_system,
		code);				/* try again using space at the end of the stack ... */

	     do while (code = error_table_$smallarg);	/* ... and keep trying 'till it fits */
		call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		message_id_string_max_lth = message_id_string_max_lth + (4 * STACK_EXTENSION);
		call mail_system_$decode_message_id (p_message_id, message_id_string, message_id_system,
		     is_local_system, code);
	     end;
	end;

	call add_to_buffer_fixed (LEFT_ANGLE_BRACKET);

	call format_top_level_string (message_id_string);

	if ifo.include_local_system_name | ^is_local_system then do;
	     if ifo.rfc822_format then
		call add_to_buffer_fixed (ATSIGN);
	     else call add_to_buffer_fixed (SP_AT_SP);
	     if ifo.dont_canonicalize_system_names then
		call add_to_buffer_varying (message_id_system);
	     else call add_to_buffer_varying (mlsys_nit_interface_$canonicalize_system_name (message_id_system));
	end;

	call add_to_buffer_fixed (RIGHT_ANGLE_BRACKET);

	return;

     end format_message_id;
%page;
/* Actually formats a list of references to other messages */

format_references_list:
     procedure (p_message_references_list_ptr) options (non_quick);

dcl  p_message_references_list_ptr pointer parameter;
dcl  idx fixed binary;

	message_references_list_ptr = p_message_references_list_ptr;

	do idx = 1 to message_references_list.n_references;
	     call format_reference (addr (message_references_list.references (idx)));
	     if idx < message_references_list.n_references then do;
		call add_to_buffer_fixed (COMMA);	/* must separate each reference from the next */
		call new_line ();
	     end;
	end;

	return;



/* Internal to format_references_list: formats a single message reference.  If the reference only has a Message-ID, the
   text of the ID is used as the text of the field */

format_reference:
	procedure (p_message_reference_ptr);

dcl  p_message_reference_ptr pointer parameter;

dcl  message_id_string character (message_id_string_max_lth) varying based (message_id_string_ptr);
dcl  message_id_string_ptr pointer;
dcl  message_id_string_max_lth fixed binary (21);

dcl  author_string character (256) varying;		/* will be truncated if necessary */
dcl  local_message_id_string character (256) varying;
dcl  code fixed binary (35);


	     message_reference_ptr = p_message_reference_ptr;

	     ifo.indentation = ifo.indentation + 5;	/* in case something wraps (which it won't) */

	     if (message_reference.date_time_created > 0) & (message_reference.from ^= null ()) then do;
		/*** A modern reference: create the "Message of DATE from AUTHOR" format of reference */
		call add_to_buffer_fixed ("Message of ");
		call format_date_time (message_reference.date_time_created, "0"b);
		call add_to_buffer_fixed (" from ");
		call mlsys_misc_utils_$get_best_address_name (message_reference.from -> address_list.addresses (1),
		     author_string, (0));
		call format_top_level_string (author_string);
	     end;

	     else do;
		/*** A old reference: get its text from the Message-ID and print it (newlines and all) */
		message_id_string_ptr = addr (local_message_id_string);
		message_id_string_max_lth = maxlength (local_message_id_string);
		call mail_system_$decode_message_id (message_reference.message_id, message_id_string, (""), ("0"b),
		     code);
		if code = error_table_$smallarg then do;
		     call cu_$grow_stack_frame (STACK_EXTENSION, message_id_string_ptr, (0));
		     message_id_string_max_lth = 4 * (STACK_EXTENSION - 1);
		     call mail_system_$decode_message_id (message_reference.message_id, message_id_string, (""),
			("0"b), code);
		     do while (code = error_table_$smallarg);
			call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
			message_id_string_max_lth = message_id_string_max_lth + (4 * STACK_EXTENSION);
			call mail_system_$decode_message_id (message_reference.message_id, message_id_string, (""),
			     ("0"b), code);
		     end;
		end;
		call add_to_buffer_varying (message_id_string);
	     end;					/* sure would be nice to format it but it's random text */

	     ifo.indentation = ifo.indentation - 5;

	     return;

	end format_reference;

     end format_references_list;
%page;
/* Actually formats a piece of text which is to appear in the message envelope, header, or redistributions list (called by
   several entrypoints) */

format_text:
     procedure (p_text, p_multiline_text);

dcl  p_text character (*) parameter;
dcl  p_multiline_text bit (1) aligned parameter;

	if p_multiline_text then			/* just invoke the proper internal procedure */
	     call format_multiline_text (p_text);
	else call format_single_line_text (p_text);

	return;



/* Internal to format_text: formats a piece of text which is a single line field; as the mail system will turn such text
   back into a single line field, this procedure will wrap the text at the requested line length for readability */

format_single_line_text:
	procedure (p_text);

dcl  p_text character (*) parameter;

dcl  (text_lth, text_used, space_left_on_line, idx) fixed binary (21);


	     text_used = verify (p_text, SP) - 1;	/* mail system guarentees only spaces; no other whitespace */
	     if text_used = -1 then return;		/* ... it's a blank field */

	     begin;				/* strip trailing whitespace */
dcl  text character (length (p_text) - text_used) unaligned defined (p_text) position (text_used + 1);
		text_lth = length (rtrim (text, SP));
		text_lth = text_lth + text_used;	/* ... get true length for proper use of defined */
	     end;


	     if ifo.wrap then do;			/* text must be split to fit within request line length ... */

		do while (text_used < text_lth);
		     begin;
dcl  rest_of_text character (text_lth - text_used) unaligned defined (p_text) position (text_used + 1);

			space_left_on_line = ifo.line_length - last_column_used;

			if length (rest_of_text) <= space_left_on_line then
			     idx = length (rest_of_text) + 1;

			else do;			/* find an appropriate place to split the text */
			     begin;
dcl  text_substring character (space_left_on_line) unaligned defined (p_text) position (text_used + 1);
				idx = length (text_substring) - index (reverse (text_substring), SP) + 1;
				if idx = (length (text_substring) + 1) then do;
				     idx = index (rest_of_text, SP);
				     if idx = 0 then idx = length (rest_of_text) + 1;
				end;		/* do-group is executed iff the substring is a ... */
			     end;			/* ... single word longer than the space left on the line */
			end;

			begin;			/* output all but the space on which we split the text */
dcl  output_substring character (idx - 1) unaligned defined (p_text) position (text_used + 1);
			     call add_to_buffer_fixed (output_substring);
			end;

			text_used = text_used + idx;	/* the SP is never actuall sent: but a NL is if needed */

			if text_used < length (p_text) then call new_line ();
		     end;				/* ... there's more to come */
		end;
	     end;


	     else call add_to_buffer_fixed (p_text);	/* no line wrapping requested: just output the text as is */


	     return;

	end format_single_line_text;



/* Internal to format_text: formats a multiline text text fieldfor subsquent displayby insuring each line starts out at
   least at the indentation column and that no blank lines appear in the printed representation */

format_multiline_text:
	procedure (p_text);

dcl  p_text character (*) parameter;

dcl  first_line bit (1) aligned;
dcl  (text_lth, text_used, idx) fixed binary (21);


	     text_used = verify (p_text, WHITESPACE) - 1;
	     if text_used = -1 then return;		/* nothing in the field but whitespace */

	     begin;				/* strip trailing whitespace */
dcl  text character (length (p_text) - text_used) unaligned defined (p_text) position (text_used + 1);
		text_lth = length (rtrim (text, WHITESPACE));
		text_lth = text_lth + text_used;	/* ... get proper length for use of defined */
	     end;


	     if ifo.indentation <= MAX_MULTILINE_INDENTATION then do;
		ifo.indentation = max (1, (ifo.indentation - length (MULTILINE_BLANK_LINE_DESIGNATOR)));
		first_line = "1"b;			/* ... this line is already at the proper indentation */
	     end;

	     else do;				/* enforce a maximum indentation for aesthetic reasons */
		begin;				/* ... strip any trailing whitespace after fieldname ... */
dcl  buffer_in_use character (buffer_used) unaligned defined (buffer) position (1);
		     buffer_used = length (rtrim (buffer_in_use, SP));
		end;
		ifo.indentation = STANDARD_MULTILINE_INDENTATION - length (MULTILINE_BLANK_LINE_DESIGNATOR);
		call new_line ();			/* ... and start a new line */
		first_line = "0"b;
	     end;


	     do while (text_used < length (p_text));
		begin;
dcl  rest_of_text character (length (p_text) - text_used) unaligned defined (p_text) position (text_used + 1);

		     idx = index (rest_of_text, NL);
		     if idx = 0 then idx = length (rest_of_text) + 1;
		end;

		begin;
dcl  the_line character (idx - 1) unaligned defined (p_text) position (text_used + 1);

		     if verify (the_line, WHITESPACE) = 0 then
			call add_to_buffer_fixed (MULTILINE_BLANK_LINE_DESIGNATOR);

		     else do;
			if ^first_line then call add_to_buffer_fixed (SPSP);
			call add_to_buffer_fixed (the_line);
		     end;
		end;

		first_line = "0"b;			/* can't be on the first line anymore */
		text_used = text_used + idx;		/* skip to next line */

		if text_used < text_lth then call new_line ();
	     end;					/* more to come */

	     return;

	end format_multiline_text;

     end format_text;
%page;
/* Actually formats a section of the message body (called by several entrypoints):  This procedure violates the modularity
   of this program by its use of the knowledge of whether we are printing or formatting in order to cut down on the number
   iox_$put_chars calls per body section */

format_body_section_internal:
     procedure (p_body_section_ptr);

dcl  p_body_section_ptr pointer parameter;

dcl  the_line character (80) varying;
dcl  words (4) bit (36) aligned;
dcl  words_as_characters (4) character (4) aligned based (addr (words));
dcl  last_line_printed (4) bit (36) aligned;
dcl  translated_words (4) character (4) aligned;
dcl  in_duplicate bit (1) aligned;
dcl  (n_words, n_lines, n_words_on_line, n_bits_in_last_word, offset, idx, jdx, kdx) fixed binary;


	message_body_section_ptr = p_body_section_ptr;	/* none of our caller's uses this variable */

	go to FORMAT_BODY_SECTION (message_body_section.section_type);


FORMAT_BODY_SECTION (1):				/* preformatted text: use single iox_$put_chars if possible */
	if printing then do;
	     call print_buffer ();			/* ... dump anything that's still pending */
	     call iox_$put_chars (output_switch, message_preformatted_body_section.text_ptr,
		message_preformatted_body_section.text_lth, code);
	     if code ^= 0 then do;			/* ... fatal error */
		P_code = code;
		go to RETURN_FROM_FORMAT_ENTRY_WITH_ERROR;
	     end;
	     if substr (message_preformatted_body_section_text, message_preformatted_body_section.text_lth, 1) ^= NL
		then
		call iox_$put_chars (output_switch, addr (NL), 1, (0));
	     line_count = count_lines_in_text (message_preformatted_body_section_text);
	     last_column_used = 0;			/* ... guarenteed to now be at the start of a line */
	end;

	else do;
	     call add_to_buffer_fixed (message_preformatted_body_section_text);
	     if substr (message_preformatted_body_section_text, message_preformatted_body_section.text_lth, 1) ^= NL
		then
		call add_to_buffer_fixed (NL);	/* ... insure a trailing newline in the section */
	end;

	return;


FORMAT_BODY_SECTION (2):				/* bit string: generated dump_segment-like output */
	n_words = divide ((message_bit_string_body_section.bit_string_lth + 35), 36, 18, 0);
	n_lines = divide ((n_words + 3), 4, 18, 0);

	unspec (last_line_printed) = ""b;		/* nothing printed (will set this before it's checked) */
	in_duplicate = "0"b;			/* not suppressing duplicate lines yet */

	offset = 0;				/* offset from start of the string */

	do idx = 1 to n_lines;
	     if idx = n_lines then do;
		n_words_on_line = mod (n_words, 4);
		if n_words_on_line = 0 then n_words_on_line = 4;
		n_bits_in_last_word = mod (message_bit_string_body_section.bit_string_lth, 36);
		if n_bits_in_last_word = 0 then n_bits_in_last_word = 36;
	     end;
	     else do;
		n_words_on_line = 4;
		n_bits_in_last_word = 36;
	     end;
	     do jdx = 1 to (n_words_on_line - 1);
		unspec (words (jdx)) =
		     substr (message_bit_string_body_section_bit_string, (36 * (4 * (idx - 1) + jdx - 1) + 1), 36);
	     end;
	     unspec (words (n_words_on_line)) =
		substr (message_bit_string_body_section_bit_string, (36 * (4 * (idx - 1) + n_words_on_line - 1) + 1),
		n_bits_in_last_word);
	     do jdx = 1 to n_words_on_line;
		do kdx = 1 to 4;
		     if index (SINGLE_WIDTH_CHARACTERS, substr (words_as_characters (jdx), kdx, 1)) = 0 then
			substr (translated_words (jdx), kdx, 1) = ".";
		     else substr (translated_words (jdx), kdx, 1) = substr (words_as_characters (jdx), kdx, 1);
		end;
	     end;
	     if (idx = 1) & (idx = n_lines) then do;	/* don't perform duplicate suppression on 1st/last lines */
DISPLAY_THIS_LINE_OF_DUMP:
		call ioa_$rsnnl ("^6.3b", the_line, (0), bit (binary (offset, 18, 0), 18));
		call ioa_$rsnnl ("^a^v( ^12.3b^)", the_line, (0), the_line, n_words_on_line, words (*));
		call ioa_$rsnnl ("^a^vx^v(^4a^)", the_line, (0), the_line, (13 * (4 - n_words_on_line) + 1),
		     n_words_on_line, translated_words (*));
		call add_to_buffer_varying (the_line);
		call add_to_buffer_fixed (NL);
		unspec (last_line_printed) = unspec (words);
		in_duplicate = "0"b;
	     end;
	     else if unspec (words) ^= unspec (last_line_printed) then go to DISPLAY_THIS_LINE_OF_DUMP;
	     else do;				/* a duplicate line */
		if ^in_duplicate then do;
		     call add_to_buffer_fixed ("======");
		     call add_to_buffer_fixed (NL);
		end;
		in_duplicate = "1"b;
	     end;


	     offset = offset + 4;
	end;

	return;

     end format_body_section_internal;
%page;
/* Computes the width of phrases which appear outside of comments and structured addresses */

simple_lengths:
     procedure (p_string) returns (fixed binary (21));

	return (0);				/* not an entrypoint */

dcl  p_string character (*) varying parameter;

dcl  must_requote bit (1) aligned;
dcl  (string_lth, used, idx) fixed binary (21);


phrase_length:					/* RFC822 format may contain spaces but no unquoted periods */
     entry (p_string) returns (fixed binary (21));

	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote =
		(search (p_string, TOP_LEVEL_RFC822_REQUOTE) ^= 0) | (index (p_string, PERIOD) ^= 0)
		| (index (p_string, SPSP) ^= 0);
	else must_requote = (search (p_string, TOP_LEVEL_REQUOTE) ^= 0) | (index (p_string, SPSP) ^= 0);
	go to COMPUTE_THE_LENGTH;


top_level_length:					/* RFC822 format must be quoted for single spaces */
     entry (p_string) returns (fixed binary (21));

	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote = (search (p_string, TOP_LEVEL_RFC822_REQUOTE) ^= 0) | (index (p_string, SP) ^= 0);
	else must_requote = (search (p_string, TOP_LEVEL_REQUOTE) ^= 0) | (index (p_string, SPSP) ^= 0);


COMPUTE_THE_LENGTH:
	if must_requote then			/* start out with surrounding quotes */
	     string_lth = 2 * length (QUOTE);
	else return (length (p_string));		/* can use it just the way it is */

	used = 0;

	do while (used < length (p_string));
	     if ifo.rfc822_format then		/* find next character which must be escaped */
		idx = search (substr (p_string, (used + 1)), BACKSLASH_QUOTE_NL);
	     else idx = search (substr (p_string, (used + 1)), QUOTE_NL);
	     if idx = 0 then idx = length (p_string) - used + 1;
	     string_lth = string_lth + idx - 1;
	     used = used + idx - 1;			/* skip past normal characters */
	     if used < length (p_string) then do;
		string_lth = string_lth + 2;		/* escape character (quote/backslash) plus the character */
		used = used + 1;
		if ifo.rfc822_format then		/* for RFC822: newlines are printed as three characters */
		     if substr (p_string, used, 1) = NL then string_lth = string_lth + 1;
	     end;
	end;

	return (string_lth);

     end simple_lengths;
%page;
/* Computes the length of a string which is used within a structured address: always uses Multics conventions for those
   characters which must be escaped but, for RFC822 format, the entire text will be quoted */

structured_length:
     procedure (p_string) returns (fixed binary (21));

dcl  p_string character (*) varying parameter;

dcl  must_requote bit (1) aligned;
dcl  (string_lth, used, idx) fixed binary (21);


	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote = (search (p_string, STRUCTURED_RFC822_REQUOTE) ^= 0);
	else must_requote = (search (p_string, STRUCTURED_REQUOTE) ^= 0);

	if must_requote then			/* start out with surrounding quotes */
	     if ifo.rfc822_format then		/* ... these quotes are within quotes: preceed them "\" */
		string_lth = 2 * length (BACKSLASH_QUOTE);
	     else string_lth = 2 * length (QUOTE);
	else return (length (p_string));		/* can use it just the way it is */

	used = 0;

	do while (used < length (p_string));
	     if ifo.rfc822_format then		/* find next character which must be escaped */
		idx = search (substr (p_string, (used + 1)), BACKSLASH_QUOTE_NL);
	     else idx = search (substr (p_string, (used + 1)), QUOTE_NL);
	     if idx = 0 then idx = length (p_string) - used + 1;
	     string_lth = string_lth + idx - 1;
	     used = used + idx - 1;			/* skip past normal characters */
	     if used < length (p_string) then do;
		string_lth = string_lth + 2;		/* escape character (quote/backslash) plus the character */
		used = used + 1;
		if ifo.rfc822_format then		/* for RFC822: newlines are printed as three characters */
		     if substr (p_string, used, 1) = NL then string_lth = string_lth + 1;
		if ifo.rfc822_format then		/* for RFC822: quotes are printed as four(!) characters */
		     if substr (p_string, used, 1) = QUOTE then string_lth = string_lth + length (BACKSLASH_QUOTE);
	     end;
	end;

	return (string_lth);

     end structured_length;
%page;
/* Computes the width of a string which is a comment */

comment_length:
     procedure (p_string) returns (fixed binary (21));

dcl  p_string character (*) varying parameter;

dcl  must_requote bit (1) aligned;
dcl  (string_lth, used, idx) fixed binary (21);

	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote = (search (p_string, COMMENT_RFC822_REQUOTE) ^= 0);
	else must_requote = (search (p_string, COMMENT_REQUOTE) ^= 0);

	if must_requote then
	     if ifo.rfc822_format then		/* RFC822 comment: quotes aren't special */
		string_lth = 0;
	     else string_lth = 2 * length (QUOTE);	/* start out with surrounding quotes */
	else return (length (p_string));		/* can use it just the way it is */

	used = 0;

	do while (used < length (p_string));
	     if ifo.rfc822_format then		/* find next character which must be escaped */
		idx = search (substr (p_string, (used + 1)), BACKSLASH_PARENS_NL);
	     else idx = search (substr (p_string, (used + 1)), QUOTE_NL);
	     if idx = 0 then idx = length (p_string) - used + 1;
	     string_lth = string_lth + idx - 1;
	     used = used + idx - 1;			/* skip past normal characters */
	     if used < length (p_string) then do;
		string_lth = string_lth + 2;		/* escape character (quote/backslash) plus the character */
		used = used + 1;
		if ifo.rfc822_format then		/* for RFC822: newlines are printed as three characters */
		     if substr (p_string, used, 1) = NL then string_lth = string_lth + 1;
	     end;
	end;

	return (string_lth);

     end comment_length;
%page;
/* Places phrases which appear outside of comments and structured addresses into the output buffer */

format_simple_strings:
     procedure (p_string);

	return;					/* not an entrypoint */

dcl  p_string character (*) varying parameter;

dcl  1 the_string aligned based (addr (p_string)),
       2 lth fixed binary (21),
       2 string character (maxlength (p_string));

dcl  the_character character (1);
dcl  must_requote bit (1) aligned;
dcl  (used, idx) fixed binary (21);


format_phrase_string:				/* RFC822 format may contain spaces but no unquoted periods */
     entry (p_string);

	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote =
		(search (p_string, TOP_LEVEL_RFC822_REQUOTE) ^= 0) | (index (p_string, PERIOD) ^= 0)
		| (index (p_string, SPSP) ^= 0);
	else must_requote = (search (p_string, TOP_LEVEL_REQUOTE) ^= 0) | (index (p_string, SPSP) ^= 0);
	go to OUTPUT_THE_STRING;


format_top_level_string:				/* RFC822 format must be quoted for single spaces */
     entry (p_string);

	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote = (search (p_string, TOP_LEVEL_RFC822_REQUOTE) ^= 0) | (index (p_string, SP) ^= 0);
	else must_requote = (search (p_string, TOP_LEVEL_REQUOTE) ^= 0) | (index (p_string, SPSP) ^= 0);


OUTPUT_THE_STRING:
	if ^must_requote then do;			/* simplest case: just put it out verbatim */
	     call add_to_buffer_varying (p_string);
	     return;
	end;

	call add_to_buffer_fixed (QUOTE);

	used = 0;

	do while (used < length (p_string));
	     if ifo.rfc822_format then		/* find next character which must be escaped */
		idx = search (substr (p_string, (used + 1)), BACKSLASH_QUOTE_NL);
	     else idx = search (substr (p_string, (used + 1)), QUOTE_NL);
	     if idx = 0 then idx = length (p_string) - used + 1;
	     if idx > 1 then call add_to_buffer (addcharno (addr (the_string.string), used), (idx - 1));
	     used = used + idx - 1;			/* skip past normal characters */
	     if used < length (p_string) then do;	/* process the special character */
		used = used + 1;
		the_character = substr (p_string, used, 1);
		if ifo.rfc822_format then do;
		     call add_to_buffer_fixed (BACKSLASH);
		     call add_to_buffer_fixed (the_character);
		     if the_character = NL then call add_to_buffer_fixed (SP);
		end;
		else do;
		     if the_character = QUOTE then
			call add_to_buffer_fixed (QUOTE_QUOTE);
		     else call add_to_buffer_fixed (NLSP);
		end;
	     end;
	end;

	call add_to_buffer_fixed (QUOTE);		/* close the string */

	return;

     end format_simple_strings;
%page;
/* format: ^indcomtxt */

/* Places a structured address into the output buffer:  When generating Multics format, the entire address is left
   unquoted (ie: the braces ({}) are the first and last characters of the address) and the arguument string, if any, is
   quoted if necessary.  When generating RFC822 format, however, the entire address is quoted as it would be syntactically
   incorrect otherwise.  Further, if the argument string needs quoting, it is done using the Multics doubling convention
   with the RFC822 backslash escape added on top.  In other words, if the printed presentation on Multics is

				  {list ">udd>""Multi Homed"">hackers"}

   then the RFC822 representation will be

			        "{list \">udd>\"\"Multi Homed\"\">hackers\"}"
   */

/* format: indcomtxt */

format_structured_string:
     procedure (p_address_type_string, p_string);

dcl  p_address_type_string character (*) parameter;
dcl  p_string character (*) varying parameter;

dcl  1 the_string aligned based (addr (p_string)),
       2 lth fixed binary (21),
       2 string character (maxlength (p_string));

dcl  the_character character (1);
dcl  must_requote bit (1) aligned;
dcl  (used, idx) fixed binary (21);


	if ifo.rfc822_format then			/* always quote these addresses in RFC 822 land */
	     call add_to_buffer_fixed (QUOTE_LEFT_BRACE);
	else call add_to_buffer_fixed (LEFT_BRACE);

	call add_to_buffer_fixed (p_address_type_string);

	if length (p_string) > 0 then do;		/* it has an argument ... */
	     call add_to_buffer_fixed (SP);

	     if ifo.rfc822_format then		/* check for requoting with the proper specials */
		must_requote = (search (p_string, STRUCTURED_RFC822_REQUOTE) ^= 0);
	     else must_requote = (search (p_string, STRUCTURED_REQUOTE) ^= 0);

	     if must_requote then do;			/* start out with surrounding quotes */
		if ifo.rfc822_format then		/* ... these quotes are within quotes: preceed them "\" */
		     call add_to_buffer_fixed (BACKSLASH_QUOTE);
		else call add_to_buffer_fixed (QUOTE);

		used = 0;

		do while (used < length (p_string));
		     if ifo.rfc822_format then	/* find next character which must be escaped */
			idx = search (substr (p_string, (used + 1)), BACKSLASH_QUOTE_NL);
		     else idx = search (substr (p_string, (used + 1)), QUOTE_NL);
		     if idx = 0 then idx = length (p_string) - used + 1;
		     if idx > 1 then call add_to_buffer (addcharno (addr (the_string.string), used), (idx - 1));
		     used = used + idx - 1;		/* skip past normal characters */
		     if used < length (p_string) then do;
						/* needs to be quoted */
			used = used + 1;
			the_character = substr (p_string, used, 1);
			if ifo.rfc822_format then do;
			     if the_character = QUOTE then do;
				call add_to_buffer_fixed (BACKSLASH_QUOTE);
				call add_to_buffer_fixed (BACKSLASH_QUOTE);
			     end;
			     else do;
				call add_to_buffer_fixed (BACKSLASH);
				call add_to_buffer_fixed (the_character);
				if the_character = NL then call add_to_buffer_fixed (SP);
			     end;
			end;
			else do;			/* Multics format */
			     if the_character = QUOTE then
				call add_to_buffer_fixed (QUOTE_QUOTE);
			     else call add_to_buffer_fixed (NLSP);
			end;
		     end;
		end;

		if ifo.rfc822_format then
		     call add_to_buffer_fixed (BACKSLASH_QUOTE);
		else call add_to_buffer_fixed (QUOTE);
	     end;

	     else call add_to_buffer_varying (p_string);
	end;

	if ifo.rfc822_format then
	     call add_to_buffer_fixed (RIGHT_BRACE_QUOTE);
	else call add_to_buffer_fixed (RIGHT_BRACE);

	return;

     end format_structured_string;
%page;
/* Places a comment into the output buffer */

format_comment_string:
     procedure (p_string);

dcl  p_string character (*) varying parameter;

dcl  1 the_string aligned based (addr (p_string)),
       2 lth fixed binary (21),
       2 string character (maxlength (p_string));

dcl  the_character character (1);
dcl  must_requote bit (1) aligned;
dcl  (used, idx) fixed binary (21);

	call add_to_buffer_fixed (SP_OPEN_PAREN);

	if ifo.rfc822_format then			/* check for requoting with the proper specials */
	     must_requote = (search (p_string, COMMENT_RFC822_REQUOTE) ^= 0);
	else must_requote = (search (p_string, COMMENT_REQUOTE) ^= 0);

	if must_requote then do;			/* there are special characters in the comment */
	     if ^ifo.rfc822_format then		/* Multics supports quoted comments */
		call add_to_buffer_fixed (QUOTE);

	     used = 0;

	     do while (used < length (p_string));
		if ifo.rfc822_format then		/* find next character which must be escaped */
		     idx = search (substr (p_string, (used + 1)), BACKSLASH_PARENS_NL);
		else idx = search (substr (p_string, (used + 1)), QUOTE_NL);
		if idx = 0 then idx = length (p_string) - used + 1;
		if idx > 1 then call add_to_buffer (addcharno (addr (the_string.string), used), (idx - 1));
		used = used + idx - 1;		/* skip past normal characters */
		if used < length (p_string) then do;
		     used = used + 1;
		     the_character = substr (p_string, used, 1);
		     if ifo.rfc822_format then do;
			call add_to_buffer_fixed (BACKSLASH);
			call add_to_buffer_fixed (the_character);
			if the_character = NL then call add_to_buffer_fixed (SP);
		     end;
		     else do;
			if the_character = QUOTE then
			     call add_to_buffer_fixed (QUOTE_QUOTE);
			else call add_to_buffer_fixed (NLSP);
		     end;
		end;
	     end;

	     if ^ifo.rfc822_format then call add_to_buffer_fixed (QUOTE);
	end;

	else call add_to_buffer_varying (p_string);

	call add_to_buffer_fixed (CLOSE_PAREN);

	return;

     end format_comment_string;
%page;
/* Returns either 0 or 2 depending on whether something will be surrounded by quotes in RFC822 format text */

quotes_if_rfc822:
     procedure () returns (fixed binary);

	if ifo.rfc822_format then
	     return (2);
	else return (0);

     end quotes_if_rfc822;



/* Start a new line with the level of indentation presently in effect */

new_line:
     procedure ();

dcl  n_spaces_to_add fixed binary (21);

	call add_to_buffer_fixed (NL);

	n_spaces_to_add = ifo.indentation;
	do while (n_spaces_to_add > length (SPACES));
	     call add_to_buffer_fixed (SPACES);
	     n_spaces_to_add = n_spaces_to_add - length (SPACES);
	end;

	call add_to_buffer (addr (SPACES), n_spaces_to_add);

	return;

     end new_line;
%page;
/* Output a piece of text to the buffer and invoke the overflow handler if necessary */

add_to_buffer:
     procedure (p_text_ptr, p_text_lth);

dcl  p_text_ptr pointer parameter;
dcl  p_text_lth fixed binary (21) parameter;
dcl  p_fixed_text character (*) parameter;
dcl  p_varying_text character (*) varying parameter;

dcl  text character (text_lth) unaligned based (text_ptr);
dcl  text_ptr pointer;
dcl  (text_lth, text_used) fixed binary (21);

dcl  1 varying_string aligned based,			/* need to know PL/I's internal format to set text_ptr */
       2 lth fixed binary (21),
       2 string character (maxlength (p_varying_text));


/* add_to_buffer: entry (p_text_ptr, p_text_lth); */

	text_ptr = p_text_ptr;
	text_lth = p_text_lth;
	go to ADD_TO_BUFFER_COMMON;


add_to_buffer_fixed:				/* a fixed length string */
     entry (p_fixed_text);

	text_ptr = addr (p_fixed_text);
	text_lth = length (p_fixed_text);
	go to ADD_TO_BUFFER_COMMON;


add_to_buffer_varying:				/* a varying length string */
     entry (p_varying_text);

	text_ptr = addr (addr (p_varying_text) -> varying_string.string);
	text_lth = length (p_varying_text);


ADD_TO_BUFFER_COMMON:
	text_used = 0;

	do while (text_used < text_lth);		/* while there's stuff left to output */
	     begin;
dcl  rest_of_text character (text_lth - text_used) unaligned defined (text) position (text_used + 1);

		begin;

dcl  rest_of_buffer character (buffer_size - buffer_used) unaligned defined (buffer) position (buffer_used + 1);

		     begin;
dcl  next_piece_of_text character (min (length (rest_of_buffer), length (rest_of_text))) unaligned defined (text)
	position (text_used + 1);

			substr (rest_of_buffer, 1, length (next_piece_of_text)) = next_piece_of_text;
			call update_last_column (next_piece_of_text);
			if ifo.count_lines then do;
			     line_count = line_count + count_lines_in_text (next_piece_of_text);
			     if substr (next_piece_of_text, length (next_piece_of_text), 1) ^= NL then
				line_count = line_count - 1;
			end;			/* ... count_lines_in_text always counts partial pieces */
			buffer_used = buffer_used + length (next_piece_of_text);
			text_used = text_used + length (next_piece_of_text);
		     end;
		end;
	     end;

	     if text_used < text_lth then		/* only can happen due to buffer overflow */
		call ifo.buffer_overflow ();
	end;

	return;



/* Internal to add_to_buffer: computes the last column occupied by the given string */

update_last_column:
	procedure (p_string);

dcl  p_string character (*) parameter;

dcl  the_character character (1);
dcl  (string_used, idx) fixed binary (21);


	     string_used = 0;

	     do while (string_used < length (p_string));

		begin;
dcl  rest_of_string character (length (p_string) - string_used) unaligned defined (p_string) position (string_used + 1);

		     idx = verify (rest_of_string, SINGLE_WIDTH_CHARACTERS);
		     if idx = 0 then idx = length (rest_of_string) + 1;

		     last_column_used = last_column_used + idx - 1;
		     string_used = string_used + idx - 1;
		end;				/* update where we are */

		if string_used < length (p_string) then do;
						/* we did find a special character */
		     the_character = substr (p_string, (string_used + 1), 1);
		     string_used = string_used + 1;

		     if the_character = HT then last_column_used = last_column_used + 10 - mod (last_column_used, 10);

		     else if the_character = BS then last_column_used = max ((last_column_used - 1), 0);

		     else if (the_character = NL) | (the_character = CR) | (the_character = VT) | (the_character = FF)
			then
			last_column_used = 0;

		     else ;			/* ... all others are non-printing */
		end;
	     end;

	     return;

	end update_last_column;

     end add_to_buffer;
%page;
/* Buffer overflow handler for the formatting entrypoints: returns error_table_$smallarg to the caller */

report_smallarg:
     procedure ();

	P_code = error_table_$smallarg;

	go to RETURN_FROM_FORMAT_ENTRY_WITH_ERROR;

     end report_smallarg;

RETURN_FROM_FORMAT_ENTRY_WITH_ERROR:
	return;



/* Buffer overflow handler for the format_address_for_ism entrypoint: returns mlsys_et_$foreign_address_too_long */

report_foreign_address_too_long:
     procedure ();

	P_code = mlsys_et_$foreign_address_too_long;

	go to RETURN_FROM_FORMAT_ENTRY_WITH_ERROR;

     end report_foreign_address_too_long;



/* Buffer overflow handler for the printing entrypoints: prints the buffer, empties it, and then continues */

print_buffer:
     procedure ();

	call iox_$put_chars (output_switch, buffer_ptr, buffer_used, code);
	if code ^= 0 then do;			/* fatal error of some kind */
	     P_code = code;
	     go to RETURN_FROM_FORMAT_ENTRY_WITH_ERROR;
	end;

	buffer_used = 0;

	return;

     end print_buffer;
%page;
/* Compare two date/times for equality with appropriate fuzz factor */

date_time_equal:
     procedure (p_date_time_1, p_date_time_2) returns (bit (1) aligned);

dcl  (p_date_time_1, p_date_time_2) fixed binary (71) parameter;

	return (abs ((p_date_time_1 - p_date_time_2)) < ONE_MINUTE);

     end date_time_equal;



/* Count the lines in a piece of text */

count_lines_in_text:
     procedure (p_text) returns (fixed binary (21));

dcl  p_text character (*) parameter;
dcl  (text_lth, n_lines, used, idx) fixed binary (21);

	text_lth = length (p_text);

	n_lines, used = 0;

	do while (used < text_lth);

	     begin;

dcl  rest_of_text character (text_lth - used) unaligned defined (p_text) position (used + 1);

		idx = index (rest_of_text, NL);
		if idx = 0 then idx = length (rest_of_text) + 1;

		n_lines = n_lines + 1;
		used = used + idx;
	     end;
	end;

	return (n_lines);

     end count_lines_in_text;
%page;
%include mlsys_format_options;
%page;
%include mlsys_field_names;
%page;
%include mlsys_message;
%page;
%include mlsys_address_types;
%page;
%include mlsys_address_list;
%page;
%include mlsys_address_route;
%page;
%include mlsys_data;
%page;
%include mlsys_internal_data;
%page;
%include mail_format;
%page;
%include mlsys_mf_extension;
%page;
%include time_names;
%page;
%include mlsys_special_chars;

     end mlsys_format_;
