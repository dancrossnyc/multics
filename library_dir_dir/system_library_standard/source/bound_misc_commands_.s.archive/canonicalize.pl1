/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1978 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(71-01-01,VanVleck), approve(), audit(), install():
      Written by THVV, date unknown (above date is made up).
  2) change(71-01-01,Vinograd), approve(), audit(), install():
      Modified by D. Vinograd to add subroutine entry (date unknown).
  3) change(78-11-01,Spector), approve(), audit(), install():
      Modified by David Spector:
      1. Bug which could cause a fatal process error fixed.
      2. Subroutine entry made to call clean_up when done.
      3. Bug in which final lines not terminated by NL, VT, or FF were deleted
         fixed.
      4. Bug in which final lines consisting only of NL, VT, or FF ("null
         lines") were deleted fixed.
      5. Command made to check for error when setting bit count of the output
         segment.
      6. Truncation of output segment now done in right place and with right
         count.
      7. Precision of several char length calculations corrected to 21 bits.
      8. Command made to check for write access to output segment.
      9. Bug in which allocated "bead" not freed upon certain errors fixed.
      10. Command made to use expand_pathname_ instead of expand_path_.
  4) change(80-03-26,Herbst), approve(), audit(), install():
      Modified by S. Herbst to leave zero-length seg alone.
  5) change(81-04-01,Wallman), approve(), audit(), install():
      Modified by E. Wallman to enforce range of printing chars.
  6) change(84-01-01,Lippard), approve(85-12-30,MCR7322),
     audit(86-01-15,KFleming), install(86-01-20,MR12.0-1006):
      Modified by Jim Lippard to:
      1. allow input tab length specification
      2. refuse to canonicalize object segments and archives
      3. not delete nonprinting characters
      4. terminate zero-length segments
      5. query if input segment is to be overwritten
      6. add the name "-ev" to "-every"
      7. optimize processing of non-overstruck data (speedup from
         Calgary's modified canonicalize by Tom Oke)
  7) change(86-02-11,Lippard), approve(86-02-11,PBF7322),
     audit(86-02-11,Dickson), install(86-02-17,MR12.0-1018):
      Modified to determine if a character is a nonprinting character
      correctly.
  8) change(86-03-06,Lippard), approve(86-03-14,MCR7371),
     audit(86-04-22,Dickson), install(86-04-22,MR12.0-1042):
      Modified to calculate the increment of col correctly.
  9) change(86-08-21,Lippard), approve(86-09-08,MCR7537),
     audit(86-09-30,Dickson), install(86-10-07,MR12.0-1178):
      Modified to properly strip white space off the ends of lines which
      contain no other characters.
 10) change(88-05-26,TLNguyen), approve(88-05-26,MCR7879),
     audit(88-10-04,RBarstad), install(90-04-12,MR12.4-1004):
     SCP6348: allow MSF in canon.
 11) change(90-03-02,LZimmerman), approve(90-03-02,MCR8158),
     audit(90-03-07,Kallstrom), install(90-04-12,MR12.4-1004):
     Correct unwarranted termination of input segment. (canonicalize_,
     canonicalize_tabs_)
                                                   END HISTORY COMMENTS */

/* format: style4 */

canonicalize:
canon:
     proc;

/* CANONICALIZE - fix file up to be canonical form. take out tabs too. (option to put in again) */

/* Syntax as a command: canon path1 {path2} {-control_args}             */


/* automatic variables */
dcl  Access_ptr ptr;				/* access pointer */
						/* the structure defined below is needed for both special cases: */
						/* SSF canonicalize MSF (expanded); MSF canonicalize SSF (shrunk) */
						/* Warning: the access structure defined below must be the same as */
						/* the access structure defined in the access_.pl1 program */
						/* access.set can be:  0 = NO, 1 = ACL_ADDED, or 2 = ACL_REPLACED */
						/* access.type can be SEGMENT, DIRECTORY, or MSF */
						/* access.old_mode to be reset when ACL_REPLACED */
						/* directory path whose access was changed */
						/* entryname whose access was changed */
dcl  1 Access aligned based (Access_ptr),
       2 version char (8),
       2 set fixed bin,
       2 type fixed bin (2),
       2 old_mode bit (36),
       2 dir char (168) unaligned,
       2 ent char char (32) unaligned;

dcl  Arg_len fixed bin;				/* length of an input argument */
dcl  Arg_numb fixed bin;				/* counter */
dcl  Arg_ptr ptr;					/* pointer to an input argument. */
dcl  Arg_count fixed bin;				/* counter */

dcl  Area_ptr ptr;
dcl  Bead_ptr ptr;
dcl  Bead_storage (1024) fixed bin;
dcl  Bead_storage_size fixed bin;
dcl  Beg_line fixed bin (21);				/* location of the beginning of the next line */
dcl  Bitc fixed bin (24);				/* bit count of an input segment */
dcl  Cantab_flag bit (1) aligned;
dcl  Chars_in_line fixed bin (21);			/* counter */
dcl  Chars_to_remove fixed bin (21);			/* counter */
dcl  Charx fixed bin;				/* counter */
dcl  Col fixed bin;					/* column position in input scan */
dcl  Create_temp_msf_flag bit (1) aligned;
dcl  Desired_access bit (36);
dcl  Dn char (168);					/* directory name of an input segment. */
dcl  Do_not_create_temp_msf_flag bit (1) aligned;
dcl  Ec fixed bin (35);				/* error code */
dcl  En char (32);					/* entryname of an input segment */
dcl  Eof_flag bit (1) aligned;			/* set when end of file of an input segment reaches. */
dcl  Eqln char (32);				/* equal entryname of an output segment.  Got from calling expand_pathname_, given an output segment pathname. */
dcl  Everytab fixed bin;
dcl  Fs_util_type char (32);				/* determine the type of a specified entry */
dcl  Have_infile_flag bit (1) aligned;			/* set if an input segment is specified */
dcl  Have_outfile_flag bit (1) aligned;			/* set if an output segment is specified */
dcl  Ii fixed bin (21);				/* counter */
dcl  In_everytab fixed bin;
dcl  In_nstops fixed bin;
dcl  In_msf_comp_bitc fixed bin (24);			/* bit count of a component of an input MSF */
						/* the number of components in an input MSF */
dcl  In_msf_total_original_comps fixed bin (24);
dcl  Input_msf_comp_index fixed bin;			/* the number of components in an input MSF */
dcl  Input_msf_comp_ptr ptr;				/* pointer to a component of an input msf */
dcl  Input_msf_fcb_ptr ptr;				/* pointer to the FCB for an input MSF */
dcl  In_stops (40) fixed bin;
dcl  In_stopx fixed bin;
dcl  Jj fixed bin (21);				/* counter */
dcl  Kk fixed bin (21);				/* counter */
dcl  Lth fixed bin (21);				/* line length */
dcl  Mm fixed bin;					/* counter */
dcl  Nch fixed bin (21);				/* population of Beads */
dcl  Next_pos fixed bin;				/* number of positions output */
dcl  Nonexistent_outfile_flag bit (1) aligned;
dcl  Nstops fixed bin;
dcl  Obuf_ptr ptr;					/* ptr to output buffer temp */
dcl  Out_seg_ptr ptr;				/* ptr to an Outc segment. */
dcl  Outc_ptr ptr;					/* ptr to Outc which holds a line of canonical characters */
dcl  Out_dname char (168);				/* a directory name contains a specified Outc file (path2) */
dcl  Out_ename char (32);				/*  an entryname of a specified Outc file (path2) */
dcl  Outc_len fixed bin (21);				/* the length of Outc which holds a line of canonical chars */
dcl  Output_segment_length_in_words fixed bin (19);
dcl  Overwrite_exist_path_flag bit (1);
dcl  Ox fixed bin (21);				/* output line index */
dcl  Spaces_to_go fixed bin;				/* counter */
dcl  Second_temp_seg_ptr ptr;
dcl  Specified_infile_type fixed bin (2);
dcl  Specified_temp_file_flag bit (1) aligned;		/* set when -temp_file PATH is specified */
dcl  Seg_ptr ptr;					/* ptr to an input segment. */
dcl  Stops (40) fixed bin;
dcl  Stopx fixed bin;				/* counter */
dcl  Subroutine_call_flag bit (1) aligned;
dcl  Tab_flag bit (1) aligned;			/* set if insert tabs. */
dcl  Target_tabstop fixed bin;
dcl  Temp_msf_comp_bitc fixed bin (24);			/* bit count of an component of an output MSF */
dcl  Temp_msf_fcb_ptr ptr;				/* pointer to the FCB for an output MSF */
dcl  Temp_ptr ptr;
dcl  Temp_dn char (168);				/* directory name contains a temp file */
dcl  Temp_en char (32);				/* temp file */
dcl  Temp_seg_len fixed bin (21);			/* the length of a temp seg */
dcl  Temp_seg_len_in_chars fixed bin (21);		/* the length of a temp seg in characters */
dcl  Temp_seg_ptr ptr;				/* points to a temp seg */
dcl  Temp_msf_total_components fixed bin (24);		/* the number of components in a temp MSF */
dcl  Temp_msf_comp_index fixed bin;
dcl  Temp_msf_comp_ptr ptr;				/* pointer to an component of an output MSF. */
dcl  This_tabstop fixed bin;

/* based */

dcl  Arg char (Arg_len) based (Arg_ptr);		/* temp storage for for each input argument on the command line. */

dcl  Bcs char (Lth) based (Seg_ptr) aligned;		/* holds the contents of the input file in NONcanonical form */

/* Temp storage for a char string in line. It has a char position and char value fields */
dcl  1 Bead (Bead_storage_size) based (Bead_ptr) aligned,
       2 loc fixed bin (26) unal,
       2 char char (1) unal;

dcl  Obuf char (512) based (Obuf_ptr);			/* holds up to 512 chars of path1 in NONcanonical form */
						/* temporary segment holds the contents of path1 in CANONICAL form */

dcl  Outc char (Outc_len) based (Outc_ptr);		/* holds the contents of one line of characters in CANONICAL form */

dcl  Second_temp_seg char (Temp_seg_len_in_chars) based (Second_temp_seg_ptr);

dcl  Temp_seg char (Temp_seg_len_in_chars) based (Temp_seg_ptr);

dcl  System_area area based (Area_ptr);

dcl  Word_array (Output_segment_length_in_words) bit (36) based;
						/* an array of an output segment in words. */

/* builtin */
dcl  (
     addr,
     copy,
     divide,
     hbound,
     index,
     max,
     min,
     null,
     rank,
     reverse,
     rtrim,
     search,
     substr,
     unspec,
     verify
     ) builtin;

/* condition */
dcl  (cleanup, record_quota_overflow) condition;

/* external entries */
dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
dcl  access_$reset entry (ptr, fixed bin (35));
dcl  access_$set_temporarily entry (char (*), char (*), fixed bin (2), bit (*), ptr, fixed bin (35));
dcl  active_fnc_err_ entry options (variable);
dcl  archive_$next_component entry (ptr, fixed bin (24), ptr, fixed bin (24), char (*), fixed bin (35));
dcl  com_err_ entry options (variable);
dcl  com_err_$suppress_name entry options (variable);
dcl  command_query_$yes_no entry () options (variable);
dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  delete_$path entry (char (*), char (*), bit (6), char (*), fixed bin (35));
dcl  dm_error_$file_in_use fixed bin (35) external;
dcl  (
     error_table_$active_function,
     error_table_$archive_pathname,
     error_table_$bad_arg,
     error_table_$badopt,
     error_table_$dirseg,
     error_table_$empty_file,
     error_table_$rqover,
     error_table_$noarg,
     error_table_$noentry,
     error_table_$no_m_permission,
     error_table_$no_r_permission,
     error_table_$no_w_permission,
     error_table_$not_seg_type,
     error_table_$zero_length_seg
     ) fixed bin (35) external;

dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  fs_util_$get_type entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_equal_name_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_group_id_ entry returns (char (32) aligned);
dcl  get_pdir_ entry returns (char (168));
dcl  get_system_free_area_ entry () returns (ptr);
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  initiate_file_$create entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
dcl  msf_manager_$adjust entry (ptr, fixed bin, fixed bin (24), bit (3), fixed bin (35));
dcl  msf_manager_$close entry (ptr);
dcl  msf_manager_$msf_get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
dcl  msf_manager_$open entry (char (*), char (*), ptr, fixed bin (35));
dcl  object_info_$brief entry (ptr, fixed bin (24), ptr, fixed bin (35));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
dcl  unique_chars_ entry (bit (*)) returns (char (15));

/* like attribute */
dcl  1 oi aligned like object_info;

/* static constants */
dcl  ACL_REPLACED fixed bin (2) int static options (constant) init (2);

dcl  HT char (1) int static options (constant) init ("	");
dcl  NLVTFF char (3) int static options (constant) init ("
");
dcl  SP char (1) int static options (constant) init (" ");
dcl  BS char (1) int static options (constant) init ("");
dcl  CR char (1) int static options (constant) init ("");
dcl  SPBSCRHT char (4) int static options (constant) init (" 	");
dcl  HTSP char (2) int static options (constant) init ("	 ");
dcl  BSCR char (2) int static options (constant) init ("");

dcl  COMPONENT_ZERO fixed bin int static options (constant) init (0);

dcl  DIRECTORY fixed bin (2) int static options (constant) init (2);
dcl  MSF fixed bin (2) int static options (constant) init (3);
dcl  SEGMENT fixed bin (2) int static options (constant) init (1);

dcl  FALSE bit (1) int static options (constant) init ("0"b);
dcl  TRUE bit (1) int static options (constant) init ("1"b);

dcl  PRECISION_FIXED_BIN_17 fixed bin int static options (constant) init (17);
dcl  PRECISION_FIXED_BIN_19 fixed bin int static options (constant) init (19);
dcl  PRECISION_FIXED_BIN_21 fixed bin int static options (constant) init (21);

dcl  SWITCHES bit (6) int static options (constant) init ("100111"b);
dcl  THREE_BIT_SWITCH bit (3) int static options (constant) init ("111"b);

dcl  ME char (12) int static options (constant) init ("canonicalize");

/* -------------------------------------------------------------------------- */
%page;
/* begin canonicalize main program */

	call initialization;

	call parsing_input_arguments;
	if Ec ^= 0 then return;

	if ^Have_infile_flag then do;			/* forget path1 */
	     call com_err_$suppress_name ((0), ME, "Usage: ^a path1 {path2} {-control_args}", ME);
	     return;
	end;
						/* prepare access values for later reference */
	if ^Have_outfile_flag then
	     Desired_access = RW_ACCESS;		/* when wanted to overwrite the original input file (segment or MSF) */
	else Desired_access = R_ACCESS;		/* otherwise, only "read" access is needed */

	on cleanup begin;
	     call clean_up;
	     call term_segs;
	end;
	

/* mainly proceeds canonicalization of an input file whose type is either a Segment or a Multisegment_file */
	call get_temp_segment_ (ME, Outc_ptr, Ec);	/* points to a temp storage Outc which holds one line of canincal chars */
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "Cannot get temp segment.");
	     return;
	end;

	if ^Specified_temp_file_flag then do;		/* by default, create a temp seg in the process directory */
						/* points to a temp storage Temp_seg which holds a segment size of canonical chars */
	     call get_temp_segment_ (ME, Temp_seg_ptr, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME, "Cannot get temp segment.");
		return;
	     end;
	end;
	else do;					/* -temp_file PATH was specified */
	     call hcs_$make_seg (Temp_dn, Temp_en, "", RW_ACCESS_BIN, Temp_seg_ptr, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME, "^a", pathname_ (Temp_dn, Temp_en));
		return;
	     end;
	end;

/* determine the entry type of an input file path1 and its length in bits */
	call hcs_$status_minf (Dn, En, 1, Specified_infile_type, Bitc, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "^a", pathname_ (Dn, En));
	     call release_temp_segment_ (ME, Outc_ptr, (0));
	     call release_temp_segment_ (ME, Temp_seg_ptr, (0));
	     return;
	end;

	if Specified_infile_type = SEGMENT then
	     call canon_segment;

	else if Specified_infile_type = DIRECTORY then
	     call canon_msf;

	else do;
	     call com_err_ (error_table_$not_seg_type, ME, "^a", pathname_ (Dn, En));
	     call release_temp_segment_ (ME, Outc_ptr, (0));
	     call release_temp_segment_ (ME, Temp_seg_ptr, (0));
	     return;
	end;

	call clean_up;
	call term_segs;


	return;					/* complete canonicalize main program */

/* --------------------------------------------------------------------------- */
%page;
parsing_input_arguments: proc;

/* evaluate each input argument specified on the command level.              */

/* begin parsing_input_arguments procedure */

	Ec = 0;

	call cu_$arg_count (Arg_count, Ec);
	if Ec ^= 0 then do;
	     if Ec = error_table_$active_function then call active_fnc_err_ (Ec, ME);
	     else call com_err_ (Ec, ME);
	     return;
	end;

	do Arg_numb = 1 to Arg_count;
	     call cu_$arg_ptr (Arg_numb, Arg_ptr, Arg_len, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME);
		return;
	     end;

	     if index (Arg, "-") = 1 then do;
		if Arg = "-output_tabs" | Arg = "-otabs" then do;
		     Tab_flag = TRUE;

		     Arg_numb = Arg_numb + 1;
		     if Arg_numb > Arg_count then do;
			Ec = error_table_$noarg;
			call com_err_ (Ec, ME);
			return;
		     end;

		     call continue_parsing_arguments;
		     if Ec ^= 0 then return;
		end;
		else if Arg = "-no_output_tabs" | Arg = "-notabs" then Tab_flag = FALSE;
		else if Arg = "-input_tabs" | Arg = "-itabs" then do;
		     Arg_numb = Arg_numb + 1;
		     if Arg_numb > Arg_count then do;
			Ec = error_table_$noarg;
			call com_err_ (Ec, ME);
			return;
		     end;

		     call continue_parsing_arguments;
		     if Ec ^= 0 then return;
		end;
		else if Arg = "-force" | Arg = "-fc" then Overwrite_exist_path_flag = TRUE;
		else if Arg = "-no_force" | Arg = "-nfc" then Overwrite_exist_path_flag = FALSE;
		else if Arg = "-temp_file" | Arg = "-tf" then do;
		     Specified_temp_file_flag = TRUE;

		     if Arg_numb = Arg_count then do;	/* -temp_file */
			Ec = -1;
			call com_err_ (0, ME, "Missing PATH argument for ^a.", Arg);
			return;
		     end;
		     else do;			/* -temp_file PATH */
			Arg_numb = Arg_numb + 1;
			call cu_$arg_ptr (Arg_numb, Arg_ptr, Arg_len, Ec);
			if Ec ^= 0 then do;
			     call com_err_ (Ec, ME, "Cannot get PATH argument for -temp_file.");
			     return;
			end;

			if index (Arg, "-") = 1 then do;
						/* -temp_file -bad_input_argument */
			     Ec = error_table_$badopt;
			     call com_err_ (Ec, ME, "^a.  Missing PATH argument for -temp_file.", Arg);
			     return;
			end;

			call expand_pathname_ (Arg, Temp_dn, Temp_en, Ec);
			if Ec ^= 0 then do;
			     call com_err_ (Ec, ME, "Cannot expand the given PATH argument ^a for -temp_file.", Arg);
			     return;
			end;
						/* since  the equal convention is allowed to specify a temp file similar to the input file */
			call get_equal_name_ (En, Temp_en, Temp_en, Ec);

			if Ec ^= 0 then do;
			     call com_err_ (Ec, ME, "Cannot get an equal name similar to the original input file name ^a", pathname_ (Dn, En));
			     return;
			end;
		     end;
		end;
		else do;
		     Ec = error_table_$badopt;
		     call com_err_ (Ec, ME, "^a", Arg);
		     return;
		end;
	     end;
	     else if ^Have_infile_flag then do;
		call expand_pathname_ (Arg, Dn, En, Ec);
		if Ec ^= 0 then do;
		     call com_err_ (Ec, ME, "Cannot expand the given input path1 ^a", Arg);
		     return;
		end;
		Have_infile_flag = TRUE;
	     end;
	     else if ^Have_outfile_flag then do;
		Have_outfile_flag = TRUE;
		call expand_pathname_ (Arg, Out_dname, Eqln, Ec);
		if Ec ^= 0 then do;			/* name for output seg */
		     call com_err_ (Ec, ME, "Cannot expand the specified output path2 ^a", Arg);
		     return;
		end;

		call get_equal_name_ (En, Eqln, Out_ename, Ec);
		if Ec ^= 0 then do;
		     call com_err_ (Ec, ME, "Cannot get an equal name similar to the original file name ^a", pathname_ (Dn, En));
		     return;
		end;
	     end;
	     else do;
		Ec = error_table_$bad_arg;
		call com_err_$suppress_name (Ec, ME, "Usage: ^a path1 {path2} {-control_args}", ME);
		return;
	     end;
	end;

	return;					/* return from parsing_input_arguments procedure to canonicalize main program */

/* --------------------------------------------------------------------------- */
%page;
continue_parsing_arguments: proc;

	     call cu_$arg_ptr (Arg_numb, Arg_ptr, Arg_len, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME, "^a", Arg);
		return;
	     end;

	     if Arg = "-every" | Arg = "-ev" then do;
		Arg_numb = Arg_numb + 1;
		if Arg_numb > Arg_count then do;
		     Ec = error_table_$noarg;
		     call com_err_ (Ec, ME, "Missing value for ^a", Arg);
		     return;
		end;

		call cu_$arg_ptr (Arg_numb, Arg_ptr, Arg_len, Ec);
		if Ec ^= 0 then do;
		     call com_err_ (Ec, ME);
		     return;
		end;

		if Tab_flag then Everytab = cv_dec_check_ (Arg, Ec);
		else In_everytab = cv_dec_check_ (Arg, Ec);

		if Ec ^= 0 then do;
		     Ec = error_table_$bad_arg;
		     call com_err_ (Ec, ME, "^a", Arg);
		     return;
		end;
	     end;
	     else do;
		if Tab_flag then call grab_tabs (Stops, Nstops);
		else call grab_tabs (In_stops, In_nstops);

		if Ec ^= 0 then return;
	     end;

	     return;				/* return to parsing_input_arguments procedure */

	end continue_parsing_arguments;

/* --------------------------------------------------------------------------- */
%page;
grab_tabs: proc (p_stops, p_nstop);


dcl  p_nstop fixed bin,				/* number of stops set */
     p_stops (*) fixed bin;				/* array of set tab stops */

/* begin grab_tabs procedure */

	     Ec = 0;
	     Kk = 1;
	     do while (Kk < Arg_len);
		Jj = index (substr (Arg, Kk), ",");
		if Jj = 0 then Jj = Arg_len - Kk + 2;

		Mm = cv_dec_check_ (substr (Arg, Kk, Jj - 1), Ec);
		if Ec ^= 0 then do;
		     Ec = error_table_$bad_arg;
		     call com_err_ (Ec, ME, "^a", substr (Arg, Kk, Jj - 1));
		     return;
		end;

		p_nstop = p_nstop + 1;
		if p_nstop > hbound (p_stops, 1) - 1 then do;
		     Ec = -1;			/* indicates error */
		     call com_err_ (0, ME, "Too many ^[output^;input^] tabstops: ^d - max is ^d", Tab_flag, Mm, hbound (p_stops, 1) - 1);
		     return;			/* we blew it */
		end;

		p_stops (p_nstop) = Mm;
		Kk = Kk + Jj;
	     end;

	     return;				/* return to parsing_input_arguments. */

	end grab_tabs;

/* --------------------------------------------------------------------------- */
%page;
     end parsing_input_arguments;

/* --------------------------------------------------------------------------- */
%page;
canonicalize_tabs_:
     entry (p_input_ptr, p_input_len, p_output_ptr, p_output_len, p_tab_flag, p_code);

dcl  p_tab_flag bit (1);				/* input parameter */

/* begin canonicalize_tabs_ external entry */

	call initialization;

	Tab_flag = p_tab_flag;
	if Tab_flag then Everytab = 10;

	goto NON_MSF_COMMON;

/* ----------------------------------------------------------------------- */

canonicalize_:
     entry (p_input_ptr, p_input_len, p_output_ptr, p_output_len, p_code);

dcl  p_code fixed bin (35);
dcl  p_input_ptr ptr;
dcl  p_input_len fixed bin (21);
dcl  p_output_ptr ptr;
dcl  p_output_len fixed bin (21);

/* begin canonicalize_ entry */

	call initialization;

NON_MSF_COMMON:
	p_code = 0;
						/* prepare canonicalization of the given input file whose type is segment */
	Seg_ptr = p_input_ptr;
	Lth = p_input_len;

	if Lth = 0 then do;				/* the given input file is empty */
	     p_code = error_table_$zero_length_seg;
	     return;
	end;

	on cleanup call clean_up;

	call get_temp_segment_ (ME, Outc_ptr, p_code);	/* each line of the input file is canonicalized and then a line of */
						/* canonical characters are stored in a temp segment pointed by Outc_ptr pointer */
	if p_code ^= 0 then return;

/* the entire input file is canonicalized and then the entire canonical */
/* characters are stored in a temp segment pointed by Temp_seg_ptr pointer */
	call get_temp_segment_ (ME, Temp_seg_ptr, p_code);
	if p_code ^= 0 then return;
						/* do not create a temp MSF when canonicalization of an input file */
						/* causes a temp segment reach its max seg size while canonicalization is in progress */
	Do_not_create_temp_msf_flag = TRUE;

	call do_canon;				/* convert the contents of the input SSF into a canonical form */

	if Ec ^= 0 then p_code = Ec;
	else do;
	     p_output_ptr -> Temp_seg = Temp_seg;	/* copy Temp_seg into a specified output file whose type is segment */
	     p_output_len = Temp_seg_len_in_chars;	/* update the length of the output file */
	end;

Seg_ptr = null;

	call clean_up;

	return;					/* complete either canonicalize_tabs_ or canonicalize_ */

/* --------------------------------------------------------------------------- */
%page;
validate_access: proc (p_dir, p_ename, p_type, p_desired_access, p_overwritten_flag);

/* validate the access modes of the directory input parameter.  If that      */
/* directory doesn't have a "modify" mode then canon reports an error.       */
/* Otherwise, an appropriate queried message will be printed when an user    */
/* wanted to overwrite an input path1 or a specified existent output path2,  */
/* but he either did not have a "write" access mode to it or has a           */
/* sufficient access (rew or rw) to it.                                      */
/* For the case of unsufficient access, if he answers yes to the question,   */
/* a "write" mode is TEMPORARILY set on it.  Otherwise, canon returns to the */
/* command level.                                                            */

/* in/out parameters */
dcl  p_desired_access bit (*);			/* input */
dcl  (p_dir, p_ename) char (*);			/* input */
dcl  p_type char (*);				/* input */
dcl  p_overwritten_flag bit (1);			/* input/output */

/* local */
dcl  full_pathname char (168);
dcl  grand_dn char (168);
dcl  mode fixed bin (5);
dcl  msf_directory_pathname char (168);
dcl  parents_dn char (32);
dcl  ring fixed bin;
dcl  user_id char (32);

/* begin validate_access procedure */

	Ec = 0;
	full_pathname = " ";
	grand_dn = " ";
	mode = 0;
	msf_directory_pathname = " ";
	parents_dn = " ";
	ring = -1;				/* indicates that a default value of the validation level of the calling process is used */
	user_id = " ";

	on cleanup call clean_up;

	call absolute_pathname_ (p_dir, full_pathname, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "Cannot get the absolute pathname of the directory ^a", p_dir);
	     return;
	end;
	call expand_pathname_ (full_pathname, grand_dn, parents_dn, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "Cannot expand the directory ^a", full_pathname);
	     return;
	end;

	user_id = get_group_id_ ();
	call hcs_$get_user_effmode (grand_dn, parents_dn, user_id, ring, mode, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "Cannot get the user effective mode of directory ^a", pathname_ (grand_dn, parents_dn));
	     return;
	end;

	if (mode ^= M_ACCESS_BIN) & (mode ^= SM_ACCESS_BIN) & (mode ^= SMA_ACCESS_BIN) then do;
	     Ec = error_table_$no_m_permission;
	     call com_err_ (Ec, ME, "^a", pathname_ (grand_dn, parents_dn));
	     return;
	end;

	if p_type = FS_OBJECT_TYPE_SEGMENT then do;
	     call command_query_$yes_no (p_overwritten_flag, (0), ME, "", "Do you want to update the protected file ^a?", pathname_ (p_dir, p_ename));
	     if ^p_overwritten_flag then return;

	     call access_$set_temporarily (p_dir, p_ename, SEGMENT, p_desired_access, Access_ptr, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME, "Cannot set ""write"" access mode on ^a", pathname_ (p_dir, p_ename));
		return;
	     end;
	end;

	if p_type = FS_OBJECT_TYPE_MSF then do;
	     msf_directory_pathname = pathname_ (p_dir, p_ename);
	     call hcs_$get_user_effmode (msf_directory_pathname, "0", user_id, ring, mode, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME, "Cannot get effective access mode of component 0 for MSF ^a", pathname_ (p_dir, p_ename));
		return;
	     end;

	     if (mode = N_ACCESS_BIN) | (mode = E_ACCESS_BIN) | (mode = W_ACCESS_BIN) then do;
		Ec = error_table_$no_r_permission;
		call com_err_ (Ec, ME, "^a", pathname_ (p_dir, p_ename));
		return;
	     end;

	     else if (mode = R_ACCESS_BIN) | (mode = RE_ACCESS_BIN) then do;
		call command_query_$yes_no (p_overwritten_flag, (0), ME, "", "Do you want to update the protected file ^a?",
		     pathname_ (p_dir, p_ename));
		if ^p_overwritten_flag then return;
						/* add a "write" access mode temporarily on a "read" only MSF */
		call access_$set_temporarily (p_dir, p_ename, MSF, p_desired_access, Access_ptr, Ec);
		if Ec ^= 0 then do;
		     call com_err_ (Ec, ME, "Cannot set ""write"" access  mode on ^a", pathname_ (p_dir, p_ename));
		     return;
		end;
	     end;
						/* ask for overwritten a specified existent MSF after finding that */
						/* it has a sufficient ACL (either RW_ACCESS_BIN or REW_ACCESS_BIN */
	     else call command_query_$yes_no (p_overwritten_flag, (0), ME, "", "Do you want to overwrite ^a?", pathname_ (p_dir, p_ename));
	end;

	return;

     end validate_access;

/* --------------------------------------------------------------------------- */
%page;
canon_msf: proc;

/* given an input file whose type is MSF, an user's request was wanted to   */
/* convert its NONCANONICAL characters into a CANONICAL form.               */
/* The canonical data can be put either back into that input file if wanted */
/* to overwrite it (e.g. canon infile_MSF) or into a specified  output      */
/* file (e.g. canon infile_MSF existent_or_nonexistent_outfile).  Note      */
/* that a specified output file can be ALREADY existed in an user's working */
/* working directory or NOT existed yet.                                    */
/*                                                                          */
/* If an output path2 is specified and is not existed yet in the current    */
/* working directory, it will be created in one of the following methods:   */
/*    (a) by calling initiate_file_$create when canonicalization of the     */
/*        input MSF gives canonical characters which are stored in the      */
/*        Temp_seg and Temp_seg length has NEVER reached its max segment    */
/*        length.                                                           */
/*    (b) by creating a temporary MSF when canonicalization of the input    */
/*        MSF gives canonical characters which are stored in the Temp_seg   */
/*        and Temp_seg length has reached its maximum segment length        */
/*        AT LEAST ONCE while canonicalization is in progress.  This causes */
/*        a temp MSF to be created to copy Temp_seg's contents into an      */
/*        appropriate component of the temp MSF in order to continue        */
/*        canonicalization of the remaining components of the input MSF.    */
/*                                                                          */
/* There are two cases for processing canonicalization of the original      */
/* inut file whose entry type is Multissegment file (MSF):                  */
/*    Case 1: MSF canonicalize MSF (unchanged: type is unchanged)           */
/*           Canonicalization of an input file, whose type is MSF, gives    */
/*           canonical characters to be stored in an output file.           */
/*           The length of the canonical output file is GREATER than the    */
/*           max length of a segment.  So its type is MSF which is the same */
/*           type as the type of the noncanonical input file path1.         */
/*                                                                          */
/*    Case 2: MSF canonicalize SSF (shrink: type changed from MSF to SSF)   */
/*            Canonicalization of an input file path1, whose type is MSF,   */
/*            gives canonical characters to be stored in an output file.    */
/*            The length of the canonical output file is LESS or EQUAL than */
/*            the max length of a segment.  So the type of the canonical    */
/*            output file is SSF which is different type with the           */
/*            noncanonical input file path1 whose type is MSF.              */
/*                                                                          */


/* begin canon_msf procedure */

	In_msf_total_original_comps = Bitc;		/* save the total components of the input path1 MSF for later reference */

	on cleanup call clean_up;

	if Bitc = 0 then do;			/* the input path1 is a directory type which is not allowed for canon. */
	     call com_err_ (error_table_$dirseg, ME, "Cannot canonicalize a directory.  ^a", pathname_ (Dn, En));
	     return;
	end;
						/* make sure that acceptable path1 type is either segment or Multisegment-file. */
	call get_specified_file_type (Dn, En, Fs_util_type);
	if Ec ^= 0 then return;

	if ^Have_outfile_flag then do;		/* only an input path1 is specified */
	     call validate_access (Dn, En, Fs_util_type, RW_ACCESS, Overwrite_exist_path_flag);
	     if Ec ^= 0 then return;

	     if ^Overwrite_exist_path_flag then return;	/* did not want to overwrite the input path2 MSF */
	end;
	else do;					/* an output file path2 is specified */
	     call initiate_specified_output_file;
	     if Ec ^= 0 then return;
						/* the specified output file path2 exists and do not want to overwrite it */
	     if ^Nonexistent_outfile_flag & ^Overwrite_exist_path_flag then return;
	end;

/* open the specified input path1 whose type is MSF */
	call msf_manager_$open (Dn, En, Input_msf_fcb_ptr, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "Cannot open MSF input file.   ^a", pathname_ (Dn, En));
	     return;
	end;
						/* for each component of input path1 MSF, call do_canon to convert */
						/* its noncanonical data into a canonical data which stored in Temp_seg */
	do Input_msf_comp_index = COMPONENT_ZERO to (In_msf_total_original_comps - 1);
						/* get a specified component of the input file path1 whose type is MSF */
	     call msf_manager_$msf_get_ptr (Input_msf_fcb_ptr, Input_msf_comp_index, FALSE, Input_msf_comp_ptr, In_msf_comp_bitc, Ec);
	     if Ec ^= 0 then do;			/* the input MSF and the temp MSF will be closed in the clean_up internal proc */
		if Seg_ptr ^= null then		/* sp points to a specified component of the input file (MSF) path1 */
		     Seg_ptr = null;		/* do not call terminate_file_ to terminate the current component of the input MSF */
		call com_err_ (Ec, ME, "Cannot get component ^d of input MSF ^a.", Input_msf_comp_index, pathname_ (Dn, En));
		return;
	     end;

	     Seg_ptr = Input_msf_comp_ptr;		/* prepare for converting a particular component's contents into a canonical form */
						/* calculate the length of that component in characters */
	     Lth = divide (In_msf_comp_bitc + (BITS_PER_CHAR - 1), BITS_PER_CHAR, PRECISION_FIXED_BIN_21, 0);

	     if Lth = 0 then do;
		Seg_ptr = null;			/* do not call terminate_file_ to terminate the current component of an input MSF */
		Ec = error_table_$empty_file;
		call com_err_ (Ec, ME, "The component ^d of the input MSF ^a is empty.", Input_msf_comp_index, rtrim (pathname_ (Dn, En)));
		return;
	     end;

	     call do_canon;				/* perform canonicalization of a specified component of the input MSF */

	     if Ec ^= 0 then do;			/* the input MSF path1 and temp MSF will be closed in the clean_up int.proc */
		Seg_ptr = null;			/* do not call terminate_file_ to terminate the current component of an input MSF */
		return;
	     end;

	     Eof_flag = FALSE;			/* prepare to convert the next component's contents of the input MSF into a canonical form */
	end;					/* complete read in components of the input path1 MSF */

	if ^Create_temp_msf_flag then do;		/* case: MSF canonicalize SSF SHRUNK */
	     if ^Have_outfile_flag then do;		/* wanted to overwrite the input path1 MSF */
		call copy_temp_seg_into_msf (Dn, En, Input_msf_fcb_ptr, COMPONENT_ZERO, Input_msf_comp_ptr, In_msf_comp_bitc,
		     Temp_msf_total_components);
		if Ec ^= 0 then return;

		call msf_manager_$adjust (Input_msf_fcb_ptr, COMPONENT_ZERO, In_msf_comp_bitc, THREE_BIT_SWITCH, Ec);
		if Ec ^= 0 then do;			/* the input MSF path1 will be closed in the clean_up internal proc. */
		     Seg_ptr = null;		/* do not call terminate_file_ to terminate the current component of an input MSF */
		     call com_err_ (Ec, ME, "Cannot adjust component ^d of MSF  ^a", COMPONENT_ZERO, rtrim (pathname_ (Dn, En)));
		     return;
		end;
	     end;					/* only the input path1 was specified */
	     else do;				/* output path2 was specified */
		if Out_seg_ptr ^= null then		/* the specified output path2 exists and its type is SSF */
						/* put the contents of Temp_seg into a specified existent output path2 SSF */
		     call copy_temp_seg_into_segment;

		else if Nonexistent_outfile_flag then do;
						/* output path2 was specified and did not exist yet since Out_seg_ptr value is null */
						/* so, creates and initiates the specified nonexistent output path2 */
		     call initiate_file_$create (Out_dname, Out_ename, RW_ACCESS, Out_seg_ptr, Nonexistent_outfile_flag, Bitc, Ec);
		     if Ec ^= 0 then do;		/* will close the input MSF path1 in the clean_up internal proc. */
			Seg_ptr = null;		/* do not call terminate_file_ to terminate the current component of an input MSF */
			call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
			return;
		     end;
						/* copy the contents of Temp_seg into a newly created segment */
		     call copy_temp_seg_into_segment;
		end;				/* output path2 was specified and did not exist yet */

		else if Fs_util_type = FS_OBJECT_TYPE_MSF then do;
						/* copy Temp_seg into the specified output path2 whose type is MSF */
		     call copy_temp_seg_into_spec_pth2_MSF;
		     if Ec ^= 0 then do;		/* will close the input MSF path1 in the clean_up internal proc. */
			Seg_ptr = null;		/* do not call terminate_file_ to terminate the current component of an input MSF */
			return;
		     end;
		end;				/* copy Temp_seg into a specified existent path2 whose type is MSF */
	     end;					/* copy Temp_seg into a specified path2 whose type is either SSF or MSF */
	end;					/* case: MSF canonicalize SSF SHRUNK */
	else do;					/* case: MSF canonicalize MSF UNCHANGED */
	     if Temp_seg_len_in_chars > 0 then do;
		call temp_seg_to_temp_msf;		/* copy Temp_seg into a the next created component of a temp MSF */
		if Ec ^= 0 then return;		/* will close the input MSF path1 in the clean_up; temp MSF is already closed */
	     end;

	     if ^Have_outfile_flag then do;		/* only the input MSF path1 was specified */
		call temp_msf_to_infile_or_outfile (Dn, En);
		if Ec ^= 0 then return;
	     end;
	     else do;
						/* open the specified output file path2 */
		call msf_manager_$open (Out_dname, Out_ename, Input_msf_fcb_ptr, Ec);
		if Ec ^= 0 then do;
		     if Ec ^= error_table_$noentry then do;
			call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
			return;
		     end;
		     else Ec = 0;			/* no problem.  It will be created soon by the call to msf_manager_$msf_get_ptr */
		end;
						/* copy temp MSF into the specified output file */
		call temp_msf_to_infile_or_outfile (Out_dname, Out_ename);
		if Ec ^= 0 then return;

		if Out_seg_ptr ^= null then Out_seg_ptr = null; /* points to a specified output SSF path2.  Do not call terminate_file_ */
	     end;					/* output file path2 was specified */
	end;					/* case: MSF canonicalize MSF UNCHANGED */

	return;

     end canon_msf;

/* ------------------------------------------------------------------------ */
%page;
canon_segment: proc;

/* given an input file whose type is Segment, an user's request was to      */
/* convert its NONCANICAL characters into a CANONICAL form.                 */
/* Canonical chars can be put either back into that input file if wanted    */
/* to overwrite it (e.g. canon infile_MSF) or into a specified  output      */
/* file (e.g. canon infile_MSF existent_or_nonexistent_outfile).  Note      */
/* that a specified output file can be ALREADY existed in an user's working */
/* working directory or NOT existed yet.                                    */
/*                                                                          */
/* If an output path2 is specified and is not existed yet in the current    */
/* working directory, it will be created in one of the following methods:   */
/*    (a) by calling initiate_file_$create when canonicalization of the     */
/*        input SSF gives canonical characters which are stored in the      */
/*        Temp_seg and Temp_seg length has NEVER reached its max segment    */
/*        length.                                                           */
/*    (b) by creating a temporary MSF when canonicalization of the input    */
/*        SSF gives canonical characters which are stored in the Temp_seg   */
/*        and Temp_seg length has reached its maximum segment length        */
/*        AT LEAST ONCE while canonicalization is in progress.  This causes */
/*        a temp MSF to be created to copy Temp_seg's contents into an      */
/*        appropriate component of the temp MSF in order to continue        */
/*        canonicalization of the remaining components of the input SSF.    */
/*                                                                          */
/* There are two cases for processing canonicalization of a specified input */
/* file whose type is segment (SSF).                                        */
/*                                                                          */
/* Case 1: SSF canonicalize SSF (type is unchanged)                         */
/*         Canonicalization of input file path1, whose type is SSF, gives   */
/*         canonical characters to be stored in an output file.             */
/*         Because the length of the canonical output file is LESS or EQUAL */
/*         the maximum length of a segment, so the type of the output file  */
/*         is SSF which is the same type as the noncanical input file path1 */
/*                                                                          */
/* Case 2: SSF canonicalize MSF (expanded: type is changed from SSF to MSF) */
/*         Canonicalization of input file path1, whose type is SSF, gives   */
/*         canonical characters to be stored in an output file.             */
/*         Because the max length of canonical output file is GREATER than  */
/*         the max length of a segment, so the type of the canonical output */
/*         file is MSF which is different type with the noncanonical input  */
/*         file path1 whose type is SSF.                                    */
/*                                                                          */

/* begin canon_segment procedure */

	on cleanup call clean_up;

	if Bitc = 0 then do;			/* the input path1 whose type is SSF is empty */
	     call com_err_ (error_table_$zero_length_seg, ME, "^a", pathname_ (Dn, En));
	     return;
	end;
						/* initiate the input path1 SSF */
	call initiate_file_ (Dn, En, Desired_access, Seg_ptr, Bitc, Ec);
	if Ec ^= 0 then do;
	     if Ec = error_table_$no_w_permission then do;/* do not treat as an error until digging in details */
		Fs_util_type = FS_OBJECT_TYPE_SEGMENT;
		call validate_access (Dn, En, Fs_util_type, Desired_access, Overwrite_exist_path_flag);
		if Ec ^= 0 then return;
		if ^Overwrite_exist_path_flag then return;
						/* must reinitiate again to get Seg_ptr pointer pointing to an input SSF path1 */
		call initiate_file_ (Dn, En, Desired_access, Seg_ptr, Bitc, (0));
	     end;
	     else do;
		call com_err_ (Ec, ME, "^a", pathname_ (Dn, En));
		return;
	     end;
	end;					/* an error occured while initiating the input path1 */
						/* assume had no problem with initiation.  Ask for overwritting the input path1 */
	if ^Have_outfile_flag & ^Overwrite_exist_path_flag then do;
	     call command_query_$yes_no (Overwrite_exist_path_flag, (0), ME, "", "Do you want to overwrite ^a?", pathname_ (Dn, En));
	     if ^Overwrite_exist_path_flag then return;
						/* at this point, users want to overwrite the input path1 SSF */
	     Fs_util_type = FS_OBJECT_TYPE_SEGMENT;	/* mark for later reference for the case: SSF canonicalize MSF (expanded) */
	end;

	call archive_$next_component (Seg_ptr, Bitc, (null ()), (0), (""), Ec);
	if Ec = 0 then do;
	     Ec = error_table_$archive_pathname;
	     call com_err_ (Ec, ME, "The specified path is an archive. ^a", pathname_ (Dn, En));
	     return;
	end;

	oi.version_number = object_info_version_2;
	call object_info_$brief (Seg_ptr, Bitc, addr (oi), Ec);
	if Ec = 0 then do;
	     Ec = error_table_$bad_arg;
	     call com_err_ (Ec, ME, "The specified path is an object segment. ^a", pathname_ (Dn, En));
	     return;
	end;
						/* calculate the length of input path1 SSF in characters */
	Lth = divide (Bitc + (BITS_PER_CHAR - 1), BITS_PER_CHAR, PRECISION_FIXED_BIN_21, 0);

	if Have_outfile_flag then do;			/* output path2 is specified */
	     call initiate_specified_output_file;
	     if Ec ^= 0 then return;
						/* the specified output file path2 exists and do not want to overwrite it */
	     if ^Nonexistent_outfile_flag & ^Overwrite_exist_path_flag then return;
	end;
	else Out_seg_ptr = Seg_ptr;			/* Out_seg_ptr points to an input file path1 SSF because wanted to overwrite it */


	call do_canon;				/* convert the contents of the input SSF into a canonical form */
	if Ec ^= 0 then return;

	if ^Create_temp_msf_flag then do;		/* case: SSF canonicalize SSF (canonical chars are stored in a temp seg) */
	     if Out_seg_ptr ^= null then
						/* copy Temp_seg into either the input file (SSF) path1, or */
						/* the specified existent output file (SSF) path2 */
		call copy_temp_seg_into_segment;

	     else if Nonexistent_outfile_flag then do;	/* the specified output file path2 did not exist */
		call initiate_file_$create (Out_dname, Out_ename, RW_ACCESS, Out_seg_ptr, Nonexistent_outfile_flag, Bitc, Ec);
		if Ec ^= 0 then do;
		     call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
		     return;
		end;

		call copy_temp_seg_into_segment;	/* copy Temp_seg contents into the newly created output file (SSF) path2 */
	     end;

	     else do;				/* the specified existent output path2 is a Multisegment-file (MSF) */
		call copy_temp_seg_into_spec_pth2_MSF;
		if Ec ^= 0 then return;
	     end;					/* the specified existent output path2 is a Multisegment-file (MSF) */
						/* terminate the input path1 SSF pointed by Seg_ptr pointer by call terminate_file_ */
	     call terminate_file_ (Seg_ptr, (0), TERM_FILE_TERM, (0));
	end;					/* case: SSF canonicialize SSF */
	else do;					/* case: SSF canonicalize MSF */
	     if Temp_seg_len_in_chars > 0 then do;	/* Temp_seg contains canonical characters */
		call temp_seg_to_temp_msf;		/* copy the contents of Temp_seg into a proper component of a temp MSF */
		if Ec ^= 0 then return;
	     end;

	     if ^Have_outfile_flag then do;		/* for overwritten an input path1 SSF */
		call msf_manager_$open (Dn, En, Input_msf_fcb_ptr, Ec);
		if Ec ^= 0 then do;			/* will close temp MSF in the clean_up internal proc. */
		     call com_err_ (Ec, ME, "^a", pathname_ (Dn, En));
		     return;
		end;
						/* copy the contents of temp msf into the input path1 SSF which converted to MSF */
		call temp_msf_to_infile_or_outfile (Dn, En);
		if Ec ^= 0 then return;

		Seg_ptr = null;			/* don't call terminate_file_ because the input SSF path1 has converted to MSF */
	     end;
	     else do;				/* a output path2 was specified */
						/* open either a specified existent output path2 whose type either SSF or MSF */
						/* or a specified nonexistent output file path2 */
		call msf_manager_$open (Out_dname, Out_ename, Input_msf_fcb_ptr, Ec);
		if Ec ^= 0 then do;
		     if Ec ^= error_table_$noentry then do; /* will close the temp MSF in the clean_up internal procedure */
			call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
			return;
		     end;
		     else Ec = 0;			/* OK for specifying a nonexistent output file path2 */
						/* it will be created when msf_manager_$msf_get_ptr is called */
		end;
						/* copy the contents of temp MSF into a specified output file path2 */
		call temp_msf_to_infile_or_outfile (Out_dname, Out_ename);
		if Ec ^= 0 then do;
		     if Nonexistent_outfile_flag then
			call delete_$path (Out_dname, Out_ename, SWITCHES, ME, (0));
		     return;
		end;
						/* call terminate_file_ to terminate the input SSF path1 after */
						/* copying the contents of temp MSF into a specified output file path2 */
		call terminate_file_ (Seg_ptr, (0), TERM_FILE_TERM, (0));
	     end;
	end;					/*  case: SSF CANONICALIZE MSF EXPANDED */

	return;

     end canon_segment;

/* --------------------------------------------------------------------------- */
%page;
clean_up: proc;

/* begin clean_up procedure */

	if Access_ptr ^= null then do;		/* a write access mode has been temporarily added to a read only file */
	     if Create_temp_msf_flag then do;		/* a temp MSF has been created earlier */

		if Fs_util_type = FS_OBJECT_TYPE_SEGMENT then do;
						/* must take care the ACL of the converted MSF whose original type is SSF */
		     Access.type = MSF;		/* reinitialize to 3 to indicate that the new entry type is MSF */
		     Access.set = ACL_REPLACED;	/* prepare to replace the current ACL with its original ACL */
		     Access.old_mode = R_ACCESS;	/* restore its origial access mode */
		     call access_$reset (Access_ptr, (0)); /* replace the current ACL with the original ACL */
		end;				/* the original type of the converted path2 MSF was SSF */

		if Fs_util_type = FS_OBJECT_TYPE_MSF then /* the original entry type was MSF */
		     call access_$reset (Access_ptr, (0)); /* remove the "write" access mode that temporarily added earlier */
	     end;					/* a temp MSF was created */
	     else if Fs_util_type ^= " " then do;	/* a temp MSF has NEVER been created and the entry type is SSF or MSF */
		if Fs_util_type = FS_OBJECT_TYPE_MSF then
						/* the original type of the converted path2 SSF was MSF */
		     Access.type = SEGMENT;		/* update the entry type which is SSF */

		call access_$reset (Access_ptr, (0));	/* remove the "write" access mode that temporarily added earlier */
	     end;
	end;					/* a "write" access mode has been temporarily added to a "read" only in/out file */

	if Input_msf_fcb_ptr ^= null then do;
	     call msf_manager_$close (Input_msf_fcb_ptr);
	     if Seg_ptr ^= null then Seg_ptr = null;	/* double check since sp pointed to a specified component of an input MSF path1 */
						/* or to the convert input MSF path1 whose original type was SSF */
	end;

	if Temp_msf_fcb_ptr ^= null then do;
	     call msf_manager_$close (Temp_msf_fcb_ptr);
	     if Out_seg_ptr ^= null then Out_seg_ptr = null; /* double check since Out_seg_ptr pointed to the converted output MSF path2 whose original type is SSF */
	end;

	if Temp_ptr ^= null then free Temp_ptr -> Bead;

	if Outc_ptr ^= null then
	     call release_temp_segment_ (ME, Outc_ptr, (0));

	if Temp_seg_ptr ^= null then do;
	     if ^Specified_temp_file_flag then
		call release_temp_segment_ (ME, Temp_seg_ptr, (0));
	     else do;
		Temp_seg_ptr = null;
		call delete_$path (Temp_dn, Temp_en, SWITCHES, ME, (0));
	     end;
	end;

	if Second_temp_seg_ptr ^= null then
	     call release_temp_segment_ (ME, Second_temp_seg_ptr, (0));

	return;

     end clean_up;

/***************************************************************************/
/*  This is part of the clean_up procedure that is not required if the
    call has come thru canonicalize_ or canonicalize_tabs_.                */

term_segs:
     proc;
     
	if Out_seg_ptr = Seg_ptr then Out_seg_ptr = null; /* Out_seg_ptr also pointed to source since wanted to overwrite the input file path1 */

	if Seg_ptr ^= null then
	     call terminate_file_ (Seg_ptr, (0), TERM_FILE_TERM, (0));

	if Out_seg_ptr ^= null then
	     call terminate_file_ (Out_seg_ptr, (0), TERM_FILE_TERM, (0));

end term_segs;
/****************************************************************************/

/* -------------------------------------------------------------------------- */
%page;
copy_temp_seg_into_msf: proc (p_dn, p_en, p_fcb_ptr, p_comp_index, p_comp_ptr, p_comp_bitc, p_temp_msf_total_components);

/* put the contents of Temp_seg which contains canonical characters into     */
/* either an appropriate component of the temp MSF or component 0 of a       */
/* specified output path2 whose type is MSF.                                 */

/* parameters */
dcl  (p_dn, p_en) char (*);
dcl  (p_comp_ptr, p_fcb_ptr) ptr;
dcl  p_comp_index fixed bin;
dcl  (p_comp_bitc, p_temp_msf_total_components) fixed bin (24);

/* begin copy_temp_seg_into_msf procedure */

	Ec = 0;

	on cleanup call clean_up;

	on record_quota_overflow begin;
	     Ec = error_table_$rqover;
	     call msf_manager_$close (p_fcb_ptr);
	     revert record_quota_overflow;
	     goto temp_seg_to_msf_ERROR_RETURN;
	end;
						/* want to create a specified component if it doesn't exist yet */
	call msf_manager_$msf_get_ptr (p_fcb_ptr, p_comp_index, TRUE, p_comp_ptr, p_comp_bitc, Ec);
	if Ec ^= 0 then do;
	     call msf_manager_$close (p_fcb_ptr);

	     if Fs_util_type = FS_OBJECT_TYPE_MSF then
		call com_err_ (Ec, ME, "Cannot get component ^d of specified output MSF ^a", p_comp_index, pathname_ (p_dn, p_en));
	     else call com_err_ (Ec, ME, "Cannot get component ^d of temp MSF ^a", p_comp_index, pathname_ (p_dn, p_en));

	     return;
	end;

	p_comp_ptr -> Temp_seg = Temp_seg;		/* copy the contents of Temp_seg into into a specified component */

	if (p_comp_index = 0) & (p_temp_msf_total_components = 0) then
						/* case of a specified path2 is nonexistent and a temp MSF has been created */
	     p_temp_msf_total_components = 1;		/* update the total number of components in a temp MSF */

/* calculate the bitc count of that component */
	p_comp_bitc = Temp_seg_len_in_chars * BITS_PER_CHAR;

temp_seg_to_msf_ERROR_RETURN:

	return;

     end copy_temp_seg_into_msf;

/* --------------------------------------------------------------------------- */
%page;
copy_temp_seg_into_spec_pth2_MSF: proc;

/* copy the contents of Temp_seg into the component 0 of a specified output  */
/* path2 whose type is MSF.                                                  */

/* begin copy_temp_seg_into_spec_pth2_MSF procedure */
/* get File control Block pointer */
	call msf_manager_$open (Out_dname, Out_ename, Temp_msf_fcb_ptr, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
	     return;
	end;
						/* copy Temp_seg into the component 0 of the specified output path2 MSF */
	call copy_temp_seg_into_msf (Out_dname, Out_ename, Temp_msf_fcb_ptr, Temp_msf_comp_index, Temp_msf_comp_ptr,
	     Temp_msf_comp_bitc, Temp_msf_total_components);
	if Ec ^= 0 then return;
						/* sets the bit count, truncates, and terminates its component 0 */
	call msf_manager_$adjust (Temp_msf_fcb_ptr, (Temp_msf_comp_index), Temp_msf_comp_bitc, THREE_BIT_SWITCH, Ec);
	if Ec ^= 0 then do;
	     call msf_manager_$close (Temp_msf_fcb_ptr);
	     call com_err_ (Ec, ME, "Cannot adjust component ^d of MSF ^a", Temp_msf_comp_index, pathname_ (Out_dname, Out_ename));
	     return;
	end;

	return;

     end copy_temp_seg_into_spec_pth2_MSF;

/* --------------------------------------------------------------------------- */
%page;
copy_temp_seg_into_segment: proc;

/* when canonicalization of an input SSF is finished and Temp_seg length has */
/* not reached the system defined max length yet, CHARS_PER_SEGMENT,         */
/* copy_temp_seg_into_segment copies the contents of Temp_seg into one       */
/* of the following files:                                                   */
/*    (a) the specified output path2.  Note that if it did not exist, it     */
/*        was created by calling initiate_file_$create earlier.              */
/*    (b) the original input path1.                                          */


dcl  output_segment_length_in_bits fixed bin (24);

/* begin copy_temp_seg_into_segment procedure */

	output_segment_length_in_bits = 0;

	on cleanup call clean_up;

	on record_quota_overflow begin;
	     Ec = error_table_$rqover;
	     revert record_quota_overflow;
	     goto temp_seg_to_segment_ERROR_RETURN;
	end;

	Output_segment_length_in_words = divide (Temp_seg_len_in_chars + (CHARS_PER_WORD - 1), CHARS_PER_WORD, PRECISION_FIXED_BIN_19, 0);
	call terminate_file_ (Out_seg_ptr, (Output_segment_length_in_words), TERM_FILE_TRUNC, Ec);
	if Ec ^= 0 then do;
	     if Out_seg_ptr = Seg_ptr then
		call com_err_ (Ec, ME, "^a", pathname_ (Dn, En));
	     else call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
	     return;
	end;
						/* Clear last word used */
	Out_seg_ptr -> Word_array (Output_segment_length_in_words) = FALSE;

	Out_seg_ptr -> Temp_seg = Temp_seg;		/* copy canonical data into either input path1 or a specified output path2 */

	output_segment_length_in_bits = Temp_seg_len_in_chars * BITS_PER_CHAR;
	call terminate_file_ (Out_seg_ptr, (output_segment_length_in_bits), TERM_FILE_BC, Ec);
	if Ec ^= 0 then do;
	     if Out_seg_ptr = Seg_ptr then
		call com_err_ (Ec, ME, "^a", pathname_ (Dn, En));
	     else call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
	     return;
	end;

temp_seg_to_segment_ERROR_RETURN:
	call terminate_file_ (Out_seg_ptr, (0), TERM_FILE_TERM, Ec);

	return;

     end copy_temp_seg_into_segment;

/* -------------------------------------------------------------------------- */
%page;
do_canon: procedure;

/* Each line of either the input segment or the specified component of the  */
/* input MSF is read in.  Scan each character in that line to find out      */
/* whether it is a normal character or a specified character.  For standard */
/* characters, no convertion to canonical form is made, just copied them    */
/* into Outc.  However, for special characters such as Backspace (BS), SP,  */
/* Carriage return (CR), Horizontal tab (HT), ect., special processing is   */
/* required to convertion them into standard (canonical) form before storing */
/* in Outc.  So, continue to proceed the input line until a slew character  */
/* is found.  Then copy the Outc which contains a line of characters in     */
/* standard (canonical) form into the Temp_seg.  At this point, canon       */
/* checks the length of Temp_seg in order to decide what actions will be    */
/* taken next if tem_seg length reaches the maximum segment length.         */
/* (a) Assume that the max segment length has not been reached.  Read in the */
/*     next input line.  Repeat canonicalization of that line.  do_canon    */
/*     terminates the convertion after the last line of the input segment   */
/*     or of a specified component of the input MSF has been converted into */
/*     a canonical form.                                                    */
/* (b) Assume that the max segment length has been reached while            */
/*     canonicalization is in progress.  A temporarly MSF is created in     */
/*     either the process directory with a unique name (by default) or      */
/*     in a specified directory (-temp_file was specified).  Copy Temp_seg  */
/*     which is now full into a specified component of the newly created    */
/*     temp MSF.  Then clear out the Temp_seg before continuing to put the  */
/*     remaining contents of Outc (which is left over) into Temp_seg.       */
/*     do_canon terminates the canonicalization of the input file after     */
/*     the last line of the input file has been converted.                  */
/*                                                                          */
/* A "slew" character is a line-terminator (NL, VT, or FF).                 */

dcl  available_pos_for_insertion fixed bin (21);
dcl  next_char_pos fixed bin (21);
dcl  remaining_pos_for_insertion fixed bin (21);
dcl  slew_index fixed binary (21);
dcl  slew_present_flag bit (1);

%page;
/* begin do_canon procedure */

	Ec = 0;
	available_pos_for_insertion = 0;
	remaining_pos_for_insertion = 0;
	Obuf_ptr = null;
	Beg_line = 1;				/* beginning line position */

	on cleanup call clean_up;

	Bead_storage_size = hbound (Bead_storage, 1);

	Bead_ptr = addr (Bead_storage);
	Area_ptr = get_system_free_area_ ();

	do while (^Eof_flag);			/* scan each existing line of the input (segment or MSF component). */
	     Outc_len, Ox = 0;			/* clear out Outc which contains a line of caninical chars before continuing */
						/* to convert the next input line into canonical form and store them in Outc */
	     Nch = 0;				/* no chars seen */
	     Obuf_ptr = addr (substr (Bcs, Beg_line, 1)); /* locate begin of line */

	     Chars_in_line = search (substr (Bcs, Beg_line), NLVTFF);
						/* find end of line */
	     if Chars_in_line = 0 then do;		/* no more NL or other slew chars remain in input */
		slew_present_flag = FALSE;
		Chars_in_line = Lth - Beg_line + 2;
						/* include a mythical slew char in count */
	     end;
	     else slew_present_flag = TRUE;		/* NL or other slew char found in input */

	     Beg_line = Beg_line + Chars_in_line;	/* up to begin of next line */
	     if Beg_line > Lth then Eof_flag = TRUE;

	     slew_index = Chars_in_line;

/* Remove trailing SPBSCRHTs. */
	     Chars_to_remove = verify (reverse (substr (Obuf_ptr -> Bcs, 1, Chars_in_line - 1)), SPBSCRHT);
	     if Chars_to_remove = 0 then Chars_to_remove = Chars_in_line;

	     Chars_in_line = Chars_in_line - Chars_to_remove + 1;

	     Col, Jj, In_stopx, Stopx, Next_pos = 1;
	     if search (substr (Obuf_ptr -> Bcs, 1, Chars_in_line - 1), BSCR) ^= 0 then do; /* special processing necessary */
		do while (Jj <= Chars_in_line - 1);	/* .. simulating a typewriter */
		     if substr (Obuf, Jj, 1) = BS then do;
			Ii = verify (substr (Obuf, Jj, Chars_in_line - Jj), BS) - 1;
			Jj = Jj + Ii;
			Col = max (Col - Ii, 1);	/* don't backspace off end */
		     end;
		     else if substr (Obuf, Jj, 1) = CR then do;
			Col = 1;
			Jj = Jj + 1;
		     end;
		     else if substr (Obuf, Jj, 1) = HT then do;
			Ii = verify (substr (Obuf, Jj, Chars_in_line - Jj), HT) - 1;
			if In_nstops > 0 then do;
			     if Col >= In_stops (In_nstops) then Col = Col + Ii;
			     else do;
				do In_stopx = In_stopx to In_nstops + 1
				     while (Col >= In_stops (In_stopx));
				end;
				if In_stopx + Ii > In_nstops then
				     Col = In_stops (min (In_stopx + Ii - 1, In_nstops)) + In_stopx + Ii - 1 - In_nstops;
				else Col = In_stops (In_stopx + Ii - 1);
			     end;
			end;
			else Col = In_everytab * (divide (Col - 1, In_everytab, PRECISION_FIXED_BIN_17, 0) + Ii) + 1;

			Jj = Jj + Ii;
		     end;
		     else if substr (Obuf, Jj, 1) = SP then do;
			Ii = verify (substr (Obuf, Jj, Chars_in_line - Jj), SP) - 1;
			Jj = Jj + Ii;
			Col = Col + Ii;
		     end;
		     else do;			/* printing char */
			Nch = Nch + 1;		/* allocate */
			if Nch > Bead_storage_size then do; /* make sure don't blow array */
			     Mm = Bead_storage_size;
			     Bead_storage_size = 2 * Bead_storage_size;

			     allocate Bead set (Temp_ptr) in (System_area);

			     Bead_storage_size = Mm;
			     Temp_ptr -> Bead = Bead;
			     if Bead_ptr ^= addr (Bead_storage) then free Bead;

			     Bead_ptr = Temp_ptr;
			     Bead_storage_size = 2 * Bead_storage_size;
			end;
			Bead (Nch).char = substr (Obuf, Jj, 1);
			Bead (Nch).loc = Col;	/* note (aparent) position */

			if (rank (substr (Obuf, Jj, 1)) >= rank (" ") & rank (substr (Obuf, Jj, 1)) <= rank ("~")) then Col = Col + 1;

			Jj = Jj + 1;
		     end;
		end;				/* looping termination */

		call sort;			/* all chars done. sort array */

		Next_pos = 1;			/* next output pos */
		do Charx = 1 to Nch;		/* now put out the chars in right order */
		     if Charx > 1 then do;
			if unspec (Bead (Charx)) = unspec (Bead (Charx - 1))
			then goto do_canon_SKIP;
		     end;
						/* Canonical form says no duplicate in same pos */
		     Spaces_to_go = Bead (Charx).loc - Next_pos;
						/* number of spaces to put */
		     if Spaces_to_go > 0 then do;	/* if space needed */
			if Tab_flag & Spaces_to_go > 1 then do; /* inserting tabs? */
			     if Nstops > 0 then do;
				do Stopx = 1 to Nstops while (Next_pos >= Stops (Stopx));
				end;

				Cantab_flag = (Stopx <= Nstops);
				do while (Cantab_flag & (Bead (Charx).loc >= Stops (Stopx)));
				     call output (HT);
				     Next_pos = Stops (Stopx);
				     Spaces_to_go = Bead (Charx).loc - Next_pos;
						/* Recalculate spaces needed. */
				     if Stopx >= Nstops then Cantab_flag = FALSE;
				     else if Stops (Stopx + 1) > Bead (Charx).loc then Cantab_flag = FALSE;
				     else Stopx = Stopx + 1;
				end;
			     end;
			     else do;		/* -every case */
				Target_tabstop = Everytab * divide (Bead (Charx).loc - 1, Everytab, PRECISION_FIXED_BIN_17, 0) + 1;

				do while (Next_pos < Target_tabstop);
				     call output (HT);

				     This_tabstop = Everytab * divide (Next_pos - 1 + Everytab, Everytab, PRECISION_FIXED_BIN_17, 0) + 1;
				     Next_pos = This_tabstop;
				     Spaces_to_go = Bead (Charx).loc - Next_pos;
						/* Recalculate spaces needed */
				end;
			     end;
			end;

			do Ii = 1 to Spaces_to_go;	/* put out blanks */
			     call output (SP);
			end;
		     end;

/* We consider nonprinting characters to not take up space for the purposes of
   calculating tabs and so forth, but we don't actually want to separate them
   by backspaces. */
		     if Spaces_to_go < 0 & (rank (Bead (Charx).char) >= rank (" ") & rank (Bead (Charx).char) <= rank ("~"))
		     then call output ((BS));		/* never more than one */

		     call output (Bead (Charx).char);	/* type char out */

		     Next_pos = Bead (Charx).loc + 1;	/* next column */
do_canon_SKIP:
		end;
	     end;					/* typewriter simulation */
	     else do;				/* just take the whole line */
		Nch = 1;				/* non_zero to start copy */

		if ^Tab_flag then do;		/* process case with space fill */
		     do while (Nch ^= 0);
			Nch = index (substr (Obuf_ptr -> Bcs, Jj, Chars_in_line - Jj), HT); /* find HT */
			if Nch = 0 then
			     Ii = Chars_in_line - Jj;
			else Ii = Nch - 1;		/* omit the tab in copy */
			if Ii > 0 then do;
			     Outc_len = Outc_len + Ii;
			     substr (Outc, Ox + 1, Ii) = substr (Obuf_ptr -> Bcs, Jj, Ii);

			     do Kk = Jj to (Jj + Ii - 1);
				if (rank (substr (Obuf_ptr -> Bcs, Kk, 1)) >= rank (" ") & rank (substr (Obuf_ptr -> Bcs, Kk, 1)) <= rank ("~"))
				then Col = Col + 1;
			     end;

			     Ox = Ox + Ii;
			     Jj = Jj + Ii;
			end;

			if Nch ^= 0 then do;	/* fill spaces */
			     Ii = verify (substr (Obuf_ptr -> Bcs, Jj, Chars_in_line - Jj), HT) - 1; /* take out multiples */

			     Next_pos = Col;
			     if In_nstops > 0 then do;
				if Col >= In_stops (In_nstops) then Spaces_to_go = Ii;
				else do;
				     do In_stopx = In_stopx to In_nstops + 1
					while (Col >= In_stops (In_stopx));
				     end;

				     if In_stopx + Ii > In_nstops
				     then Spaces_to_go = In_stops (min (In_stopx + Ii - 1, In_nstops)) + In_stopx + Ii - 1 - In_nstops - Col;
				     else Spaces_to_go = In_stops (In_stopx + Ii - 1) - Next_pos;
				end;
			     end;
			     else Spaces_to_go = In_everytab * (divide (Col - 1, In_everytab, PRECISION_FIXED_BIN_17, 0) + Ii) + 1 - Next_pos; /* number of spaces to fill in */

			     Outc_len = Outc_len + Spaces_to_go;
			     substr (Outc, Ox + 1, Spaces_to_go) = copy (SP, Spaces_to_go);
			     Ox = Ox + Spaces_to_go;
			     Col = Col + Spaces_to_go;
			     Jj = Jj + Ii;		/* add source space for the tab */
			end;
		     end;
		end;

%page;
/* Process Case with Tab Fill */
		else do;
		     do while (Jj <= Chars_in_line - 1);

/* Clip spacing before section */
			do while (search (substr (Obuf_ptr -> Bcs, Jj, 1), HTSP) ^= 0);
			     if substr (Obuf_ptr -> Bcs, Jj, 1) = SP then do;
				Ii = verify (substr (Obuf_ptr -> Bcs, Jj, Chars_in_line - Jj), SP) - 1;
				Col = Col + Ii;
				Jj = Jj + Ii;
			     end;
			     else do;
				Ii = verify (substr (Obuf_ptr -> Bcs, Jj, Chars_in_line - Jj), HT) - 1;

				if In_nstops > 0 then do;
				     if Col >= In_stops (In_nstops) then
					Col = Col + Ii;
				     else do;
					do In_stopx = In_stopx to In_nstops + 1
					     while (Col >= In_stops (In_stopx));
					end;
					if In_stopx + Ii > In_nstops then
					     Col = In_stops (min (In_stopx + Ii - 1, In_nstops)) + In_stopx + Ii - 1 - In_nstops;
					else Col = In_stops (In_stopx + Ii - 1);
				     end;
				end;
				else Col = In_everytab * (divide (Col - 1, In_everytab, PRECISION_FIXED_BIN_17, 0) + Ii) + 1;

				Jj = Jj + Ii;
			     end;
			end;

/* At this point initial white space has been clipped, Col = column after the
   white space, and Next_pos = last column printed + 1.  Now section through
   the tabulation. */
			Spaces_to_go = Col - Next_pos;/* number of spaces to put */
			if Spaces_to_go > 0 then do;	/* if space needed */
			     if (Tab_flag) & (Spaces_to_go > 1) then do; /* inserting tabs? */
				if Nstops > 0 then do;
				     if Next_pos > Stops (Nstops)
				     then goto omit_simple_spaces; /* beyond reach */
						/* Start from last tabstop for scan */
				     do Stopx = Stopx to Nstops + 1
					while (Next_pos >= Stops (Stopx));
				     end;

				     do Ii = Stopx to Nstops + 1
					while (Col >= Stops (Ii));
				     end;		/* find terminator */

				     Ii = Ii - Stopx; /* number of tabs involved */
				     if Ii < 1 then goto omit_simple_spaces; /* no tabs involved */

				     Spaces_to_go = Col - Stops (Ii + Stopx - 1); /* spaces after last tab */
				end;
				else do;		/* -every */
						/* tabstop number */
				     Target_tabstop = divide (Col - 1, Everytab, PRECISION_FIXED_BIN_17, 0);
						/* number of tabs to do */
				     Ii = Target_tabstop - divide (Next_pos - 1, Everytab, PRECISION_FIXED_BIN_17, 0);
				     if Ii < 1 then goto omit_simple_spaces; /* no tabbing involved */
				     Spaces_to_go = Col - (Target_tabstop * Everytab + 1); /* spaces left after */
				end;

				if Ii > 0 then do;
				     Outc_len = Outc_len + Ii;
				     substr (Outc, Ox + 1, Ii) = copy (HT, Ii);
				     Ox = Ox + Ii;	/* Output Horizontal tabs */
				end;
			     end;

omit_simple_spaces:
			     if Spaces_to_go > 0 then do;
				Outc_len = Outc_len + Spaces_to_go;
				substr (Outc, Ox + 1, Spaces_to_go) = copy (SP, Spaces_to_go);
				Ox = Ox + Spaces_to_go;
			     end;
			end;

/* Take out a string of text, to next gap. */
			Ii = search (substr (Obuf_ptr -> Bcs, Jj, Chars_in_line - Jj), HTSP) - 1;
			if Ii < 1 then
			     Ii = Chars_in_line - Jj;

			Outc_len = Outc_len + Ii;
			substr (Outc, Ox + 1, Ii) = substr (Obuf_ptr -> Bcs, Jj, Ii); /* output string */
			Ox = Ox + Ii;
			do Kk = Jj to (Jj + Ii - 1);
			     if (rank (substr (Obuf_ptr -> Bcs, Kk, 1)) >= rank (" ") & rank (substr (Obuf_ptr -> Bcs, Kk, 1)) <= rank ("~")) then
				Col = Col + 1;
			end;

			Jj = Jj + Ii;
			Next_pos = Col;
		     end;				/* end of parse loop */
		end;
	     end;

	     if slew_present_flag then
						/* finally, append the slew char to the Outc which contains a line of CANONINCAL chars */
		call output (substr (Obuf, slew_index, 1));

/* check the boundary of temp seg after adding an entire line of canonincal chars to it */
	     if (Temp_seg_len_in_chars + Outc_len) < CHARS_PER_SEGMENT then do;
						/* copy the entire line of canonical chars (stored in Outc) into the Temp_seg */
		next_char_pos = Temp_seg_len_in_chars + 1;
		Temp_seg_len_in_chars = Temp_seg_len_in_chars + Outc_len;
		substr (Temp_seg, next_char_pos, Outc_len) = Outc;
	     end;
	     else do;				/* case of reaching the maximum length of Temp_seg */
						/* calculate the number of spaces left in temp seg, then filled up temp seg */
		available_pos_for_insertion = CHARS_PER_SEGMENT - Temp_seg_len_in_chars;
		next_char_pos = Temp_seg_len_in_chars + 1;
		Temp_seg_len_in_chars = Temp_seg_len_in_chars + available_pos_for_insertion;
		substr (Temp_seg, next_char_pos, available_pos_for_insertion) = substr (Outc, 1, available_pos_for_insertion);

		if Do_not_create_temp_msf_flag then do;
						/* the canonicalize_tab_ and canonincal_ entries don't want to expand path1 SSF into MSF */
		     Ec = error_table_$rqover;
		     return;
		end;
						/* temp seg containing canonical characters is full */
		if ^Create_temp_msf_flag then do;
		     Create_temp_msf_flag = TRUE;

		     if ^Specified_temp_file_flag then do; /* by default: prepare to create a temp MSF in the process directory with an unique name */
			Temp_dn = get_pdir_ ();
			Temp_en = unique_chars_ (FALSE);
		     end;
		     else do;			/* a temp segment ws created ealier by hcs_$make_seg when -tf was given */
						/* this specified temp segment will be converted to a temp MSF very soon. */
						/* So, canon must get another temp seg for continuing canonicalization. */
			call get_temp_segment_ (ME, Second_temp_seg_ptr, Ec);
			if Ec ^= 0 then do;
			     call com_err_ (Ec, ME, "Cannot get temp segment.");
			     return;
			end;
						/* copy the specified temp segment's contents into another temp segment */
			Second_temp_seg_ptr -> Second_temp_seg = Temp_seg_ptr -> Temp_seg;
						/* assign Temp_seg_ptr points to another temp segment */
						/* such that the remaining canonical chars will be stored in the second temp seg */
						/* and the specified temp segment in a specified directory will be */
						/* converted into a temp MSF by calling msf_manager_$msf_get_ptr soon */
						/* in the call to copy_temp_seg_into_msf internal procedure */
			Temp_seg_ptr = Second_temp_seg_ptr;

			Second_temp_seg_ptr = null;	/* no need */
		     end;
						/* open temp MSF.  Wants a pointer that points to the FCB of the temp MSF */
		     call msf_manager_$open (Temp_dn, Temp_en, Temp_msf_fcb_ptr, Ec);
		     if Ec ^= 0 then do;
			if Ec ^= error_table_$noentry then do;
			     call com_err_ (Ec, ME, "^a", pathname_ (Temp_dn, Temp_en));
			     return;
			end;
			else Ec = 0;		/* OK for temp MSF not found.  It will be created in copy_temp_seg_into_msf */
		     end;
		end;
						/* prepare to request a component greater than 0 */
		if Temp_msf_total_components > 0 then do;
		     Temp_msf_comp_index = Temp_msf_total_components;
		     Temp_msf_total_components = Temp_msf_total_components + 1;
		end;

/* copy tem_seg into an appropriate component of a newly created temp MSF */
		call copy_temp_seg_into_msf (Temp_dn, Temp_en, Temp_msf_fcb_ptr, Temp_msf_comp_index,
		     Temp_msf_comp_ptr, Temp_msf_comp_bitc, Temp_msf_total_components);
		if Ec ^= 0 then return;

		Temp_seg_len_in_chars = 0;		/* clear out Temp_seg  to indicate it is now empty. */
						/* Is any char left in the Outc after filled up tem_seg? */
		remaining_pos_for_insertion = Outc_len - available_pos_for_insertion;
		if remaining_pos_for_insertion > 0 then do;
						/* copy left over canonical characters from the Outc into Temp_seg */
		     Temp_seg_len_in_chars = remaining_pos_for_insertion;
		     substr (Temp_seg, 1, remaining_pos_for_insertion) = substr (Outc, available_pos_for_insertion + 1, remaining_pos_for_insertion);
		end;
	     end;					/* case of reaching the boundary of Temp_seg */
	end;					/* end of do while (^Eof_flag) */

	return;					/* return from do_canon procedure */

/* --------------------------------------------------------------------------- */
%page;
output:	proc (p_slew_char);

/* append a slew character (NL, VT, or FF) to Outc which contains a line    */
/* of canonical (standard) characters.                                      */

dcl  p_slew_char char (1);				/* input parameter */

/* begin output procedure which is called by do_canon procedure */

	     Outc_len, Ox = Ox + 1;			/* update canonical line length.  Also update output line index */
	     substr (Outc, Ox, 1) = p_slew_char;	/* append a slew character to a line of canonical character */

	     return;				/* return to do_canon procedure */

	end output;

/* -------------------------------------------------------------------------- */
%page;
sort:	proc;

/* Sort characters in Bead array of record.  Bead contains characters */
/* and corresponding character positions in the current line.  Nch is */
/* the actual upper bound of the array.                               */

dcl  d fixed bin;
dcl  i fixed bin;
dcl  swaps fixed bin;
dcl  temp bit (36) aligned;

/* begin sort procedure */

	     d = Nch;				/* get the actual max array index */

sort_pass:
	     swaps = 0;				/* prepare to sort characters in alphabetic order */

	     d = divide (d + 1, 2, 17, 0);		/* split the entire portion into two equal array portions */

	     do i = 1 to Nch - d;			/* loop through the upper portion */
						/* compare each character in the upper portion with each character in the lower portion, respectively */
		if unspec (Bead (i)) > unspec (Bead (i + d)) then do;
		     swaps = swaps + 1;
		     temp = unspec (Bead (i));
		     unspec (Bead (i)) = unspec (Bead (i + d));
		     unspec (Bead (i + d)) = temp;
		end;
	     end;

	     if d > 1 then goto sort_pass;		/* continue to split the upper array portion based on upper array portion's update max index */

	     if swaps > 0 then goto sort_pass;

	     return;				/* return to do_canon procedure */

	end sort;

/* --------------------------------------------------------------------------- */
%page;
     end do_canon;

/* --------------------------------------------------------------------------- */
%page;
get_specified_file_type: proc (p_dn, p_en, p_fs_util_type);

/* get the entry type of a specified file by calling fs_util_$get_type.      */
/* Only accept canonicalization of either a single Segment file (SSF) or     */
/* a Multisegment_file (MSF).                                                */

/* parameters */
dcl  (p_dn, p_en) char (*);				/* input */
dcl  p_fs_util_type char (32);			/* in/out */

/* begin get_specified_file_type procedure */

	Ec = 0;

	call fs_util_$get_type (p_dn, p_en, p_fs_util_type, Ec);
	if Ec ^= 0 then do;
	     call com_err_ (Ec, ME, "^a", pathname_ (p_dn, p_en));
	     return;
	end;

	if p_fs_util_type = FS_OBJECT_TYPE_DIRECTORY then do;
	     Ec = error_table_$dirseg;
	     call com_err_ (Ec, ME, "^a", pathname_ (p_dn, p_en));
	end;

	if p_fs_util_type = FS_OBJECT_TYPE_DM_FILE then do;
	     Ec = dm_error_$file_in_use;
	     call com_err_ (Ec, ME, "^a", pathname_ (p_dn, p_en));
	end;

	return;

     end get_specified_file_type;

/* ------------------------------------------------------------------------ */
%page;
initialization: proc;

/* initializes all automatic variables.  They are grouped together        */
/* depending on their data types.  For each group, their appearance       */
/* is based on alphabetic order.  This purpose is used to speed up canon. */

/* begin initialization procedure */

	Access_ptr,
	     Input_msf_comp_ptr,
	     Input_msf_fcb_ptr,
	     Outc_ptr,
	     Out_seg_ptr,
	     Second_temp_seg_ptr,
	     Seg_ptr,
	     Temp_msf_comp_ptr,
	     Temp_msf_fcb_ptr,
	     Temp_ptr,
	     Temp_seg_ptr = null;

	Bitc,
	     Ec,
	     Everytab,
	     Input_msf_comp_index,
	     In_msf_comp_bitc,
	     In_msf_total_original_comps,
	     In_nstops,
	     In_stops (*),
	     Mm,
	     Nstops,
	     Specified_infile_type,
	     Stops (*),
	     Temp_msf_comp_bitc,
	     Temp_msf_comp_index,
	     Temp_msf_total_components,
	     Temp_seg_len,
	     Temp_seg_len_in_chars = 0;

	Dn,
	     En,
	     Fs_util_type,
	     Out_dname,
	     Out_ename,
	     Temp_dn,
	     Temp_en = " ";

	Create_temp_msf_flag,
	     Do_not_create_temp_msf_flag,
	     Eof_flag,
	     Have_infile_flag,
	     Have_outfile_flag,
	     Overwrite_exist_path_flag,
	     Nonexistent_outfile_flag,
	     Specified_temp_file_flag,
	     Subroutine_call_flag,
	     Tab_flag = FALSE;

	Desired_access = (36)"0"b;

	In_everytab = 10;				/* by default */

	return;

     end initialization;

/* --------------------------------------------------------------------------- */
%page;
initiate_specified_output_file: proc;

/* initiate the specified output file path2.  If suceeds initiatation, ask   */
/* for overwritten the specified existent output path2.                      */

/* begin initiate_specified_output_file procedure */

	Ec = 0;

	call initiate_file_ (Out_dname, Out_ename, RW_ACCESS, Out_seg_ptr, Bitc, Ec);
	if Ec ^= 0 then do;
	     if Ec = error_table_$noentry then do;	/* it's OK for a specified NONEXISTENT output path2.  Will make it exist later on */
						/* depending on either case MSF canonicalize MSF or MSF canonicalize SSF */
		Ec = 0;
		Nonexistent_outfile_flag = TRUE;	/* mark that the specified output path2 does not exist. */
	     end;

	     else if Ec = error_table_$no_w_permission then do;
						/* do not treat as an error until digging in details */
		Fs_util_type = FS_OBJECT_TYPE_SEGMENT;
		call validate_access (Out_dname, Out_ename, Fs_util_type, RW_ACCESS, Overwrite_exist_path_flag);
		if Ec ^= 0 then return;
		if ^Overwrite_exist_path_flag then return;
						/* must reinitiate again to get its pointer value, Out_seg_ptr */
		call initiate_file_ (Out_dname, Out_ename, RW_ACCESS, Out_seg_ptr, Bitc, Ec);
		if Ec ^= 0 then do;
		     call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
		     return;
		end;
	     end;

	     else if Ec = error_table_$dirseg then do;	/* the specified output path2 EXISTS and its type is either directory or MSF */
						/* do not treat as an error until digging in details */
		call get_specified_file_type (Out_dname, Out_ename, Fs_util_type);
		if Ec ^= 0 then return;

		call validate_access (Out_dname, Out_ename, Fs_util_type, RW_ACCESS, Overwrite_exist_path_flag);
		if Ec ^= 0 then return;
		if ^Overwrite_exist_path_flag then return;
	     end;					/* the specified path2 exists and its type is either directory or MSF */
	     else do;
		call com_err_ (Ec, ME, "^a", pathname_ (Out_dname, Out_ename));
		return;
	     end;
	end;					/* an error occured while initiating the specified output path2 */

	if ^Overwrite_exist_path_flag & ^Nonexistent_outfile_flag then do;
						/* assume had no problem when initiated the specified EXISTENT output path2 */
	     call command_query_$yes_no (Overwrite_exist_path_flag, (0), ME, "", "Do you want to overwrite ^a?", pathname_ (Out_dname, Out_ename));
	     if ^Overwrite_exist_path_flag then return;

	     Fs_util_type = FS_OBJECT_TYPE_SEGMENT;
	end;

	return;

     end initiate_specified_output_file;

/* --------------------------------------------------------------------------- */
%page;
temp_seg_to_temp_msf: proc;

/* copies the contents of Temp_seg into the next component of the temp MSF.  */
/* This is done by calling the internal procedure named                      */
/* copy_temp_seg_into_msf.  Then calls msf_manager_$adjust to set          */
/* the bit count, truncate, and terminate that component.                    */

/* begin temp_seg_to_temp_msf procedure */

	if Temp_msf_total_components > 0 then do;	/* prepare to create another component in the temp MSF */
	     Temp_msf_comp_index = Temp_msf_total_components;
	     Temp_msf_total_components = Temp_msf_total_components + 1;
	end;
						/* copy the contents of Temp_seg into a specified component of a temp. MSF */
	call copy_temp_seg_into_msf (Temp_dn, Temp_en, Temp_msf_fcb_ptr, Temp_msf_comp_index, Temp_msf_comp_ptr,
	     Temp_msf_comp_bitc, Temp_msf_total_components);
	if Ec ^= 0 then do;				/* close temp MSF */
	     call msf_manager_$close (Temp_msf_fcb_ptr);
	     return;
	end;
						/* sets the bit count, truncates and terminates the components of the temp. MSF */
	call msf_manager_$adjust (Temp_msf_fcb_ptr, Temp_msf_comp_index, Temp_msf_comp_bitc, THREE_BIT_SWITCH, Ec);
	if Ec ^= 0 then do;				/* close temp MSF */
	     call msf_manager_$close (Temp_msf_fcb_ptr);
	     call com_err_ (Ec, ME, "Cannot adjust component ^d of MSF ^a", Temp_msf_comp_index, pathname_ (Temp_dn, Temp_en));
	     return;
	end;

	return;

     end temp_seg_to_temp_msf;

/* --------------------------------------------------------------------------- */
%page;
temp_msf_to_infile_or_outfile: proc (p_dirname, p_enname);

/* copy each component of a temp MSF into the corresponding component of     */
/* either the input file path1 or a specified output file path2.             */
/* If path2 was specified and does not exist, the call to                    */
/* msf_manager_$msf_get_ptr will create it as a MSF.                         */

/* input parameters */
dcl  p_dirname char (*);
dcl  p_enname char (*);

/* begin temp_msf_to_infile_or_outfile procedure */

	Ec = 0;

	on record_quota_overflow begin;
	     Ec = error_table_$rqover;
	     call msf_manager_$close (Input_msf_fcb_ptr);
	     call msf_manager_$close (Temp_msf_fcb_ptr);
	     revert record_quota_overflow;
	     goto temp_msf_ERROR_RETURN;
	end;

	Temp_seg_len = Temp_seg_len_in_chars;		/* save the current length of Temp_seg */

	Temp_seg_len_in_chars = CHARS_PER_SEGMENT;	/* prepare to copy full components (whose length has reached the max */
						/* component length) of a temp MSF */

	do Temp_msf_comp_index = COMPONENT_ZERO to (Temp_msf_total_components - 1);
						/* prepare to create a specified component */
	     Input_msf_comp_index = Temp_msf_comp_index;
						/* create a specified component if it does not exist yet */
	     call msf_manager_$msf_get_ptr (Input_msf_fcb_ptr, Input_msf_comp_index, TRUE, Input_msf_comp_ptr, In_msf_comp_bitc, Ec);

	     if Ec ^= 0 then do;
		call msf_manager_$close (Input_msf_fcb_ptr);
		call msf_manager_$close (Temp_msf_fcb_ptr);
		call com_err_ (Ec, ME, "Cannot get component ^d of MSF ^a", Input_msf_comp_index, pathname_ (p_dirname, p_enname));
		return;
	     end;
						/* get a specified component of the temp MSF */
	     call msf_manager_$msf_get_ptr (Temp_msf_fcb_ptr, Temp_msf_comp_index, FALSE, Temp_msf_comp_ptr, Temp_msf_comp_bitc, Ec);
	     if Ec ^= 0 then do;
		call com_err_ (Ec, ME, "Cannot get component ^d of MSF ^a.", Input_msf_comp_index, pathname_ (Temp_dn, Temp_en));
		call msf_manager_$close (Input_msf_fcb_ptr);
		call msf_manager_$close (Temp_msf_fcb_ptr);
		return;
	     end;
						/* have the last component of the temp MSF been reached */
	     if Temp_msf_comp_index = (Temp_msf_total_components - 1) then
						/* prepare to copy the last component of the temp MSF */
		Temp_seg_len_in_chars = Temp_seg_len;

/* copy the contents of each component of temp MSF into the corresponding */
/* component of either input file path1 or a specified output file path2 */
	     Input_msf_comp_ptr -> Temp_seg = Temp_msf_comp_ptr -> Temp_seg;
	end;					/* complete copied one by one component */
						/* sets bit count, truncates, and terminates the components of that file */
	call msf_manager_$adjust (Input_msf_fcb_ptr, Input_msf_comp_index, Temp_msf_comp_bitc, THREE_BIT_SWITCH, Ec);
	if Ec ^= 0 then do;
	     call msf_manager_$close (Input_msf_fcb_ptr);
	     call msf_manager_$close (Temp_msf_fcb_ptr);
	     call com_err_ (Ec, ME, "Cannot adjust component ^d of MSF ^a.", Input_msf_comp_index, pathname_ (p_dirname, p_enname));
	     return;
	end;

temp_msf_ERROR_RETURN:
	return;

     end temp_msf_to_infile_or_outfile;

/* --------------------------------------------------------------------------- */
%page;
%include access_mode_values;
%page;
%include object_info;
%page;
%include system_constants;
%page;
%include terminate_file;
%page;
%include copy_flags;
%page;
%include suffix_info;

     end canonicalize;
