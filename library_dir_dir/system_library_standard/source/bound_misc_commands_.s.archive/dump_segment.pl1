/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

dump_segment:
ds:
     proc;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* This command dumps the contents of a segment in octal, hex8, or hex9 with */
/* optional ascii, bcd, ebcdic9, ebcdic8, or 4-bit translation. The segment  */
/* to be dumped may be specified by octal segment number, SLT name,	       */
/* (relative) pathname.					       */
/*							       */
/* Usage:							       */
/*							       */
/*    dump_segment seg start count -control_args			       */
/* or:							       */
/*    dump_segment virtual_pointer count -control_args		       */
/*							       */
/* where:							       */
/*							       */
/* seg		is the segment to dump			       */
/* start		is the first word to dump			       */
/* count		is the number of words to dump		       */
/* virtual_pointer	is a pointer understood by cv_ptr_		       */
/*							       */
/* and control args can be:					       */
/*							       */
/* -long (-lg)						       */
/* -short (-sh)						       */
/* -character (-ch, -ascii)					       */
/* -bcd							       */
/* -ebcdic9						       */
/* -ebcdic8						       */
/* -4bit							       */
/* -name (-nm) path						       */
/* -hex8							       */
/* -hex9							       */
/* -block (-bk) N						       */
/* -address (-addr)						       */
/* -no_address (-nad, -naddr)					       */
/* -offset (-ofs) N						       */
/* -no_offset (-nofs)					       */
/* -header (-he)						       */
/* -no_header (-nhe)					       */
/* -entry_point (-ep) name					       */
/* -interpreted_data (-id)					       */
/* -no_interpreted_data (-nid)				       */
/* -raw_data (-rd)						       */
/* -no_raw_data (-nrd)					       */
/* -suppress_duplicates (-sd)					       */
/* -no_suppress_duplicates (nsd)				       */
/* -rest							       */
/* -as structure_name					       */
/* -in pathname						       */
/*							       */
/* Defaults for use as a command:				       */
/*   -no_offset, -raw_data, -no_interpreted_data, -suppress_duplicates       */
/* Defaults for use as an active function:			       */
/*   -no_header, -no_address, -no_offset, -raw_data, -no_interpreted_data    */
/*   -no_suppress_duplicates					       */
/*							       */
/* Last modified (date and reason):				       */
/* 5/15/75	by S.Webber Initial coding (discarding earlier code)     */
/* 11/15/75	by S.Webber to add -address, -offset, -header, and       */
/*			         -block control args		       */
/* 04/27/76	by T. Casey to fix "-block N -offset" to reset offset    */
/*			  for each block, to make -name N work right,  */
/* 			  to accept control argument abbreviations     */
/*			  -addr and -bk, and clean up code and fix     */
/*			  minor obscure bugs.		       */
/* 10/18/76 	by R.Kissel to add -ebcdic9, -ebcdic8, -4bit, -hex8,     */
/*			  hex9 to clean up code, and to change	       */
/*  			  the output format.		       */
/* 02/16/77	by R.Kissel to add the dump_segment_ subroutine entry    */
/*			  point.				       */
/* 01/16/79	by R.J.C. Kissel to fix error message bug.	       */
/* 06/22/79	by S. Herbst to fix error message for MSF's.	       */
/* 04/04/81	by W. Olin Sibert, to use			       */
/*			         ring_zero_peek_$get_max_length_ptr    */
/*			         instead of depending on SDW format.   */
/* 11/03/81	by J. Bongiovanni for -entry_point		       */
/* 09/26/83	by C. Spitzer				       */
/*		phx07028 return more than 1 word if invoked as AF.       */
/*		phx07253 add -raw_data -interpreted_data and complements */
/*		phx08128 use current length instead of max length.       */
/*		phx10338,phx12336 bugfix to print et_$dirseg for	       */
/*			        directories.		       */
/* 		phx08905 make -lg -hex9 -ch work together.	       */
/*		phx14729 correct display for -hex8 and hex9 format.      */
/*		suggestion: add -suppress_duplicates and complement      */
/*			        format.			       */
/*		bug: diagnose illegal CAs when used as active function.  */
/*		bug: correct display for -ch and incompletely filled line*/
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/****^  HISTORY COMMENTS:
  1) change(85-12-17,Spitzer), approve(85-12-17,MCR7119),
     audit(86-01-20,Lippard), install(86-01-29,MR12.0-1009):
     Make -ep work same as octal offsets. Allow rzd dump stack_0.  Add -rest
     CA.
  2) change(85-12-17,Spitzer), approve(85-12-17,MCR7268),
     audit(86-01-20,Lippard), install(86-01-29,MR12.0-1009):
     Allow virtual pointers as input.
  3) change(86-07-30,Kissel), approve(86-07-30,MCR7476), audit(86-08-01,Ex),
     install(86-08-19,MR12.0-1132):
     Changed to call translate_bytes_to_hex9_, which is the new name for
     translate_to_hex9.
  4) change(87-01-02,TLNguyen), approve(87-01-02,MCR7596),
     audit(87-01-16,GWMay), install(87-03-19,MR12.1-1004):
     Fixed the "dump_segment" active function to strip trailing spaces.
  5) change(87-11-26,GDixon), approve(88-01-05,MCR7817),
     audit(88-01-06,Farley), install(88-01-12,MR12.2-1012):
      A) Add -as and -in to display data as a structure.
                                                   END HISTORY COMMENTS */

%page;

/* Automatic */

	dcl     active_func		 bit (1) aligned;
	dcl     arg_for_header_given
				 bit (1);
	dcl     argc		 fixed bin;
	dcl     bit_count		 fixed bin (24);
	dcl     block		 fixed bin (18);
	dcl     buffer		 (64) fixed bin;
	dcl     code		 fixed bin (35);
	dcl     count		 fixed bin (18);
	dcl     cur_length		 fixed bin (18);
	dcl     defn_ptr		 ptr;
	dcl     dir_len		 fixed bin;
	dcl     dirname		 char (168);
	dcl     ename		 char (32);
	dcl     entry_point_name	 char (32);
	dcl     entry_point_offset	 fixed bin (18);
	dcl     entry_type		 fixed bin;
	dcl     entry_var		 entry variable options (variable);
	dcl     first		 fixed bin (18);
	dcl     have_count		 bit (1);
	dcl     have_entry_point	 bit (1);
	dcl     have_first		 bit (1);
	dcl     have_name		 bit (1);
	dcl     have_structure	 bit (1);
	dcl     have_structure_path	 bit (1);
	dcl     hcsp		 (1) ptr;
	dcl     hc_seg		 bit (1);
	dcl     highseg		 fixed bin;
	dcl     i			 fixed bin;
	dcl     initsw		 bit (1);
	dcl     iocbp		 ptr;
	dcl     line_format		 char (28) var;
	dcl     max_length		 fixed bin (19);
	dcl     1 obj_info		 aligned like object_info;
	dcl     p			 ptr;		/* pointer to the segment we are dumping */
	dcl     rel_offset		 fixed bin (18);
	dcl     rest		 bit (1) aligned;
	dcl     ret_tc		 fixed bin (21);
	dcl     ret_tp		 ptr;
	dcl     output_line_len	 fixed bin (21);
	dcl     output_line		 char (256);
	dcl     rz_call		 bit (1);
	dcl     rb2		 bit (6);		/* third ring bracket number */
	dcl     segno		 fixed bin (18);
	dcl     seg_num		 bit (1);
	dcl     structure_name	 char(256) varying; /* name of structure to dump. */
	dcl     structure_path	 char(168);	/* pathname of object pgm compiled with -table */
	dcl     tc		 fixed bin;	/* count of chars in command_arg */
	dcl     tca		 fixed bin;	/* count of chars in seg_name */
	dcl     tp		 ptr;		/* pointer to command_arg */
	dcl     tpa		 ptr;		/* pointer to seg_name */

/* Format control flags */

%include dump_segment_format;
	dcl     address_fmt		 bit (1) defined (dump_segment_format) pos (1);
	dcl     offset_fmt		 bit (1) defined (dump_segment_format) pos (2);
	dcl     short_fmt		 bit (1) defined (dump_segment_format) pos (3);
	dcl     bcd_fmt		 bit (1) defined (dump_segment_format) pos (4);
	dcl     char_fmt		 bit (1) defined (dump_segment_format) pos (5);
	dcl     long_fmt		 bit (1) defined (dump_segment_format) pos (6);
	dcl     ebcdic9_fmt		 bit (1) defined (dump_segment_format) pos (7);
	dcl     ebcdic8_fmt		 bit (1) defined (dump_segment_format) pos (8);
	dcl     bit4_fmt		 bit (1) defined (dump_segment_format) pos (9);
	dcl     hex8_fmt		 bit (1) defined (dump_segment_format) pos (10);
	dcl     hex9_fmt		 bit (1) defined (dump_segment_format) pos (11);
	dcl     octal_fmt		 bit (1) defined (dump_segment_format) pos (12);
	dcl     header		 bit (1) defined (dump_segment_format) pos (13);
	dcl     raw_data_fmt	 bit (1) defined (dump_segment_format) pos (14);
	dcl     interpreted_data_fmt	 bit (1) defined (dump_segment_format) pos (15);
	dcl     suppress_dup_fmt	 bit (1) defined (dump_segment_format) pos (16);
	dcl     command_output_fmt	 bit (1) defined (dump_segment_format) pos (17);

/* Based */

	dcl     command_arg		 char (tc) based (tp);
	dcl     seg_name		 char (tca) based (tpa);
	dcl     return_arg		 char (ret_tc) based (ret_tp) var;

/* Conditions */

	dcl     linkage_error	 condition;
	dcl     cleanup		 condition;
	dcl     not_in_read_bracket
				 condition;

/* Static */

	dcl     dots		 char (33) aligned internal static options (constant) init ((33)".");
	dcl     first_time		 bit (1) static init ("1"b);
	dcl     nonprinting_chars	 char (33) aligned internal static;
	dcl     com_err_fmt		 (25) char (80) var options (constant) static
				 init ("", "^a", "^s^a>^a", "Nonoctal number: ^a", "name/no of segment",
				 "Hardcore segment won't be dumped.", "block size for dumping", "Zero is illegal for count",
				 "First word is ^4s^o, max_length is only ^o", "No control arguments specified to dump any data.",
				 "Control arguments were specified to dump both raw and interpreted data.", "-hex8 and -hex9.",
				 "entry_point name", "^2s^a$^a", "^1s^a>^a$^a",
				 "word count and -entry_point", "Nonpositive octal number: ^a",
				 "Attempt to dump before the beginning of the referenced segment.",
				 "Count argument and -rest.", 
				 "-as must be followed by a structure name.",
				 "-in must be followed by path of object segment.",
				 "-as not allowed with active function.",
				 "Parsing structure ^6s^a.",
				 "Searching for structure ^6s^a in ^[^a^;library^].",
				 "Displaying structure ^6s^a.");
	dcl     active_all_rings_data_$stack_base_segno fixed bin (35) ext static;
	dcl     hcscnt		 fixed bin static;
	dcl     NL		 char (1) int static options (constant) init ("
");
	dcl     me		 (0:1) char (14) internal static options (constant)
				 init ("dump_segment", "ring_zero_dump");

/* External */

	dcl     error_table_$badopt	 fixed bin (35) ext;
	dcl     error_table_$dirseg	 fixed bin (35) ext;
	dcl     error_table_$inconsistent fixed bin(35) ext static;
	dcl     error_table_$lower_ring fixed bin (35) ext;
	dcl     error_table_$msf	 fixed bin (35) ext;
	dcl     error_table_$no_s_permission fixed bin (35) ext;
	dcl     error_table_$noarg	 fixed bin (35) ext;
	dcl     error_table_$too_many_args fixed bin (35) ext;

	dcl     iox_$user_output	 ptr ext;

/* Builtin */

	dcl     (addr, addrel, baseno, baseptr, binary, clock, collate,
	         divide, fixed, index, length, min, mod, null, rel, ptr,
	         reverse, rtrim, search, substr, string, translate, wordno,
	         unspec, verify) builtin;

/* Entries */

	dcl     get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35));
	dcl     release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     initiate_file_	 entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
	dcl     phcs_$initiate	 entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
	dcl     requote_string_	 entry (char(*)) returns(char(*));
	dcl     (ioa_$ioa_switch, com_err_, active_fnc_err_)
				 entry options (variable);
	dcl     hcs_$fs_get_path_name  entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
	dcl     hcs_$high_low_seg_count
				 entry (fixed bin, fixed bin);
	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2),
				 fixed bin (24), fixed bin (35));
	dcl     ring0_get_$segptr	 entry (char (*), char (*), ptr, fixed bin (35));
	dcl     ring0_get_$definition entry (ptr, char (*), char (*), fixed bin (18), fixed bin, fixed bin (35));
	dcl     ring0_get_$name	 entry (char (*), char (*), ptr, fixed bin (35));
	dcl     ring_zero_peek_	 entry (ptr, ptr, fixed bin (18), fixed bin (35));
	dcl     ring_zero_peek_$get_max_length_ptr
				 entry (ptr, fixed bin (19), fixed bin (35));
	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
	dcl     cu_$af_return_arg	 entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
	dcl     (ioa_$rs, ioa_$rsnnl)	 entry options (variable);
	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
	dcl     cv_oct_check_	 entry (char (*), fixed bin (35)) returns (fixed bin);
	dcl     translate_bytes_to_hex9_	 entry (bit (*), char (*));
	dcl     get_ring_		 entry returns (fixed bin (3));
	dcl     get_definition_	 entry (ptr, char (*), char (*), ptr, fixed bin (35));
	dcl     object_info_$brief	 entry (ptr, fixed bin (24), ptr, fixed bin (35));
	dcl     display_data_$for_azm  entry (ptr, bit(*) aligned, (*) char(*) var,
				 fixed bin, ptr, ptr, fixed bin(18), ptr, ptr, (2,*) fixed bin(24),
				 fixed bin, fixed bin(35));
	dcl     structure_find_$pathname
		        		 entry (char(*), char(*), ptr, fixed bin(35));
	dcl     structure_find_$search entry (char(*), ptr, fixed bin(35));
	dcl     structure_ref_$parse   entry (char(*), char(*), char(*), (2,*) fixed bin(24),
				 fixed bin, (*) char(*) var, fixed bin, fixed bin(35));
%page;
	rz_call = "0"b;

	goto COMMON_CODE;				/* dump_segment entry */

ring_zero_dump:
rzd:
     entry;

	rz_call = "1"b;				/* indicate it is legal to dump ring 0 segs */

COMMON_CODE:
	if first_time
	then do;					/* only once get segment number of last hardcore segment */
		call hcs_$high_low_seg_count (highseg, hcscnt);
						/* so we can know if the given seg is hardcore or not */
		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
		first_time = "0"b;
	     end;


/* Initialize */

	string (dump_segment_format) = ""b;		/* initialize all the format flags to 0 */
	iocbp = iox_$user_output;
	have_name, seg_num, have_first, have_count, have_entry_point,
	     have_structure, have_structure_path, initsw,
	     arg_for_header_given, hc_seg = "0"b;
	rest = "0"b;
	rel_offset = 0;
	entry_point_offset = 0;
	block = 0;
	max_length = 0;
	hcsp (1) = null;
	tp = null;
	tc = 0;

	call cu_$af_return_arg (argc, ret_tp, ret_tc, code);
						/* see if active function, also get return string info */
	if code = 0
	then do;
		active_func = "1"b;			/* active function call */
		raw_data_fmt = "1"b;
		return_arg = "";
	     end;
	else do;
		active_func = "0"b;			/* command call */
		address_fmt, raw_data_fmt, suppress_dup_fmt = "1"b;
	     end;

	if argc = 0
	then call PRINT_ERROR (error_table_$noarg, 5);	/* need at least a segment name */

	on cleanup
	     call cleaner_upper;

/* Loop through all arguments setting flags and variables */

	do i = 1 to argc;
	     call get_arg_ptr (i);			/* get pointer and length of i'th arg */
	     if index (command_arg, "-") = 1
	     then do;				/* process control arguments */
		     if (command_arg = "-long" | command_arg = "-lg") & ^active_func
		     then do;
			     long_fmt = "1"b;
			     short_fmt = "0"b;
			end;
		     else if (command_arg = "-suppress_duplicates" | command_arg = "-sd") & ^active_func
		     then suppress_dup_fmt = "1"b;
		     else if command_arg = "-no_suppress_duplicates" | command_arg = "-nsd"
		     then suppress_dup_fmt = "0"b;
		     else if command_arg = "-raw"
		     then raw_data_fmt = "1"b;
		     else if command_arg = "-no_raw" | command_arg = "-nraw"
		     then raw_data_fmt = "0"b;
		     else if command_arg = "-rest"
		     then rest = "1"b;
		     else if command_arg = "-interpreted" | command_arg = "-it"
		     then interpreted_data_fmt = "1"b;
		     else if command_arg = "-no_interpret" | command_arg = "-nit"
		     then interpreted_data_fmt = "0"b;
		     else if command_arg = "-character" | command_arg = "-ch" | command_arg = "-ascii"
		     then do;
			     char_fmt, interpreted_data_fmt = "1"b;
			     bit4_fmt, ebcdic8_fmt, ebcdic9_fmt, bcd_fmt = "0"b;
			     if active_func
			     then raw_data_fmt = "0"b;
			end;
		     else if command_arg = "-bcd"
		     then do;
			     bcd_fmt, interpreted_data_fmt = "1"b;
			     char_fmt, bit4_fmt, ebcdic8_fmt, ebcdic9_fmt = "0"b;
			     if active_func
			     then raw_data_fmt = "0"b;
			end;
		     else if command_arg = "-ebcdic9"
		     then do;
			     ebcdic9_fmt, interpreted_data_fmt = "1"b;
			     char_fmt, bit4_fmt, ebcdic8_fmt = "0"b;
			     if active_func
			     then raw_data_fmt = "0"b;
			end;
		     else if command_arg = "-ebcdic8"
		     then do;
			     ebcdic8_fmt, interpreted_data_fmt = "1"b;
			     char_fmt, bit4_fmt, ebcdic9_fmt = "0"b;
			     if active_func
			     then raw_data_fmt = "0"b;
			end;
		     else if command_arg = "-4bit"
		     then do;
			     bit4_fmt, interpreted_data_fmt = "1"b;
			     char_fmt, ebcdic8_fmt, ebcdic9_fmt = "0"b;
			     if active_func
			     then raw_data_fmt = "0"b;
			end;
		     else if command_arg = "-hex8"
		     then do;
			     hex8_fmt, raw_data_fmt = "1"b;
			     hex9_fmt, octal_fmt = "0"b;
			     if active_func
			     then interpreted_data_fmt = "0"b;
			end;
		     else if command_arg = "-hex9"
		     then do;
			     hex9_fmt, raw_data_fmt = "1"b;
			     hex8_fmt, octal_fmt = "0"b;
			     if active_func
			     then interpreted_data_fmt = "0"b;
			end;
		     else if command_arg = "-octal" | command_arg = "-oc"
		     then do;
			     octal_fmt, raw_data_fmt = "1"b;
			     hex8_fmt, hex9_fmt = "0"b;
			     if active_func
			     then interpreted_data_fmt = "0"b;
			end;
		     else if (command_arg = "-short" | command_arg = "-sh") & ^active_func
		     then do;
			     short_fmt = "1"b;
			     long_fmt = "0"b;
			end;
		     else if (command_arg = "-address" | command_arg = "-ad" | command_arg = "-addr") & ^active_func
		     then address_fmt = "1"b;
		     else if (command_arg = "-no_address" | command_arg = "-naddr" | command_arg = "-nad") & ^active_func
		     then address_fmt = "0"b;
		     else if (command_arg = "-offset" | command_arg = "-ofs") & ^active_func
		     then do;
			     offset_fmt = "1"b;
			     if i < argc
			     then do;
				     call get_arg_ptr (i + 1);
						/* check next arg, if octal then use as offset */
				     rel_offset = cv_oct_check_ (command_arg, code);
				     if code = 0
				     then i = i + 1;/* if octal, advance arg index past it */
				     else rel_offset = 0;
						/* else leave arg index alone and use default of zero */
				end;
			end;
		     else if (command_arg = "-no_offset" | command_arg = "-nofs") & ^active_func
		     then offset_fmt = "0"b;
		     else if (command_arg = "-header" | command_arg = "-he") & ^active_func
		     then header = "1"b;
		     else if (command_arg = "-no_header" | command_arg = "-nhe") & ^active_func
		     then do;
			     header = "0"b;
			     arg_for_header_given = "1"b;
			end;
		     else if (command_arg = "-block" | command_arg = "-bk") & ^active_func
		     then do;
			     if i < argc
			     then do;		/* next argument is the block size */
				     call get_arg_ptr (i + 1);
				     block = cv_oct_check_ (command_arg, code);
				     if code = 0
				     then i = i + 1;
				     else call PRINT_ERROR (0, 4); /* block size is non-octal */
				end;		/* next argument is the block size */
			     else call PRINT_ERROR (error_table_$noarg, 7);    /* no argument given for the block size */
			end;
		     else if command_arg = "-name" | command_arg = "-nm"
		     then do;
			     if i < argc
			     then do;		/* next argument is the segment name */
				     call get_arg_ptr (i + 1);
				     tca = tc;	/* remember name of segment */
				     tpa = tp;	/* in seg_name        */
				     have_name = "1"b;
				     i = i + 1;
				end;		/* next argument is the segment name */
			     else call PRINT_ERROR (error_table_$noarg, 7);    /* no argument given with -name */
			end;
		     else if command_arg = "-entry_point" | command_arg = "-ep"
		     then do;
			     if i < argc
			     then do;
				     call get_arg_ptr (i + 1);
				     have_entry_point = "1"b;
				     entry_point_name = command_arg;
				     i = i + 1;
				end;
			     else call PRINT_ERROR (error_table_$noarg, 13);
			end;
		     else if command_arg = "-as" then do;
			     if i < argc
			     then do;
				     have_structure = "1"b;
				     call get_arg_ptr (i + 1);
				     structure_name = command_arg;
				     i = i + 1;
				end;
			     else call PRINT_ERROR (error_table_$noarg, 20);
			end;
		     else if command_arg = "-in" then do;
			     if i < argc
			     then do;
				     have_structure_path = "1"b;
				     call get_arg_ptr (i + 1);
				     structure_path = command_arg;
				     i = i + 1;
				end;
			     else call PRINT_ERROR (error_table_$noarg, 21);
			end;
		     else do;
			     if verify (command_arg, "-0123456789") = 0
			     then goto NON_CONTROL_ARG;
			     else call PRINT_ERROR (error_table_$badopt, 2);   /* bad control argument */
			end;
		end;				/* process control arguments */
	     else do;				/* process non-control arguments */

NON_CONTROL_ARG:
		     if ^have_name
		     then do;			/* segment name, number or virtual pointer is the first non-control argument */
			segno = cv_oct_check_ (command_arg, code);
			if code = 0
			then do;			/* segment number given */
			     if segno < 0 then call PRINT_ERROR (0, 17);
			     have_name = "1"b;
			     tca = tc;
			     tpa = tp;
			     seg_num = "1"b;
			     if segno < hcscnt
			     then do;		/* do check for a hc segment */
				if rz_call
				then hc_seg = "1"b;
				else call PRINT_ERROR (0, 6);
						/* rzd must be used to dump a hc segment */
				end;		/* do check for hc segment */
			     end;			/* segment number given */
			else do;			/* pathname or SLT name given */
			     have_name = "1"b;
			     tca = tc;		/* remember the segment name */
			     tpa = tp;		/* in seg_name         */
			     end;			/* pathname or SLT name given */
		          end;			/* segment name or number is the first non-control argument */
		     else if ^have_first
		     then do;			/* first word is the second non-control argument */
			     first = cv_oct_check_ (command_arg, code);
			     if code ^= 0
			     then call PRINT_ERROR (0, 4); /* non-octal number for first */
			     have_first = "1"b;
			end;			/* first word is the second non-control argument */
		     else if ^have_count
		     then do;			/* count is the third non-control argument */
			     count = cv_oct_check_ (command_arg, code);
			     if code ^= 0
			     then call PRINT_ERROR (0, 4); /* non-octal number for count */
			     if count < 0 then call PRINT_ERROR (0, 17);
			     have_count = "1"b;
			end;			/* count is the third non-control argument */
		     else call PRINT_ERROR (error_table_$too_many_args, 2); /* four non-control arguments is an error */
		end;				/* process non-control arguments */
	end;					/* do loop thru command arguments */

/* Check for legal formats and finish setting variables */

          if have_structure then
	   raw_data_fmt = (octal_fmt | hex8_fmt | hex9_fmt);

	if ^raw_data_fmt & ^interpreted_data_fmt & ^have_structure
	then call PRINT_ERROR (0, 10);		/* asked to do nothing */

	if have_structure & active_func		/* structures not allowed in AF output.*/
	then call PRINT_ERROR (0, 22);

	if raw_data & interpreted_data_fmt & active_func
	then call PRINT_ERROR (0, 11);		/* asked for both as an AF */

	if rest & have_count
	then call PRINT_ERROR (error_table_$inconsistent, 19);

          if raw_data_fmt & (^hex8_fmt & ^hex9_fmt & ^octal_fmt)
	then octal_fmt = "1"b;			/* default raw data */

	if interpreted_data_fmt & (^bit4_fmt & ^bcd_fmt & ^char_fmt & ^ebcdic8_fmt & ^ebcdic9_fmt)
	then char_fmt = "1"b;			/* default interpreted data */

	if ^have_name
	then call PRINT_ERROR (error_table_$noarg, 5);	/* segment must be specified */
	else do;					/* obtain information about specified segment */
		if seg_num
		then do;				/* segment was specified by number in segno */
			p = baseptr (segno);
			if segno < hcscnt
			then do;			/* this is a hc segment number */
				if rz_call
				then do;		/* rzd ok with hc segments */
					call ring0_get_$name (dirname, ename, p, code);
					if code ^= 0 then call PRINT_ERROR (code, 1);
					call set_max_from_SDW;
					cur_length = max_length;
				     end;		/* rzd ok with hc segments */
				else call PRINT_ERROR (0, 6); /* ds cannot be used with hc segments */
			     end;			/* this is a hc segment number */
			else if segno = active_all_rings_data_$stack_base_segno
			     then do;		/* special case stack_0 */
				     dirname = "";
				     ename = "stack_0";
				     call set_max_from_SDW;
				     cur_length = max_length;
				end;
			else do;			/* this is a user segment number */
				call hcs_$fs_get_path_name (p, dirname, dir_len, ename, code);
				if code ^= 0
				then do;		/* bad number specified */
					tp = tpa;
					tc = tca;
					call PRINT_ERROR (code, 2);
				     end;		/* bad number specified */
				if dirname = " "
				then dirname = ">"; /* handle the root special case */
				call set_curlng_and_rb;
			     end;			/* this is a user segment number */
		     end;				/* segment was specified by number in segno */
		else do;				/* segment was specified by SLT or pathname in seg_name */
			if rz_call
			then do;			/* try SLT name first for rzd call */
				call ring0_get_$segptr ("", seg_name, p, code);
				if p ^= null
				then do;		/* SLT name, get length from SDW */
					segno = fixed (baseno (p), 18);
					hc_seg = "1"b;
					call set_max_from_SDW;
					cur_length = max_length;
					ename = seg_name;
				     end;		/* SLT name, get length from SDW */
				else call process_name;  /* must be a pathname or a virtual pointer */
			     end;			/* try SLT name first for rzd call */
			else call process_name;	/* must be a pathname or virtual pointer */
		     end;				/* segment was specified by SLT or pathname in seg_name */
	     end;					/* obtain information about the specified segment */
	if have_entry_point
	then do;
		if hc_seg
		then do;
			call ring0_get_$definition (p, "", entry_point_name, entry_point_offset, entry_type, code);
			if code ^= 0 then call PRINT_ERROR (code, 14);
		     end;
		else do;
			call hcs_$status_minf (dirname, ename, 1, 0, bit_count, code);
			if code ^= 0
			then call PRINT_ERROR (code, 5);

			on not_in_read_bracket
			     call PRINT_ERROR (error_table_$lower_ring, 15);
			call object_info_$brief (p, bit_count, addr (obj_info), code);
			revert not_in_read_bracket;
			if code ^= 0
			then call PRINT_ERROR (code, 15);
			call get_definition_ (obj_info.defp, "", entry_point_name, defn_ptr, code);
			if code ^= 0 then call PRINT_ERROR (code, 15);
			entry_point_offset = binary (defn_ptr -> definition.value, 18);
		     end;
		if ^have_count & ^have_structure
		then do;				/* make it look like we did have a count of 1 word */
		          if ^have_first
			then do;
			          first = 0;
				have_first = "1"b;
			     end;
			count = 1;
			have_count = "1"b;
		     end;
	     end;
	if max_length = 0
	then do;					/* set max_length if it has'nt been done already */
		max_length = cur_length;		/* set highest dumped address to current length of */
						/* segment as guarenteed to be highest used page. */
	     end;					/* set max_length if it has'nt been done already */
	if have_structure & ^have_first
	then do;
		first = 0;
		have_first = "1"b;
	     end;

	if have_structure & ^have_count
	then do;
		count = cur_length - first;
		have_count = "1"b;
	     end;

	if ^have_first
	then do;					/* don't have first or count */
		if ^arg_for_header_given
		then header = "1"b;			/* include header when dumping the whole segment */
		first = 0;
		count = max_length;			/* default to seg length for command */
		have_first = "1"b;
	     end;					/* don't have first or count */
	else if ^have_count
	then do;					/* have first but don't have count */
		if rest
		then count = max_length;
		else count = 1;
		have_count = "1"b;
	     end;					/* have first but don't have count */
	first = first + entry_point_offset;
	if first >= max_length
	then call PRINT_ERROR (0, 9);			/* can't dump past the end of the segment */
	else if first < 0
	     then call PRINT_ERROR (0, 18);		/*   or before the beginning of the segment */
	if first + count > max_length
	then do;					/* only dump to max_length with no error indicated */
		count = max_length - first;
	     end;
	if block = 0 | block > count
	then block = count;				/* set words per block if it has'nt been done yet */

	if binary (rb2) < get_ring_ ()
	then do;					/* make a final access check */
		if rz_call
		then hc_seg = "1"b;
		else call PRINT_ERROR (0, 6);		/* error for ds call */
	     end;					/* make a final access check */

/* Now print what we are told to */


	if hc_seg
	then do;					/* output for hc segment */
		if count <= 64
		then hcsp (1) = addr (buffer);
		else do;				/* get a temp seg to copy the hc seg into */
			call get_temp_segments_ (me (binary (rz_call)), hcsp, code);
			if code ^= 0
			then call PRINT_ERROR (code, 1);	/* no temp segments available */
		     end;				/* get a temp seg to copy the hc seg into */
		call ring_zero_peek_ (addrel (p, first), hcsp (1), count, code);
		if code ^= 0
		then call PRINT_ERROR (code, 1);	/* we failed */

		if active_func
		then call return_dump (hcsp (1), first, count, cur_length, rel_offset);
		else call print_dump (hcsp (1), first, count, cur_length, block, rel_offset);

	     end;					/* output for hc segment */

	else do;					/* output for user segment */
		if active_func
		then call return_dump (addrel (p, first), first, count, cur_length, rel_offset);
		else call print_dump (addrel (p, first), first, count, cur_length, block, rel_offset);
						/* output for user segment */
	     end;					/* output for user segment */

	if active_func
	then return_arg = requote_string_ (rtrim (return_arg));
 /* fixed TR number 20051: want returned string without strailing spaces. */
CLEANUP:
	call cleaner_upper;
	return;
%page;
PRINT_ERROR:					/* come here to print all com_err_ messages. */
     proc (code, com_err_fmt_index);

dcl code fixed bin (35) parameter;
dcl com_err_fmt_index fixed bin parameter;

	if active_func
	then entry_var = active_fnc_err_;
	else entry_var = com_err_;
	if com_err_fmt_index = 3 then do;
		if code = error_table_$dirseg then do;
			bit_count = 0;
			call hcs_$status_minf (dirname, ename, 1, 0, bit_count, code);
			if code = 0
			then if bit_count ^= 0
			     then code = error_table_$msf;
			     else code = error_table_$dirseg;
			else code = error_table_$dirseg; /* couldn't get status on it, leave alone */
		     end;
	     end;
	if dirname = ">" then dirname = "";
	call entry_var (code, me (binary (rz_call)), com_err_fmt (com_err_fmt_index),
	     command_arg, dirname, ename, entry_point_name, first, max_length,
	     structure_name, have_structure_path, structure_path);
	goto CLEANUP;

	end PRINT_ERROR;
%page;

cleaner_upper:
     proc;

	if initsw & (^hc_seg)
	then call terminate_file_ (p, 0, TERM_FILE_TERM, code);
	if hcsp (1) ^= null
	then call release_temp_segments_ (me (binary (rz_call)), hcsp, code);
     end cleaner_upper;

%page;
process_name:
     proc;

/* Global variables used:
   Input:   seg_name char(tca) based(tpa)
	  hcscnt   fixed bin internal static
   Output:  dirname char (168)
	  ename   char (32)
	  p       pointer
	  segno   fixed bin (18)
	  initsw   bit (1)
	  hc_seg   bit (1)
*/

	tc = tca;					/* initialize for error messages */
	tp = tpa;

	call expand_pathname_ (seg_name, dirname, ename, code);
	if code = 0 then do;
	     call initiate_file_ (dirname, ename, R_ACCESS, p, (0), code);
	     if p ^= null then do;
		initsw = "1"b;
		segno = binary (baseno (p), 18);
		call set_curlng_and_rb;
		end;
	     else goto TRY_SEGNAME_AS_VIRTUAL_POINTER;
	     end;
	else do;
TRY_SEGNAME_AS_VIRTUAL_POINTER:
	     if rz_call				/* try through phcs_ */
	     then do;
		on linkage_error
		     call PRINT_ERROR (0, 2);		/* in case no access to gate */
		
		call phcs_$initiate (dirname, ename, "", 0, 0, p, code);
		revert linkage_error;

		if p = null
		then do;				/* try it as a virtual pointer */
		     p = cv_ptr_ (seg_name, code);
		     if code ^= 0
		     then call PRINT_ERROR (code, 2);
		     end;

		segno = binary (baseno (p), 18);
		call set_max_from_SDW;
		cur_length = max_length;
		end;
	     else do;
		p = cv_ptr_ (seg_name, code);
		if code ^= 0
		then call PRINT_ERROR (code, 2);

		call hcs_$fs_get_path_name (p, dirname, dir_len, ename, code);
		if code ^= 0
		then call PRINT_ERROR (code, 2);

		segno = binary (baseno (p), 18);
		call set_curlng_and_rb;
		end;
	     end;

	if segno < hcscnt
	then hc_seg = "1"b;				/* hardcore segment */

	if have_first
	then first = first + wordno (p);
	else do;
	     first = wordno (p);
	     have_first = (first ^= 0);
	     end;
	p = ptr (p, 0);				/* point p to base of segment */
	have_name, seg_num = "1"b;

	return;
     end process_name;
%page;
get_arg_ptr:
     proc (argno);

/* This procedure MUST be quick internal */

/* Uses as input

   active_func bit (1)
*/

/* Sets

   tp    pointer (command_arg)
   tc    fixed bin (command_arg)
   code  fixed bin (35)
*/

/* Entries */

	dcl     cu_$af_arg_ptr	 entry (fixed bin, ptr, fixed bin, fixed bin (35));
	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));

/* Automatic */

	dcl     argno		 fixed bin;

	if active_func
	then call cu_$af_arg_ptr (argno, tp, tc, code);
	else call cu_$arg_ptr (argno, tp, tc, code);

     end get_arg_ptr;

%page;

set_curlng_and_rb:
     proc;

/* Uses as input

   dirname    char (168)
   ename        char (32)
   max_length   fixed bin (19)
*/

/* Sets and uses

   code fixed bin (35)
*/

/* Sets

   rb2		 bit (6)
   cur_length        fixed bin (19)
   com_err_fmt_index fixed bin
*/

/* Automatic */

%include branch_status;

/* External Variables */

	dcl     error_table_$root	 external;

/* Entries */

	dcl     hcs_$status_long	 entry (char (*), char (*), fixed bin, ptr, ptr, fixed bin (35));

	call hcs_$status_long (dirname, ename, 1, addr (branch_status), (null), code);
	if code = error_table_$root
	then do;					/* set cur_length of root using SDW */
		call set_max_from_SDW;		/* this is required because of a bug in hcs_$status_long */
		cur_length = max_length;
	     end;					/* set cur_length  of root using SDW */
	else if code = error_table_$no_s_permission | code = 0
						/* normal segment */
	then do;
		cur_length = fixed (branch_status.current_length, 12) * 1024;
		if cur_length = 0
		then cur_length = 1;
		if type = directory_type
		then rb2 = "0"b;			/* this is a dir so the rb given by status_ is a extended */
		else rb2 = ring_brackets (1);		/* other segment so ok */

/* ------------------------------------------------------------------------------------------------- */
/* The following must be eliminated when hcs_$status_ returns the ring brackets                    */

		if code = error_table_$no_s_permission
		then do;
			if rz_call
			then rb2 = "0"b;		/* assume ring_zero_peek must be used for rzd call */
			else do;			/* handle ds call */
				if mode ^= "0"b
				then rb2 = "111"b;	/* ds can look at it */
				else rb2 = "0"b;	/* ds cannot look at it */
			     end;			/* handle ds call */
		     end;

/* ------------------------------------------------------------------------------------------------- */
	     end;					/* normal segment */
	else call PRINT_ERROR (code, 3);		/* status failed for some reason */

     end set_curlng_and_rb;

%page;

set_max_from_SDW:
     proc;

/* Uses as input

   segno fixed bin (18)
*/

/* Sets

   code		 fixed bin (35)
   max_length	 fixed bin (19)
   com_err_fmt_index fixed bin
*/

	call ring_zero_peek_$get_max_length_ptr (baseptr (segno), max_length, code);
	if code ^= 0
	then call PRINT_ERROR (code, 1);		/* we failed */

	return;

     end set_max_from_SDW;

%page;
print_header:
     proc;

/* Uses as input

   header bit (1)
   segno  fixed bin (18)
   hcscnt fixed bin static
   dirname char (168)
   ename   char (32)
   p       pointer
*/

/* Sets and uses

   code fixed bin (35)
*/

/* Automatic */

	dcl     date_time		 char (24);
	dcl     name		 char (168);
	dcl     dlen		 fixed bin;

/* Entries */

	dcl     date_time_		 entry (fixed bin (71), char (*));
	dcl     ring0_get_$name	 entry (char (*), char (*), ptr, fixed bin (35));


	call date_time_ (clock (), date_time);
	if segno < hcscnt
	then do;					/* header for hc seg */
		call ring0_get_$name ("", name, p, code);
		dlen = index (name, " ") - 1;
		name = "HARDCORE SEG -- " || substr (name, 1, dlen);
	     end;					/* header for hc seg */
	else if segno = active_all_rings_data_$stack_base_segno
	     then do;				/* special case stack_0 */
		name = "stack_0";
	     end;
	else do;					/* header for user seg */
		dlen = index (dirname, " ") - 1;
		if dlen <= 1
		then dlen = 0;			/* to avoid >>foo */
		if ename = "" & dirname = ""
		then name = "";			/* in case couldn't find the path out */
		else name = substr (dirname, 1, dlen) || ">" || ename;
	     end;					/* header for user seg */
	call ioa_$rs ("^/^2-^a^-^a^/", output_line, output_line_len, name, date_time);
	if active_func
	then return_arg = return_arg || substr (output_line, 1, output_line_len);
	else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);

/* If no header is printed, no white space will be inserted  before the dump starts */

     end print_header;

%page;
translate_line_to_dump:
     proc (wds_in_line, line_ptr, translation);

/* Formal Parameters */

	dcl     wds_in_line		 fixed bin;
	dcl     line_ptr		 ptr;
	dcl     translation		 char (32) varying;

/* Automatic, structures for accessing the input line and subrutine return args */

	dcl     ascii_chars		 char (wds_in_line * 4) based (line_ptr);
	dcl     bcd_chars		 bit (wds_in_line * 36) based (line_ptr);
	dcl     ebcdic9_chars	 char (wds_in_line * 4) based (line_ptr);
	dcl     ebcdic8_chars	 bit (divide (wds_in_line * 9, 2, 17) * 36) based (line_ptr);
	dcl     fourbit_chars	 bit (wds_in_line * 36) based (line_ptr);

	dcl     overlay_return	 char (32);	/* used to make this a quick block */
	dcl     bcd_return		 char (wds_in_line * 6) based (addr (overlay_return));
	dcl     ebcdic9_return	 char (wds_in_line * 4) based (addr (overlay_return));
	dcl     ebcdic8_return	 char (divide (wds_in_line * 9, 2, 17)) based (addr (overlay_return));
	dcl     comp_8_return	 char (wds_in_line * 8) based (addr (overlay_return));

	dcl     i			 fixed bin;	/* character string index */
	dcl     temp_overlay	 char (32);	/* used to make this a quick block */
	dcl     temp_ascii		 char (length (ascii_chars)) based (addr (temp_overlay));
	dcl     temp_ebcdic9	 char (length (ebcdic9_chars)) based (addr (temp_overlay));

/* Constants */

	dcl     last_ascii		 char (1) aligned internal static options (constant) initial ("");
						/* last ascii char code */
	dcl     last_ebcdic		 char (1) aligned internal static options (constant) initial ("ÿ");
						/* last ebcdic char code */


/* Entries */

	dcl     bcd_to_ascii_	 entry (bit (*), char (*));
	dcl     ebcdic_to_ascii_	 entry (char (*), char (*));
	dcl     comp_8_to_ascii_	 entry (bit (*), char (*));
	dcl     ebcdic8_to_ascii_	 entry (bit (*), char (*));

	translation = "";

	if char_fmt
	then do;
		temp_ascii = ascii_chars;
		do i = 1 to length (ascii_chars) by 1;	/* set illegal characters to 0 */
		     if substr (ascii_chars, i, 1) > last_ascii
		     then substr (temp_ascii, i, 1) = " ";
		end;				/* set illegal characters to 0 */
		translation = translate (temp_ascii, dots, nonprinting_chars);
	     end;

	else if bcd_fmt
	then do;
		call bcd_to_ascii_ (bcd_chars, bcd_return);
		translation = bcd_return;
	     end;

	else if ebcdic9_fmt
	then do;
		temp_ebcdic9 = ebcdic9_chars;
		do i = 1 to length (ebcdic9_chars) by 1;/* set illegal characters to 0 */
		     if substr (ebcdic9_chars, i, 1) > last_ebcdic
		     then substr (temp_ebcdic9, i, 1) = " ";
		end;				/* set illegal characters to 0 */
		call ebcdic_to_ascii_ (temp_ebcdic9, ebcdic9_return);
		translation = translate (ebcdic9_return, dots, nonprinting_chars);
	     end;

	else if ebcdic8_fmt
	then do;
		call ebcdic8_to_ascii_ (ebcdic8_chars, ebcdic8_return);
		translation = translate (ebcdic8_return, dots, nonprinting_chars);
	     end;

	else if bit4_fmt
	then do;
		call comp_8_to_ascii_ (fourbit_chars, comp_8_return);
		translation = comp_8_return;
	     end;


     end translate_line_to_dump;

%page;
return_dump:
     proc (seg_ptr, first, count, cur_length, rel_offset);

/* Return the dump when used as an active function. The format of the returned
   ascii string is set such that if -ascii is used, then the ascii
   translation is returned, otherwise the returned string is the octal, hex,
   bcd or ebcdic form of the translation. */

/* Formal parameters */

	dcl     seg_ptr		 ptr;		/* to segment to dump */
	dcl     first		 fixed bin (18);	/* in words */
	dcl     count		 fixed bin (18);	/* in words */
	dcl     cur_length		 fixed bin (18);	/* in blocks of 1024 words */
	dcl     rel_offset		 fixed bin (18);	/* in words */

/* Based */

	dcl     seg_wds		 (0:262143) bit (36) based (seg_ptr);
	dcl     word_mask		 (1:1024) fixed bin (35) based (blockp);

/* Automatic */

	dcl     tailx		 fixed bin;
	dcl     block_addr		 fixed bin;
	dcl     block_lng		 fixed bin;
	dcl     last_block		 bit (1) aligned;
	dcl     wds_in_line		 fixed bin;
	dcl     blockp		 ptr;

/* Static */

	dcl     af_format		 (0:7) char (15) var options (constant) static
				 init ("^v(^.3b ^)", "^vs^a", "^v(^.4b ^)", "^vs^a", "^v(^a ^)", "^vs^a",
				 "", "^vs^a");

	wds_in_line = 8;				/* dump 8 words at a time */

	if interpreted_data_fmt
	then tailx = 1;
	else tailx = 0;
	if raw_data_fmt
	then if hex8_fmt
	     then tailx = tailx + 2;
	     else if hex9_fmt
	     then tailx = tailx + 4;
	     else if octal_fmt
	     then ;				/* default */
	     else ;
	else tailx = tailx + 6;

	line_format = af_format (tailx);

	block_lng = min (count, 1024);		/* process by 1024 (or count if seg is less than 1024 long) */
						/* words until last block */
	last_block = "0"b;

	do block_addr = first to first + count - block_lng - 1 by block_lng;
	     call return_block;
	end;

	last_block = "1"b;				/* now do the last block in the segment */

	if ^have_count
	then do;
		blockp = addrel (seg_ptr, block_addr);
		do block_lng = first + count - block_addr to 1 by -1
		     while (blockp -> word_mask (block_lng) = 0); /* look for last non_zero word */
		end;
		if block_lng = 0 then return;		/* was all zeros */
	     end;
	else block_lng = first + count - block_addr;

	call return_block;

	return;

%page;
return_block:
     proc;

/* Automatic */

	dcl     line_addr		 fixed bin;
	dcl     first_line		 bit (1) aligned;

	first_line = "0"b;
	do line_addr = block_addr to block_addr + block_lng - wds_in_line - 1 by wds_in_line;
	     call return_line (wds_in_line, line_addr + wds_in_line - 1);
	end;

/* Now handle the last line */

	if last_block
	then call return_line (block_addr + block_lng - line_addr, block_addr + block_lng - 1);
	return;

%page;
return_line:
     proc (wds_in_line, line_addr_limit);

/* Formal parameters */

	dcl     wds_in_line		 fixed bin parameter;
	dcl     line_addr_limit	 fixed bin (18) parameter;

/* Automatic */

	dcl     output_words	 (1:wds_in_line) bit (36) based (addr (line_to_dump));
	dcl     bits_to_dump	 bit (wds_in_line * 36) based (addr (line_to_dump));
	dcl     translation		 char (32) varying;
	dcl     hex9_line		 char (64);
	dcl     hex9_array		 (1:wds_in_line) char (8) based (addr (hex9_line));
	dcl     wrd_addr		 fixed bin (18);
	dcl     line_to_dump	 (1:8) bit (36);

	do wrd_addr = line_addr to line_addr_limit by 1;
	     if wrd_addr <= cur_length - 1
	     then line_to_dump (wrd_addr - line_addr + 1) = seg_wds (wrd_addr - first);
	     else line_to_dump (wrd_addr - line_addr + 1) = (36)"0"b;
	end;

	if interpreted_data_fmt
	then call translate_line_to_dump (wds_in_line, addr (line_to_dump), translation);
	if hex9_fmt
	then do;
		call translate_bytes_to_hex9_ (bits_to_dump, hex9_line);
		call ioa_$rsnnl (line_format, output_line, output_line_len, wds_in_line, hex9_array, translation);
	     end;
	else call ioa_$rsnnl (line_format, output_line, output_line_len, wds_in_line, output_words, translation);

	return_arg = return_arg || substr (output_line, 1, output_line_len);

     end return_line;

     end return_block;

     end return_dump;

%page;
print_dump:
     proc (seg_ptr, first, count, cur_length, block_lng, rel_offset);

/* Note for future improvments that there is a complete symmetry between blocks and lines:
   duplicates must be found; the first duplicate must print a message and subsequent ones
   are suppressed; the last one must be handled separately and always printed.             */

/* Formal  parameters */

	dcl     seg_ptr		 ptr;
	dcl     first		 fixed bin (18);
	dcl     count		 fixed bin (18);
	dcl     cur_length		 fixed bin (18);
	dcl     block_lng		 fixed bin (18);
	dcl     rel_offset		 fixed bin (18);

/* Based */

	dcl     seg_wds		 (0:262143) bit (36) based (seg_ptr);

/* Automatic */

	dcl     block_addr		 fixed bin (18);
	dcl     dup_block		 bit (1);
	dcl     first_block		 bit (1);
	dcl     first_dup_block	 bit (1);
	dcl     hfx		 fixed bin;
	dcl     i			 fixed bin;
	dcl     (j, k)		 fixed bin (18);
	dcl     last_block		 bit (1);
	dcl     shfx		 fixed bin;
	dcl     length_of_digit_field	 fixed bin;
	dcl     number_of_digit_fields fixed bin;
	dcl     tailx		 fixed bin;
	dcl     wds_in_line		 fixed bin;

/* Static */

	dcl     short_format	 (0:3) char (8) static init ("^6w^s", "^s^6w", "^6w^s", "^6w ^6w");
	dcl     head_format		 (0:7) char (12) var static init ("^2s",
						/* ^addr, ^off, ^short */
				 "^2s",		/* ^addr, ^off, short */
				 "^s^6w^x",	/* ^addr, off, ^short */
				 "^s^2w^x",	/* ^addr, off, short */
				 "^6w^x^s",	/* addr, ^off, ^short */
				 "^2w^x^s",	/* addr, ^off, short */
				 "^6w^x^6w^x",	/* addr, off, ^short */
				 "^2w^x^s");	/* addr, off, short */
	dcl     tail_format		 (0:7) char (15) var options (constant) static
				 init ("^v(^.3b ^)", "^v(^.3b ^)^vx^a", "^v(^.4b ^)", "^v(^.4b ^)^vx^a", "^v(^a ^)",
				 "^v(^a ^)^vx^a", "", "^vs^s^a");

	if header
	then call print_header;

	if long_fmt
	then wds_in_line = 8;
	else wds_in_line = 4;
	shfx = binary (substr (dump_segment_format, 1, 2), 2);
	hfx = binary (substr (dump_segment_format, 1, 3), 3);
	if interpreted_data_fmt
	then tailx = 1;
	else tailx = 0;
	if raw_data_fmt
	then if hex8_fmt
	     then tailx = tailx + 2;
	     else if hex9_fmt
	     then tailx = tailx + 4;
	     else if octal_fmt
	     then ;				/* default */
	     else ;
	else tailx = tailx + 6;

	line_format = head_format (hfx) || tail_format (tailx);

/* Set the length of the field that is used for printing the octal or hex
   information according to what type of info we're displaying. */

	if hex9_fmt
	then length_of_digit_field = 9;		/* hex9 data */
	else if hex8_fmt
	then length_of_digit_field = 10;		/* hex8 data */
	else length_of_digit_field = 13;		/* octal data */

/* Set the number of digit fields on a COMPLETE output line so we can
   later calculate how many spaces to put on the last line if it is not
   filled. */

	if long_fmt
	then number_of_digit_fields = 8;
	else number_of_digit_fields = 4;

	first_block = "1"b;
	first_dup_block = "1"b;
	last_block = "0"b;
	dup_block = "0"b;
	do block_addr = first to first + count - block_lng - 1 by block_lng;
	     if first_block
	     then do;				/* always print the first block */
		     if have_structure then
		     call print_structure;
		     if raw_data_fmt | interpreted_data_fmt
		     then call print_block;
		     if active_func			/* blank line between blocks */
		     then return_arg = return_arg || NL;
		     else call ioa_$ioa_switch (iocbp, " ");
		     first_block = "0"b;
		end;				/* always print the first block */
	     else do;				/* test subsequent blocks for duplicates */
		     if block_addr - block_lng <= cur_length - 1
		     then do;			/* check for dup blocks */
			     dup_block = "1"b;
			     do i = 0 to block_lng - 1;
				j = block_addr - block_lng + i;
				k = block_addr + i;
				if j <= cur_length - 1
				then do;		/* don't exceed the current length of old block */
					if k <= cur_length - 1
					then do;	/* don't exceed the current length of new block */
						if seg_wds (k - first) ^= seg_wds (j - first)
						then dup_block = "0"b;
					     end; /* don't exceed the current length of new block */
					else do;	/* use 0 past current length of new block */
						if "0"b ^= seg_wds (j - first)
						then dup_block = "0"b;
					     end; /* use 0 past current length of new block */
				     end;		/* don't exceed the current length of old block */
				else ;
			     end;
			end;			/* check for dup blocks */
		     else dup_block = "1"b;		/* must be duplicates */
		     if dup_block & first_dup_block
		     then do;			/* print message for first dup block */
			     if active_func
			     then return_arg = return_arg || "duplicate blocks" || NL || NL;
			     else call ioa_$ioa_switch (iocbp, "duplicate blocks^/");
			     first_dup_block = "0"b;
			     if have_structure then
			     call print_structure;
			     if raw_data_fmt | interpreted_data_fmt
			     then call print_block;
			end;			/* print message for first dup block */
		     else do;			/* check further before printing */
			     if ^dup_block
			     then do;		/* not a dup block, print it */
				     if have_structure then
				     call print_structure;
				     if raw_data_fmt | interpreted_data_fmt
				     then call print_block;
				     if active_func /* blank line between blocks */
				     then return_arg = return_arg || NL;
				     else call ioa_$ioa_switch (iocbp, " ");
				     first_dup_block = "1"b;
				end;		/* not a dup block, print it */
			     else ;		/* null because we don't print dup blocks  */
			end;			/* check further before printing */
		end;				/* test subsequent blocks for duplicates */
	end;

/* Now handle the last block */

	last_block = "1"b;
	block_lng = first + count - block_addr;
	if have_structure then
	call print_structure;
	if raw_data_fmt | interpreted_data_fmt
	then call print_block;			/* always print the last block */


%page;
print_block:
     proc;


/* Automatic */

	dcl     cur_line		 char (wds_in_line * 4) based (addrel (seg_ptr, line_addr - first));
						/* dcled char instead of bit since CMPC is faster than CMPB */
	dcl     dup_line		 bit (1);
	dcl     first_dup_line	 bit (1);
	dcl     first_line		 bit (1);
	dcl     line_addr		 fixed bin (18);
	dcl     offset_addr		 fixed bin (18);
	dcl     prev_addr		 fixed bin (18);	/* for use by print_line */
	dcl     prev_line		 char (wds_in_line * 4) based (addrel (seg_ptr, prev_line_addr - first));
						/* dcled char instead of bit since CMPC is faster than CMPB */
	dcl     prev_line_addr	 fixed bin (18);
	dcl     i			 fixed bin;
	dcl     (j, k)		 fixed bin (18);

	first_line = "1"b;
	first_dup_line = "1"b;
	offset_addr = rel_offset;
	prev_addr = block_addr;
	prev_line_addr = block_addr;
	do line_addr = block_addr to block_addr + block_lng - wds_in_line - 1 by wds_in_line;
	     if first_line
	     then do;				/* handle first line differently */
		     if last_block | ^dup_block
		     then do;			/* print first line unless a dup block */
			     call print_line (wds_in_line, line_addr + wds_in_line - 1);
			     first_line = "0"b;
			end;			/* print first line unless a dup block */
		end;				/* handle first line differently */
	     else do;				/* handle subsequent lines */
		     if line_addr - wds_in_line <= cur_length - 1
		     then do;			/* check for dup lines */
			     dup_line = "1"b;
			     if line_addr + wds_in_line <= cur_length - 1
			     then do;		/* everything less than cur_length */
				     if prev_line_addr ^= line_addr
				     then do;
					     if prev_line = cur_line
					     then dup_line = "1"b;
					     else dup_line = "0"b;
					end;
				end;		/* everything less than cur_length */
			     else do;		/* cross over cur_length */
				     do i = 0 to wds_in_line - 1;
					j = line_addr - wds_in_line + i;
					k = line_addr + i;
					if j <= cur_length - 1 & k <= cur_length - 1
					then do;
						if seg_wds (j - first) ^= seg_wds (k - first)
						then dup_line = "0"b;
					     end;
					else if j <= cur_length - 1
					then do;
						if seg_wds (j - first) ^= "0"b
						then dup_line = "0"b;
					     end;
					else ;	/* both words must be 0 so equal */
				     end;
				end;		/* cross over cur_length */
			end;			/* check for dup lines */
		     else dup_line = "1"b;		/* must be duplicates */
		     if dup_line & first_dup_line & suppress_dup_fmt
		     then do;			/* print message for first dup line */
			     if active_func
			     then return_arg = return_arg || "======" || NL;
			     else call ioa_$ioa_switch (iocbp, "======");
			     first_dup_line = "0"b;
			end;			/* print message for first dup line */
		     else if ^dup_line | ^suppress_dup_fmt
		     then do;			/* print this line */
			     call print_line (wds_in_line, line_addr + wds_in_line - 1);
			     first_dup_line = "1"b;
			end;			/* print this line */
		     else ;			/* null because we don't print dup lines */
		end;				/* handle subsequent lines */
	     offset_addr = offset_addr + wds_in_line;	/* keep offset_addr up with line_addr */
	     prev_line_addr = line_addr;
	end;

/* Now handle the last line */

	if last_block | ^dup_block
	then call print_line (block_addr + block_lng - line_addr, block_addr + block_lng - 1);
	return;

%page;
print_line:
     proc (wds_in_line, line_addr_limit);

/* Formal parameters */

	dcl     wds_in_line		 fixed bin;
	dcl     line_addr_limit	 fixed bin (18);

/* Automatic */

	dcl     addr_col		 fixed bin (18);
	dcl     line_to_dump	 (1:8) bit (36);
	dcl     offset_col		 fixed bin (18);
	dcl     wrd_addr		 fixed bin (18);
	dcl     output_words	 (1:wds_in_line) bit (36) based (addr (line_to_dump));
	dcl     bits_to_dump	 bit (wds_in_line * 36) based (addr (line_to_dump));
	dcl     translation		 char (32) varying;
	dcl     hex9_line		 char (64);
	dcl     hex9_array		 (1:wds_in_line) char (8) based (addr (hex9_line));

	addr_col = line_addr;
	offset_col = offset_addr;
	do wrd_addr = line_addr to line_addr_limit by 1;
	     if wrd_addr <= cur_length - 1
	     then line_to_dump (wrd_addr - line_addr + 1) = seg_wds (wrd_addr - first);
	     else line_to_dump (wrd_addr - line_addr + 1) = (36)"0"b;
	end;
	if short_fmt
	then do;					/* print out addresses if short format */
		addr_col = mod (line_addr, 64);
		offset_col = mod (offset_addr, 64);
		if line_addr >= prev_addr + (64 - mod (prev_addr, 64)) | line_addr = prev_addr
		then do;
			call ioa_$rs (short_format (shfx), output_line, output_line_len, line_addr, offset_addr);
			if active_func
			then return_arg = return_arg || substr (output_line, 1, output_line_len);
			else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
		     end;
		prev_addr = line_addr;
	     end;					/* print out addresses if short format */
	if interpreted_data_fmt
	then call translate_line_to_dump (wds_in_line, addr (line_to_dump), translation);
	if hex9_fmt
	then do;					/* translate words to dump into hex9 format */
		call translate_bytes_to_hex9_ (bits_to_dump, hex9_line);
		call ioa_$rs (line_format, output_line, output_line_len, addr_col, offset_col, wds_in_line, hex9_array,
		     (number_of_digit_fields - wds_in_line) * length_of_digit_field, translation);
		if active_func
		then return_arg = return_arg || substr (output_line, 1, output_line_len);
		else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
	     end;					/* translate words to dump into hex9 format */
	else do;
		call ioa_$rs (line_format, output_line, output_line_len, addr_col, offset_col, wds_in_line, output_words,
		     (number_of_digit_fields - wds_in_line) * length_of_digit_field, translation);
		if active_func
		then return_arg = return_arg || substr (output_line, 1, output_line_len);
		else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
	     end;

     end print_line;

     end print_block;
%page;
print_structure:
    proc();

	dcl     code	           fixed bin(35);
	dcl     full_name		 char(256);
	dcl     match_names		 (10) char (32) varying;
	dcl     n_match_names	 fixed bin;
	dcl     n_subscripts	 fixed bin;
	dcl     structure_ptr	 ptr;
	dcl     subscripts		 (2, 16) fixed bin(24);
	dcl     symbol_ptr		 ptr;
	dcl     unsubscripted_name	 char (256);

    if address_fmt then
       call ioa_$ioa_switch (iocbp, "^6w", block_addr);
    structure_ptr = addr(seg_wds(block_addr-first));
    call structure_ref_$parse ((structure_name), full_name, unsubscripted_name,
         subscripts, n_subscripts, match_names, n_match_names, code);
    if code ^= 0 then call PRINT_ERROR (code, 23);
    if have_structure_path
    then call structure_find_$pathname (structure_path, unsubscripted_name,
         symbol_ptr, code);
    else call structure_find_$search (unsubscripted_name, symbol_ptr, code);
    if code ^= 0 then call PRINT_ERROR (code, 24);
    call display_data_$for_azm (iocbp, ^long_fmt, match_names, n_match_names,
         null, structure_ptr, cur_length, structure_ptr, symbol_ptr,
         subscripts, n_subscripts, code);
    if code ^= 0 then call PRINT_ERROR (code, 25);
    end print_structure;

    end print_dump;

%page;



/* Parameters */

	dcl     a_old_format	 bit (6);

dump_seg_:
     entry (a_iocbp, a_ptr, a_first, a_count, a_old_format);

	if first_time
	then do;
		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
		first_time = "0"b;
	     end;

	active_func, have_structure, have_structure_path = "0"b;
	iocbp = a_iocbp;
	unspec (dump_segment_format) = ""b;
	dump_segment_format = a_old_format;
	first = a_first;
	count = a_count;
	cur_length = first + count;
	block = count;
	rel_offset = 0;
	if (short_fmt & long_fmt) | (bcd_fmt & char_fmt)
	then do;
		string (dump_segment_format) = ""b;
		address_fmt = "1"b;
	     end;					/* set format to default */
	else if bcd_fmt | char_fmt
	then interpreted_data_fmt = "1"b;

	raw_data_fmt, octal_fmt = "1"b;
	command_output_fmt = "0"b;

	call print_dump (a_ptr, first, count, cur_length, block, rel_offset);
	return;

%page;

/* The following entry can be called by programs that want output in the same
   format as dump_segment. The arguments are:

   a_iocbp	a pointer to the I/O switch to use
   a_ptr		a pointer to the first word of data to dump
   a_blk_size	output dump in blocks of this number of words
   a_first	the offset of the first word to dump
   a_count	the number of words to dump
   a_format	a format control string (bit string) indicating the output mode

*/

/* Parameters */

	dcl     a_count		 fixed bin (18);
	dcl     a_first		 fixed bin (18);
	dcl     a_blk_size		 fixed bin;
	dcl     a_format		 bit (*);
	dcl     a_iocbp		 ptr;
	dcl     a_ptr		 ptr;
	dcl     MR10_FORMAT_LENGTH	 fixed bin int static options (constant) init (11);

dump_segment_:
     entry (a_iocbp, a_ptr, a_blk_size, a_first, a_count, a_format);

	if first_time
	then do;
		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
		first_time = "0"b;
	     end;

	active_func, have_structure, have_structure_path = "0"b;
	iocbp = a_iocbp;
	unspec (dump_segment_format) = ""b;
	dump_segment_format = a_format;
	first = fixed (rel (a_ptr), 18, 0);
	count = a_count;
	if count <= 0
	then count = 1;
	cur_length = first + count;
	if a_blk_size <= 0
	then block = count;
	else block = min (a_blk_size, count);
	rel_offset = a_first;
	if (short_fmt & long_fmt) | (hex8_fmt & hex9_fmt)
	     | ((binary (bcd_fmt) + binary (char_fmt) + binary (ebcdic9_fmt) + binary (ebcdic8_fmt) + binary (bit4_fmt))
	     >= 2)
	then do;
		string (dump_segment_format) = ""b;
		address_fmt = "1"b;
	     end;					/* set format to default */

	if length (a_format) <= MR10_FORMAT_LENGTH
	then do;
		raw_data_fmt, suppress_dup_fmt = "1"b;
		if bcd_fmt | char_fmt | ebcdic9_fmt | ebcdic8_fmt | bit4_fmt
		then interpreted_data_fmt = "1"b;
		if ^hex8_fmt & ^hex9_fmt
		then octal_fmt = "1"b;
		header, command_output_fmt = "0"b;
	     end;

	call hcs_$fs_get_path_name (a_ptr, dirname, dir_len, ename, code);
	if code ^= 0
	then do;		/* bad number specified */
	     dirname = "";
	     ename = "";
	     end;

	call print_dump (a_ptr, first, count, cur_length, block, rel_offset);
	return;

%page;

/* The following entry can be called by programs that want output returned
   in the same format as dump_segment when used as an active function. The
   arguments are:

   a_string_ptr	a pointer to a varying char string
   a_string_length  maximum length of the char string
   a_ptr		a pointer to the first word of data to dump
   a_blk_size	output dump in blocks of this number of words
   a_first	the offset of the first word to dump
   a_count	the number of words to dump
   a_format	a format control string (bit string) indicating the output mode

*/

/* Parameters */

	dcl     a_string_ptr	 ptr;
	dcl     a_string_length	 fixed bin (21);

dump_segment_$string:
     entry (a_string_ptr, a_string_length, a_ptr, a_blk_size, a_first, a_count, a_format);

	if first_time
	then do;
		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
		first_time = "0"b;
	     end;

	active_func = "1"b;
	ret_tc = a_string_length;
	ret_tp = a_string_ptr;
	if ret_tc <= 0 | ret_tp = null
	then return;
	return_arg = "";
	dump_segment_format = a_format;
	first = fixed (rel (a_ptr), 18, 0);
	count = a_count;
	if count <= 0
	then count = 1;
	cur_length = first + count;
	if a_blk_size <= 0
	then block = count;
	else block = min (a_blk_size, count);
	rel_offset = a_first;
	if short_fmt & long_fmt | hex8_fmt & hex9_fmt
	     | (binary (bcd_fmt) + binary (char_fmt) + binary (ebcdic9_fmt) + binary (ebcdic8_fmt) + binary (bit4_fmt))
	     >= 2
	then do;
		string (dump_segment_format) = ""b;
		address_fmt = "1"b;
	     end;					/* set format to default */

	call hcs_$fs_get_path_name (a_ptr, dirname, dir_len, ename, code);
	if code ^= 0
	then do;		/* bad number specified */
	     dirname = "";
	     ename = "";
	     end;

	if command_output_fmt
	then call print_dump (a_ptr, first, count, cur_length, block, rel_offset);
	else call return_dump (a_ptr, first, count, cur_length, rel_offset);

	return_arg = requote_string_ ((return_arg));

	return;
%page;
/* This subroutine is really cv_ptr_, but we have to modify it to work on
   inner ring segments because cv_ptr_ doesn't do that. When it does, then
   we can remove this routine and call cv_ptr_ instead. */

cv_ptr_:	procedure (string, Acode)
	returns 	(ptr);

     dcl						/*	Parameters			*/
     	string			char (*),		/* virtual pointer character string. (In)	*/
	Acode			fixed bin(35);	/* status code. (Out)			*/

     dcl						/*	Automatic Variables			*/
         (Lbit_offset, Lsegment_id, Lword_offset)
				fixed bin,	/* length of various parts of virtual pointer.	*/
         (Pbit_offset, Psegment_id, Pword_offset, Pdelim)
				ptr,		/* pointer to various parts of virtual pointer.	*/
	P			ptr,		/* returned pointer.			*/
	Pdef			ptr,		/* pointer to entry point definition structure.	*/

	bc			fixed bin(24),	/* bit count of target segment.		*/
         (bit, segno, word)		fixed bin(35),	/* numeric parts of virtual pointer.		*/
	code			fixed bin(35),
	dir			char(168),	/* dir part of segment's pathname.		*/
	ent			char(32),		/* entry part of segment's pathname.		*/
	entry_point_offset		fixed bin (18),
	i			fixed bin,
	id_case			fixed bin,	/* type of segment identifier in virtual pointer.	*/
						/*   1 = PATHNAME, 2 = REF_NAME, 3 = SEGNO.	*/
	inner_ring_segment		bit (1) aligned,	/* determines whether we can terminate the segment in the user ring */
	offset_case		fixed bin,	/* type of offset value in virtual pointer.	*/
						/*   5 = MISSING, 6 = WORD, 7 = WORD_AND_BIT,	*/
						/*   8 = ENTRY_PT.				*/
	1 oi			aligned like object_info,
	segp			ptr;

     dcl						/*	Based Variables			*/
     	bit_offset		char(Lbit_offset) based (Pbit_offset),
	bit_offset_array (Lbit_offset) char(1) based(Pbit_offset),
     	bits (36)			bit(1) unaligned based,
	delim			char(1) based (Pdelim),
	segment_id		char(Lsegment_id) based (Psegment_id),
	string_array (length(string))	char(1) based (addr (string)),
	word_offset		char(Lword_offset) based (Pword_offset),
	word_offset_array (Lword_offset)
				char(1) based (Pword_offset);
 
     dcl						/*	Entries				*/
	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
	cv_oct_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
	expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35)),
	get_definition_		entry (ptr, char(*), char(*), ptr, fixed bin(35)),
	hcs_$fs_get_path_name	entry (ptr, char(*), fixed bin, char(*), fixed bin(35)),
	hcs_$fs_get_seg_ptr		entry (char(*), ptr, fixed bin(35)),
	hcs_$initiate_count		entry (char(*), char(*), char(*), fixed bin(24),
				       fixed bin(2), ptr, fixed bin(35)),
	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
	object_info_$brief		entry (ptr, fixed bin(24), ptr, fixed bin(35));

     dcl  length			builtin;

     dcl						/*	Static Variables and Constants	*/
         (PATHNAME			init(1),		/* acceptable values which id_case may take on.	*/
	REF_NAME			init(2),
	SEGNO			init(3),
	MISSING			init(5),		/* acceptable values offset_case may take on.	*/
	WORD			init(6),
	WORD_AND_BIT		init(7),
	ENTRY_PT			init(8)) fixed bin int static options(constant),
         (TEXT			init ("000"b),	/* values which definition.class may take on.	*/
	LINKAGE			init ("001"b),
	SYMBOL			init ("010"b),
	STATIC			init ("100"b)) bit(3) int static options(constant),
	V_BAR			char(1) int static options(constant) init("|"),
         (error_table_$bad_class_def,
	error_table_$bad_conversion,
	error_table_$bigarg,
	error_table_$entlong,
	error_table_$lower_ring,
          error_table_$improper_data_format,
	error_table_$out_of_bounds)	fixed bin(35) ext static,
	sys_info$max_seg_size	fixed bin(35) ext static;


%include definition;

%include object_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* Acceptable virtual pointer strings have the following forms:			*/
	/*									*/
	/* CASES									*/
	/*  I O	FORM			COMMENT					*/
	/* -----	-----------------------	------------------------------------------	*/
	/*  1 5	path			= path|0(0)				*/
	/*  1 5	path|			= path|0(0)				*/
	/*  1 6	path|W			= path|W(0)				*/
	/*  1 7	path|W(B)			octal word W, decimal bit B of path		*/
	/*  1 8	path|entry_pt		word identified by entry point entry_pt in path	*/
	/*  1 8	path$entry_pt		word identified by entry point entry_pt in seg	*/
	/*				with pathname pat				*/
	/*									*/
	/*  2 5	ref_name$			= ref_name$0(0)				*/
	/*  2 6	ref_name$W		= ref_name$W(0)				*/
	/*  2 7	ref_name$W(B)		octal word W, decimal bit B of seg with reference	*/
	/*				name ref_name.				*/
	/*  2 8	ref_name$entry_pt		word identified by entry point entry_pt in seg	*/
	/*				with reference name ref_name			*/
	/*									*/
	/*  3 5	segno			= segno|0(0)				*/
	/*  3 5	segno|			= segno|0(0)				*/
	/*  3 6	segno|W			= segno|W(0)				*/
	/*  3 7	segno|W(B)		octal word W, decimal bit B of seg known by segno	*/
	/*  3 8	segno|entry_pt		word identified by entry point entry_pt in seg	*/
	/*				known by segno				*/
	/*									*/
	/* CASES:  I = segment identifier case (id_case), O = offset value case (offset_case).	*/
	/*	 I = 1 => PATHNAME			O = 5 => MISSING (no offset given)	*/
	/*	   = 2 => REF_NAME			  = 6 => WORD			*/
	/*	   = 3 => SEGNO			  = 7 => WORD_AND_BIT		*/
	/*					  = 8 => ENTRY_PT			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Acode = 0;				/* initialize return code.			*/
	code = error_table_$improper_data_format;	/* initialize format error code.		*/
	id_case = PATHNAME;				/* start by assuming we have a path segment	*/
	offset_case = MISSING;			/*   identifier, and no offset value.		*/

	Psegment_id = addr(string);			/* Split identifier into seg_id, delim, & offset. */
	i = search (reverse(string), "|$");		/* Look for the delimiter.			*/
	if i > 0 then i = length(string) - (i-1);
	if i = 0 then do;				/* CASE: No delimiter.			*/
	     Pdelim = addr(V_BAR);			/*   Assume |.				*/
	     Lsegment_id = length(rtrim(string));	/*   Address seg_id.			*/
	     Pword_offset = addr(Pword_offset);		/*   Indicate no word offset.			*/
	     Lword_offset = 0;
	     end;
	else do;					/* CASE: Delimiter found.			*/
	     Pdelim = addr(string_array(i));		/*   Remember delimiter.			*/
	     Lsegment_id = i-1;			/*   Address seg_id.			*/
	     Lsegment_id = length(rtrim(segment_id));
	     if i < length(string) then do;		/*   Look for word offset.			*/
		Pword_offset = addr(string_array(i+1)); /*     Remember where word offset is.		*/
		Lword_offset = length(string) - i;
		Lword_offset = length(rtrim(word_offset));
		i = verify(word_offset, " ");
		if i > 1 then do;
		     Pword_offset = addr(word_offset_array(i));
		     Lword_offset = Lword_offset - (i-1);
		     end;
		end;
	     else do;				/*   No word offset.			*/
		Pword_offset = addr(Pword_offset);
		Lword_offset = 0;
		end;
	     end;

	if verify (segment_id, "01234567") = 0 then	/* check for segno identifier.		*/
	     id_case = SEGNO;
	else if segment_id = "-1" then		/*     this includes null pointer segno.	*/
	     id_case = SEGNO;

	if  (delim = "$") & (search (segment_id, "><") > 0)  then do;
	     if id_case ^= PATHNAME then call ERROR;	/* CASE: seg_id is a pathname.		*/
	     if length(segment_id) > 168 then do;
		code = error_table_$bigarg;
		call ERROR;
		end;
	     end;
	else if delim = "$" then do;			/* CASE: seg_id is a ref_name.		*/
	     id_case = REF_NAME;
	     if length(segment_id) > 32 then do;
		code = error_table_$entlong;
		call ERROR;
		end;
	     end;
	else if delim = "|" then;			/* CASE: seg_id is path or segno.		*/
	else call ERROR;				/* CASE: seg_id followed by bad delim.  We should	*/
						/*   never get to this line.			*/

	if length(word_offset) > 0 then do;		/* Evaluate word offset.			*/
	     offset_case = WORD;			/*   Start by assuming word offset.		*/
	     i = verify (word_offset, "01234567");	/*   Check for octal word offset.		*/
	     if i = 0 then;				/*   CASE: only word offset given.		*/
	     else if (word_offset_array(i) = "(")  then do;
		code = error_table_$bad_conversion;
		offset_case = WORD_AND_BIT;
		if word_offset_array(Lword_offset) ^= ")" then
		     call ERROR;
		Pbit_offset = addr(word_offset_array(i+1));
		Lbit_offset = Lword_offset - i - 1;	/*     Overlay the bit offset.		*/
		Lbit_offset = length(rtrim(bit_offset));
		Lword_offset = i - 1;		/*     Exclude bit from word offset.	*/
		Lword_offset = length(rtrim(word_offset));
		i = verify(bit_offset, " ");
		if i > 1 then do;
		     Pbit_offset = addr(bit_offset_array(i));
		     Lbit_offset = Lbit_offset - (i-1);
		     end;
		if verify (bit_offset, "0123456789") ^= 0 then do;
		     code = error_table_$bad_conversion;
		     call ERROR;
		end;
	     end;
	     else do;				/*   CASE: no word offset, just entry_pt.	*/
		offset_case = ENTRY_PT;
		if length(word_offset) > 256 then do;	/*     Validate entry point length.		*/
		     code = error_table_$entlong;
		     call ERROR;
		     end;
		end;
	     end;
	if  (delim = "$") & (id_case = PATHNAME) & (offset_case ^= ENTRY_PT) then do;
	     code = error_table_$improper_data_format;
	     call ERROR;
	     end;

	if id_case = PATHNAME then do;		/* id_case = PATHNAME			*/
	     call expand_pathname_ (segment_id, dir, ent, code);
	     if code ^= 0 then call ERROR;		/*     Expand the pathname given in virtual ptr.	*/
	     end;

	else do;
	     if id_case = REF_NAME then do;		/* id_case = REF_NAME.			*/
		call hcs_$fs_get_seg_ptr (segment_id, P, code);
		if code ^= 0 then do;		/*     Convert reference name to a pointer.	*/
		     call ring0_get_$segptr ("", segment_id, P, code);
		     if code ^= 0 then call ERROR;
		     end;
		end;
	     else do;				/* id_case = SEGNO				*/
		segno = cv_oct_check_ (segment_id, code);
		if code ^= 0 then do;
		     code = error_table_$bad_conversion;
		     call ERROR;
		     end;
		P = baseptr (segno);		/*     Convert segment number to a pointer.	*/
		if (segment_id = "-1") | (segment_id = "77777") | (segment_id = "777777") then do;
						/*     Special case null pointers.		*/
		     if offset_case = MISSING then return (null);
		     if offset_case = ENTRY_PT then do;
			code = error_table_$improper_data_format;
			call ERROR;
			end;
		     go to OFFSET;
		     end;
		end;

	     segp = P;
	     call hcs_$fs_get_path_name (segp, dir, (0), ent, code);
	     if code ^= 0 then do;			/* try in inner ring */
		segno = binary (baseno (P));
		if segno < hcscnt
		then do;
		     call ring0_get_$name (dir, ent, segp, code);
		     if code ^= 0 then call ERROR;	/*     Convert pointer to a pathname.		*/
		     end;
		else if segno = active_all_rings_data_$stack_base_segno
		     then do;
			code = 0;
			dir = "";
			ent = "stack_0";
			end;
		else call ERROR;
		goto OFFSET;
		end;
	     end;

	call hcs_$initiate_count (dir, ent, "", bc, 0, segp, code);
						/* Initiate segment identified by pathname	*/
						/*   with a null reference name.		*/
	if segp = null then do;			/* try in an inner ring */

	     on linkage_error call ERROR;
	     call phcs_$initiate (dir, ent, "", 0, 0, segp, code);
	     revert linkage_error;

	     if segp = null then call ERROR;
	     P = segp;
	     inner_ring_segment = "1"b;
	     end;
	else inner_ring_segment = "0"b;

OFFSET:	if offset_case = MISSING then;		/* No offset was given.			*/
	else if offset_case = ENTRY_PT then do;		/* An entry point was given.			*/
	     oi.version_number = object_info_version_2;	/*     Call object_info_ to get ptr to obj defs.	*/
	     call object_info_$brief (P, bc, addr(oi), code);
	     if code = error_table_$lower_ring
	     then do;				/* try in a lower ring */
		call ring0_get_$definition (P, ent, word_offset, entry_point_offset, (0), code);
		if code ^= 0 then call ERROR;
		P = ptr (P, entry_point_offset);
		end;
	     else if code ^= 0 then call ERROR;
	     else do;
		if id_case = REF_NAME then		/*     Get ptr to definition for entry point.	*/
		     call get_definition_ (oi.defp, segment_id, word_offset, Pdef, code);
		else call get_definition_ (oi.defp, ent, word_offset, Pdef, code);
		if code ^= 0 then call ERROR;
		if      Pdef -> definition.class = TEXT then	/*     Apply definition to get word offset.	*/
		     P = addrel (oi.textp, Pdef -> definition.value);
		else if Pdef -> definition.class = LINKAGE then
		     P = addrel (oi.linkp, Pdef -> definition.value);
		else if Pdef -> definition.class = SYMBOL then
		     P = addrel (oi.symbp, Pdef -> definition.value);
		else if Pdef -> definition.class = STATIC then
		     P = addrel (oi.statp, Pdef -> definition.value);
		else do;
		     code = error_table_$bad_class_def;
		     call ERROR;
		     end;
		end;
	     end;
	else do;					/* A word, or word and bit offset was given.	*/
	     word = cv_oct_check_ (word_offset, code);	/*     Convert/validate word offset.		*/
	     if code ^= 0 then do;
		code = error_table_$bad_conversion;
		call ERROR;
		end;
	     if (0 <= word) & (word <= sys_info$max_seg_size) then;
	     else do;
		code = error_table_$out_of_bounds;
		call ERROR;
		end;
	     P = ptr (P, word);			/*     Apply word offset to pointer.		*/
	     if offset_case = WORD_AND_BIT then do;	/*     A bit offset was also given.		*/
		bit = cv_dec_check_ (bit_offset, code);	/*	 Convert/validate bit offset.		*/
		if code ^= 0 then do;
		     code = error_table_$bad_conversion;
		     call ERROR;
		     end;
		if (0 <= bit) & (bit <= 35) then;
		else do;
		     code = error_table_$out_of_bounds;
		     call ERROR;
		     end;
		P = addr (P -> bits (bit+1));		/*     Apply the bit offset.			*/
		end;
	     end;

RETURN_TO_CALLER:

	if ^inner_ring_segment
	then call hcs_$terminate_noname (segp, (0));
	return (P);				/* return the pointer.			*/

ERROR:
     proc;

	Acode = code;
	P = null;					/* return a null pointer, with the error code.	*/
	goto RETURN_TO_CALLER;
	end ERROR;

	end cv_ptr_;
%page;
%include definition;
%page;
%include object_info;
%page;
%include terminate_file;
%page;
%include access_mode_values;

     end dump_segment;
