/****^  *********************************************************
        *                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1991 *
        *                                                       *
        * Copyright, (C) Honeywell Bull Inc., 1988              *
        *                                                       *
        * Copyright (c) 1972 by Massachusetts Institute of      *
        * Technology and Honeywell Information Systems, Inc.    *
        *                                                       *
        ********************************************************* */

manage_volume_pool: mvp: mvp_: manage_volume_pool_: proc;

/*

   Written 02/18/76 by Richard Bratt

   Last Modified:

   09/10/76 by R. Bratt to add use and print requests.
   2/1/77 by D. Vinograd to lock data base, interface to volume dumper, and to be a bit more
   9/79 by D. Vinograd to add entries list and check for consistences uses by volume dumper
   and to reformat volume pool.
   11/81 by B. Braun to add subroutine move_to_head so volumes are kept in descending order.
   08/03/82 by B. Braun to correct fatal error (phx13239 phx13215), to correct $set_pool_path entry (phx11528), 
   correct $check_reserved (phx11548).
   12/01/82 by B. Braun to extensively change the command interface as defined by MCRs 5898 and 6056.  This 
   includes new keys, new control arguments and support of volume sets.
   10/31/83 by B. Braun to fix error in convert routine resulting in trashed volume pools.
   11/22/83 by B. Braun to fix another error in convert routine resulting in the list key printing a garbage line (phx16394).
   12/02/83 by B. Braun to fix the bit_count calculation and truncate the pool int finish procedure.
   12/05/83 by B. Braun to change volume_pool structure to take up less room (version 3). Fix a SERIOUS
   bug in add_key where set secondary_idx and primary_idx to no_link.
   12/21/83 by B. Braun to set variable retl to chars not words.
   04/16/84 by B. Braun to improve list performance by not buffering to a temp seg first (phx17312). 
   This also fixes a possible size condition bug as the temp seg is not used (mcr6783).
   04/18/84 by B. Braun to add control args -allocate and -reserve to the list key. To complain about
   incompatable args with the "list -total". Fix bug so "[mvp ls -com -edt]" works.
*/


/****^  HISTORY COMMENTS:
  1) change(1988-07-02,GDixon), approve(1988-07-25,MCR7937),
     audit(1988-07-28,Lippard), install(1988-08-01,MR12.2-1072):
     Change the set key to add -state_date, allowing the user to set the
     state_date field to an explicit value.  This can be important to the reuse
     operation.
  2) change(1991-10-25,Schroth), approve(1991-11-28,MECR0015),
     audit(1991-11-25,WAAnderson), install(1991-11-28,MR12.5-1001):
     Correct MR12.4 source code corruption.
  3) change(1992-05-14,Schroth), approve(1991-11-25,MCR8251),
     audit(1992-09-22,WAAnderson), install(1992-09-24,MR12.5-1016):
     Replace MECR0015: Correct MR12.4 source code corruption.
  4) change(1992-09-16,WAAnderson), approve(1992-09-16,MCR8262),
     audit(1992-10-06,Vu), install(1992-10-19,MR12.5-1028):
     The active function call [mvp l -tt] on very large volume pools failed due
     to insufficient stack space. This occurred due to a misplaced call to
     shorten_stack.  Also checked to make sure request was made as an active
     function and the totals were not wanted before adding volume names into
     the return string.
  5) change(2018-08-21,Swenson), approve(2018-08-21,MCR10048),
     audit(2018-08-22,GDixon), install(2018-08-27,MR12.6g-0015):
     Fixed initialization of command and subroutine entries so that cleanup handler
     will not fumble cleanup.
                                                   END HISTORY COMMENTS */


/*
   manage_volume_pool provides a simple librarian to keep track of a user's volumes. It uses a segment named
   <personid>.volumes in the  user's home directory. as its data base.

   USAGE: manage_volume_pool {key} {-control_args}

   where key may be:

   "add" or "a" to add volumes to the library.
   "allocate" or "alloc" marks volumes as in use.
   "append_volume_set" or "appvs" to increase the size of a volume set.
   "delete" or "dl" to delete volumes from the library.
   "free"  returns volumes to the free pool.
   "list" or "l" to list specific volumes in the library. If no arguments are
      given then all volumes owned by the user are listed. 
   "print" or "pr" or "p" prints the pathname of the volume pool currently in use.
   "pv_expire" or "pvexp" marks volumes as physically expired in the pool.
   "remove_volume_set" or "rmvs" removes volumes from a volume set thereby shrinking the volume set.
   "reserve" or "rsv" marks a volume as reserved. A reserved volume is not free and can be allocated
      in the normal manner.
   "reuse" frees and re-allocates an allocated volume set.
   "set"  is the means to set the expiration dates and comment fields of a volume set.
   "test" tests whether a volume is in a given state.
   "use" or "u" specifies that a different volume pool is to be used.

   The state of a volume is validated to be consistent with a request before
   the request is honored. To facilitate use of this proc, all the entries
   may be invoked as an active functions.

   USAGE: [manage_volume_pool alloc volume_requested] returns the volume assigned

   A volume may also be tested to see if it is free by using the test entry which returns "true" or "false".

   USAGE: [manage_volume_pool test volume_requested] returns "true" or "false"

*/


dcl  Plisted			ptr;
dcl  Pvolume			ptr;
dcl  Ptvol			ptr;
dcl  a_code			fixed bin (35);
dcl  a_comment			char (*);
dcl  a_match_str			char (*) varying;
dcl  a_most_recent			bit(1);
dcl  a_number			fixed bin;
dcl  a_path			char (*);
dcl  a_requested			char (*);
dcl  a_state			fixed bin;
dcl  a_time			fixed bin (71);
dcl  a_volid			bit (36);
dcl  a_volname			char (*);
dcl  a_volumes			char (*) var;
dcl  a_vpp			ptr;
dcl  abort_sw			bit(1);
dcl  ac				fixed bin;
dcl  active_fnc			bit (1);
dcl  al				fixed bin(21);
dcl  ala				fixed bin(21);
dcl  all_states			bit (1);
dcl  all_sw			bit(1);
dcl  alloc_sw			bit (1);
dcl  alp				ptr;
dcl  ap				ptr;
dcl  apa				ptr;
dcl  areap			ptr;
dcl  arg				char (al) based (ap);
dcl  arg2				char (ala) based (apa);
dcl  asterisk_cnt			fixed bin;
dcl  asterisk_sw			bit(1);
dcl  based_area			area based (areap);
dcl  bit_count			fixed bin(24);
dcl  brief_sw			bit(1);
dcl  code				fixed bin (35);
dcl  com_len			fixed bin(21);
dcl  com_ptr			ptr;
dcl  comment_str			char(com_len) based (com_ptr);
dcl  comment_sw			bit(1);
dcl  compare			char (64);
dcl  dfmt_sw			bit(1);
dcl  ecode			fixed bin (35);
dcl  edt_sw			bit(1);
dcl  expire_len			fixed bin(21);
dcl  expire_ptr			ptr;
dcl  expire_str			char(expire_len) based (expire_ptr);
dcl  expire_sw			bit(1);
dcl  first_sw			bit(1);
dcl  first_last_sw			bit(1);
dcl  fexp_sw			bit(1);
dcl  force_sw			bit(1);
dcl  free_sw			bit (1);
dcl  header_output			char (256) var;
dcl  header_len			fixed bin;
dcl  header_to_be_printed		bit(1);
dcl  header_sw			bit (1);
dcl  ignore			fixed bin (35);
dcl  last_sw			bit(1);
dcl  listed_flag (1:volume_pool.n_vol)  bit(1) based (Plisted);
dcl  lock				bit (1) aligned;
dcl  match_string			char (64) var;
dcl  match_sw			bit (1);
dcl  most_recent			bit(1);
dcl  myname			char (32);
dcl  name_sw			bit (1);
dcl  narg				fixed bin init(-1);
dcl  new_vpp			ptr;
dcl  noaction_msg			char(256) var;
dcl  noaction_cnt			fixed bin;
dcl  noaction_str			bit(volume_cnt) based (addr(volume.noaction));
dcl  none_sw			bit(1);
dcl  output			char (256) var;
dcl  output_len			fixed bin;
dcl  pvedt_sw			bit(1);
dcl  pvexp_str			char(pvexp_len) based (pvexp_ptr);
dcl  pvexp_len			fixed bin(21);
dcl  pvexp_ptr			ptr;
dcl  pvexp_sw			bit(1);
dcl  requoted_output                    char (512) var;
dcl  reserve_sw			bit(1);
dcl  ret				char (retl) var based (retp);
dcl  retl				fixed bin(21);
dcl  retp				ptr;
dcl  sdt_sw			bit (1);
dcl  state_dt_clock			fixed bin(71);
dcl  state_dt_str			char(state_dt_len) based (state_dt_ptr);
dcl  state_dt_len			fixed bin(21);
dcl  state_dt_ptr			ptr;
dcl  state_dt_sw			bit (1);
dcl  state_sw			bit (1);
dcl  temp_path                          char (168);
dcl  tcnt				fixed bin;
dcl  total_cnt			fixed bin;
dcl  totals_wanted			bit(1);
dcl  vol_msg_list			char(256) var;
dcl  vol_msg_cnt			fixed bin;
dcl  volume_cnt			fixed bin;
dcl  vs_sw			bit(1);
dcl  vs_size			fixed bin;
dcl  specified_states(4)		bit(1) unal;
dcl  state_string			bit(4) unal based (addr(specified_states));
dcl  svol_sw			bit(1);
dcl  subroutine			bit (1) aligned;
dcl  tdir				char (168);
dcl  tname			char (32);
dcl  tvlx				fixed bin;
dcl  vlx				fixed bin (17);
dcl  vol_cnt			fixed bin;
dcl  volume_sw			bit(1);
dcl  volume_state			fixed bin;
dcl  vp_bc			fixed bin(24);
dcl  vpp				ptr;
dcl  want_str			bit(volume_cnt) based (addr(volume.want_it));
dcl  word_count			fixed bin(19);
dcl yes_sw			bit(1);

dcl  1 vol_list(1:17)		aligned,
       2 name			char(256) var,
       2 cnt			fixed bin;

dcl  1 tvol			aligned based (Ptvol),
       2 name(tcnt)			char(32),
       2 indx(tcnt)			fixed bin,
       2 switches,
         3 noaction(tcnt)		bit(1) unal,
         3 want_it(tcnt)		bit(1)unal;

dcl  1 volume			aligned based (Pvolume),
       2 name(volume_cnt)		char(32),
       2 indx(volume_cnt)		fixed bin,
       2 switches,
         3 noaction(volume_cnt)	bit(1) unal,
         3 want_it(volume_cnt)	bit(1)unal;

dcl 1 volume_pool_header		aligned,
    2 version			fixed bin,	/* version 3 structure			*/
    2 lock			bit (36),
    2 n_vol			fixed bin (17),	/* number of volume slots in the pool, free and occupied */
    2 volume_count			fixed bin(17),	/* number of volumes in the pool		*/
    2 head			fixed bin (17),	/* index into first volume in pool		*/
    2 tail			fixed bin (17),     /* index to last volume in pool		*/
    2 free_head			fixed bin (17),     /* index to first empty slot in array		*/
    2 pad				bit (36);

dcl 1 volume_pool_entry		aligned,	   /* volume pool entry. each volume has one assoc. with it */
      2 name			char (32),	/* name of volume set			*/
      2 id			bit (36),		/* used by volume dumper only			*/
      2 state			fixed bin,	/* state of the volume			*/
      2 state_date			fixed bin (71),	/* date the volume was last acted upon		*/
      2 pv_expire_date		fixed bin(71),      /* physical volume expiration date		*/
      2 expire_date			fixed bin(71),      /* allocated volume expiration date		*/
      2 processid			bit (36),		/* used when reserving volume			*/
      2 comment			char (64),
      2 switches			unaligned,
        3 secondary_vol		bit(1),	/* true if volume is a part of a multiple volume set */
        3 pv_expire			bit(1),	/* true if a physical volume expiration date is assoc. with the volume */
        3 expire			bit(1),   /* true if an expire date is associated with the volume	*/
        3 already_printed		bit(1),   /* used in listing purposes				*/
        3 pad1			bit(32),
      2 vs_count			fixed bin,	/* volume set count, includes primary and secondary volumes	*/
      2 next			fixed bin(17),      /* index to next node or volume in the pool	*/
      2 previous			fixed bin(17),      /* index to previous volume in pool		*/
      2 primary_idx			fixed bin(17),      /* index of primary volume in a set               */
      2 secondary_idx		fixed bin(17),      /* index to next secondary volume in a set	*/
      2 pad2			bit (36);

dcl 1 volume_pool			aligned based (vpp), /* This is the CURRENT volume pool structure */
    2 header			like volume_pool_header,
    2 vpe		(divide(sys_info$max_seg_size - size(volume_pool_header), size(volume_pool_entry), 17)
			refer (volume_pool.header.n_vol)) like volume_pool_entry;

/* internal static  variables  */

dcl  vol_ename			char (32) int static init ("");
dcl  vol_dir			char (168) int static init ("");

dcl  (ascii_state (4)		char (5)  int init ("FREE", "ALOC", "RESV", "PVEXP"),
      blank_NL			char (2)  int init(" 
"),
      allocated_state		fixed bin int init (2),
      free_state			fixed bin int init (1),
      reserved_state		fixed bin int init (3),
      pvexp_state			fixed bin int init (4),
      no_link			fixed bin int init (-1),
      paired_args			bit (1)   int init ("1"b),
      single_arg			bit (1)   int init ("0"b),
      volume_pool_version_3		fixed bin init (3),
      volume_pool_version_2		fixed bin init (2),
      volume_pool_version_1		fixed bin init (1),
      use				char (3) init ("use"),
      truebits			bit(4)    int init ("1111"b) unal,
      True			bit(1)    int init ("1"b),
      False			bit(1)    int init ("0"b),
      Command			bit(1) aligned int init ("0"b),
      Subroutine			bit(1) aligned int init ("1"b),
      Unlocked			bit(1) aligned int init ("0"b),
      Locked			bit(1) aligned int init ("1"b),
      lock_interval			fixed bin int init (60))
				static  options (constant);

dcl (already_alloc			init("1000000000000000"b),
     already_free			init("0100000000000000"b),
     already_reg			init("0010000000000000"b),
     already_sec_vol		init("0001000000000000"b),
     cant_delete			init("0000100000000000"b),
     cant_pvexp			init("0000010000000000"b),
     not_alloc			init("0000001000000000"b),
     not_free			init("0000000100000000"b),
     not_exp			init("0000000010000000"b),
     not_reg			init("0000000001000000"b),
     not_updated			init("0000000000100000"b),
     rsv_by_another			init("0000000000010000"b),
     sec_not_found			init("0000000000001000"b),
     check_pvexp			init("0000000000000100"b),
     vol_pvexp			init("0000000000000010"b),
     sec_vol			init("0000000000000001"b))
				bit(16) unal int static options(constant);
dcl (fb_already_alloc		init(1),
     fb_already_free		init(2),
     fb_already_reg			init(3),
     fb_already_sec_vol		init(4),
     fb_cant_delete			init(5),
     fb_cant_pvexp			init(6),
     fb_not_alloc			init(7),
     fb_not_free			init(8),
     fb_not_exp			init(9),
     fb_not_reg			init(10),
     fb_not_updated			init(11),
     fb_rsv_by_another		init(12),
     fb_sec_not_found		init(13),
     fb_check_pvexp		init(14),
     fb_vol_pvexp			init(15),
     fb_prim_name			init(17))
				fixed bin unal int static options(constant);

dcl err_msg(1:15)			char(100)var int static options(constant) init(
    " Volume set^[s^] ^a ^[are^;is^] already allocated.", 
    " Volume set^[s^] ^a ^[are^;is^] already free.",
    " Volume set^[s^] ^a ^[are^;is^] already registered in the pool.",
    " Volume^[s^] ^a ^[are^;is a^] secondary volume^[s^] of volume set ^a.", 
    " Volume set^[s^] ^a ^[are^;is^] allocated and can not be deleted.", 
    " Volume set^[s^] ^a ^[are^;is^] allocated and can not be physically expired.",
    " Volume set^[s^] ^a ^[are^;is^] not allocated.",
    " Volume set^[s^] ^a ^[are^;is^] not free.",
    " Allocated volume set^[s^] ^a ^[are^;is^] not expired.",
    " Volume^[s^] ^a ^[are^;is^] not registered.",
    " Volume set^[s^] ^a ^[are^;is^] not allocated. It has not been updated.",
    " Volume set^[s^] ^a ^[are^;is^] not reserved by your process.",
    " Secondary volume^[s^] ^a not found in set ^a.", 
    " Physical volume^[s^] ^a ^[have^;has^] expired.", 
    " Volume set^[s^] ^a ^[are^;is^] physically expired.");
					  

dcl  cleanup			condition;

/* Entries */

dcl  clock_			entry() returns(fixed bin(71)),
     command_query_$yes_no		entry() options(variable),
     convert_date_to_binary_		entry (char(*), fixed bin(71), fixed bin(35)),
     cu_$af_arg_ptr_rel		entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr),
     cu_$af_return_arg		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
     cu_$arg_list_ptr		entry (ptr),
     cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin(21), fixed bin (35), ptr),
     date_time_			entry (fixed bin (71), char (*) aligned),
     expand_pathname_		entry (char (*), char (*), char (*), fixed bin (35)),
     get_arg			variable entry (fixed bin, ptr, fixed bin(21), fixed bin (35), ptr),
     get_shortest_path_                 entry (char (*)) returns (char (168)),
     get_process_id_		entry returns (bit (36) aligned),
     get_ring_			entry() returns(fixed bin(3)),
     get_system_free_area_		entry returns (ptr),
     get_temp_segment_		entry (char (*), ptr, fixed bin (35)),
     hcs_$fs_move_seg		entry (ptr, ptr, fixed bin, fixed bin (35)),
     hcs_$fs_get_path_name		entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
     hcs_$get_user_effmode		entry (char(*), char(*), char(*), fixed bin, fixed bin(5), fixed bin(35)),
     hcs_$make_seg			entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
     hcs_$set_bc			entry (char(*), char(*), fixed bin(24), fixed bin(35)),
     hcs_$terminate_noname		entry (ptr, fixed bin (35)),
     hcs_$truncate_file		entry (char(*), char(*), fixed bin(19), fixed bin(35)),
     hcs_$validate_processid		entry (bit (36) aligned, fixed bin (35)),
     initiate_file_		entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35)),
     ioa_$general_rs		entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1), bit (1)),
     release_temp_segment_		entry (char (*), ptr, fixed bin (35)),
     requote_string_		entry (char (*)) returns (char (*)),
     set_lock_$lock			entry (bit (36) aligned, fixed bin, fixed bin (35)),
     set_lock_$unlock		entry (bit (36) aligned, fixed bin (35)),
     suffixed_name_$make		entry (char (*), char (*), char (*), fixed bin (35)),
     user_info_$homedir		entry (char (*));
					  
dcl (active_fnc_err_,
     com_err_,
     ioa_,
     ioa_$nnl,
     ioa_$rsnnl,
     user_info_)			entry options (variable);
dcl (a_error_rnt,
     abort_proc,
     error_rnt,
     msg_proc)			entry variable options (variable);

dcl (error_table_$action_not_performed,
     error_table_$badopt,
     error_table_$boundviol,
     error_table_$inconsistent,
     error_table_$invalid_lock_reset,
     error_table_$locked_by_this_process,
     error_table_$lock_not_locked,
     error_table_$noarg,
     error_table_$noentry,
     error_table_$process_unknown,
     error_table_$unimplemented_version)
				ext fixed bin (35);

/* builtins */

dcl (addr, clock, convert, currentsize, hbound, index, 
     length, max, mod, null, 
     rtrim, substr, verify)		builtin;


	call setup1(Command);
	on cleanup call finish;
	call setup2();
	call get_arg (1, ap, al, (0), alp);
	if arg = "l" | arg = "ls" | arg = "list" then call list_key();
	else if arg = "al" | arg = "alloc" |  arg = "allocate" then call determine_alloc_version();
	else if arg = "f" | arg = "free" then call free_key();
	else if arg = "a" | arg = "add" then call add_key(); 
	else if arg = "d" | arg = "dl" | arg = "delete" then call delete_key();
	else if arg = "r" | arg = "rsv" | arg = "reserve" then call reserve_key();
	else if arg = "t" | arg = "test" then call test_key();
	else if arg = "appvs" | arg = "append_volume_set" then call append_volume_set();
	else if arg = "rmvs" | arg = "remove_volume_set" then call remove_volume_set();
	else if arg = "reuse" then call reuse();
	else if arg = "set" then call set_key();
	else if arg = "pvexp" | arg = "pv_expire" then call pv_expire_key();
	else if arg = "u" | arg = "use" then call use_key();
	else if arg = "c" | arg = "change"                /* obsolete key */
	then call process (paired_args, change);
	else if arg = "cm" | arg = "comment"              /* obsolete key */
	then call process (single_arg, comment);
	else if arg = "p" | arg = "pr" | arg = "print"
	then do;
	     if active_fnc then ret = path(vol_dir,vol_ename);
	     else call msg_proc (-1, "^a", path (vol_dir, vol_ename));
	end;
	else call abort_proc (error_table_$badopt, arg);
return_to_caller:
	call finish;

	return;


reserve:	entry (a_vpp, a_error_rnt, a_requested, a_comment, a_volname, a_code);

	volume_state = reserved_state;
	goto alloc_common;

allocate:	entry (a_vpp, a_error_rnt, a_requested, a_comment, a_volname, a_code);

	volume_state = allocated_state;
alloc_common:
	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_requested);
	al = length (rtrim (a_requested));
	apa = addr (a_comment);
	ala = length (rtrim (a_comment));
	call search (arg);
	if vlx = 0
	then if arg ^= "*" then call add;
	     else call abort_proc (0, "No free volumes.");
	call allocate;
	a_volname = vpe (vlx).name;
	goto return_to_caller;

force_allocate:	entry (a_vpp, a_error_rnt, a_number, a_most_recent, a_match_str, a_volumes, a_code);

/* This entry point is to facilitate TR backup and retrievals of the Trouble Report system */

dcl volx				fixed bin;

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
          if volume_pool.volume_count < a_number then do;	/* asking for too many?			*/
	   a_code = error_table_$boundviol;
	   goto return_to_caller;
	   end;
	vol_cnt = 0;
          volume_cnt = a_number;
          if a_match_str = "" then match_sw = False;
	else match_sw = True;
	areap = get_system_free_area_();
	allocate volume in (based_area) set (Pvolume);
	if a_most_recent then do;
	   volx = volume_pool.head;
	   do while ((volx ^= no_link) & (vol_cnt < volume_cnt));	/* like -first N means return the "latest" N	*/
	      if vpe(volx).state = allocated_state & vpe(volx).vs_count = 1 then do;
	         if match_sw then do;
	            if (index (vpe(volx).comment, a_match_str) > 0) then do;
		     vol_cnt = vol_cnt + 1;
		     volume(vol_cnt).indx = volx;
		     volume(vol_cnt).name = vpe(volx).name;
		     end;
		  end; 

	         else do; /* no match str specified */
		  vol_cnt = vol_cnt + 1;
		  volume(vol_cnt).indx = volx;
		  volume(vol_cnt).name = vpe(volx).name;
		  end;
	         end;
	      volx = vpe(volx).next;
	      end;
	   end;

	else do;
	   volx = volume_pool.tail;
	   do while ((volx ^= no_link) & (vol_cnt < volume_cnt)); 	/* got to be like -last reuse oldest N		*/
	      if vpe(volx).state = allocated_state & vpe(volx).vs_count = 1 then do;
	         if match_sw then do;
	            if (index (vpe(volx).comment, a_match_str) > 0) then do;
		     vol_cnt = vol_cnt + 1;
		     volume(vol_cnt).indx = volx;
		     volume(vol_cnt).name = vpe(volx).name;
		     end;
		  end; 

	         else do;  /* no match str specified */
	            vol_cnt = vol_cnt + 1;
		  volume(vol_cnt).indx = volx;
		  volume(vol_cnt).name = vpe(volx).name;
		  end;
	         end;
	      volx = vpe(volx).previous;
	      end;
             end;

	if (vol_cnt = 0) | (vol_cnt < volume_cnt) then do;
	   a_code = error_table_$action_not_performed;
	   goto return_to_caller;
	   end;

          a_volumes = "";
	do volx = 1 to vol_cnt;
	   a_volumes = a_volumes || rtrim(volume(volx).name) || " ";
	   call move_to_head(volume(volx).indx);
	   end;

          goto return_to_caller;  

free:	entry (a_vpp, a_error_rnt, a_requested, a_code);

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_requested);
	al = length (rtrim (a_requested));
	call search (arg);
	call free;
	goto return_to_caller;

delete:	entry (a_vpp, a_error_rnt, a_requested, a_code);

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_requested);
	al = length (rtrim (a_requested));
	call search (arg);
	call delete;
	goto return_to_caller;

set_volid: entry (a_vpp, a_error_rnt, a_volname, a_volid, a_code);

/* This entry point is used by Volume Dumper */

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_volname);
	al = length (rtrim (a_volname));
	call search (arg);
	if vlx = 0 then call abort_proc (0, "Volume ^a is not registered.", arg);
	vpe (vlx).id = a_volid;
	goto return_to_caller;

check_reserved: entry (a_vpp, a_error_rnt, a_code);

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	vlx = volume_pool.head;
	do while (vlx ^= no_link);
	   if vpe (vlx).state = reserved_state then do;
	      if reserved_by_another_process(vlx) then;  /* skip it */
	      else do;
	         vpe (vlx).state = free_state;
	         vpe (vlx).processid = "0"b;
	         call move_to_head(vlx);
	         end;
	      end;
	   vlx = vpe(vlx).next;
	   end;
	goto return_to_caller;

status:	entry (a_vpp, a_error_rnt, a_requested, a_comment, a_time, a_state, a_code);

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_requested);
	al = length (rtrim (a_requested));
	call search (arg);
	if vlx = 0 then
	     call abort_proc (0, "Volume ^a is not registered.", arg);
	a_comment = vpe (vlx).comment;
	a_time = vpe (vlx).state_date;
	a_state = vpe (vlx).state;
	goto return_to_caller;

set_pool_path: entry (a_error_rnt, a_path, a_vpp, a_code);

/* Returns a pointer to the volume pool specified by pathname. */

	a_vpp = null;
	ap = addr (use);
	al = length (use);

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_path);
	al = length (rtrim (a_path));
	call setup_pool_path("1"b, "1"b);
	goto return_to_caller;

try_pool_path: entry (a_error_rnt, a_path, a_vpp, a_code);

/* Returns a pointer to the volume pool specified by pathname if it exists 
   and is valid. Otherwise returns error_table_$noentry. */

	a_vpp = null;
	ap = addr (use);
	al = length (use);

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	ap = addr (a_path);
	al = length (rtrim (a_path));
	call setup_pool_path("1"b, "0"b);
	if vpp = null() then
	     a_code = error_table_$noentry;
	goto return_to_caller;

get_pool_path: entry (a_vpp, a_error_rnt, a_path, a_code);

/* Returns the pathname of volume pool given a pointer */

	call setup1(Subroutine);
	on cleanup call finish;
	call setup2();
	call hcs_$fs_get_path_name (vpp, tdir, (0), tname, code);
	if code ^= 0
	then call abort_proc (code, "Unable to deterime pool pathname.");
	else do;
              call ioa_$rsnnl ("^a", temp_path, (0), path (tdir, tname));
              a_path = get_shortest_path_ (temp_path);
          end;
	goto return_to_caller;
%page;
abort:	proc (err) ;
dcl  argp ptr;
dcl  err fixed bin (35);
dcl  str char (256);
dcl  str_len fixed bin;

     if subroutine
     then do;
	if err = 0 then a_code = error_table_$action_not_performed;
	else a_code = err;
     end;
     call cu_$arg_list_ptr (argp);
						/* convert args to message */
     call ioa_$general_rs (argp, 2, 3, str, str_len, "0"b, "0"b);
     if lock then call set_lock_$unlock (volume_pool.lock, ignore);
     call error_rnt (err, myname, substr (str, 1, str_len));
     goto return_to_caller;
end abort;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

add:	proc();
 
/* old add used for subroutines only */

       if vlx ^= 0 then call abort_proc(0, "Volume ^a is already registered.", arg);
       vlx = get_node();
       vpe (vlx).name = arg;
       vpe (vlx).state = free_state;
       vpe (vlx).comment = "";
       vpe (vlx).switches = False;
       vpe (vlx).expire_date = 0;
       vpe (vlx).pv_expire_date = 0;
       vpe (vlx).secondary_idx, vpe (vlx).primary_idx = no_link;
       vpe (vlx).vs_count = 1;
       call insert_node(vlx);
    return;
end add;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

add_key: 	proc();

/* Used by the command, add_key adds volumes to the pool */

dcl pv_clock			fixed bin(71),
    (volx, vol_cnt, i)		fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("0"b),
      2  last			init ("0"b),
      2  force			init ("1"b),
      2  vs			init ("0"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("1"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("1"b),	/* requires a date after -pvexp		*/
      2  state_dt			init ("0"b)) bit(1);

    if narg < 2 then call abort_proc (error_table_$noarg, "^/Usage: add volume_names {-control_arg}");

    pv_clock = 0;

    call process_ctl_args(addr(args_allowed), 2, vol_cnt); 

    if vol_cnt = 0 then   call abort_proc(0, "No volume names specified.");
    if pvexp_sw then do;
       call convert_date_to_binary_(pvexp_str, pv_clock, code);
       if code ^= 0 then call abort_proc(code, pvexp_str);
       end;

    call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, already_reg);

    call evaluate_volumes_wanted("added", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
    if none_sw | abort_sw then do;
       if active_fnc then do;
	ret = "false";
	return;
	end;
       if none_sw then  call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
       else if abort_sw then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);
      end;

    /* add volumes specified */

    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if volume(i).noaction then;   /* skip */
          else do;
	   volx = get_node();
	   vpe (volx).name = volume(i).name;
	   vpe (volx).state = free_state;
	   vpe (volx).comment = "";
	   vpe (volx).switches = False;
	   vpe (volx).pv_expire = pvexp_sw;
	   vpe (volx).pv_expire_date = pv_clock;
	   vpe (volx).expire_date = 0;
	   vpe (volx).secondary_idx, vpe (volx).primary_idx = no_link;
	   vpe (volx).vs_count = 1;
	   call insert_node(volx);
	   end;
          end;
       end;

    if active_fnc then  ret = "true";
    else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg);

    return;

end add_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

allocate:	proc;

/* old allocate used by subroutine allocate and "mvp al vol_name1 comment_1 vol_name2 comment_2 ... vol_nameN comment_N" 
   command line */

	     if vlx = 0
	     then if arg = "*"
		then call abort_proc (0, "No free volumes.");
		else call abort_proc (0, "Volume ^a is not registered.", arg);
	     if vpe (vlx).state = allocated_state then call abort_proc (0, "Volume ^a is already allocated.", arg);
	     vpe (vlx).comment = arg2;
	     if subroutine then do;
		vpe (vlx).state = volume_state;
		if volume_state = reserved_state then
		     vpe (vlx).processid = get_process_id_ ();
		else vpe (vlx).processid = "0"b;
	     end;
	     else do;
		vpe (vlx).state = allocated_state;
		vpe (vlx).processid = "0"b;
	     end;
	     if active_fnc then ret = vpe (vlx).name;
	     else if arg = "*" & ^subroutine then call msg_proc (0, "Volume ^a allocated", vpe (vlx).name);
 	     call move_to_head(vlx); 
	     return;
	end allocate;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

allocate_key:   proc();

/* Used by the mvp command to allocate volume sets in the pool. */

dcl exp_clock			fixed bin (71);
dcl (i, vol_cnt, volx)		fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("1"b),
      2  last			init ("1"b),
      2  force			init ("1"b),
      2  vs			init ("1"b),
      2  com			init ("1"b),
      2  expire			init ("1"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("1"b),	/* requires a date after -exp		          */
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

     /* first process list control args */

     exp_clock = 0;

     call process_ctl_args(addr(args_allowed), 2, vol_cnt);

    if volume_sw & (vs_sw | first_last_sw) then call abort_proc(error_table_$inconsistent, 
         "volume_names ^[-volume_size^;^]^[-first^;-last^]", vs_sw, most_recent);

    if expire_sw then do;
       call convert_date_to_binary_(expire_str, exp_clock, code);
       if code ^= 0 then call abort_proc(code, expire_str);
       end;

    if vol_cnt = 0 then vol_cnt = 1;			/* vol_cnt hasn't been set yet.		*/
 
    if ^(volume_sw) then do;				/* structure needs to be allocated		*/
       specified_states(free_state) = True;
       volume_cnt = vol_cnt;
       allocate volume in (based_area) set (Pvolume);
       volume.want_it = False;
       call get_volumes_specified ("allocated", specified_states, Pvolume, vol_cnt, vs_size, most_recent);
      end;

    else do; /* volume names were specified */

       call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, 
                             not_reg | rsv_by_another | already_alloc | vol_pvexp | sec_vol | check_pvexp);
       end;

    call evaluate_volumes_wanted("allocated", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
    if none_sw then  call abort_proc(error_table_$action_not_performed, 
             "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
    else if abort_sw then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);

    /* allocate volumes specified */

    vol_msg_list = "";
    do i = 1 to vol_cnt;
       if volume(i).want_it then do;			/* else just skip over it 			*/
          if ^(volume(i).noaction) then do;
             volx = volume(i).indx;
	   if vpe(volx).secondary_vol then volx = vpe(volx).primary_idx;
	   if vpe(volx).state = reserved_state then vpe(volx).processid = "0"b;
	   vpe (volx).state = allocated_state;
	   if comment_sw then vpe (volx).comment = comment_str;
	   else vpe (volx).comment = "";
	   vpe (volx).expire_date = exp_clock;
	   vpe (volx).expire = expire_sw;
             if active_fnc then ret = ret || " " || rtrim(vpe(volx).name);
	   else if (first_last_sw) then vol_msg_list = vol_msg_list || " " || rtrim(vpe(volx).name);
	   call move_to_head(volx); 
	   end;
	end;
       end;

    if ^active_fnc then do;
       if vol_msg_list ^= "" then 
          call msg_proc(0, "Volume set^[s^] ^a ^[has^;have^] been allocated. ^[^a^;^s^]",
               (vol_cnt > 1), vol_msg_list, (vol_cnt = 1), noaction_msg ^= "", noaction_msg);  
       else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg ); 
       end;

end allocate_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

append_secondary_volumes:   proc(old_primary_idx, new_primary_idx, last_volume_idx);

/* called by append_volume_set when appending a multiple volume set.
   old_primary_idx: references the volume set to be appended. (input)
   new_primary_idx: is the volume set to be appended to.   (input)
   last_volume_idx: index to the last volume in the volume set after the set is appended on.  (output)
*/

dcl (old_primary_idx, 
     new_primary_idx,
     last_vol,
     next_vol,
     last_volume_idx)		fixed bin;

    next_vol = vpe(old_primary_idx).secondary_idx;
    last_vol = old_primary_idx;
    do while (next_vol > 0);
       if active_fnc then ret = ret || " " || rtrim(vpe(next_vol).name);
       vpe(last_vol).secondary_idx = next_vol;
       vpe(last_vol).vs_count = 1;
       vpe(last_vol).previous, vpe(last_vol).next = no_link;
       vpe(next_vol).primary_idx = new_primary_idx;
						/* update volume set count of volume set appending to. */
       vpe(new_primary_idx).vs_count = vpe(new_primary_idx).vs_count + 1;
       last_vol = next_vol;
       next_vol = vpe(next_vol).secondary_idx;
       end;

    vpe(last_vol).secondary_idx = no_link;
    vpe(last_vol).vs_count = 1;
    vpe(last_vol).previous, vpe(last_vol).next = no_link;
    last_volume_idx = last_vol;

end append_secondary_volumes;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

append_volume_set:   proc();

/* procedure called for key append_volume_set. Appends volume sets to the set designated by the primary volume name */

dcl i,
    vol_cnt,
    last_vol,
    next_vol,
    primary_idx			fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("1"b),
      2  last			init ("1"b),
      2  force			init ("1"b),
      2  vs			init ("1"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1); 

    if narg < 3 then call abort_proc (error_table_$noarg, 
                    "^/Usage: mvp appvs primary_volume_name {secondary_volume_names} {-control_args} ");

    /* first get primary_volume_name */

    ac = 2;
    call get_arg (ac, ap, al, (0), alp);
    if ^(volume_in_pool((arg), primary_idx)) then call abort_proc(error_table_$action_not_performed, 
                                  "Specified primary volume is not in the pool. " || arg);
    else if vpe(primary_idx).secondary_vol then call abort_proc(error_table_$action_not_performed, 
                   "^/Specified primary volume ^a is a secondary volume of set ^a.", arg, 
	         vpe(vpe(primary_idx).primary_idx).name);

    /* now look at secondary volumes specified or  control args  */

    call process_ctl_args(addr(args_allowed), 3, vol_cnt);

    if (vs_sw | first_last_sw) & volume_sw then call abort_proc(error_table_$inconsistent,
                                                       "secondary_volumes and -control_args");

    if vol_cnt = 0 then  vol_cnt = 1;              /* vol_cnt hasn't been set yet.		*/

    if ^(volume_sw) then do;			/* structure needs to be allocated		*/
       specified_states(free_state) = True;
       volume_cnt = vol_cnt;
       allocate volume in (based_area) set (Pvolume);
       volume.want_it = False;
       call get_volumes_specified ("freed", specified_states, Pvolume, vol_cnt, vs_size, most_recent);
      end;

    else do;  /* secondary volumes were specified */
       /* validate volumes and label whether we want them or not */

       call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | not_free | already_sec_vol | check_pvexp);
       end;

    call evaluate_volumes_wanted("appended", Pvolume, narg, vol_cnt, none_sw, abort_sw);
    if none_sw then call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
    else if abort_sw then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);

    /* append the volumes */

    vol_msg_list = "";
    last_vol = last_volume_in_set(primary_idx);
    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
	   if active_fnc then ret = ret || " " || rtrim(volume(i).name);
	   next_vol = volume(i).indx;
	   vpe(last_vol).secondary_idx = next_vol;
	   vpe(next_vol).primary_idx = primary_idx;
	   vpe(next_vol).secondary_vol = True;
	   if next_vol = volume_pool.head then volume_pool.head = vpe(next_vol).next;
             else if vpe(next_vol).previous ^= no_link then vpe(vpe(next_vol).previous).next = vpe(next_vol).next;
  	   if next_vol = volume_pool.tail then volume_pool.tail = vpe(next_vol).previous;
	    else if vpe(next_vol).next ^= no_link then vpe(vpe(next_vol).next).previous = vpe(next_vol).previous;
             vpe(next_vol).next, vpe(next_vol).previous = no_link;
	   if (first_last_sw) then do;
	      vol_msg_list = vol_msg_list || " " || rtrim(vpe(next_vol).name);
                end; 
	   if vpe(next_vol).vs_count > 1 then call append_secondary_volumes(next_vol, primary_idx, last_vol);
	   else last_vol = next_vol;
	   vpe(primary_idx).vs_count = vpe(primary_idx).vs_count + 1;
	   end;
	end;
        end;

    vpe(last_vol).secondary_idx = no_link;
    call move_to_head(primary_idx);

    if ^active_fnc then do;
       if vol_msg_list ^= "" then 
          call msg_proc(0, "Volume^[s^] ^a ^[has^;have^] been appended.",
               (vol_cnt > 1), vol_msg_list, (vol_cnt = 1));  

       if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg);
   end;

end append_volume_set;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

bad_arg:	proc (arg) returns (bit (1));

/* used in key verification */

dcl  arg char (*);
dcl  keyx fixed bin;
dcl  keys (35) char (32) static options (constant) init ("a", "add", "l", "ls", "list", "p", "pr", "print", "al", 
     "alloc", "allocate", "f", "free", "d", "dl", "delete", "c", "change", "r", "rsv", "reserve", "t", "test",
     "cm", "comment", "u", "use", "appvs", "append_volume_set", "reuse", "pv_expire",
     "pvexp", "remove_volume_set", "rmvs", "set");

     do keyx = 1 to hbound (keys, 1);
        if arg = keys (keyx) then return (False);
        end;
     return (True);

end bad_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

change:	proc;

/* obselete key that must still be supported. change changes the comment of a volume specified by volume name */

	     if vlx = 0 then call abort_proc (0, "Volume ^a is not registered.", arg);
	     if vpe (vlx).state = free_state then call abort_proc (0, "Volume ^a is free.", arg);
	     vpe (vlx).comment = arg2;
 	     call move_to_head(vlx);
	     return;
	end change;

%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

check_first_then_convert:  proc();

dcl VERSION_MSG			char(171) int init(
"Most likely an older version of mvp is being used which doesn't recognize all mvp structure versions.^/Recommendation is to copy the pool before converting or answer 'no'.") static options(constant);
		       

if volume_pool.version = volume_pool_version_1  | volume_pool.version = volume_pool_version_2 then 
   call convert_volume_pool();
else do;
   /* before assuming this is the original old volume_pool structure with no version associated with it, 
      we will ask the user, and then go merrily along converting it  */

    /* but before we query the user, is this just a zero length seg? */
     
        if vp_bc = 0 then do;   /* must be zero seg */
           call convert_volume_pool();
	 return;
           end;

     if subroutine then  /* report problem, dont query */
	call abort_proc(error_table_$action_not_performed, "Unrecognizable volume_pool version ^d.", volume_pool.version);

     call command_query_$yes_no (yes_sw, 0, "mvp", VERSION_MSG, 
 "The volume pool ^a ^/has an unrecognizable mvp structure version ^d.^/Do you want to TRY converting to the current version ^d?",
          path(vol_dir, vol_ename), volume_pool.version, volume_pool_version_3 );

     if yes_sw then call convert_volume_pool();
     else call abort_proc(error_table_$unimplemented_version, "Unrecognizable volume_pool version ^d", volume_pool.version);
     end;

end check_first_then_convert;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

check_for_errors:  proc(aptr, asize, vol_cnt, primary_idx, check);

/* checks for preliminary errors for various keys  */
/* aptr:   pointer to volume structure containing the volume names (input).
   asize:  size of structure volume (input).
   vol_cnt: actual count of valid volume names in the structure (input).
   primary_idx: primary_idx of the set if its a secondary volume, else its just 0 (input).
   check: 16-bit code specifying which errors to check for.
*/

dcl check				bit(16);
dcl error_found			bit(16);
dcl  1 volume			aligned based (aptr),
       2 name(asize)		char(32),
       2 indx(asize)		fixed bin,
       2 switches,
         3 noaction(asize)		bit(1) unal,
         3 want_it(asize)		bit(1)unal;

dcl (asize, vol_cnt,
     primary_idx, i, volx)		fixed bin;
dcl aptr				ptr;
dcl just_expired			bit(1);

       error_found = "0000000000000000"b;
       just_expired = False;
       volume.want_it = True;
       volume.noaction = False;

       do i = 1 to vol_cnt by 1;
          if ^(volume_in_pool ((volume(i).name), volx)) then do;
	   if check & not_reg then do;
   	      volume(i).noaction = True;
	      substr(error_found, fb_not_reg, 1) = True;
	      vol_list.name(fb_not_reg) = vol_list.name(fb_not_reg)  || " " || rtrim(volume(i).name);
	      vol_list.cnt(fb_not_reg) = vol_list.cnt(fb_not_reg) + 1;
                end;
	   end;
          else do;
             volume(i).indx = volx;

	   if (check & sec_not_found) then do;
   	      if ^(volume_in_volume_set((volume(i).name), primary_idx, volx)) then do;
   	         volume(i).noaction = True;
	         substr(error_found, fb_sec_not_found, 1) = True;
	         vol_list.name(fb_sec_not_found) = vol_list.name(fb_sec_not_found)  || " " || rtrim(volume(i).name);
	         vol_list.cnt(fb_sec_not_found) = vol_list.cnt(fb_sec_not_found) + 1;
	         vol_list.name(fb_prim_name) = rtrim(vpe(primary_idx).name);
	         goto END_CHECK;
	         end;
    	      end;

	   if check & already_reg then do;
   	      volume(i).noaction = True;
	      substr(error_found, fb_already_reg, 1) = True;
	      vol_list.name(fb_already_reg) = vol_list.name(fb_already_reg)  || " " || rtrim(volume(i).name);
	      vol_list.cnt(fb_already_reg) = vol_list.cnt(fb_already_reg) + 1;
	      goto END_CHECK;
                end;

	   if vpe(volx).secondary_vol then do;
	      if (check & sec_vol) then volx = vpe(volx).primary_idx;
    	      else if (check & already_sec_vol)then do;
	         volume(i).noaction = True;
	         substr(error_found, fb_already_sec_vol, 1) = True;
	         vol_list.name(fb_already_sec_vol) = vol_list.name(fb_already_sec_vol)  || " " || rtrim(volume(i).name);
	         vol_list.cnt(fb_already_sec_vol) = vol_list.cnt(fb_already_sec_vol) + 1;
	         vol_list.name(fb_prim_name) = rtrim(vpe(vpe(volx).primary_idx).name);
	         goto END_CHECK;
                   end;
               end;

             if (check & rsv_by_another) then if vpe (volx).state = reserved_state then do;
	      if reserved_by_another_process(volx) then do;
	         volume(i).noaction = True;
	         substr(error_found, fb_rsv_by_another, 1) = True;
	         vol_list.name(fb_rsv_by_another) = vol_list.name(fb_rsv_by_another)  || " " || rtrim(volume(i).name);
	         vol_list.cnt(fb_rsv_by_another) = vol_list.cnt(fb_rsv_by_another) + 1;
	         goto END_CHECK;
	         end;
	       end;

	    if vpe (volx).state = allocated_state then do;
	       if (check & already_alloc) then do;
		volume(i).noaction = True;
	          substr(error_found, fb_already_alloc, 1) = True;
	          vol_list.name(fb_already_alloc) = vol_list.name(fb_already_alloc)  || " " || rtrim(volume(i).name);
	          vol_list.cnt(fb_already_alloc) = vol_list.cnt(fb_already_alloc) + 1;
		goto END_CHECK;
		end;
                 else if (check & cant_delete) then do;
		volume(i).noaction = True;
	          substr(error_found, fb_cant_delete, 1) = True;
	          vol_list.name(fb_cant_delete) = vol_list.name(fb_cant_delete)  || " " || rtrim(volume(i).name);
	          vol_list.cnt(fb_cant_delete) = vol_list.cnt(fb_cant_delete) + 1;
		goto END_CHECK;
		end;

                 else if (check & cant_pvexp) then do;
		volume(i).noaction = True;
	          substr(error_found, fb_cant_pvexp, 1) = True;
	          vol_list.name(fb_cant_pvexp) = vol_list.name(fb_cant_pvexp)  || " " || rtrim(volume(i).name);
	          vol_list.cnt(fb_cant_pvexp) = vol_list.cnt(fb_cant_pvexp)+ 1;
		goto END_CHECK;
		end;

                 if (check & not_exp) then if vpe(volx).expire then do;
	          if vpe(volx).expire_date < clock() | fexp_sw then do;
		   call check_for_pvexp(volx, brief_sw, just_expired);
		   if just_expired then do;
		      volume(i).noaction = True;
		      goto END_CHECK;
		      end;
	             end; 
	          else do; /* allocated volume hasn't expired yet */
	             volume(i).noaction = True;
		   if brief_sw then do;
		      if active_fnc then  do;
    	                   substr(error_found, fb_not_exp, 1) = True;
		         vol_list.name(fb_not_exp) = vol_list.name(fb_not_exp)  || " " || rtrim(volume(i).name);
		         vol_list.cnt(fb_not_exp) = vol_list.cnt(fb_not_exp)+ 1;
		         goto END_CHECK;
		         end;
		      end;
		   else do;
    	                substr(error_found, fb_not_exp, 1) = True;
	                vol_list.name(fb_not_exp) = vol_list.name(fb_not_exp)  || " " || rtrim(volume(i).name);
	                vol_list.cnt(fb_not_exp) = vol_list.cnt(fb_not_exp)+ 1;
		      goto END_CHECK;
		      end;
                       end;
	          end;
                 end;

              if (check & vol_pvexp) then if vpe(volx).state = pvexp_state then do;
	       volume(i).noaction = True;
	       substr(error_found, fb_vol_pvexp, 1) = True;
	       vol_list.name(fb_vol_pvexp) = vol_list.name(fb_vol_pvexp)  || " " || rtrim(volume(i).name);
	       vol_list.cnt(fb_vol_pvexp) = vol_list.cnt(fb_vol_pvexp) + 1;
	       goto END_CHECK;
                 end;

	    if  (check & not_free) then if vpe(volx).state ^= free_state then do;
	       volume(i).noaction = True;
	       substr(error_found, fb_not_free, 1) = True;
	       vol_list.name(fb_not_free) = vol_list.name(fb_not_free)  || " " || rtrim(volume(i).name);
	       vol_list.cnt(fb_not_free) = vol_list.cnt(fb_not_free) + 1;
	       goto END_CHECK;
                 end;

	    if  (check & not_alloc) then if vpe(volx).state ^= allocated_state then do;
	       volume(i).noaction = True;
	       substr(error_found, fb_not_alloc, 1) = True;
	       vol_list.name(fb_not_alloc) = vol_list.name(fb_not_alloc)  || " " || rtrim(volume(i).name);
	       vol_list.cnt(fb_not_alloc) = vol_list.cnt(fb_not_alloc) + 1;
	       goto END_CHECK;
                 end;

	    if (check & already_free) then if vpe(volx).state = free_state then do;
	       volume(i).noaction = True;
	       substr(error_found, fb_already_free, 1) = True;
	       vol_list.name(fb_already_free) = vol_list.name(fb_already_free)  || " " || rtrim(volume(i).name);
	       vol_list.cnt(fb_already_free) = vol_list.cnt(fb_already_free) + 1;
	       goto END_CHECK;
                 end;

	    if (check & not_updated) then if (expire_sw & vpe(volx).state ^= allocated_state) then do;
	       volume(i).noaction = True;
	       substr(error_found, fb_not_updated, 1) = True;
	       vol_list.name(fb_not_updated) = vol_list.name(fb_not_updated)  || " " || rtrim(volume(i).name);
	       vol_list.cnt(fb_not_updated) = vol_list.cnt(fb_not_updated) + 1;
	       goto END_CHECK;
                 end;

	   if (check & check_pvexp) then do;
                call check_for_pvexp(volx, False, just_expired);
	      if just_expired then do;
	         volume(i).noaction = True;
	         substr(error_found, fb_check_pvexp, 1) = True;
	         end;
	      end;
             end;
END_CHECK:  
          end;   /* end of do loop */

     call construct_msg(error_found);

end check_for_errors;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

check_for_pvexp:  proc(vol_idx, no_print, just_expired);

/* checks to see if a volume is physically expired.
   vol_idx: index of volume to be checked. (input)
   no_print: designates whether to report the expiration or not. (input)
   just_expired: set to true if the volume
                 is physically expired, ie. the pv_expire date is less than the current date/time. (output)
*/

dcl vol_idx			fixed bin;
dcl (no_print, just_expired)		bit(1);

   just_expired = False;	/* assume not expired */

   if vpe(vol_idx).pv_expire then do;
      if vpe(vol_idx).pv_expire_date < clock() | pvexp_secondary_vol_check(vol_idx) then do;
         if active_fnc then do;  /* always want message flagged when AF whether no_print is specified or not */
	  vol_list.name(fb_check_pvexp) = vol_list.name(fb_check_pvexp)  || " " || rtrim(vpe(vol_idx).name);
	  vol_list.cnt(fb_check_pvexp) = vol_list.cnt(fb_check_pvexp) + 1;
	  end;
         else if ^no_print then do;
	  vol_list.name(fb_check_pvexp) = vol_list.name(fb_check_pvexp)  || " " || rtrim(vpe(vol_idx).name);
	  vol_list.cnt(fb_check_pvexp) = vol_list.cnt(fb_check_pvexp) + 1;
            end;
         call pvexp_volume(vol_idx);
         just_expired = True;
         end;
      end;

end check_for_pvexp;



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

comment:	proc;

/* obselete key that must still be supported. It prints the comment of a specified volume name.  */

	     if vlx = 0 then call abort_proc (0, "Volume ^a is not registered.", arg);
	     if active_fnc then ret = vpe (vlx).comment;
	     else call msg_proc (0, "Volume ^a", vpe (vlx).comment);
	end comment;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

construct_msg: proc(a_check);

/* called by check_for_errors. Constructs the actual error messages if errors were found.
   a_check: 16 bit code which maps to err_msg array and flags the errors found  */

dcl position			fixed bin;
dcl a_check			bit(16);
dcl check				bit(16);
dcl  output_msg			char(256) var;
dcl  output_len			fixed bin;

    check = a_check;
    position = index(check, "1"b);
    do while (position ^= 0);
       if position = fb_sec_not_found then
          call ioa_$rsnnl(err_msg(position), output_msg, output_len, (vol_list.cnt(position) > 1), 
               vol_list.name(position), vol_list.name(fb_prim_name));

       else if position = fb_already_sec_vol then
               call ioa_$rsnnl(err_msg(position), output_msg, output_len, (vol_list.cnt(position) > 1), 
               vol_list.name(position), vol_list.cnt(position) > 1, vol_list.cnt(position) > 1, 
	     vol_list.name(fb_prim_name));

       else if (position = fb_not_exp | position = fb_check_pvexp) & brief_sw then do;
               if active_fnc then   /* print msg when its an active function regardless brief_sw specified 	*/
	     call ioa_$rsnnl(err_msg(position), output_msg, output_len, vol_list.cnt(position) > 1, 
                               vol_list.name(position), vol_list.cnt(position) > 1);
            end;
       else call ioa_$rsnnl(err_msg(position), output_msg, output_len, vol_list.cnt(position) > 1, 
                 vol_list.name(position), vol_list.cnt(position) > 1);

       noaction_msg = noaction_msg || output_msg;
       substr(check, position, 1)  = False;
       position = index(check, "1"b);
       end;

end construct_msg;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

convert_volume_pool: proc;

/* This procedure converts a volume pool to the new format */

dcl 1 volume_pool_old		aligned based (vpp),
    2 lock			bit (36),
    2 pad (7)			bit (36),
    2 n_vol			fixed bin (17),
    2 vpe_old (1:1 refer (volume_pool_old.n_vol)) aligned,
      3 name			char (32),
      3 id			bit (36),
      3 state			fixed bin (8) unaligned,
      3 flags			bit (27) unaligned,
      3 time			char (16) unaligned,
      3 comment			char (64);

dcl 1 volume_pool_old_1		aligned based (vpp),
    2 version			fixed bin,
    2 lock			bit (36),
    2 n_vol			fixed bin (17),
    2 pad (5)			bit (36),
    2 vpe_old_1 (1:1 refer (volume_pool_old_1.n_vol)) aligned,
      3 name			char (32),
      3 id			bit (36),
      3 state			fixed bin,
      3 processid			bit (36),
      3 time			fixed bin (71),
      3 comment			char (64),
      3 pad1 (8)			bit (36);

dcl 1 volume_pool_header_2		aligned,
    2 version			fixed bin,	/* version 2 structure			*/
    2 lock			bit (36),
    2 n_vol			fixed bin (17),	/* number of volume slots in the pool, free and occupied */
    2 volume_count			fixed bin(17),	/* number of volumes in the pool		*/
    2 head			fixed bin (17),	/* index into first volume in pool		*/
    2 tail			fixed bin (17),     /* index to last volume in pool		*/
    2 free_head			fixed bin (17),     /* index to first empty slot in array		*/
    2 pad (2)			bit (36);

dcl 1 volume_pool_entry_2		aligned,	   /* volume pool entry. each volume has one assoc. with it */
      2 name			char (32),	/* name of volume set			*/
      2 id			bit (36),		/* used by volume dumper only			*/
      2 state			fixed bin,	/* state of the volume			*/
      2 processid			bit (36),		/* used when reserving volume			*/
      2 state_date			fixed bin (71),	/* date the volume was last acted upon		*/
      2 comment			char (64),
      2 switches			unaligned,
        3 secondary_vol		bit(1),	/* true if volume is a part of a multiple volume set */
        3 pv_expire			bit(1),	/* true if a physical volume expiration date is assoc. with the volume */
        3 expire			bit(1),   /* true if an expire date is associated with the volume	*/
        3 already_printed		bit(1),   /* used in listing purposes				*/
        3 pad1			bit(31),
      2 pv_expire_date		fixed bin(71),      /* physical volume expiration date		*/
      2 expire_date			fixed bin(71),      /* allocated volume expiration date		*/
      2 vs_count			fixed bin,	/* volume set count, includes primary and secondary volumes	*/
      2 next			fixed bin(17),      /* index to next node or volume in the pool	*/
      2 previous			fixed bin(17),      /* index to previous volume in pool		*/
      2 primary_idx			fixed bin(17),      /* index of primary volume in a set               */
      2 secondary_idx		fixed bin(17);      /* index to next secondary volume in a set	*/

dcl 1 volume_pool_2			aligned based(vpp),      /* This is the CURRENT volume pool structure */
    2 header			like volume_pool_header_2,
    2 vpe_2		(divide(sys_info$max_seg_size - size(volume_pool_header_2), size(volume_pool_entry_2), 17)
			refer (volume_pool_2.header.n_vol)) like volume_pool_entry_2;


     if volume_pool.version = volume_pool_version_2 then 
        /* convert version_2 to version_3 */
        call set_lock_$lock (volume_pool_2.lock, lock_interval, code);

     else if volume_pool.version = volume_pool_version_1 then 
        /* convert version_1 to version_3 */
        call set_lock_$lock (volume_pool_old_1.lock, lock_interval, code);

     else      /* convert old version to version 3 */
        call set_lock_$lock (volume_pool_old.lock, lock_interval, code);

     if code ^= 0 then do;
        if ^(code = error_table_$invalid_lock_reset | code = error_table_$locked_by_this_process) then
           call abort_proc (code, "Attempting to convert volume pool.^/Contact owner of pool ^a", path(vol_dir, vol_ename));
        end;

     if ^(subroutine | active_fnc) then call ioa_("Converting volume pool ^a from version ^d to version ^d.", vol_ename, volume_pool.version, volume_pool_version_3 );
     call get_temp_segment_ (myname, new_vpp, code);
     if code ^= 0 then call abort_proc (code, "Unable to get temp seg - volume pool conversion of ^a failed",
	       path (vol_dir, vol_ename));

     new_vpp -> volume_pool.version = volume_pool_version_3;
     new_vpp -> volume_pool.header.pad = "0"b;
 
     if volume_pool.version = volume_pool_version_2 then do;
        /* convert header stuff first */
        new_vpp -> volume_pool.head         = vpp -> volume_pool_2.head;
        new_vpp -> volume_pool.volume_count = vpp -> volume_pool_2.volume_count;
        new_vpp -> volume_pool.tail         = vpp -> volume_pool_2.tail;
        new_vpp -> volume_pool.free_head    = vpp -> volume_pool_2.free_head;
        new_vpp -> volume_pool.n_vol        = vpp -> volume_pool_2.n_vol;
        /* now copy each entry */
        do vlx = 1 to new_vpp -> volume_pool_2.n_vol;
           new_vpp -> vpe (vlx).name       = vpp -> vpe_2(vlx).name;
	 new_vpp -> vpe (vlx).id	   = vpp -> vpe_2(vlx).id;
	 new_vpp -> vpe (vlx).state	   = vpp -> vpe_2(vlx).state;
	 new_vpp -> vpe (vlx).state_date = vpp -> vpe_2(vlx).state_date;
	 new_vpp -> vpe (vlx).comment	   = vpp -> vpe_2(vlx).comment;
	 new_vpp -> vpe (vlx).vs_count   = vpp -> vpe_2(vlx).vs_count;
	 new_vpp -> vpe (vlx).pv_expire  = vpp -> vpe_2(vlx).pv_expire;
	 new_vpp -> vpe (vlx).expire     = vpp -> vpe_2(vlx).expire;
	 new_vpp -> vpe (vlx).pv_expire_date = vpp -> vpe_2(vlx).pv_expire_date;
	 new_vpp -> vpe (vlx).expire_date    = vpp -> vpe_2(vlx).expire_date;
	 new_vpp -> vpe (vlx).secondary_idx  = vpp -> vpe_2(vlx).secondary_idx;
	 new_vpp -> vpe (vlx).primary_idx    = vpp -> vpe_2(vlx).primary_idx;
	 new_vpp -> vpe (vlx).next           = vpp -> vpe_2(vlx).next;
	 new_vpp -> vpe (vlx).previous       = vpp -> vpe_2(vlx).previous;

	 new_vpp -> vpe (vlx).secondary_vol   = vpp -> vpe_2(vlx).secondary_vol;
	 new_vpp -> vpe (vlx).pv_expire       = vpp -> vpe_2(vlx).pv_expire;
	 new_vpp -> vpe (vlx).expire	        = vpp -> vpe_2(vlx).expire;
	 new_vpp -> vpe (vlx).already_printed = vpp -> vpe_2(vlx).already_printed;
	 new_vpp -> vpe (vlx).pad2 = "0"b;
	 end;
        goto CONVERT_FINISH;
        end;

     if volume_pool.version = volume_pool_version_1 then do;
        /* convert version_1 to version_3 */

        new_vpp -> volume_pool.head = 1;
        new_vpp -> volume_pool.volume_count = volume_pool_old_1.n_vol;
        new_vpp -> volume_pool.tail = volume_pool_old_1.n_vol;
        new_vpp -> volume_pool.free_head,
        new_vpp -> volume_pool.n_vol = volume_pool_old_1.n_vol + 1;
        do vlx = 1 to new_vpp -> volume_pool.volume_count;
           new_vpp -> vpe (vlx).name = vpe_old_1 (vlx).name;
	 new_vpp -> vpe (vlx).id = vpe_old_1 (vlx).id;
	 new_vpp -> vpe (vlx).state = vpe_old_1 (vlx).state;
	 new_vpp -> vpe (vlx).state_date = vpe_old_1 (vlx).time;
	 new_vpp -> vpe (vlx).comment = vpe_old_1 (vlx).comment;
	 new_vpp -> vpe (vlx).switches =  False;
	 new_vpp -> vpe (vlx).vs_count =  1;
	 new_vpp -> vpe (vlx).pv_expire, new_vpp -> vpe (vlx).expire =  False;
	 new_vpp -> vpe (vlx).pv_expire_date, new_vpp -> vpe (vlx).expire_date =  0;
	 new_vpp -> vpe (vlx).secondary_idx = no_link;
	 new_vpp -> vpe (vlx).primary_idx = no_link;
	 new_vpp -> vpe (vlx).next = vlx + 1;
	 new_vpp -> vpe (vlx).previous = vlx - 1;
	 new_vpp -> vpe (vlx).pad2 = "0"b;
	 end;
        end;

     else do;  /* converting from old version to version 3 */
        new_vpp -> volume_pool.head = 1;
        new_vpp -> volume_pool.volume_count = volume_pool_old.n_vol;
        new_vpp -> volume_pool.tail = volume_pool_old.n_vol;
        new_vpp -> volume_pool.free_head,
        new_vpp -> volume_pool.n_vol = volume_pool_old.n_vol + 1;
        if volume_pool_old.n_vol = 0 then do;
	 /* the volume pool is either empty or initially created via the create command, not by mvp use     */
	 new_vpp -> volume_pool.n_vol = 1;
	 new_vpp -> volume_pool.volume_count = 0;
	 new_vpp -> volume_pool.tail = 1;
	 new_vpp -> volume_pool.free_head = 1;
	 new_vpp -> volume_pool.head = no_link;
	 new_vpp -> vpe(new_vpp ->volume_pool.n_vol).next = no_link;
	 new_vpp -> vpe(new_vpp ->volume_pool.n_vol).previous = no_link;
	 goto CONVERT_FINISH;
	 end;
        do vlx = 1 to new_vpp -> volume_pool.volume_count;
           new_vpp -> vpe (vlx).name = vpe_old (vlx).name;
	 new_vpp -> vpe (vlx).id = vpe_old (vlx).id;
	 new_vpp -> vpe (vlx).state = vpe_old (vlx).state;
	 call convert_date_to_binary_ (vpe_old (vlx).time, new_vpp -> vpe (vlx).state_date, code);
	 if code ^= 0 then do;
	    new_vpp -> vpe (vlx).state_date = clock_();
	    if ^(subroutine | active_fnc) then 
	       call msg_proc (code, "Unable to convert state date of volume ^a. It will be set to the current date.", 
	            new_vpp -> vpe(vlx).name);
	    end;
	 new_vpp -> vpe (vlx).comment = vpe_old (vlx).comment;
	 new_vpp -> vpe (vlx).switches =  False;
	 new_vpp -> vpe (vlx).vs_count =  1;
	 new_vpp -> vpe (vlx).pv_expire, new_vpp -> vpe (vlx).expire =  False;
	 new_vpp -> vpe (vlx).pv_expire_date, new_vpp -> vpe (vlx).expire_date =  0;
	 new_vpp -> vpe (vlx).secondary_idx = no_link;
	 new_vpp -> vpe (vlx).primary_idx = no_link;
	 new_vpp -> vpe (vlx).next = vlx + 1;		/* need to link all the volumes together	*/
	 new_vpp -> vpe (vlx).previous = vlx - 1;
	 new_vpp -> vpe (vlx).pad2 = "0"b;
	 end;
        end;
   
     /* initialize the free (ie. next available) node in the volume_pool */
     new_vpp -> vpe(new_vpp->volume_pool.n_vol).next = no_link; /* designates end of volume list 		*/
     new_vpp -> vpe(new_vpp->volume_pool.n_vol).previous = no_link; 
     new_vpp -> vpe(new_vpp->volume_pool.n_vol).secondary_idx = no_link;
     new_vpp -> vpe(1).previous = no_link;	          /* start of volume list, no previous volume       */
						/* end of volume list, no next volume  		*/
     new_vpp -> vpe(new_vpp->volume_pool.volume_count).next = no_link;

CONVERT_FINISH:
     call hcs_$fs_move_seg (new_vpp, vpp, 1, code);
     if code ^= 0 then call abort_proc (code, "Unable to move temp file.- volume pool conversion of ^a failed",
	path (vol_dir, vol_ename));
     call release_temp_segment_ (myname, new_vpp, (0));
     return;

end convert_volume_pool;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


create_pool:  proc();

       call hcs_$make_seg (vol_dir, vol_ename, "", RW_ACCESS_BIN, vpp, code);
       if code = 0 then do;
          if subroutine then call ioa_ ("^a: Volume pool ^a created.", myname, path (vol_dir, vol_ename));  
	else call msg_proc (0, "Volume pool ^a created", path (vol_dir, vol_ename));
	vpp -> volume_pool.version = volume_pool_version_3;
	vpp -> volume_pool.n_vol, vpp -> volume_pool.free_head = 1;
	vpp -> vpe(vpp ->volume_pool.n_vol).next = no_link;
	vpp -> vpe(vpp ->volume_pool.n_vol).previous = no_link;
	vpp -> volume_pool.head = no_link;
	vpp -> volume_pool.tail = 1;
	vpp -> volume_pool.volume_count = 0;
	end; 
       else do;
	  if vpp = null then call abort_proc (code, "Unable to create ^a", path (vol_dir, vol_ename));
	  end;

end create_pool;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

delete:	proc;

/* used only for subroutine delete only */

	     if vlx = 0 then call abort_proc (0, "Volume ^a is not registered.", arg);
	     if vpe (vlx).state = allocated_state then 
                    call abort_proc (0, "Volume ^a is in use and can not be deleted.", arg);
               call free_node(vlx);
	     return;
	end delete;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

delete_key:	proc();

/* Used by mvp command, it deletes the designated volumes from the pool. */

dcl (volx, i, vol_cnt)		fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("0"b),
      2  last			init ("0"b),
      2  force			init ("1"b),
      2  vs			init ("0"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1); 

    if narg < 2 then call abort_proc (error_table_$noarg, "^/Usage: delete volume_names {-control_arg}");

    call process_ctl_args(addr(args_allowed), 2, vol_cnt);
    if vol_cnt = 0 & ^asterisk_sw then call abort_proc (0, "No volumes specified.");

    if asterisk_sw then do;
       call msg_proc(-1, "The asterisk '*' is obsolete.");
       specified_states(free_state) = True;
       specified_states(pvexp_state) = True;
       specified_states(reserved_state) = True;
       tcnt = asterisk_cnt;
       allocate tvol in (based_area) set (Ptvol);
       tvol.want_it = False;
       call get_volumes_specified ("deleted", specified_states, Ptvol, tcnt, vs_size, most_recent);
       end;

   if volume_sw then 
      call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | cant_delete | sec_vol | check_pvexp);

    if asterisk_sw then do;
       if ^(volume_sw) then do;
          vol_cnt = 0;
          volume_cnt = tcnt;
	allocate volume in (based_area) set (Pvolume);
	end;
       do i = 1 to tcnt;
          volume(vol_cnt + 1).name = tvol(i).name;
	volume(vol_cnt + 1).indx = tvol(i).indx;
	volume(vol_cnt + 1).want_it = tvol(i).want_it;
	vol_cnt = vol_cnt + 1;
          end;
       end;

    call evaluate_volumes_wanted("deleted", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
    if none_sw | abort_sw then do;
       if active_fnc then do;
	ret = "false";
	return;
	end;
       if none_sw then  call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
       else if abort_sw then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);
      end;


   /* delete volumes specified */

    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
	   volx = volume(i).indx;
             if vpe(volx).secondary_vol then volx = vpe(volx).primary_idx;
	   call free_node(volx);
	   end;
          end;
       end;

   if active_fnc then ret = "true";
   else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg);

end delete_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

determine_alloc_version:	proc();

/* as the old allocate format is supported but undocumented, this procedure determines whether we are dealing with 
   the new or old format.  This is determined by the following guidelines:

  (a) If first argument is an asterisk "*", assume old version.
  (b) Check for an odd or even number of arguments.  If an odd
      number, then assume new version.
  (c) If control arguments -comment, -com, -volume_set, -vs, -first,
      -ft, -last, -lt are specified, assume new version.
  (d) If any even argument (the key "alloc" is not considered an arg)
      is a volume existing in the pool, assume new version.
  (e) If any argument is an asterisk (*), assume old version.
*/

dcl even_arg			bit(1);

    if narg < 2 then call abort_proc (error_table_$noarg, "Usage: mvp alloc {volume_names} {-control_args}");

    /* first check for an asterisk '*' arg. If found then assume old version. 			    */

    call get_arg (2, ap, al, (0), alp);
    if arg = "*" then goto old_version;

    /* Do we have an odd number of args?  Use narg - 1 as the key "alloc" isn't included as an argument */

    if mod(narg-1, 2) = 1 then goto new_version;

    /* check further for which version */
    even_arg = False;
    do ac=2 to narg;
       call get_arg (ac, ap, al, (0), alp);
       if arg = "-com" | arg = "-comment" 
          | arg = "-vs" | arg = "-volume_size" 
          | arg = "-ft" | arg = "-first" 
	| arg = "-lt" | arg = "-last" then goto new_version;
       else if even_arg then do;
	     if volume_in_pool(arg, 0) then goto new_version;
	     end;
       else if arg = "*" then goto old_version;
       even_arg = ^(even_arg);
       end;


/* if we get here it means we fell out of loop by default and it's most likely the old version */
/* ie. essentially the even args specified were not volumes known to the pool so we  assume it's a comment */

old_version:
    call process (paired_args, allocate);  
    return;

new_version:
    call allocate_key(); 
    return;

end determine_alloc_version;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

evaluate_volumes_wanted:    proc(action, aptr, asize, vol_cnt, none_sw, abort_sw);
		        
/* called by various keys to determine, out of the volumes specified, which ones are to be acted upon and whether 
   to query the user or not .
   action: action requested in query message. (input)
   aptr:  pointer to volume structure (input)
   asize: size of the volume array (input)
   vol_cnt: number of volumes to be considered. (input)
   none_sw: true when no volumes are found. (output)
   abort_sw: true when all volumes specified cannot be acted upon or when the response to the query is no . (output)
*/

dcl action			char(*);
dcl (abort_sw, none_sw)		bit(1);
dcl aptr				ptr,
    (asize,		
    i,
    vol_cnt,
    want_cnt,
    noaction_cnt)			fixed bin;
		        
dcl  1 volume			aligned based (aptr),
       2 name(asize)		char(32),
       2 indx(asize)		fixed bin,
       2 switches,
         3 noaction(asize)		bit(1) unal,
         3 want_it(asize)		bit(1)unal;
dcl continue			bit(1);

    none_sw, abort_sw = False;
    if index(want_str, "1"b) = 0 then do;
       none_sw = True;
       return;
       end;

    if (index (want_str & noaction_str, "1"b) > 0) then do;

       /* only query when some of the volumes wanted, some have noaction bit True, and others have noaction bit false */

       continue = False;
       if asize > 1 then do;
	want_cnt = 0;
	noaction_cnt = 0;
	do i = 1 to vol_cnt;
	   if volume(i).want_it then do;
	      want_cnt = want_cnt + 1;
	      if volume(i).noaction then noaction_cnt = noaction_cnt + 1;
	      end;
	   end;
       
           if (want_cnt = noaction_cnt) then do;
	    abort_sw = True;
	    return;
	    end;
	 else  call query_to_continue(action, "", force_sw, continue);
	 end;

       if ^(continue) then abort_sw = True;
       end;

end evaluate_volumes_wanted;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

finish:	proc();

     if lock then do;
        if vpp ^= null() then do;
           word_count = currentsize(volume_pool);
           bit_count = word_count*36;
           call hcs_$set_bc(vol_dir, vol_ename, bit_count, code);
           if code ^= 0 then call abort_proc (code, "Unable to set bit count of volume pool ^a", path (vol_dir, vol_ename));
	 call hcs_$truncate_file (vol_dir, vol_ename, word_count, code);
           if code ^= 0 then call abort_proc (code, "Unable to trucncate volume pool ^a", path (vol_dir, vol_ename));
           end;

        call set_lock_$unlock (volume_pool.lock, ignore);
        end;

     if vpp ^= null & ^subroutine then call hcs_$terminate_noname (vpp, ignore);
     if Pvolume ^= null() then free volume in (based_area);
     if Ptvol ^= null() then free tvol in (based_area);

end finish;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

format_print_output:	proc(vol_idx, secondary_volume);

/* formats all the many flavors of outputing the volume pool info via the list key.
   vol_idx: index to the volume to be listed. (input)
   secondary_volume: true when the volume is a secondary volume of a set. (input)
*/ 

dcl vol_idx			fixed bin parameter;
dcl (go_ahead, secondary_volume)	bit(1);

    go_ahead = True;
    if secondary_volume then do;
       if pvedt_sw & vpe(vol_idx).pv_expire then;
       else do;				/* secondary volumes are listed only when -dfmt, -nm are    */
          output = "";			/* specified, and when the volume has a pvexp date associated */
	go_ahead = False;                       /* with it and -pvedt was specified.                        */
	end;
       end;

    if dfmt_sw & ^(pvedt_sw | edt_sw) then do;
       if header_to_be_printed & ^active_fnc then do;
          call ioa_$rsnnl("^/Volume^1-^5xState Date^1-^5xState^3xComment", header_output, header_len);
	header_to_be_printed = False;
	end;
       if secondary_volume then call ioa_$rsnnl ("^1x^a", output, output_len, vpe(vol_idx).name); 
       else call ioa_$rsnnl ("^a^[^/^]^[^1x^;^13t^]^20a^[^1x^;^36t^]^a^[^1x^;^44t^]^a", output, output_len,
	              vpe (vol_idx).name,
                        (index(vpe(vol_idx).name, "  ") > 12) & ^active_fnc,
		    active_fnc, time_string_ (vpe (vol_idx).state_date),
		    active_fnc, ascii_state (vpe (vol_idx).state),
		    active_fnc, vpe (vol_idx).comment);
       end;

    else if dfmt_sw & ((pvedt_sw | edt_sw ) & ^(pvedt_sw & edt_sw )) then do;
	            /*  one or the other.....but not both       */
            if header_to_be_printed & ^active_fnc then do;
               call ioa_$rsnnl ("^/Volume^1-^5xState Date^1-^5xState^7x^[Expires Date^;PV Expires  ^]^6xComment",
	                   header_output, header_len, edt_sw);
	     header_to_be_printed = False;
	     end;
	  if secondary_volume then 
                  call ioa_$rsnnl ("^1x^a^[^[^1x^;^13t^31x^]^a^;^2s^]", output, output_len, vpe(vol_idx).name, go_ahead, 
                                  active_fnc, time_string_(vpe(vol_idx).pv_expire_date));
            else call ioa_$rsnnl 
                ("^a^[^/^]^[^1x^;^13t^]^20a^[^1x^;^36t^]^a^[^1x^;^44t^]^[^20a^;^s^]^[^1x^s^;^[^20x^]^]^[^20a^;^s^]^[^1x^s^;^[^20x^]^]^[^1x^;^2x^]^a", 
	              output, output_len,
	              vpe (vol_idx).name,
                        (index(vpe(vol_idx).name, "  ") > 12) & ^active_fnc,
		    active_fnc, time_string_ (vpe (vol_idx).state_date),
		    active_fnc, ascii_state (vpe (vol_idx).state),
		    active_fnc, ^(pvedt_sw) & (edt_sw & vpe (vol_idx).expire),
		    (time_string_ (vpe (vol_idx).expire_date)),	
		    active_fnc, ^(pvedt_sw) & (edt_sw & ^(vpe (vol_idx).expire)),
		    ^(edt_sw) & (pvedt_sw & vpe (vol_idx).pv_expire),
		    (time_string_ (vpe (vol_idx).pv_expire_date)),
		    active_fnc, ^(edt_sw) & (pvedt_sw & ^(vpe (vol_idx).pv_expire)),
		    active_fnc, vpe (vol_idx).comment);
            end;

    else if dfmt_sw & pvedt_sw & edt_sw then do;
            if header_to_be_printed & ^active_fnc then do;
	      call ioa_$rsnnl ("^/Volume^1-^5xState Date^1-^9xExpires Date^1-^1xPV Expires^/^13tState^34tComment", header_output, header_len);
	      header_to_be_printed = False;
	      end;
	  if secondary_volume then 
                  call ioa_$rsnnl ("^1x^a^[^[^1x^;^59t^]^a^;^2s^]", output, output_len, vpe(vol_idx).name, go_ahead, 
                                  active_fnc, time_string_(vpe(vol_idx).pv_expire_date));
             else call ioa_$rsnnl 
                  ("^a^[^/^]^[^1x^;^13t^]^20a^[^1x^s^;^[^3x^]^]^[^20a^s^;^s^[^23x^]^]^[^1x^s^;^[^3x^]^]^[^20a^s^;^s^[^23x^]^]^[^1x^;^/^13t^]^a^[^1x^;^34t^]^a",  
	              output, output_len,
	              vpe (vol_idx).name,
                        (index(vpe(vol_idx).name, "  ") > 12) & ^active_fnc,
		    active_fnc, time_string_ (vpe (vol_idx).state_date),
		    active_fnc, (vpe (vol_idx).expire), (vpe (vol_idx).expire),
		    (time_string_ (vpe (vol_idx).expire_date)),	
		    ^active_fnc, active_fnc,
		    (vpe (vol_idx).pv_expire), (vpe (vol_idx).pv_expire),
		    (time_string_ (vpe (vol_idx).pv_expire_date)),
		    ^active_fnc, active_fnc,
		    ascii_state (vpe (vol_idx).state),
		    active_fnc, vpe (vol_idx).comment);
         end;

    else if ^(dfmt_sw) then do;   /* only individual output fields specified */
            if header_to_be_printed & ^active_fnc then do;
	     call ioa_$rsnnl
               ("^/^[Volume^1-^5x^]^[State Date^1-^5x^]^[State^3x^]^[Expires Date^1-^6x^]^[PV Expires  ^9x^]^[Comment^]",
	      header_output, header_len, name_sw,  sdt_sw, state_sw, edt_sw, pvedt_sw, comment_sw);
	     header_to_be_printed = False;
	     end;

            if name_sw then do;
               call ioa_$rsnnl("^[^1x^]^a^[^/^]", output, output_len, secondary_volume, vpe(vol_idx).name, 
              (index(vpe(vol_idx).name, "  ") > 12) & (sdt_sw | comment_sw | pvedt_sw | edt_sw | state_sw) & (^active_fnc));
               if sdt_sw & go_ahead then 
                  call ioa_$rsnnl("^a^[^1x^;^13t^]^20a^[^1x^;^3x^]", output, output_len, (output), active_fnc, 
                                  time_string_ (vpe (vol_idx).state_date), active_fnc);
               if state_sw & go_ahead then 
                  call ioa_$rsnnl("^a^[^1x^s^;^[^36t^;^16t^]^]^a", output, output_len, (output), active_fnc, sdt_sw,
                        ascii_state (vpe (vol_idx).state));
               if edt_sw & go_ahead then call ioa_$rsnnl
                 ("^a^[^1x^s^;^[^43t^]^]^[^1x^s^;^[^35t^]^]^[^1x^s^;^[^22t^;^13t^]^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^29x^]^]",
	              output, output_len, (output),
	              active_fnc, sdt_sw & state_sw,
	              active_fnc, sdt_sw & ^state_sw,
		    active_fnc, state_sw & ^sdt_sw,
		    vpe (vol_idx).expire, 
		    time_string_ (vpe (vol_idx).expire_date),
		    active_fnc);
               if pvedt_sw & go_ahead then call ioa_$rsnnl
                 ("^a^[^1x^s^;^[^22t^]^]^[^1x^s^;^[^43t^]^]^[^1x^s^;^[^58t^]^]^[^1x^s^;^[^36t^;^13t^]^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^29x^]^]", 
	              output, output_len, (output),
	              active_fnc, state_sw & ^(sdt_sw & edt_sw),
		    active_fnc, state_sw & sdt_sw & ^edt_sw,
	              active_fnc, sdt_sw & edt_sw & ^state_sw,
		    active_fnc, (sdt_sw | edt_sw) & ^state_sw,
		    vpe (vol_idx).pv_expire, 
		    time_string_ (vpe (vol_idx).pv_expire_date),
		    active_fnc);

               if comment_sw & go_ahead  then
                  call ioa_$rsnnl
	        ("^a^[^1x^3s^;^[^66t^2s^;^[^58t^1s^;^[^37t^]^]^]^]^[^1x^2s^;^[^43t^1s^;^[^67t^]^]^]^[^1x^3s^;^[^24t^2s^;^[^45t^s^;^[^67t^;^16t^]^]^]^]^a",
                        output, output_len, (output),
	              active_fnc, ^state_sw & (sdt_sw & pvedt_sw & edt_sw),
	              ^state_sw & ((sdt_sw & edt_sw) | (sdt_sw & pvedt_sw) | (pvedt_sw & edt_sw)),
		    ^state_sw & (sdt_sw | pvedt_sw | edt_sw),
                        active_fnc, 
		    sdt_sw & state_sw & ^(pvedt_sw | edt_sw),
		    sdt_sw & state_sw & (pvedt_sw | edt_sw),
		    active_fnc, state_sw & ^(sdt_sw | pvedt_sw | edt_sw),
		    ^sdt_sw & state_sw & (pvedt_sw | edt_sw),
		    ^sdt_sw & state_sw & (pvedt_sw & edt_sw),
                        vpe(vol_idx).comment); 
               end; /* end if name_sw */
    
            else if sdt_sw  then do;
                    if go_ahead then call ioa_$rsnnl("^20a", output, output_len, time_string_ (vpe (vol_idx).state_date));
                    if state_sw & go_ahead then call ioa_$rsnnl("^a^[^1x^;^26t^]^a", output, output_len, (output), 
                              active_fnc, ascii_state (vpe (vol_idx).state));
                    if edt_sw & go_ahead then call ioa_$rsnnl
                       ("^a^[^1x^s^;^[^32t^;^24t^]^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^29x^]^]", output, output_len, (output),
	              active_fnc, state_sw,
		    vpe (vol_idx).expire, 
		    time_string_ (vpe (vol_idx).expire_date),
		    active_fnc);
                    if pvedt_sw & go_ahead then call ioa_$rsnnl
                      ("^a^[^1x^s^;^[^32t^]^]^[^1x^s^;^[^55t^]^]^[^1x^s^;^[^46t^]^]^[^1x^s^;^[^24t^]^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^29x^]^]",
	              output, output_len, (output),
	              active_fnc, state_sw & ^edt_sw,
	              active_fnc, state_sw & edt_sw,
	              active_fnc, ^state_sw & edt_sw,
	              active_fnc, ^state_sw & ^edt_sw,
		    vpe (vol_idx).pv_expire, 
		    time_string_ (vpe (vol_idx).pv_expire_date), active_fnc);
                    if comment_sw & go_ahead then do;
                       if active_fnc then call ioa_$rsnnl("^a^1x^a", output, output_len, (output), vpe(vol_idx).comment);
		   else call ioa_$rsnnl("^a^[^34t^]^[^70t^]^[^70t^]^[^59t^]^[^57t^]^[^47t^]^[^26t^]^a",
                        output, output_len, (output), 
	              state_sw & ^(pvedt_sw | edt_sw),
	              state_sw & pvedt_sw & edt_sw,
	              ^state_sw & (pvedt_sw & edt_sw),
	              state_sw &  edt_sw,
	              state_sw & pvedt_sw,
	              ^state_sw & (pvedt_sw | edt_sw),
		    ^state_sw & ^pvedt_sw & ^edt_sw,
                        vpe(vol_idx).comment); 
		   end;

              end; /* end if sdt_sw */

            else if state_sw  then do;
                    if go_ahead then call ioa_$rsnnl("^[^1x^]^5a^[^1x^;^3x^]", output, output_len, active_fnc, 
                                                     ascii_state (vpe (vol_idx).state), active_fnc);
                    if edt_sw & go_ahead then call ioa_$rsnnl("^a^[^1x^;^9t^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^23x^]^]", 
                        output, output_len, (output), 
                        active_fnc, vpe (vol_idx).expire, 
		    time_string_ (vpe (vol_idx).expire_date), active_fnc);
                    if pvedt_sw & go_ahead then 
		   call ioa_$rsnnl("^a^[^1x^s^;^[^36t^;^9t^]^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^23x^]^]", 
                        output, output_len, (output),
	              active_fnc, edt_sw,
		    vpe (vol_idx).pv_expire, 
		    time_string_ (vpe (vol_idx).pv_expire_date),
		    active_fnc);
                    if comment_sw & go_ahead then
		   call ioa_$rsnnl("^a^[^1x^s^;^[^57t^]^]^[^1x^2s^;^[^37t^s^;^[^31t^;^9t^]^]^]^a",
	              output, output_len, (output),
	              active_fnc, edt_sw & pvedt_sw,
	              active_fnc, edt_sw, pvedt_sw,
                        vpe(vol_idx).comment); 
              end; /* end if state_sw  */

            else if edt_sw then do;
                    if go_ahead then call ioa_$rsnnl("^[^20a^[^1x^;^3x^]^;^s^[^1x^;^23x^]^]", output, output_len,
		    vpe (vol_idx).expire, 
		    time_string_ (vpe (vol_idx).expire_date), active_fnc);

                    if pvedt_sw & go_ahead then call ioa_$rsnnl("^a^[^1x^;^24t^]^[^20a^[^1x^;^3x^]^;^s^[^1x^;^23x^]^]",
		    output, output_len, (output),
		    active_fnc, vpe (vol_idx).pv_expire, 
		    time_string_ (vpe (vol_idx).pv_expire_date), active_fnc);
                    if comment_sw & go_ahead then call ioa_$rsnnl("^a^[^1x^s^;^[^48t^;^27t^]^]^a",
		    output, output_len, (output),
	              active_fnc, pvedt_sw,
		    vpe(vol_idx).comment);

	          end; /* of edt_sw  */

            else if pvedt_sw & go_ahead then do;
                    call ioa_$rsnnl("^[^20a^[^1x^;^3x^]^;^s^[^1x^;^23x^]^]", output, output_len,
		    vpe (vol_idx).pv_expire, 
		    time_string_ (vpe (vol_idx).pv_expire_date), active_fnc);

                    if comment_sw & go_ahead then call ioa_$rsnnl("^a^[^1x^;^22t^]^a", output, output_len, (output),
		    active_fnc, vpe(vol_idx).comment);

	          end; /* of if pvedt_sw  */

            else if comment_sw & go_ahead then do;
                    call ioa_$rsnnl("^a^[^1x^]", output, output_len, vpe (vol_idx).comment, active_fnc);
	          end; 
         end;

end format_print_output;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

free:	proc();

/*  called by free subroutine only */

	     if vlx = 0 then call abort_proc (0, "Volume ^a is not registered", arg);
	     if vpe (vlx).state = free_state then call abort_proc (0, "Volume ^a is already free.", arg);
	     vpe (vlx).state = free_state;
	     vpe (vlx).expire = False;
	     call move_to_head(vlx); 
	     return;
	     end free;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

free_key:  	proc();

/* Used by the mvp command, it frees volumes by changing the state to free */

dcl (found, just_expired)		bit(1);
dcl (i, volx, vol_idx, vol_cnt)	fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("0"b),
      2  last			init ("0"b),
      2  force			init ("1"b),
      2  vs			init ("0"b),
      2  com			init ("0"b),
      2  expire			init ("1"b),
      2  brief			init ("1"b),
      2  fexp			init ("1"b),
      2  match			init ("1"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

    if narg < 2 then call abort_proc (error_table_$noarg, "Usage: mvp free {volume_names} {-control_args}");

    /* process control arguments */

    call process_ctl_args(addr(args_allowed), 2, vol_cnt);

    if volume_sw & (expire_sw | match_sw) then call abort_proc(error_table_$inconsistent, 
                                     "volume names and ^[-expire^;^] ^[-match^;^]", expire_sw, match_sw);

    /* -expire control arg case */

    if expire_sw then do;

       volume_cnt = volume_pool.n_vol;
       allocate volume in (based_area) set (Pvolume);
       volume.want_it, volume.noaction = False;

       do vol_idx = 1 to volume_pool.n_vol by 1;
          if vpe(vol_idx).state = allocated_state then do;  /* check expires date */
               if vpe(vol_idx).expire then do;
	        if vpe(vol_idx).expire_date < clock() | fexp_sw then do;
		 call check_for_pvexp(vol_idx, brief_sw, just_expired);
		 if ^(just_expired) then do;
                        vol_cnt = vol_cnt +1;
	              volume(vol_cnt).name = vpe(vol_idx).name;
	              volume(vol_cnt).indx = vol_idx;
		    volume(vol_cnt).want_it =True;
		    end;
                     end;
	        end;
	     end;   /* end if allocate state */
	end;  /* loop */
       if vol_cnt = 0 then call abort_proc(error_table_$action_not_performed,
                                            "No allocated volume sets found with overdue expiration dates.");
       if just_expired then call construct_msg(check_pvexp);
       end;

    if match_sw then do;
       if vol_cnt = 0 then do;			/* -expire wasn't specified			*/
          volume_cnt = volume_pool.n_vol;
          allocate volume in (based_area) set (Pvolume);
          volume(*).want_it = False;

	do i = 1 to volume_pool.n_vol;
             if index (vpe(i).comment, match_string) > 0  then do; /* found a match			*/
	      call check_for_pvexp(i, brief_sw, just_expired); 
	      if ^(just_expired) then do;		/* not expired? we want it			*/
	         vol_cnt = vol_cnt + 1;
	         volume(vol_cnt).name = vpe(i).name;
	         volume(vol_cnt).indx = i;
	         volume(vol_cnt).want_it = True;
	         end;
	      end; 
             end;  /* do loop */
          if vol_cnt = 0 then call abort_proc(error_table_$action_not_performed,
                                        "^/No volume sets found with comment string matching ^a.", match_string);
          if just_expired then call construct_msg(check_pvexp);
          end;
       else do;  /* -expire was specified and -expire criteria has already been met successfully		*/
          volume(*).want_it, found = False;
          do i = 1 to vol_cnt;
	   if index (vpe(i).comment, match_string) > 0  then volume(i).want_it, found = True;
	   end;
          if ^(found) then call abort_proc(error_table_$action_not_performed,
                     "^/No expired volume sets found with comment string matching ^a.", match_string);
          end;
       end; /* if match_sw */

    /* here's the case where volume names were specified */

    else if volume_sw then call check_for_errors
            (Pvolume, volume_cnt, vol_cnt, 0, not_reg | sec_vol | rsv_by_another | already_free | not_exp | check_pvexp);

    call evaluate_volumes_wanted("freed", Pvolume, narg, vol_cnt, none_sw, abort_sw);
    if none_sw then call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
    else if abort_sw then if noaction_msg ^= "" then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);


    /* now free the volumes */

    vol_msg_list = "";
    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
             volx = volume(i).indx;
             if vpe(volx).secondary_vol then volx = vpe(volx).primary_idx;
	   if active_fnc then ret = ret || " " || rtrim(vpe(volx).name);
	   vpe(volx).state = free_state;
	   vpe(volx).expire = False;
	   if vpe(volx).state = pvexp_state then  vpe(volx).pv_expire = False;
	   if ((expire_sw | match_sw | first_last_sw) & ^brief_sw) then 
	      vol_msg_list = vol_msg_list || " " || rtrim(vpe(volx).name);
             call move_to_head(volx);
	   end;
          end;
       end;

    if ^active_fnc then do;
       if vol_msg_list ^= "" then 
          call msg_proc(0, "Volume set^[s^] ^a ^[has^;have^] been freed. ^[^a^;^s^]",
               (vol_cnt > 1), vol_msg_list, (vol_cnt = 1), (noaction_msg ^= ""), noaction_msg ); 
       else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg ); 
       end;
  
end free_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

free_node:  proc(volx);

/* free_node unlinks the volume_pool array entry specified by volx from the volume list 
   and relinks it into the free list of array nodes available for reuse.  This effectively
   deletes a volume from the pool.
*/

dcl volx				fixed bin;

     if volume_pool.head = volume_pool.tail then do;
        /* freeing the last volume set in the pool, so set conditions as for an empty pool */
        volume_pool.n_vol = 1;
        volume_pool.volume_count = 0;
        volume_pool.tail = 1;
        volume_pool.free_head = 1;
        volume_pool.head = no_link;
        vpe(volume_pool.n_vol).next = no_link;
        vpe(volume_pool.n_vol).previous = no_link;
        goto END_FREE_NODE;
        end;

     if volx = volume_pool.tail then do;
        volume_pool.tail = vpe(volx).previous;
        vpe(volume_pool.tail).next = vpe(volx).next;
        end;
     else if volx = volume_pool.head then do;
        volume_pool.head = vpe(volx).next;
        vpe(volume_pool.head).previous = vpe(volx).previous;
        end;
     else do;  /* in middle of volume list chain, relink it to exclude volume specified by volx 		*/
        vpe(vpe(volx).previous).next = vpe(volx).next;
        vpe(vpe(volx).next).previous = vpe(volx).previous;
        end;

     /* now chain the just freed node into the free node list */

     vpe(volx).next = volume_pool.free_head;
     vpe(volx).previous = no_link;		/* backwards index references are not used in the free node linked list */
     volume_pool.free_head = volx;
     volume_pool.volume_count = volume_pool.volume_count - 1;

END_FREE_NODE:
     return;
end free_node;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_list_names:     proc(aptr, asize, vs_size, most_recent);
		  
/* Called by list_key procedure, get_list_names fills in the volume
   structure with the name and index 
   of the desired volumes.
   aptr: Pointer to volume structure (input).
   asize: Size of structure (input).
   vs_size: Specifies what size of volume sets to look for (input).
   most_recent: true when the most recently updated volumes are wanted.
*/

dcl  1 volume			aligned based (aptr),
       2 name(asize)		char(32),
       2 indx(asize)		fixed bin,
       2 switches,
         3 noaction(asize)		bit(1) unal,
         3 want_it(asize)		bit(1)unal;

dcl (asize, vs_size, volx, vol_idx)		fixed bin;
dcl aptr				ptr;
dcl most_recent			bit(1);

    if most_recent then do;  /* -first */
       vol_idx = 0;
       volx = volume_pool.head;
       do while ((volx ^= no_link) & (vol_idx < asize));
	if get_names_check_switches(volx, vs_size) then do;
	   vol_idx = vol_idx + 1;
	   volume(vol_idx).name = vpe(volx).name;
	   volume(vol_idx).indx = volx;
	   volume(vol_idx).want_it = True;
	   end;
	volx = vpe(volx).next;
          end;
       end;
    else do;  /* -last specified */
       vol_idx = asize;
       volx = volume_pool.tail;
       do while ((volx ^= no_link) & (vol_idx > 0));
	if get_names_check_switches(volx, vs_size) then do;
	   volume(vol_idx).name = vpe(volx).name;
	   volume(vol_idx).indx = volx;
	   volume(vol_idx).want_it = True;
	   vol_idx = vol_idx - 1;
	   end;
	volx = vpe(volx).previous;
          end;
       end;

end get_list_names;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_names_check_switches:  proc(volx, vs_size) returns(bit(1));
     
/* Called by get_list_names, this procedure determines whether a volume meets the criteria specifed and 
   returns true, else false.
   volx: Index of volume to look at.
   vs_size: Size of volume set to be considered.
*/

dcl (volx, vidx, vs_size)		fixed bin;

    if listed_flag(volx) then return(False);      /* did we already print this?                            */
    vidx = volx;
    if vpe(vidx).secondary_vol then               /* set vidx to primary volume as he has all the info.    */
       vidx = vpe(vidx).primary_idx;

    if ^(specified_states(vpe (vidx).state)) then return(False);

    if vs_size = -1 then;   /* get volume_sets of any size */
    else if (vpe(vidx).vs_count) ^= vs_size then return(False);

    if expire_sw then do;
       /* want only those whose expire_date is < clock */
       if ^(vpe(vidx).expire) then return(False);
       if vpe(vidx).expire_date > clock() then return(False);
       end;

    if match_sw then do;
       compare = vpe (vidx).comment;
       if ((index (compare, match_string) = 0) | (index (compare, match_string) = 64)) then return(False);
       end;

return(True);

end get_names_check_switches;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_next_arg: proc(Arg_expected, ap1, al1);

/*  This guy gets the next argument from the argument string, complaining if it's not there  */

dcl Arg_expected			char(*);
dcl (ap1				ptr,
     al1				fixed bin(21));
	    
	if (ac + 1) > narg then do;
	     call abort_proc(error_table_$noarg, "A ^a expected after ^a.", Arg_expected, arg);
	     return;
	     end;
	ac = ac + 1;
	call get_arg (ac, ap1, al1, (0), alp);
     
end get_next_arg;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_node:  proc() returns (fixed bin);

/* Called by add procedures, get_node looks for the next available, or empty node in the volume pool structure, 
   and returns the index of this node to the caller.  */

dcl volx				fixed bin;

     volx = volume_pool.free_head;
     volume_pool.free_head = vpe(volume_pool.free_head).next;
     if volume_pool.free_head = no_link then do;
        volume_pool.free_head, volume_pool.n_vol = volume_pool.n_vol + 1;
        vpe(volume_pool.free_head).next = no_link;
        vpe(volume_pool.free_head).previous = no_link;
        vpe(volume_pool.free_head).secondary_idx = no_link;
        end;

     return(volx);
end get_node;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_number:    proc() returns(fixed bin);

/* Called when processing arguments for various keys, get_number returns the number specified for 
   control args -first, -last, -vs_size.   */

dcl arg_fb			fixed bin;

    if ac = narg then return(1);  /* this is the default */
    ac = ac + 1;
    call get_arg (ac, ap, al, (0), alp);
    if verify(arg, "0123456789") = 0 then do;
        arg_fb = convert(arg_fb, arg);
        if arg_fb = 0 then call abort_proc(error_table_$action_not_performed, " 0 volume set size specified.");
        return(arg_fb);
        end;
    else do;
       ac = ac - 1;	  /* reset arg pointer */
       return(1);   
       end;

end get_number;     
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_volumes_specified:     proc(requestor, a_states, aptr, asize, vs_size, most_recent);
		  
/* Called by the various key procedures, get_volumes_specified fills in the volume structure with volumes
   meeting specified criteria, querying the user and reporting errors when appropriate.
   requestor: The action required by the caller, used in querying (input).
   a_states:  Defines the states possible for a volume to be considered (input).
*/
dcl requestor			char(*);
dcl a_states(4)			bit(1) parameter;
dcl  1 volume			aligned based (aptr),
       2 name(asize)		char(32),
       2 indx(asize)		fixed bin,
       2 switches,
         3 noaction(asize)	bit(1) unal,
         3 want_it(asize)	bit(1)unal;

dcl (asize, vs_size, i, vol_idx)	fixed bin;
dcl aptr				ptr;
dcl (continue, 
     most_recent,
     just_expired)			bit(1);
dcl msg				char(256);
dcl msg_len			fixed bin;

    vol_idx = 0;
    if most_recent then do;
       i = volume_pool.head;
       do while ((i ^= no_link) & (vol_idx < asize));
          call get_volumes_specified_loop();
	i = vpe(i).next;
          end;
       end;
    else do;  /* get the volumes with the oldest state_date */
       i = volume_pool.tail;
       do while ((i ^= no_link) & (vol_idx < asize));
          call get_volumes_specified_loop();
	i = vpe(i).previous;
          end;
       end;

    if just_expired then call construct_msg(check_pvexp);

    if vol_idx = 0 then call abort_proc(0,
            "No ^[free^s^;^[allocated^]^] volume sets ^[of size ^d^;specified^] exist in the pool.^[ Allocate reserved volumes by name.^]", 
            a_states(free_state), a_states(allocated_state), vs_size > 0, vs_size, requestor = "allocated" );

    else if vol_idx < asize then do;
       /* query when some but not all volumes specified are found for -lt and -ft			*/
       continue = False;
       call ioa_$rsnnl("Only ^d volume set^[s^] ^[of size ^d ^;^s^]can be ^a.", msg, msg_len, vol_idx, vol_idx > 1, 
                       vs_size > 0, vs_size, requestor);

       call query_to_continue("", msg, force_sw, continue);
       if ^(continue) then call abort_proc(0,
	     "The ^d volume sets specified ^[of size ^d ^]are not in the pool. ", asize, vs_size > 0, vs_size);
       end;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_volumes_specified_loop:  proc();

   if a_states(vpe(i).state) then do;  
      if (vpe(i).vs_count = vs_size) | vs_size = -1 then do;
         if vpe(i).state = free_state then do;  
            call check_for_pvexp(i, brief_sw, just_expired);
	  if ^just_expired then do;
               vol_idx = vol_idx + 1;
	     volume(vol_idx).indx = i;
	     volume(vol_idx).name = vpe(i).name;
	     volume(vol_idx).want_it = True;
	     end;
	  end;
         else do;
            vol_idx = vol_idx + 1;
	  volume(vol_idx).name = vpe(i).name;
	  volume(vol_idx).indx = i;
	  volume(vol_idx).want_it = True;
	  end;
         end;
      end;

end get_volumes_specified_loop;

end get_volumes_specified;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

insert_node:  proc(volx);

/* Called by the add procedures, insert_node puts a new node into the linked volume list 
   contained in volume_pool.vpe  
   volx: index to the node to be linked (input).   */

dcl volx				fixed bin;

     vpe(volx).state_date = clock();
     vpe(volx).next = volume_pool.head;
     if volume_pool.head ^= no_link then vpe(volume_pool.head).previous = volx;
     vpe(volx).previous = no_link;
     volume_pool.head = volx;
     volume_pool.volume_count = volume_pool.volume_count + 1;

end insert_node;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

last_volume_in_set:  proc(primary_idx) returns(fixed bin);
		 
/* Determines the last volume in a volume set and returns the index of this last volume
   primary_idx:  index of the primary volume of the set (input).
*/   
dcl (primary_idx, vol_idx)		fixed bin;

     if vpe(primary_idx).vs_count = 1 then return(primary_idx);
     vol_idx = vpe(primary_idx).secondary_idx;
     do while (vpe(vol_idx).secondary_idx ^= no_link); 
        vol_idx = vpe(vol_idx).secondary_idx;
        end;
     return (vol_idx);

end last_volume_in_set;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

list_key:    proc();
	   
/* Lists volume sets in the pool. */

dcl (volx, i)			fixed bin;
dcl total_char			char(256) var;
dcl (get_area, not_in_pool)		bit(1);

    if volume_pool.volume_count = 0 then call abort_proc (0, "Volume pool is empty.");
    vs_size = -1;
    most_recent = False;
    allocate listed_flag in (based_area) set (Plisted);
    listed_flag = False;

    if narg = 1 then do;		/* No control args. Print the default. */
       i = volume_pool.head;
       do while (i ^= no_link);
          if active_fnc then do;
	   ret = ret || " " || rtrim(vpe(i).name);
	   end;
          else do;
	   dfmt_sw = True;
	   specified_states = "1"b;
	   call print (i, vs_size);
	   end;
	i = vpe(i).next;
          end;
       goto END_LIST;
       end;

     /* first process list control args */

    vol_cnt = 0;
    get_area = True;
    do ac = 2 to narg;
       call get_arg (ac, ap, al, (0), alp);
       if arg = "-match" then do;
	ac = ac + 1;
	call get_arg (ac, ap, al, code, alp);
	if code ^= 0 then call abort_proc (code, "Unable to get arg after ^a", arg);
	match_sw = True;
	match_string = arg;
	end;
       else if arg = "-free" then do;
	specified_states(free_state), free_sw = True;
	all_states = False;
	end;
       else if arg = "-alloc" | arg = "-allocate" | arg = "-allocated" then do;
	specified_states(allocated_state), alloc_sw = True;
	all_states = False;
	end;
       else if arg = "-pvexp" | arg = "-pv_expire" then do;
	specified_states(pvexp_state), pvexp_sw = True;
	all_states = False;
	end;
       else if arg = "-rsv" | arg = "-reserve" | arg = "-reserved" then do;
	specified_states(reserved_state), reserve_sw = True;
	all_states = False;
	end;
       else if arg = "-exp" | arg = "-expire" then expire_sw = True;
       else if arg = "-ft" | arg = "-first" then do;
	first_last_sw, first_sw, most_recent = True;
	vol_cnt = get_number();
	end;
       else if arg = "-lt" | arg = "-last" then do;
	first_last_sw, last_sw = True;
	most_recent = False;
	vol_cnt = get_number();
	end;
       else if arg = "-vs" | arg = "-volume_size" then do;
 	vs_sw = True;
	vs_size = get_number();
	end;
       else if arg = "-nm" | arg = "-name" then name_sw = True;
       else if arg = "-edt" | arg = "expire_date" then edt_sw = True;
       else if arg = "-pvedt" | arg = "pv_expire_date" then pvedt_sw = True;
       else if arg = "-com" | arg = "-comment" then comment_sw = True;
       else if arg = "-sdt" | arg = "state_date" | arg = "-time" then sdt_sw= True;
       else if arg = "-state" then state_sw = True;
       else if arg = "-nhe" | arg = "-no_header" then header_sw, header_to_be_printed = False;
       else if arg = "-ast" | arg = "-all_states" | arg = "-all" then all_states = True;
       else if arg = "-dfmt" | arg = "-default_format" then dfmt_sw  = True;
       else if arg = "-he" | arg = "-header" then  header_sw, header_to_be_printed = True;
       else if arg = "-tt" | arg = "-total" then do;
         totals_wanted = True;
         header_sw, header_to_be_printed = False;
         end;
       else do; /* assume a volume name */
          if get_area then do;
	   get_area = False;
	   volume_cnt = narg;
	   allocate volume in (based_area) set (Pvolume);
	   end;
          volume_sw = True;
	vol_cnt = vol_cnt + 1;
	volume(vol_cnt).name = arg;
	end;
    end;

if totals_wanted & (header_sw | state_sw | sdt_sw | name_sw | edt_sw | pvedt_sw | dfmt_sw | comment_sw | first_last_sw)
    then call abort_proc(error_table_$inconsistent, 
        "-total^[ -header^;^]^[ -state^;^]^[ -state_date^;^]^[ -name^;^]^[ -edt^;^]^[ -pvedt^;^]^[ -dfmt^;^]^[ -first^;^]^[ -last^;^]",
         header_sw, state_sw, sdt_sw, name_sw, edt_sw, pvedt_sw, dfmt_sw, first_sw, last_sw);

    if volume_sw & (match_sw | vs_sw | expire_sw | reserve_sw | pvexp_sw | free_sw | alloc_sw | first_last_sw)
    then call abort_proc(error_table_$inconsistent, 
        "volume_names ^[ -match^;^]^[ -volume_size^;^]^[ -expire^;^]^[ -rsv^;^]^[ -pvexp^;^]^[ -free^;^]^[ -alloc^;^]^[ -first^;^]^[ -last^;^]",
         match_sw, vs_sw, expire_sw, reserve_sw, pvexp_sw, free_sw, alloc_sw, first_sw, last_sw);

    if ^(name_sw | sdt_sw | state_sw | comment_sw | pvedt_sw | edt_sw) then dfmt_sw = True;
    if (name_sw & sdt_sw & state_sw & comment_sw) then dfmt_sw = True;

    if index(state_string, "1"b) = 0 then     /* set the default to consider all states			*/
              specified_states(*) = True;

    if volume_sw then do;
       not_in_pool = False;
       do i = 1 to vol_cnt;
          if volume_in_pool ((volume(i).name), volx) then call print(volx, vs_size);
	else do;
	   not_in_pool = True;
	   vol_list.name(fb_not_reg) = vol_list.name(fb_not_reg)  || " " || rtrim(volume(i).name);
	   vol_list.cnt(fb_not_reg) = vol_list.cnt(fb_not_reg) + 1;
	   end;
	end;
       if not_in_pool then call construct_msg(not_reg);
       end;

    else if (vs_sw | first_last_sw) then do;
       if vol_cnt = 0 then vol_cnt = volume_pool.n_vol;    /* -ft or -lt not specified, set default	*/
       volume_cnt = vol_cnt;
       allocate volume in (based_area) set (Pvolume);
       volume(*).want_it = False;
       call get_list_names(Pvolume, vol_cnt, vs_size, most_recent);
       if vol_cnt = 0 then call abort_proc(0, "No volumes met the list criteria specified.");
       do i = 1 to vol_cnt;
          if volume(i).want_it then call print (volume(i).indx, vs_size);
	end;
       end;

    else do;
       i = volume_pool.head;
       do while (i ^= no_link);
	call print (i, vs_size);
	i = vpe(i).next;
	end;
       end;

    if totals_wanted then do;
       if active_fnc then ret = convert(total_char, total_cnt);
       else do;
          if total_cnt = 0 then call msg_proc(0, "No volume sets met the list criteria specified.");
	else call msg_proc(0, "A total of ^d volume set^[s^].", total_cnt, total_cnt > 1);
	end;
       goto END_LIST;
       end;

    if total_cnt = 0 then call msg_proc(0, "No volume sets met the list criteria specified.");
    else if ^active_fnc then 
       if noaction_msg ^= "" then call ioa_$nnl("^/^a", noaction_msg);

END_LIST:
      return;
end list_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

lock_required: proc() returns(bit(1));

/* lock_required determines whether the pool has to be locked or not, depending on the requested action 
   and the effective access of the caller
*/

dcl code				fixed bin(35);
dcl mode				fixed bin(5);

    code = 0;
    if arg = "l" | arg = "ls" | arg = "list" |
       arg = "p" | arg = "pr" | arg = "print" |
       arg = "t" | arg = "test" then do;
       call hcs_$get_user_effmode (vol_dir, vol_ename, "", (get_ring_()), mode, code);
       if code ^= 0 then call abort_proc(code, "^/Unable to determine access of ^a", path(vol_dir, vol_ename));
       if mode = R_ACCESS_BIN | mode = RE_ACCESS_BIN then return(False);
       end;

    return(True);

end lock_required;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

lock_volume_pool: proc;

/* Locks the volume pool */

     lock = False;
     call set_lock_$lock (volume_pool.lock, lock_interval, code);
     if code ^= 0
     then do;
	if code = error_table_$invalid_lock_reset then code = 0;
	else if code = error_table_$locked_by_this_process then code = 0;
	else call abort_proc (code, " ^a",
	     path (vol_dir, vol_ename));
     end;
     lock = (code = 0);
end lock_volume_pool;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

msg:	proc (err);

/* msg is a semi all-purpose message reporting facility. 
   err = 0  means print the "manage_volume_pool:" header before the message.
   err = -1 says don't identify myself before the message.
*/

dcl  err fixed bin (35);
dcl  str char (256);
dcl  argp ptr;
dcl  str_len fixed bin;

     if subroutine then do;
        if err = 0 | err = -1 then a_code = error_table_$action_not_performed;
        else a_code = err;
        if lock then call unlock_volume_pool;
        end;

     call cu_$arg_list_ptr (argp);			/* convert args to message */
     call ioa_$general_rs (argp, 2, 3, str, str_len, "0"b, "0"b);
     if (err = 0 | err = -1) & ^subroutine & ^active_fnc then
        call ioa_ ("^[^a: ^;^s^]^a", err = 0, myname, substr (str, 1, str_len));
        else call error_rnt (err, myname, substr (str, 1, str_len));
     if subroutine then goto return_to_caller;

end msg;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

move_into_state_date_order:
     proc(volx);

/* move_into_state_date_order moves the volume entry specified by volx to the appropriate
   location in the volume_pool list (based upon its state_date) by relinking the volume list.
*/

dcl volx				fixed bin;
dcl voli				fixed bin;

     if volume_pool.head = volx &			/* volume is alone in the list.*/
        volume_pool.tail = volx then return;

     if volume_pool.head = volx then do;		/* first, remove volume from the list. */
        volume_pool.head = vpe(volx).next;
        vpe(vpe(volx).next).previous = no_link;
        end;
     else if volume_pool.tail = volx then do;
        volume_pool.tail = vpe(volx).previous;
        vpe(vpe(volx).previous).next = no_link;
        end;
     else do;
        vpe(vpe(volx).previous).next = vpe(volx).next;
        vpe(vpe(volx).next).previous = vpe(volx).previous;
        end;
     
     do voli = volume_pool.head repeat vpe(voli).next	/* then skip over volumes with more */
        while (voli ^= no_link & vpe(voli).state_date > vpe(volx).state_date);
        end;					/* state date than our volume.      */

     if voli = no_link then do;			/* put volume at tail of list.      */
        voli = volume_pool.tail;
        vpe(voli).next = volx;
        vpe(volx).previous = voli;
        vpe(volx).next = no_link;
        volume_pool.tail = volx;
        end;
     else if voli = volume_pool.head then do;		/* put volume at head of list.      */
        voli = volume_pool.head;
        vpe(voli).previous = volx;
        vpe(volx).next = voli;
        vpe(volx).previous = no_link;
        volume_pool.head = volx;
        end;
     else do;					/* put volume in front of voli      */
        vpe(vpe(voli).previous).next = volx;
        vpe(volx).previous = vpe(voli).previous;
        vpe(volx).next = voli;
        vpe(voli).previous = volx;
        end;

end move_into_state_date_order;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

move_to_head:  proc(volx);

/* move_to_head moves the volume entry specified by volx to the head of the volume_pool list by
   relinking the volume list.
*/

dcl volx				fixed bin;

     vpe(volx).state_date = clock();
     if volx = volume_pool.head then goto END_MOVE_TO_HEAD; /* Volume is already at head of pool		*/
     if vpe(volx).previous ^= no_link then do;
        vpe(vpe(volx).previous).next = vpe(volx).next;
        if volx = volume_pool.tail then volume_pool.tail = vpe(volx).previous;
        end;
     if vpe(volx).next ^= no_link then  vpe(vpe(volx).next).previous = vpe(volx).previous;
     vpe(volx).previous = no_link;
     vpe(volx).next = volume_pool.head;
     vpe(volume_pool.head).previous = volx;
     volume_pool.head = volx;

END_MOVE_TO_HEAD:
     return;
end move_to_head;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

path:	proc (dirname, ename) returns (char (168));

/* Constructs a pathname given the directory name and the entry name. */

dcl  dirname char (*);
dcl  ename char (*);
dcl  pathname char (168);
	     call ioa_$rsnnl ("^a^[>^]^a", pathname, (0), dirname, dirname ^= ">", ename);
	     return (pathname);
	end path;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

print:	proc(vidx, vs_size);
	
/* Called by list_key, print determines whether a volume is to be printed.
   vidx: Index to volume.
   vs_size: Size of volumes to be printed.  */

dcl (vs_size, printx, vidx)		fixed bin;

    printx = vidx;
    if listed_flag(printx) then goto END_PRINT;

    if vpe(printx).secondary_vol then          /*  set printx to primary volume as he has all the info.    */
       printx = vpe(printx).primary_idx;

    if ^(specified_states(vpe (printx).state)) then goto END_PRINT;

    if vs_size = -1 then;   /* get volume_sets of any size */
    else if (vpe(printx).vs_count) ^= vs_size then goto END_PRINT;

    if expire_sw then do;
       /* print only those whose expire_date is < clock */
       if ^(vpe(printx).expire) then goto END_PRINT;
       if vpe(printx).expire_date > clock() then goto END_PRINT;
       end;

    if match_sw then do;
       compare = vpe (printx).comment;
       if ((index (compare, match_string) = 0) | (index (compare, match_string) = 64)) then goto END_PRINT;
       end;
  
       /* At this point, all initial criteria to print has been met */

       call format_print_output(printx, False);

       if verify(output, blank_NL) = 0 then;  /* don't print if no output is found */
       else do;
          if active_fnc & ^totals_wanted then do;
               requoted_output = requote_string_ (substr (output, 1, length(output)));
	     ret = ret || " ";
   	     ret = ret || requoted_output;
	     end;
          else do;
             if header_sw then do;               /* did we print the header yet?  */
	      call ioa_("^a", header_output);
	      header_sw = False;
	      end;
	   if ^totals_wanted then call ioa_("^a", output);
	   end;
          total_cnt = total_cnt + 1;
       end;
    
       if vpe(printx).vs_count > 1  then call print_secondary_volumes(printx);

END_PRINT:
    return;
end print;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

print_secondary_volumes:   proc(printx);

/* Called by print, this procedure prints secondary volumes of a set. */

dcl printx			fixed bin parameter;

          /* printx is the index to the primary volume. we want to now print the secondary volumes only */

          listed_flag(printx) = True;

          printx = vpe(printx).secondary_idx;
          do while (printx ^= no_link);
             call format_print_output(printx, True);
	   listed_flag(printx) = True;
             if output ^= "" then do;
	      if active_fnc & ^totals_wanted then do;
	           requoted_output = requote_string_ (substr (output, 1, length(output)));
		 ret = ret || " ";
		 ret = ret || requoted_output;
   	           end;
	      else if ^totals_wanted then call ioa_("^a", output);
	      end;
	   printx = vpe(printx).secondary_idx;
	   end;
        
end print_secondary_volumes;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

process:	proc (fetch, routine);

/* Used by obselete keys change, comment and the old version of allocate. */

dcl  fetch bit (1) ;
dcl  routine entry;
	     if narg < 2 then call abort_proc (error_table_$noarg, "");
	     ac = 2;
	     do while (ac <= narg);
   	        call get_arg (ac, ap, al, (0), alp);
		if arg = "" then call abort_proc (error_table_$noarg, "");
		call search (arg);
		if fetch	then do;
		   ac = ac + 1;
		   call get_arg (ac, apa, ala, code, alp);
		   if code ^= 0 then call abort_proc (code, "No comment specified.");
		   end;
		   call routine;
		ac = ac + 1;
	     end;
	     return;
	end process;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

process_ctl_args:   proc(Pargs_allowed, begin_arg, vol_cnt);

/* Called by various keys to process their control arguments. Also fills in the volume structure when 
   volume names are specified.
   Pargs_allowed: Pointer to structure which specifies which arguments are allowed for the given 
   key procedure caller (input).
   begin_arg: Where to start argument processing (input).
   vol_cnt: The number of volumes to be acted upon (output).
*/
dcl begin_arg			fixed bin;
dcl get_area			bit(1);
dcl vol_cnt			fixed bin;
dcl Pargs_allowed			ptr;

dcl 1 args_allowed			unaligned based (Pargs_allowed),
      2  first			bit(1),
      2  last			bit(1),
      2  force			bit(1),
      2  volume_size		bit(1),
      2  comment			bit(1),
      2  expire			bit(1),
      2  brief			bit(1),
      2  fexp			bit(1),
      2  match			bit(1),
      2  all			bit(1),
      2  pvexp			bit(1),
      2  alloc			bit(1),
      2  reserve			bit(1),
      2  free			bit(1),
      2  svol			bit(1),
      2  asterisk			bit(1),
      2  exp_dt			bit(1),		/* requires a date after -exp			*/
      2  pvexp_dt			bit(1),		/* requires a date after -pvexp		*/
      2  state_dt			bit(1);

     vs_size = -1;					/* default is any size volume set if -vs isn't specified */
     vol_cnt = 0;
     asterisk_cnt = 0;
     get_area = True;
     most_recent = False;

     do ac = begin_arg to narg;
        call get_arg (ac, ap, al, (0), alp);
        if arg = "-exp" | arg = "-expire" then do;
           if ^(args_allowed.expire) then goto bad_ctl;
	 expire_sw = True;
 	 if (args_allowed.exp_dt) then			/* some keys require a date		*/
	    call get_next_arg("date", expire_ptr, expire_len);
	 end;

        else if arg = "-fc" | arg = "-force" then do;
           if ^(args_allowed.force) then goto bad_ctl;        
	 force_sw = True;
	 end;

        else if arg = "-ft" | arg = "-first" then do;
           if ^(args_allowed.first) then goto bad_ctl;
	 first_last_sw, first_sw, most_recent = True;
	 vol_cnt = get_number();
	 end;

        else if arg = "-lt" | arg = "-last" then do;
           if ^(args_allowed.last) then goto bad_ctl;
	 first_last_sw, last_sw = True;
	 most_recent = False;
	 vol_cnt = get_number();
	 end;

        else if arg = "*" then do;  /* have to support obsolete '*' use for test, delete, reserve. Same as -last 1 */
           if ^(args_allowed.asterisk) then goto bad_ctl;
	 asterisk_sw = True;
	 most_recent = False;
	 asterisk_cnt = asterisk_cnt + 1;
	 end;

        else if arg = "-vs" | arg = "-volume_size" then do;
           if ^(args_allowed.volume_size) then goto bad_ctl;
	 vs_sw = True;
	 vs_size = get_number();
	 end;

        else if arg = "-com" | arg = "-comment" then do;
           if ^(args_allowed.comment) then goto bad_ctl;
	 comment_sw = True;
	 call get_next_arg("comment", com_ptr, com_len);
	 end;

        else if arg = "-bf" | arg = "-brief" then do;
           if ^(args_allowed.brief) then goto bad_ctl;
	 brief_sw = True;
	 end;

        else if arg = "-fexp" | arg = "-force_expire" then do;
           if ^(args_allowed.fexp) then goto bad_ctl;
	 fexp_sw = True;
	 end;

        else if arg = "-a" | arg = "-all" then do;
           if ^(args_allowed.all) then goto bad_ctl;
	 all_sw = True;
	 end;

        else if arg = "-pvexp" | arg = "-pv_expire" then do;
           if ^(args_allowed.pvexp) then goto bad_ctl;
	 pvexp_sw = True;
           if (args_allowed.pvexp_dt) then		/* add and set keys require a date */
              call get_next_arg("date", pvexp_ptr, pvexp_len);
	 end;

        else if arg = "-stdt" | arg = "-state_date" then do;
	 if ^(args_allowed.state_dt) then go to bad_ctl;
           state_dt_sw = True;
	 call get_next_arg("date", state_dt_ptr, state_dt_len);
	 end;

        else if arg = "-free" then do;
           if ^(args_allowed.free) then goto bad_ctl;
	 free_sw = True;
	 end;

        else if arg = "-alloc" | arg = "-allocate" | arg = "-allocated" then do;
           if ^(args_allowed.alloc) then goto bad_ctl;
	 alloc_sw = True;
	 end;

        else if arg = "-rsv" | arg = "-reserved" | arg = "-reserve" then do;
           if ^(args_allowed.reserve) then goto bad_ctl;
 	 reserve_sw = True;
	 end;
	   
        else if arg = "-match" then do;
           if ^(args_allowed.match) then goto bad_ctl;
	 ac = ac + 1;
	 call get_arg (ac, ap, al, code, alp);
	 if code ^= 0 then call abort_proc (code, "Unable to get arg after ^a", arg);
	 match_sw = True;
	 match_string = arg;
	 end;

        else if arg = "-svol" | arg = "-secondary_volumes" then do;
           if ^(args_allowed.svol) then goto bad_ctl;
	 svol_sw = True;
	 end;

        else do; /* assume a volume name */
           if get_area then do;
	    get_area = False;
	    volume_cnt = narg;
	    allocate volume in (based_area) set (Pvolume);
	    end;
           volume_sw = True;
	 vol_cnt = vol_cnt + 1;
	 volume(vol_cnt).name = arg;
	 end;
     end;

     return;

bad_ctl:
     call abort_proc(error_table_$badopt, " ^a", arg);
     
end process_ctl_args;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

pv_expire_key:    proc();
	    
/* Procedure which handles the pv_expire key */

dcl primary_idx			fixed bin;
dcl (i, volx, vol_cnt)   		fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("0"b),
      2  last			init ("0"b),
      2  force			init ("1"b),
      2  vs			init ("0"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

    if narg < 2 then call abort_proc (error_table_$noarg, "Usage: mvp pvexp volume_names {-control_arg}");

    /* get volume_names */

    call process_ctl_args(addr(args_allowed), 2, vol_cnt);
    
    if vol_cnt = 0 then call abort_proc (error_table_$noarg, "No volume names specified.");

    call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | sec_vol | check_pvexp);

    call evaluate_volumes_wanted("physically expired", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
    if none_sw | abort_sw then do;
       if active_fnc then do;
	ret = "false";
	return;
	end;
       if none_sw then  call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
       else if abort_sw then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);
      end;

    /* expire the volumes */

    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
             volx = volume(i).indx;
             if vpe(volx).secondary_vol then volx = vpe(volx).primary_idx;
             vpe(volx).state = pvexp_state;
	   vpe(volx).pv_expire = False;
   	   if vpe(volx).vs_count > 1 then do; /* multiple volume set */
	      primary_idx = volx;
	      do while (volx ^= no_link);
	         vpe(volx).pv_expire = False;
	         volx = vpe(volx).secondary_idx;
	         end;
	      volx = primary_idx;
	      end;
             call move_to_head(volx);
	   end;
          end;
       end;

      if active_fnc then ret = "true";
      else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg);

end pv_expire_key;



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

pvexp_secondary_vol_check:   proc(a_idx) returns(bit(1));
	      
/* Called by check_for_pvexp, this procedure determines whether any secondary volumes of a set have 
   physically expired. If so, true is returned, else false. */

dcl (a_idx, vol_idx)		fixed bin;

    vol_idx = a_idx;
    if vpe(vol_idx).vs_count = 1 then return(False);	/* Not a multiple volume set			*/
    if vpe(vol_idx).state = allocated_state then return(False); /* allocated volumes cannot be expired */
     
     vol_idx = vpe(vol_idx).secondary_idx;
     do while (vol_idx ^= no_link);
        if vpe(vol_idx).pv_expire & vpe(vol_idx).pv_expire_date < clock() then return(True);
        vol_idx = vpe(vol_idx).secondary_idx;
        end;

    return(False);
    
end pvexp_secondary_vol_check;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

pvexp_volume:   proc(vol_idx);
	      
/* Called by check_for_pvexp, pvexp_volume does the actual work of physically expiring a volume as 
   specified by vol_idx. */

dcl (primary_idx, vol_idx)		fixed bin;

     vpe(vol_idx).state = pvexp_state;
     vpe(vol_idx).pv_expire = False;
     if vpe(vol_idx).vs_count > 1 then do;		/* multiple volume set, reset secondary volumes too */
        primary_idx = vol_idx;
        do while (vol_idx ^= no_link);
	 vpe(vol_idx).pv_expire = False;
	 vol_idx = vpe(vol_idx).secondary_idx;
	 end;
        vol_idx = primary_idx;
        end;
    call move_to_head(vol_idx);
    
end pvexp_volume;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

query_to_continue:    proc(requestor, msg, force, continue);

/* Determines whether to query or not.
   requestor: The action required by the caller, used in querying (input).
   msg:  The message specified by the caller (input).
   force: Specifies whether to query the user or not (input).
   continue: Continue or abort the request? (output).
*/
dcl (continue, force)		bit(1);
dcl (requestor, msg)		char(*);

             if force then continue = True;
	   else if active_fnc then continue = False;
	   else continue = yes_to_query(requestor, msg);
	   return;

end query_to_continue;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

remove_volume_set:    proc();
	    
/* This procedure handles the rmvs key of the mvp command */

dcl (done, just_expired, found)	bit(1);
dcl i,
    volx,
    current_idx,
    remove_cnt,
    prev_idx,
    primary_idx,
    set_state			fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("0"b),
      2  last			init ("0"b),
      2  force			init ("1"b),
      2  vs			init ("0"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("1"b),
      2  fexp			init ("1"b),
      2  match			init ("0"b),
      2  all			init ("1"b),
      2  pvexp			init ("1"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

        if narg < 3 then call abort_proc (error_table_$noarg, 
                        "^/Usage: mvp rmvs primary_volume_name {secondary_volume_names} {-control_args} ");

        /* first get primary_volume_name */

        ac = 2;
        call get_arg (ac, ap, al, (0), alp);
        if ^(volume_in_pool((arg), primary_idx)) then call abort_proc(error_table_$action_not_performed,
                    "Primary volume specified is not in the pool. " || arg);
        else if vpe(primary_idx).secondary_vol then call abort_proc(error_table_$action_not_performed,
                    "^/Primary volume specified ^a is a secondary volume of set ^a.", arg, 
		vpe(vpe(primary_idx).primary_idx).name);

        /* now look at secondary volumes specified or  control args */

        call process_ctl_args(addr(args_allowed), 3, vol_cnt);
     
        if pvexp_sw then set_state = pvexp_state;
        else set_state = free_state;

       if (pvexp_sw  & all_sw) then call abort_proc(error_table_$inconsistent, "-pvexp -all");
       if (pvexp_sw | all_sw) & volume_sw then call abort_proc(error_table_$inconsistent,
                                                       "secondary_volumes and -control_args");

       if vpe(primary_idx).state = allocated_state & ^(fexp_sw) then do;
          /* check -expire date 			*/
	if  vpe(primary_idx).expire & (vpe(primary_idx).expire_date > clock()) then do; 
						/* hasn't expired, abort request 		*/
	      if brief_sw then do;
	         if active_fnc then call abort_proc(error_table_$action_not_performed,
	                 "^/Volume set ^a is not expired. ^a", vpe(primary_idx).name, 
                           time_string_(vpe(primary_idx).expire_date));
	         end;
	      else call abort_proc(error_table_$action_not_performed,
	                 "^/Volume set ^a is not expired. ^a", vpe(primary_idx).name, 
                            time_string_(vpe(primary_idx).expire_date));
             end;
	end;

       if ^(volume_sw) then do;
	vol_cnt, volume_cnt = max( 1, vpe(primary_idx).vs_count - 1);
	allocate volume in (based_area) set (Pvolume);
	volume.want_it, volume.noaction = False;

	if vpe(primary_idx).vs_count = 1 then    /* volume set is size one 		*/
             volx = primary_idx;		
          else     /* set index to first secondary volume. primary volume stays unchanged */
             volx = vpe(primary_idx).secondary_idx;  

	do i = 1 to vol_cnt while (volx >= 1);		/* fill volume array with volumes to be removed	*/
	   volume(i).name = vpe(volx).name;
	   volume(i).indx = volx;
	   volume(i).want_it = True;
	   volx = vpe(volx).secondary_idx;
	   end;

          if pvexp_sw then do;
	   volume.want_it = False;
	   do i = 1 to vol_cnt;
	      if vpe(volume(i).indx).pv_expire & (vpe(volume(i).indx).pv_expire_date < clock()) then 
                   volume(i).want_it = True;
	      end;
	   end;
          end;

       else do;  /* secondary volume names were specified, verify them.  */
          call check_for_errors(Pvolume, volume_cnt, vol_cnt, primary_idx, not_reg | sec_not_found);
          end;

       call evaluate_volumes_wanted("removed", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
       if none_sw then call abort_proc(error_table_$action_not_performed, 
	        "No physically expired volumes found in set ^a.", vpe(primary_idx).name);
       else if abort_sw then if noaction_msg ^= "" then call abort_proc(error_table_$action_not_performed, "^a", 
                                                        noaction_msg);

       /* now remove the volumes */
       
       remove_cnt = 0;
       prev_idx = primary_idx;
       if vpe(primary_idx).vs_count = 1 then current_idx = primary_idx;
       else current_idx = vpe(primary_idx).secondary_idx;  
       done = False;
       do while (^done);
          if vpe(current_idx).secondary_idx <= 0 then done = True;
          found = False;
	do i = 1 to vol_cnt while (^found);
	   if volume(i).want_it & (volume(i).name = vpe(current_idx).name) then found = True;
	   end;
	if found then call remove_volume();
 	else do;  /* update prev_idx */
	   prev_idx = current_idx;
	   current_idx = vpe(current_idx).secondary_idx;
	   end;
	end;  /* do loop */

       vpe(primary_idx).vs_count = max(1, vpe(primary_idx).vs_count - remove_cnt);
       if all_sw then do;				/* remove primary volume also			*/
          current_idx, prev_idx = primary_idx;
	call remove_volume();
	end;
       if just_expired then do;
	call construct_msg(check_pvexp);
          if ^active_fnc & noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg);
	end;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

remove_volume:  proc();

/* Internal procedure to remove_volume_set procedure, this guy does the actual removing of volumes */

dcl save_idx			fixed bin;

   /* first check pvexp date  to print message */
   call check_for_pvexp(current_idx, brief_sw, just_expired);

   remove_cnt = remove_cnt + 1;

   /* relink the volume set chain */
    vpe(prev_idx).secondary_idx = vpe(current_idx).secondary_idx;

    /* reset the vpe being removed */
    if active_fnc & ^just_expired then ret = ret || " " || rtrim(vpe(current_idx).name);
    vpe(current_idx).comment = "";
    vpe(current_idx).secondary_vol = False;
    vpe(current_idx).expire = False;
    vpe(current_idx).expire_date = 0;
    vpe(current_idx).primary_idx = no_link;
    if ^just_expired then do;
       vpe(current_idx).state = free_state;
       vpe(current_idx).state_date = clock();
       call move_to_head(current_idx);
       end;
    if vpe(current_idx).secondary_idx > 0 then do;
       save_idx = current_idx;
       current_idx = vpe(current_idx).secondary_idx;
       vpe(save_idx).secondary_idx = no_link;
       end;

end remove_volume;

end remove_volume_set;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

reserved_by_another_process:	proc(vol_idx) returns (bit(1));

/* Returns true when a volume specified by vol_idx is reserved by another process */

dcl vol_idx			fixed bin;

    if vpe(vol_idx).processid ^= get_process_id_() then do;  /* reserved by another process */
       call hcs_$validate_processid (vpe (vol_idx).processid, code);
       if code = error_table_$process_unknown then return(False);  /* other process is not active  */
       else return(True);
       end;

    return(False);

end reserved_by_another_process;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

reserve_key:    proc();

/* Procedure which handles the mvp command reserve key. */

dcl (i, vol_cnt, volx)		fixed bin;
dcl just_expired			bit(1);

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("1"b),
      2  last			init ("1"b),
      2  force			init ("1"b),
      2  vs			init ("1"b),
      2  com			init ("1"b),
      2  expire			init ("0"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("1"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

     /* first process control args */

    if narg < 2 then call abort_proc (error_table_$noarg, "Usage: reserve {volume_names} {-control_args}");

     specified_states(free_state) = True;
     just_expired = False;

    call process_ctl_args(addr(args_allowed), 2, vol_cnt);

    if asterisk_sw then 
       if (vs_sw | first_last_sw) then call abort_proc(error_table_$inconsistent, 
                                            "The asterisk '*' is obsolete. Use '-last'");
       else call msg_proc(-1, "The asterisk '*' is obsolete. Use '-last'");

    if volume_sw & (vs_sw | first_last_sw) then call abort_proc(error_table_$inconsistent, 
         "volume_names ^[-volume_size^;^]^[-first^;-last^]", vs_sw, most_recent);

    if asterisk_sw then do;
       tcnt = asterisk_cnt;
       allocate tvol in (based_area) set (Ptvol);
       tvol.want_it = False;
       call get_volumes_specified ("reserved", specified_states, Ptvol, tcnt, vs_size, most_recent);
       end;	

    else if ^(volume_sw) then do;     /* -first or -last or -vs were specified */
       if vol_cnt = 0 then vol_cnt = 1;
       volume_cnt = vol_cnt;
       allocate volume in (based_area) set (Pvolume);
       call get_volumes_specified ("reserved", specified_states, Pvolume, vol_cnt, vs_size, most_recent);
       end;

    if volume_sw then 
       call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | sec_vol | not_free | check_pvexp);

    if asterisk_sw then do;
       if ^(volume_sw) then do;
          vol_cnt = 0;
          volume_cnt = tcnt;
	allocate volume in (based_area) set (Pvolume);
	end;
       do i = 1 to tcnt;
          volume(vol_cnt + 1).name = tvol(i).name;
	volume(vol_cnt + 1).indx = tvol(i).indx;
	volume(vol_cnt + 1).want_it = tvol(i).want_it;
	vol_cnt = vol_cnt + 1;
          end;
       end;
    
    call evaluate_volumes_wanted("reserved", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
    if none_sw then call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
    else if abort_sw then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);

    /* reserve volumes specified */

    vol_msg_list = "";
    vol_msg_cnt = 0;
    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
	   volx = volume(i).indx;
             if vpe(volx).secondary_vol then volx = vpe(volx).primary_idx;
	   if active_fnc then ret = ret || " " || rtrim(vpe(volx).name);
	   vpe (volx).state = reserved_state;
	   vpe(volx).processid =  get_process_id_ ();
	   if comment_sw then vpe (volx).comment = comment_str;
	   else vpe (volx).comment = "";
	   if (first_last_sw | asterisk_sw) then  do;
                vol_msg_list = vol_msg_list || " " || rtrim(vpe(volx).name);
	      vol_msg_cnt = vol_msg_cnt + 1;
	      end;
             call move_to_head(volx);
	   end;
	end;
       end;

    if ^active_fnc then do;    
       if vol_msg_list ^= "" then			
          call msg_proc (0, "Volume set^[s^] ^a ^[has^;have^] been reserved. ^[^a^;^s^]",
            (vol_msg_cnt > 1), vol_msg_list, (vol_msg_cnt = 1), (noaction_msg ^=""), noaction_msg);  
       else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg ); 
       end;

end reserve_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

reuse:    proc();

/* Procedure which handles the mvp command reuse key. */

dcl (i, vol_cnt, volx)		fixed bin;
dcl just_expired			bit(1);

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("1"b),
      2  last			init ("1"b),
      2  force			init ("1"b),
      2  vs			init ("1"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("1"b),
      2  fexp			init ("1"b),
      2  match			init ("1"b),
      2  all			init ("0"b),
      2  pvexp			init ("0"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("0"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

     /* first process list control args */

     call process_ctl_args(addr(args_allowed), 2, vol_cnt);

    if volume_sw & (vs_sw | match_sw | first_last_sw) then call abort_proc(error_table_$inconsistent, 
         "volume_names ^[-volume_size^;^]^[-match^;^]^[-first^;-last^]", vs_sw, match_sw, most_recent);

    if first_last_sw | vs_sw then do;
       if vol_cnt = 0 then volume_cnt, vol_cnt = 1;
       else volume_cnt = vol_cnt;
       allocate volume in (based_area) set (Pvolume);
       volume.want_it, volume.noaction = False;
       specified_states(allocated_state) = True;
       call get_volumes_specified("re-allocated", specified_states, Pvolume, vol_cnt, vs_size, most_recent);
       end;

    if match_sw then do;
       if vol_cnt = 0 then do;  
          volume_cnt, vol_cnt = volume_pool.n_vol;
          allocate volume in (based_area) set (Pvolume);
	end;
       volume.want_it, volume.noaction = False;
       do i = 1 to vol_cnt;
          if (index (vpe(i).comment, match_string) > 0) & (vpe(i).state = allocated_state)  then do;
             volume(i).name = vpe(i).name;
             volume(i).indx = i; 
             volume(i).want_it = True;
             if (vpe(i).expire & vpe(i).expire_date < clock()) & ^fexp_sw then volume(i).noaction = True;
             call check_for_pvexp(i, brief_sw, just_expired);
             if just_expired then volume(i).noaction = True;
	   end; 
          end;  /* do loop */

       if index(want_str, "1"b) = 0 then if ^(brief_sw) then call abort_proc(error_table_$action_not_performed,
                                        "^/No allocated volumes found with comment string matching ^a.", match_string);
       if just_expired then call construct_msg(check_pvexp);
       end; /* if match_sw */

    /* here's the case where volume names were specified */

    else if volume_sw then do;
       call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | not_alloc | already_sec_vol | not_exp | check_pvexp);
       end;

    call evaluate_volumes_wanted("reused", Pvolume, volume_cnt, vol_cnt, none_sw, abort_sw);
    if none_sw then call abort_proc(error_table_$action_not_performed, 
                "Volume set^[s^] specified ^[are^;is^] not registered in the pool.", (vol_cnt > 1), (vol_cnt > 1));
    else if abort_sw then if noaction_msg ^= "" then call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);

    /* now free and re-allocate  the volumes */

    vol_msg_list = "";
    vol_msg_cnt = 0;
    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
             volx = volume(i).indx;
	   if active_fnc then ret = ret || " " || rtrim(vpe(volx).name);
	   if (( match_sw | first_last_sw) & ^brief_sw) then  do;
	      vol_msg_cnt = vol_msg_cnt +1;
	      vol_msg_list = vol_msg_list || " " || rtrim(vpe(volx).name);
	      end;
             call move_to_head(volx);
	   end;
          end;
       end;

    if ^active_fnc then do;
       if vol_msg_list ^= "" then 
          call msg_proc(-1, "^a: Volume set^[s^] ^a ^[has^;have^] been re-allocated. ^[^a^;^s^]",
            myname, (vol_msg_cnt > 1), vol_msg_list, (vol_msg_cnt = 1), (noaction_msg ^= ""), noaction_msg);  
        end;

end reuse;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

search:	proc (name);

/* Used by obselete keys and subroutine entry points. */

dcl  name char (*);

    vlx = 0;
    if name = "*"  then do;
       tvlx = volume_pool.tail;
       do while ((tvlx ^= no_link) & (vlx = 0));
          if vpe(tvlx).state = free_state & vpe(tvlx).vs_count = 1 then vlx = tvlx;
	tvlx = vpe(tvlx).previous;
          end;
       end;
    else do;
       if volume_in_pool(arg, tvlx) then do;
	if vpe(tvlx).secondary_vol then vlx = vpe(tvlx).primary_idx;
	else vlx = tvlx;
	end;
       end;

     return;
end search;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

set_key:  proc();
	    
/* Procedure which handles the mvp command set key. */

dcl (exp_clock, pv_clock)		fixed bin(71);
dcl i, vol_idx			fixed bin;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("0"b),
      2  last			init ("0"b),
      2  force			init ("0"b),
      2  vs			init ("0"b),
      2  com			init ("1"b),
      2  expire			init ("1"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("0"b),
      2  all			init ("0"b),
      2  pvexp			init ("1"b),
      2  alloc			init ("0"b),
      2  reserve			init ("0"b),
      2  free			init ("0"b),
      2  svol			init ("1"b),
      2  asterisk			init ("0"b),
      2  exp_dt			init ("1"b),
      2  pvexp_dt			init ("1"b),
      2  state_dt			init ("1"b)) bit(1);

        if narg < 3 then call abort_proc (error_table_$noarg, 
                        "^/Usage: mvp set volume_names -control_args ");

       pv_clock = 0;
       call process_ctl_args(addr(args_allowed), 2, vol_cnt);

       if vol_cnt = 0 then   call abort_proc(0, "No volume names specified.");
       if ^(comment_sw | pvexp_sw | expire_sw | state_dt_sw) then    call abort_proc(0, "No -control_args specified.");
       if (svol_sw  & ^(pvexp_sw | state_dt_sw)) then
          call abort_proc(error_table_$inconsistent,
	"-svol is used only in conjuction with -pvexp or -state_date");

       if pvexp_sw then do;
	call convert_date_to_binary_(pvexp_str, pv_clock, code);
	if code ^= 0 then call abort_proc(code, pvexp_str);
	end;

       if expire_sw then do;
	call convert_date_to_binary_(expire_str, exp_clock, code);
	if code ^= 0 then call abort_proc(code, expire_str);
	end;
 
       if state_dt_sw then do;
	call convert_date_to_binary_(state_dt_str, state_dt_clock, code);
	if code ^= 0 then call abort_proc(code, state_dt_str);
	end;

    call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | not_updated | check_pvexp);

    if vol_list.name(fb_not_updated) ^= "" then do;		/* this is the only case to abort the request	*/
       if active_fnc then do;
	ret = "false";
	return;
	end;
       else call abort_proc(error_table_$action_not_performed, "^a", noaction_msg);
       end;

    /* process volumes specified */

    do i = 1 to vol_cnt;
       if volume(i).want_it then do;
          if ^(volume(i).noaction) then do;
	   vol_idx = volume(i).indx;
	   if pvexp_sw then do;
	      if svol_sw then do;
	         if vpe(vol_idx).secondary_vol then vol_idx = vpe(vol_idx).primary_idx;
	         do while (vol_idx ^= no_link);
		  vpe(vol_idx).pv_expire_date = pv_clock;
		  vpe(vol_idx).pv_expire = True;
     	            vol_idx = vpe(vol_idx).secondary_idx;
		  end;
	         end;
	      else do;
	         vpe(vol_idx).pv_expire = pvexp_sw;
	         vpe(vol_idx).pv_expire_date = pv_clock;
	         end;
	      vol_idx = volume(i).indx;
                end;
	   if state_dt_sw then do;
	      if vpe(vol_idx).secondary_vol then vol_idx = vpe(vol_idx).primary_idx;
	      do while (vol_idx ^= no_link);
	         vpe(vol_idx).state_date = state_dt_clock;
	         vol_idx = vpe(vol_idx).secondary_idx;
	         end;
	      vol_idx = volume(i).indx;
	      call move_into_state_date_order (vol_idx);
	      end;
	   if vpe(vol_idx).secondary_vol then vol_idx = vpe(vol_idx).primary_idx;
	   if expire_sw & vpe(vol_idx).state = allocated_state then do;
	         vpe(vol_idx).expire = True;
	         vpe(vol_idx).expire_date = exp_clock;
	         end;
             if comment_sw then vpe (vol_idx).comment = comment_str;
             end;
          end;		
       end;

    if active_fnc then  ret = "true";
    else if noaction_msg ^= "" then call msg_proc(0, "^a", noaction_msg);

end set_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

setup1:  proc(a_subroutine);

     /* Called by command and entrypoints to initializer variables referenced by 
        cleanup handler. */

     dcl a_subroutine bit (1) aligned;

     Pvolume, Ptvol, areap, retp, vpp = null();
     lock = Unlocked;
     subroutine = a_subroutine;

     return;

end setup1;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

setup2:	proc ;

/* Called by just about everyone to initialize things after cleanup handler has been established. */

	     code, ecode = 0;
	     active_fnc = False;
	     abort_proc = abort;
	     msg_proc = msg;
	     if subroutine then do;
		a_code = 0;
		myname = "manage_volume_pool_";
		error_rnt = a_error_rnt;
		vpp = a_vpp;
		if vpp ^= null() then do;
		     if volume_pool.version ^= volume_pool_version_3 then call check_first_then_convert();                         
		     call lock_volume_pool;
		end;
	     end;
	     else do;
	          noaction_cnt, total_cnt = 0;
		vol_msg_list, noaction_msg  = "";
		vol_list.name = "";
		vol_list.cnt = 0;
		free_sw, match_sw, most_recent, asterisk_sw = False;
		name_sw, sdt_sw, comment_sw, state_sw, alloc_sw, reserve_sw, free_sw, 
		        force_sw, fexp_sw, brief_sw, pvedt_sw, edt_sw, first_sw, last_sw, expire_sw, first_last_sw,
		        pvexp_sw, state_dt_sw, all_sw, totals_wanted, svol_sw, volume_sw, vs_sw, dfmt_sw, specified_states(*) = False;
		all_states, header_sw, header_to_be_printed = True;
		call cu_$arg_list_ptr (alp);
		call cu_$af_return_arg (narg, retp, retl, code);
		active_fnc = (code = 0);
		if active_fnc  then error_rnt = active_fnc_err_;
		else error_rnt = com_err_;
		myname = "manage_volume_pool";
		if active_fnc then get_arg = cu_$af_arg_ptr_rel;
		else get_arg = cu_$arg_ptr_rel;

		if narg = 0 then
arg_err:		     call abort_proc (0, "USAGE: manage_volume_pool key {-control_args}");
		call get_arg (1, ap, al, (0), alp);
		if bad_arg (arg) then goto arg_err;
		if arg = "use" | arg = "u" then goto END_SETUP;
		else call setup_pool_path("0"b, "1"b);
		if volume_pool.version ^= volume_pool_version_3 then call check_first_then_convert();                         
		if lock_required() then call lock_volume_pool();
		areap = get_system_free_area_();
	     end;
END_SETUP:
	return;
end setup2;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

setup_pool_path:   proc(have_pool_path, create_flag);

/*  Two cases:                                                                                                */
/*    1)  have_pool_path is FALSE                                                                             */
/*      Called by setup and use_key procedures. Sets the default volume pool, which is person_id.volumes in   */
/*      the user's home_dir,                      						*/
/*      creating the pool if it doesn't exist.                                                                */
/*    2)  have_pool_path is TRUE                                                                              */
/*      Called by use_key procedure and set_pool_path entry.  Initiates the volume pool specified by arg      */
/*      creating the pool if it doesn't exist.                                                                */
/*											*/
/*  Variables vol_dir and vol_ename are set.                                                                  */

dcl have_pool_path		bit(1);
dcl create_flag bit(1) aligned;

    if have_pool_path then do;
        call expand_pathname_ (arg, vol_dir, vol_ename, code);
        if code ^= 0 then call abort_proc (code, "Unable to expand ^a", arg);
    end;
    else do;   /* Use volume pool last referenced */ 
        if vol_dir = "" then do; /* no previous volume pool was referenced; set to default pool, */
            call user_info_$homedir (vol_dir);
            call user_info_ (vol_ename, "", "");
        end;  /* if vol_dir = "" */
    end;

    call suffixed_name_$make (vol_ename, "volumes", vol_ename, code);
    if code ^= 0 then call abort_proc (code, "Unable to construct volume pool name ^a.volumes.", vol_ename);

    call initiate_file_ (vol_dir, vol_ename, RW_ACCESS, vpp, vp_bc, code);
    if vpp = null then 
        if create_flag then
            call create_pool();

    if subroutine then a_vpp = vpp;

end setup_pool_path;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

test_key:		proc();

/* Procedure which handles the mvp command test key. */

dcl (volx, list_cnt, list_no_cnt,
     vol_cnt, i)			fixed bin;
dcl (yes, no)			bit(1);
dcl (test_vol_list,
     test_no_vol_list)		char(256) var;

/* The structure below describes the control arguments allowed for a given key.
   A control arg is valid when the bit is "1"b.  */

dcl 1 args_allowed			unaligned static int options(constant),
     (2  first			init ("1"b),
      2  last			init ("1"b),
      2  force			init ("0"b),
      2  vs			init ("1"b),
      2  com			init ("0"b),
      2  expire			init ("0"b),
      2  brief			init ("0"b),
      2  fexp			init ("0"b),
      2  match			init ("1"b),
      2  all			init ("0"b),
      2  pvexp			init ("1"b),
      2  alloc			init ("1"b),
      2  reserve			init ("1"b),
      2  free			init ("1"b),
      2  svol			init ("0"b),
      2  asterisk			init ("1"b),
      2  exp_dt			init ("0"b),
      2  pvexp_dt			init ("0"b),
      2  state_dt			init ("0"b)) bit(1);

     /* process control args */

    if narg < 2 then call abort_proc (error_table_$noarg, "^/Usage: mvp test {volume_names} {-control_args}");

     call process_ctl_args(addr(args_allowed), 2, vol_cnt);

     if asterisk_sw then 
       if (vs_sw | first_last_sw) then call abort_proc(error_table_$inconsistent, 
                                            "The asterisk '*' is obsolete. Use '-last'");
       else call msg_proc(-1, "The asterisk '*' is obsolete. Use '-last'");

     if volume_sw & (vs_sw | first_last_sw ) then call abort_proc(error_table_$inconsistent, 
         "volumes and ^[-vs ^]^[-first^;-last ^]", vs_sw, most_recent);

     specified_states(free_state) = free_sw;
     specified_states(allocated_state) = alloc_sw;
     specified_states(reserved_state) = reserve_sw;
     specified_states(pvexp_state) = pvexp_sw;

     if state_string = truebits then call abort_proc(error_table_$inconsistent,
        "^[ -free ^]^[-alloc ^]^[-reserve ^]^[-pvexp ^]", specified_states(free_state), specified_states(allocated_state),
        specified_states(reserved_state), specified_states(pvexp_state));

     if index(state_string, "1"b) = 0 then                /* set default */
        specified_states(free_state) = True;

    force_sw = True;			/* query feature is not used with test key		*/
    if vol_cnt = 0 then vol_cnt = 1;

    if asterisk_sw then do;
       tcnt = asterisk_cnt;
       allocate tvol in (based_area) set (Ptvol);
       tvol.want_it = False;
       call get_volumes_specified ("tested", specified_states, Ptvol, tcnt, vs_size, most_recent);
       end;	

    else if ^(volume_sw) then do;
       volume_cnt = vol_cnt;
       allocate volume in (based_area) set (Pvolume);
       call get_volumes_specified("tested", specified_states, Pvolume, vol_cnt, vs_size, most_recent);
       end;

    if volume_sw then  do;   /* volume names were specified */
       call check_for_errors(Pvolume, volume_cnt, vol_cnt, 0, not_reg | sec_vol | check_pvexp);
       end;  

    if asterisk_sw then do;
       if ^(volume_sw) then do;
          vol_cnt = 0;
          volume_cnt = tcnt;
	allocate volume in (based_area) set (Pvolume);
	end;
       do i = 1 to tcnt;
          volume(vol_cnt + 1).name = tvol(i).name;
	volume(vol_cnt + 1).indx = tvol(i).indx;
	volume(vol_cnt + 1).want_it = tvol(i).want_it;
	vol_cnt = vol_cnt + 1;
          end;
       end;
    
    yes, no = False;
    test_vol_list, test_no_vol_list = "";
    list_cnt, list_no_cnt = 0;

    do i = 1 to vol_cnt;
       if volume(i).want_it & ^(volume(i).noaction) then do;
          volx = volume(i).indx;
          if vpe(volx).secondary_vol then volx = vpe(volx).primary_idx;
          if specified_states (vpe(volx).state) then do;
             yes = True;
	   test_vol_list = test_vol_list || " " || rtrim(volume(i).name);
	   list_cnt = list_cnt +1;
	   end;
          else do;
	   no = True;
	   test_no_vol_list = test_no_vol_list || " " || rtrim(volume(i).name);
	   list_no_cnt = list_no_cnt + 1;
	   end;
          end;
       end;

    if active_fnc then do;
       if yes & no then ret = "false";
       else if yes then ret = "true";
       else ret = "false";  /* no  */
       end;
    else do;
       if noaction_msg ^= "" then call msg_proc (0, "^a", noaction_msg);

       if yes then 
          call msg_proc
            (-1, "^[^a: ^;^s^]Volume set^[s^]^a ^[are^;is^] ^[free^;^[reserved^;^[allocated^;pv_expired^]^]^].",
            (noaction_msg = ""), myname,
	  (list_cnt > 1), test_vol_list, (list_cnt > 1),
	  specified_states(free_state), specified_states(reserved_state),
	  specified_states(allocated_state), specified_states(pvexp_state));

       if no then 
          call msg_proc
            (-1, "^[^a: ^;^s^]Volume set^[s^]^a ^[is^;are^] not ^[free^;^[reserved^;^[allocated^;pv_expired^]^]^].",
            (^yes), myname, (list_no_cnt > 1), test_no_vol_list, (list_no_cnt = 1), 
	  specified_states(free_state), specified_states(reserved_state),
	  specified_states(allocated_state), specified_states(pvexp_state));
      end;

end test_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

time_string_: proc (time) returns (char (20));

dcl  time fixed bin (71);
dcl  time_char char (24) aligned;
     
     call date_time_ (time, time_char);
     return (substr(time_char, 1, 20));

end time_string_;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

unlock_volume_pool: proc;

/* unlocks the volume pool */

     call set_lock_$unlock (volume_pool.lock, ecode);
     if ecode ^= 0 then do;
	if ecode = error_table_$lock_not_locked then ecode = 0;
	else call abort_proc (ecode, "Error unlocking volume pool ^a.",
	     path (vol_dir, vol_ename));
     end;
     lock = ^(ecode = 0);
     return;
end unlock_volume_pool;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

use_key:      proc();
	    
/* Procedure which handles the mvp command use key. */

     if narg > 2 then call abort_proc (0, "USAGE: manage_volume_pool use {pathname}.");
     if narg = 1 then do;
        vol_dir, vol_ename = "";
        call setup_pool_path("0"b, "1"b);
     end;
     else do;
        call get_arg (2, ap, al, code, alp);
        call setup_pool_path("1"b, "1"b);
        end;

    if active_fnc then ret = path(vol_dir, vol_ename);

end use_key;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

volume_in_pool:  proc(vol_name, vol_idx) returns(bit(1));

/* Determines whether the volume specified by vol_name is in the pool, and returns true.
   vol_name:  name of the volume to be looked for. (input)
   vol_idx:   index of the volume found in the pool(output)
*/

dcl vol_name			char(*),
    (i, vol_idx)			fixed bin;

     if volume_pool.volume_count = 0 then return(False); /* no volumes yet in the pool */
     vol_idx = volume_pool.head;
     do while (vol_idx ^= no_link);
        if vpe (vol_idx).name = vol_name then return(True);
        if vpe(vol_idx).vs_count > 1 then do;
	 i = vpe(vol_idx).secondary_idx;
	 do while (i ^= no_link);
	    if vpe (i).name = vol_name then do;
	       vol_idx = i;				/* return secondary volume index 		*/
	       return(True);
	       end;
	    i = vpe(i).secondary_idx;
	    end;
           end;
        vol_idx = vpe(vol_idx).next;
        end;
     return(False);

end volume_in_pool;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

volume_in_volume_set:  proc(vol_name, primary_idx, vol_idx) returns(bit(1));

/* determines whether a volume specified by vol_name is in a given volume set.
   vol_name:  name of the volume to be looked for. (input)
   primary_idx: idx of primary volume of the set to be searched (input)   
   vol_idx:   index of the secondary volume found in the pool (output)
*/

dcl vol_name			char(*),
    (primary_idx, vol_idx)		fixed bin;

     vol_idx = vpe(primary_idx).secondary_idx;
     do while (vol_idx ^= no_link);
        if vpe (vol_idx).name = vol_name then return(True);
        vol_idx = vpe(vol_idx).secondary_idx;
        end;
     return(False);

end volume_in_volume_set;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

yes_to_query:  proc(request_type, msg) returns(bit(1));

          /* Initializes the query_info structure and querys the user about continuing  a           */
	/*  given request or not.                                                                 */

dcl (request_type, msg)			char(*);
dcl EXPLAIN_FORCE_MSG                 char(163) int static options(constant) init(
                                        "A no reply aborts the key request.  A yes will perform the request on eligible
volume sets and a message printed listing the ones upon which no action was taken.");


     if msg = "" then
     call command_query_$yes_no(yes_sw, 0, "mvp", EXPLAIN_FORCE_MSG,
         "Some volumes requested cannot be ^a. Do you wish to continue?", request_type);

     else
     call command_query_$yes_no(yes_sw, 0, "mvp", EXPLAIN_FORCE_MSG, "^a Do you wish to continue?", msg);

     return (yes_sw);

end yes_to_query;
%page;
%include access_mode_values;
end manage_volume_pool;
