/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(90-03-14,Kallstrom), approve(90-03-27,MCR8150),
     audit(90-04-03,Zimmerman), install(90-04-11,MR12.4-1003):
     Added an rtrim after CRs and VTs are removed.
  2) change(92-09-14,Vu), approve(92-09-14,MCR8260), audit(92-09-23,Zimmerman),
     install(92-10-06,MR12.5-1024):
     format_document_ looses characters and generates unwanted new paragraph.
                                                   END HISTORY COMMENTS */


format_document_:
	proc (dnamin, enamin, dnamout, enamout, optptr, code);
	
/* subroutine to format text a la compose and runoff.  Used by 
   format_document (fdoc) command.  There are 3 entries:

	format_document_              takes input and output pathnames.
          format_document_$string       takes input and output strings.
          format_document_$switch       takes input pathname and writes to
                                        an i/o switch.

   Command written 79.01.12 by Paul W. Benjamin.
   Subroutine interface added 80.02.14 by PWB.
   Re-Written 81.02.10 by PWB.
   Modified 81.04.20 by PWB to supress compression of leading spaces.
   Modified 81.04.20 by PWB to fix bug where page numbers not centered 
		        properly.
   Modified 81.06.26 by PWB to fix 2 more bugs relating to leading spaces.
   Modified 81.08.14 by PWB to fix bug where extra NL written to end when store
		        is empty.
   Modified 81.10.22 by PWB to avoid storage condition when compressing blanks
		        in long (truncated to 508 chars) strings.
   Modified 81.10.22 by PWB to fix bug where lines beginning with ". " or ".." 
                            interpreted as undent controls (!)
   Modified 82.07.16 by PWB to initially null 3 pointers before checking 
		        version
   Modified 82.07.16 by PWB to remove nonlocal goto on cleanup.
   Modified 82.09.02 by PWB to prevent backing up into left margin when looking
		        looking for a place to break an overlength line.
   Modified 82.10.18 by PWB to add support for dont_compress_sw.
   Modified 83.02.15 by PWB to add support for break_word_sw and 
		        max_line_length_sw.
   Modified 83.02.22 by PWB to stop truncating input lines at 508 chars.
   Modified 83.03.01 by PWB to implement dont_break_indented_lines_sw.
   Modified 83.03.03 by PWB to implement sub_err_sw.
   Modified 83.06.07 by PWB to implement dont_fill_sw.
   Modified 83.06.08 by PWB to implement hyphenation.
   Modified 83.08.30 by PWB to fix bug where words that were larger than the
		        line length didn't get hyphenated.
   Modified 83.11.17 by PWB to have dont_break_indented_lines imply "don't
		        do compression or sentence formatting on indented
		        lines, either."
   Modified 83.11.23 by PWB to add the names: .inl to .in, .unl to .un and to
		        add the .spf control.
   Modified 83.11.28 by PWB for various minor changes in response to audit.
   Modified 83.12.01 by PWB to add .brf and .brp.
   Modified 84.01.24 by PWB to fix bug introduced in MR10.2 that caused callers
		        using version_1 to possibly have random values for
		        the option switches that were new in that release.
   Modified 84.02.08 by PWB to apply defaults for dont_compress, break_word,
		        dont_break_indented_lines, sub_err, dont_fill
		        and hyphenation for version_1 callers.
*/

/* parameters */

dcl  code fixed bin (35) parameter;			/* output system status code */
dcl  dnamin char (*) parameter;			/* input file directory */
dcl  dnamout char (*) parameter;			/* output file directory */
dcl  enamin char (*) parameter;			/* input file name */
dcl  enamout char (*) parameter;			/* output file name */
dcl  instring char (*) parameter;			/* input string for string entry */
dcl  iocbptr ptr parameter;				/* output switch for switch entry */
dcl  optptr ptr parameter;				/* input ptr to options structure */
dcl  outlen fixed bin (21) parameter;			/* output string length for string entry */
dcl  outstring char (*) parameter;			/* output string for string entry */
	
/* entries */

dcl  canonicalize_ entry (ptr, fixed bin(21), ptr, fixed bin(21),
	fixed bin(35));
dcl  convert_status_code_ entry (fixed bin(35), char(8) aligned,
	char(100) aligned);
dcl  cv_dec_check_ entry (char(*), fixed bin(35)) returns(fixed bin(35));
dcl  hyphenate_word_ entry (char(*), fixed bin, fixed bin, fixed bin(35));
dcl  ioa_$rs entry() options(variable);
dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  msf_manager_$close entry (ptr);
dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit(1), ptr, fixed bin(24),
	fixed bin(35));
dcl  msf_manager_$open entry (char(*), char(*), ptr, fixed bin(35));
dcl  sub_err_ entry() options(variable);
dcl  tssi_$finish_file entry (ptr, fixed bin, fixed bin(24),
	bit(36) aligned, ptr, fixed bin(35));
dcl  tssi_$get_file	entry (char(*), char(*), ptr, ptr, ptr, fixed bin(35));

/* external static */

dcl  error_table_$smallarg fixed bin(35) ext static;
dcl  error_table_$fatal_error external static fixed bin (35);
dcl  error_table_$improper_data_format external static fixed bin(35);
dcl  error_table_$noentry fixed bin(35) ext static;
dcl  error_table_$recoverable_error fixed bin(35) ext static;
dcl  error_table_$unimplemented_version	external static fixed bin(35);
dcl  error_table_$zero_length_seg fixed bin(35) ext static;
dcl  fdoc_et_$indent_too_far_left fixed bin(35) ext static;
dcl  fdoc_et_$indent_too_far_right fixed bin(35) ext static;
dcl  fdoc_et_$line_length_too_small fixed bin(35) ext static;
dcl  fdoc_et_$line_too_long fixed bin(35) ext static;
dcl  fdoc_et_$no_hyphenate_word fixed bin(35) ext static;
dcl  fdoc_et_$no_parameter_allowed fixed bin(35) ext static;
dcl  fdoc_et_$no_sign_allowed fixed bin(35) ext static;
dcl  fdoc_et_$nonnumeric_parameter fixed bin(35) ext static;
dcl  fdoc_et_$page_length_lt_13 fixed bin(35) ext static;
dcl  fdoc_et_$page_length_lt_14 fixed bin(35) ext static;
dcl  fdoc_et_$page_width_exceeds_max fixed bin(35) ext static;
dcl  fdoc_et_$text_too_long_for_line fixed bin(35) ext static;
dcl  fdoc_et_$undent_too_far_left fixed bin(35) ext static;
dcl  fdoc_et_$undent_too_far_right fixed bin(35) ext static;
dcl  fdoc_et_$unsupported_control fixed bin(35) ext static;
dcl  iox_$error_output ptr ext static;
dcl  sys_info$max_seg_size fixed bin (19) ext static;
	
/* automatic */

dcl  aclinfoptr ptr;				/* required for tssi_$get_file */
dcl  adj_line_out char (508) varying;			/* temporary output line for adjust_line proc */
dcl  adjust bit (1) aligned;				/* ON = in adjust mode */
dcl  bc fixed bin (24);				/* required for various calls */
dcl  blank_lines_to_be_written fixed bin;		/* user used .spf N and this has value N */
dcl  breaking_words bit (1) aligned;			/* user specified break_word_sw */
dcl  bsndx fixed bin;				/* index of backspace in line */
dcl  bsndx1 fixed bin;				/* used when incrementing bsndx */
dcl  bscnt fixed bin;				/* number of backspaces in line */
dcl  buf char (256) varying;				/* input buffer */
dcl  buf_len21 fixed bin (21);			/* length of buf -- needed for call to canonicalize_ */
dcl  char_cnt fixed bin (21);				/* position of next char to be written */
dcl  component_ends_wo_NL bit;			/* ON = component ends without a newline */
dcl  continued_line bit (1);
dcl  ctl char (5);					/* user specified control */
dcl  ctl_index fixed bin;				/* index of ctl into ctl_list */
dcl  current_syllable_size fixed bin;			/* syllable size as currently adjusted */
dcl  default_syllable_size fixed bin;			/* syllable size as originally specified */
dcl  dont_break_indented_lines bit (1) aligned;		/* user specified dont_break_indented_lines_sw */
dcl  dont_compress bit (1) aligned;			/* user specified dont_compress_sw */
dcl  elen fixed bin (21);				/* length of error message */
dcl  error bit (1) aligned;				/* ON = an error has occurred */
dcl  error_lines char (508);				/* error message */
dcl  errtxt char (100) aligned;			/* output from convert_status_code_ */
dcl  fill bit (1) aligned;				/* ON = fill mode */
dcl  filout bit (1) aligned;				/* ON = main entry or string entry */
dcl  fit bit (1) aligned;				/* used in bs_rtn: can use portion of line as is */
dcl  galley_mode bit (1) aligned;			/* user specified galley_sw */
dcl  h fixed bin;					/* index for do-group */
dcl  hyph_len fixed bin (21);				/* length of based variable hyph_word */
dcl  hyph_point fixed bin;				/* where to hyphenate, output from hyphenate_word_ */
dcl  hyph_ptr ptr;					/* pointer to based variable hyph_word */
dcl  hyph_space fixed bin;				/* how much space in which to hyphenate */
dcl  hyphenating bit (1) aligned;			/* caller has requested hyphenation */
dcl  hyphenation_routine_state fixed bin;		/* = 0 hyphenate_word_ not looked for yet */
						/* = 1 hyphenate_word_ found */
						/* = 2 hyphenate_word_ not found */
dcl  hyphenate_entry entry variable;			/* dummy entry to test for linkage error */
dcl  i fixed bin;					/* index for do-group */
dcl  in_comp_no fixed bin;				/* current input component number */
dcl  ind fixed bin;					/* current indentation value */
dcl  ind_minus_und fixed bin;				/* current calculation of ind - und */
dcl  indptr ptr;					/* ptr to initial indentation string */
dcl  infcbptr ptr;					/* ptr to fcb for input file */
dcl  initial_ind fixed bin;				/* initial indentation value */
dcl  initial_inlen fixed bin (21);			/* length of input component */
dcl  initial_inptr ptr;				/* pointer to beginning of input component */
dcl  initial_line_length fixed bin;			/* user specified line_length */
dcl  initial_outptr ptr;				/* pointer to beginning of output component */
dcl  inlen fixed bin (21);				/* length of remainder of input component */
dcl  inplnctr fixed;				/* current line in input file */
dcl  inptr ptr;					/* current position in input file */
dcl  ioxbuf char (508);				/* output buffer for switch entry */
dcl  j fixed bin;					/* index for do-group */
dcl  k fixed bin;					/* index for do-group */
dcl  last_blank fixed bin;				/* position of blank in line for bs_rtn */
dcl  left bit (1) aligned;				/* ON = start adjusting from left side */
dcl  line_began_with_blank bit (1) aligned;		/* exactly what it says */
dcl  literal_mode bit (1) aligned;			/* user specified literal_sw */
dcl  ll fixed bin;					/* current linelength */
dcl  lnctr fixed bin;				/* output line counter */
dcl  long_line_and_no_blank bit (1) aligned;		/* used in bs_rtn when having problems breaking line */
dcl  maxcnt fixed bin (21);				/* position of first character past end of segment */
dcl  maximum_line_length bit (1) aligned;		/* user specified max_line_length_sw */
dcl  new_adjust bit (1) aligned;			/* new value for adjust */
dcl  new_fill bit (1) aligned;			/* new value for fill */
dcl  new_ind fixed bin;				/* new value for ind */
dcl  new_und fixed bin;				/* new value for und */
dcl  nlindex fixed bin;				/* index of next newline in input component */
dcl  out_comp_no fixed bin;				/* current output component number */
dcl  outline char (508) varying;			/* line to be written out */
dcl  outfcbptr ptr;					/* ptr to fcb for output file */
dcl  outptr ptr;					/* ptr to next character position in output file */
dcl  outstringlen fixed bin (21);			/* length of output string for string entry */
dcl  pads fixed;					/* number of spaces for adjust_line to fill in */
dcl  param char (100) varying;			/* parameter to ctl */
dcl  paramfb fixed bin;				/* fixed bin version of param */
dcl  pgctr fixed bin;				/* last output page number */
dcl  pgctra char (10) varying;			/* ascii representation of pgctr */
dcl  pgno bit;					/* ON = end page with centered page number */
dcl  pl fixed bin;					/* current output page length */
dcl  retval fixed bin (35);				/* meaningless but required by sub_err_ */
dcl  signed bit;					/* ON = param has optional leading sign */
dcl  space_available fixed bin;			/* characters remaining in output string or component */
dcl  space_pos (100) fixed;				/* where adjust_line keeps track of spaces in line */
dcl  spaces fixed;					/* number of spaces in line found by adjust_line */
dcl  spindex fixed bin;				/* index of space in line */
dcl  spindex1 fixed bin;				/* used when incrementing spindex */
dcl  store char (508) varying;			/* characters read but not yet written */
dcl  string_entry bit;				/* ON = entry via format_document_$string */
dcl  subcode fixed bin (35);				/* used in call to sub_err_ */
dcl  tabfill fixed bin;				/* number of spaces needed to replace tab */
dcl  tabndx fixed bin;				/* index of first tab in line */
dcl  temp_code fixed bin (35);			/* temporary code used at cleanup time */
dcl  tlen fixed bin;				/* length of text in write_file */
dcl  trash char (8) aligned;				/* unused output from convert_status_code_ */
dcl  und fixed bin;					/* current undentation value */
dcl  using_sub_err bit (1) aligned;			/* user asked for the usage of sub_err_ */
dcl  vlen fixed bin;				/* virtual length (width) of line */
dcl  vtabndx fixed bin;				/* virtual position of tab in line */

dcl  1 error_info like format_document_error;

/* based */

dcl  hyph_word char (hyph_len) based (hyph_ptr);		/* word passed to hyphenate_word_ */
dcl  indstr char (initial_ind) based (indptr);		/* initial indentation string */
dcl  in_chars (inlen + 2) char (1) based (inptr);		/* infile: one char at a time */
						/* (the +2 is to avoid a subscriptrange) */
dcl  infile char (inlen) based (inptr);			/* remainder of input component */
dcl  initial_in_chars (initial_inlen) char (1) 
	based (initial_inptr);			/* input component */
dcl  out_chars (sys_info$max_seg_size * 4) char (1) 
	based (initial_outptr);			/* output component */
dcl  outfile char ((sys_info$max_seg_size * 4) + 1 - char_cnt) 
	based (outptr);				/* remainder of output component */

dcl  1 buf_structure based (addr (buf)),		/* to look at buf as non-varying */
       2 buf_len fixed bin (35),
       2 buf_chars (256) char (1);
dcl  1 store_structure based (addr (store)),		/* to look at store one character at a time */
       2 store_len fixed bin (35),
       2 store_char (508) char (1);

/* internal static */

dcl  BS char (1) internal static options (constant) init ("");
dcl  BS_or_HT char (2) internal static options (constant) init ("	");
dcl  BS_or_HT_or_SP char (3) internal static options (constant) init ("	 ");
dcl  BUFFER_SIZE fixed internal static options (constant) init (256);
dcl  BUFFER_SIZE_PLUS_ONE fixed internal static options (constant) init (257);
dcl  CR char (1) internal static options (constant) init ("");
dcl  CR_or_VT char (2) internal static options (constant) init ("");
dcl  DEFAULT_LINE_LENGTH fixed internal static options (constant) init (65);
dcl  DEFAULT_PAGE_LENGTH fixed internal static options (constant) init (66);
dcl  FF char (1) internal static options (constant) init ("");
dcl  HT char (1) internal static options (constant) init ("	");
dcl  HT_or_SP char (2) internal static options (constant) init ("	 ");
dcl  HT_or_NL_or_SP char (3) internal static options (constant) init ("	 
");
dcl  HYPHEN char (1) internal static options (constant) init ("-");
dcl  NL char (1) internal static options (constant) init ("
");
dcl  VT char (1) internal static options (constant) init ("");
dcl  ctl_list char (83) internal static options (constant) init 
	("   .un .in .alb.all.fin.fif.pdw.pdl.hy .hyf.hyn.inl.unl.spf.   ..  ... .....brf.brp");
	
	
/* builtins */

dcl (addr, after, before, char, copy, decat, divide, index, length, ltrim, 
	mod, null, reverse, rtrim, search, substr, translate, verify) builtin;

/* condition */

dcl (cleanup, linkage_error) condition;
	

/* include file */

%include format_document_options;

%include format_document_error;

%include sub_err_flags;

/* program */

/* main entry -- format_document_ */

          error = "0"b;
	indptr = null ();
	infcbptr = null ();
	outfcbptr = null ();
          format_document_options_ptr = optptr;
	format_document_options.file_sw = "0"b;
	call check_version_and_set_options;
	if format_document_options.switches.mbz ^= "0"b
	     then do;
	     code = error_table_$improper_data_format;
	     goto done;
	end;
	filout = "1"b;
	string_entry = "0"b;

	on cleanup call done_proc;
	call msf_manager_$open (dnamin, enamin, infcbptr, code);
	if code ^= 0
	     then goto done;
	call msf_manager_$get_ptr (infcbptr, 0, "0"b, inptr, bc, code);
	if inptr = null ()
	     then goto done;
	if bc = 0
	     then do;
	     code = error_table_$zero_length_seg;
	     goto done;
	end;
	inlen = divide (bc, 9, 21, 0);
	call tssi_$get_file (dnamout, enamout, outptr, aclinfoptr, outfcbptr, code);
	if code ^= 0
	     then do;
	     format_document_options.file_sw = "1"b;
	     goto done;
	end;
	out_comp_no = 0;
	initial_outptr = outptr;
	code = 0;
	goto process;

string:	entry (instring, outstring, outlen, optptr, code);

	error = "0"b;
	indptr = null ();
	infcbptr = null ();
	outfcbptr = null ();
          format_document_options_ptr = optptr;
	format_document_options.file_sw = "0"b;
	call check_version_and_set_options;
	if format_document_options.switches.mbz ^= "0"b
	     then do;
	     code = error_table_$improper_data_format;
	     goto done;
	end;
	code = 0;
	filout = "1"b;
	inlen = length (instring);
	inptr = addr (instring);
	outptr, initial_outptr = addr (outstring);
	outstringlen = length (outstring);
	string_entry = "1"b;
	on cleanup call done_proc;
	goto process;

switch:	entry (dnamin, enamin, iocbptr, optptr, code);

	error = "0"b;
	indptr = null ();
	infcbptr = null ();
	outfcbptr = null ();
          format_document_options_ptr = optptr;
	format_document_options.file_sw = "0"b;
	call check_version_and_set_options;
	if format_document_options.switches.mbz ^= "0"b
	     then do;
	     code = error_table_$improper_data_format;
	     goto done;
	end;
	filout = "0"b;
	string_entry = "0"b;

	on cleanup call done_proc;
	call msf_manager_$open (dnamin, enamin, infcbptr, code);
	if code ^= 0
	     then goto done;
	call msf_manager_$get_ptr (infcbptr, 0, "0"b, inptr, bc, code);
	if inptr = null ()
	     then goto done;
	if bc = 0
	     then do;
	     code = error_table_$zero_length_seg;
	     goto done;
	end;
	inlen = divide (bc, 9, 21, 0);
	code = 0;

process:
	char_cnt = 1;
	component_ends_wo_NL = "0"b;
          continued_line = "0"b;
	current_syllable_size = default_syllable_size;
	hyphenation_routine_state = 0;
	in_comp_no = 0;
	ind = 0;
	ind_minus_und = 0;
	inplnctr = 0;
	left = "1"b;
	lnctr = 0;
	maxcnt = (sys_info$max_seg_size * 4) + 1;
	pgctr = 0;
	pl = DEFAULT_PAGE_LENGTH;
	store = "";
	und = 0;
	if hyphenating
	     then call look_for_hyphenation_routine;
          allocate indstr;
	indstr = copy (" ", initial_ind);
process_one_component:
	initial_inlen = inlen;
	initial_inptr = inptr;
	do while (inlen > 0);			/* while there is more input */
	     nlindex = index (infile, NL);
	     inplnctr = inplnctr + 1;
               continued_line = "0"b;
	     if nlindex = 0
		then nlindex = inlen + 1;
	     if nlindex > BUFFER_SIZE_PLUS_ONE		/* line longer than internal buffer */
		then do;				/* find someplace to break it */
                    continued_line = "1"b;
		if length (rtrim (substr (infile, 1, nlindex - 1), HT_or_SP)) <= BUFFER_SIZE
                    /* line merely had a lot of trailing blanks */
		     then buf = rtrim (substr (infile, 1, nlindex - 1), HT_or_SP);
		else do;
		     spindex = BUFFER_SIZE_PLUS_ONE - index (reverse (substr (infile, 1, BUFFER_SIZE_PLUS_ONE)), " ");
		     if spindex ^= BUFFER_SIZE_PLUS_ONE /* and break it there */
			then do;
			buf = rtrim (substr (infile, 1, spindex), HT_or_SP);
			nlindex = spindex + 1;
		     end;
		     else if breaking_words
			then do;
			buf = substr (infile, 1, ll);
			nlindex = ll;
		     end;
		     else do;			/* no place to break it */
			if store_len ^= 0		/* write out store if not empty */
			     then do;
			     store = copy (" ", ind_minus_und) || store;
			     call write (store);
			     store = "";
			end;
			call err_reporter (fdoc_et_$line_too_long); /* report as (recoverable) error */
			call write ((substr (infile, 1, nlindex - 1)));	/* and write it as is */
			goto continue;
		     end;
		end;
	     end;
	     else buf = rtrim (substr (infile, 1, nlindex - 1), HT_or_SP); /* get the next line into buf */

               if ^literal_mode & buf_len > 0 
                    & ^continued_line                       /* literal_sw says ignore controls */
		then if buf_chars (1) = "."
		then do;
		buf = translate (buf, " ", HT);	/* quasi- */
		do while (index (buf, "  ") ^= 0);	/* canonicalize */
		     buf = before (buf, "  ") || " " || after (buf, "  ");
		end;
		ctl = before (buf, " ");
		if index (ctl, " ") = 0		/* ctl is 1 char longer than the longest ctl */
		     then do;			/* so it better end in a space or two */
		     call err_reporter (fdoc_et_$unsupported_control);
		     goto continue;
		end;
		code = 0;
		param = (after (buf, " "));
		if length (param) ^= 0
		     then do;
		     signed = (verify (substr (param, 1, 1), "+-") = 0);
		     paramfb = cv_dec_check_ ((param), code);
		end;
		ctl_index = divide (index (ctl_list, substr (ctl, 1, 4)), 4, 17, 0);
		if ctl_index = 0
		     then do;
		     call err_reporter (fdoc_et_$unsupported_control);
		     goto continue;
		end;
		goto process_ctl (ctl_index);

process_ctl (1):					/* undent */
process_ctl (13):	if code ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$nonnumeric_parameter);
		     goto continue;
		end;
		if length (param) = 0
		     then new_und = ind;
		else do;
		     new_und = paramfb;
		     if new_und > ind
			then do;
			call err_reporter (fdoc_et_$undent_too_far_left);
			new_und = ind;
		     end;
		     else if (ll -ind) + new_und < 0
			then do;
			call err_reporter (fdoc_et_$undent_too_far_right);
			new_und = ind - ll;
		     end;
		end;
		goto process_break;

process_ctl (2):					/* indent */
process_ctl (12):	if code ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$nonnumeric_parameter);
		     goto continue;
		end;
		if length (param) = 0
		     then new_ind = 0;
		else do;
		     if signed 
			then do;
			new_ind = paramfb + ind;
			if new_ind < 0
			     then do;
			     call err_reporter (fdoc_et_$indent_too_far_left);
			     new_ind = 0;
			end;
		     end;
		     else new_ind = paramfb;
		     if new_ind > ll
			then do;
			call err_reporter (fdoc_et_$indent_too_far_right);
			new_ind = ll;
		     end;
		end;
		goto process_break;

process_ctl (3):					/* allign both */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		new_adjust = "1"b;
		goto process_break;

process_ctl (4):					/* allign left */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		new_adjust = "0"b;
		goto process_break;
process_ctl (5):					/* fill on */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		new_fill = "1"b;
		goto process_break;
process_ctl (6):					/* fill off */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		new_fill = "0"b;
		goto process_break;

process_ctl (7):					/* page width */
		if code ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$nonnumeric_parameter);
		     goto continue;
		end;
		if length (param) = 0
		     then ll = DEFAULT_LINE_LENGTH;
		else if signed
		     then ll = ll + paramfb;
		else ll = paramfb;
		if maximum_line_length
		     & ll > initial_line_length
		     then do;
		     ll = initial_line_length;
		     call err_reporter (fdoc_et_$page_width_exceeds_max);
		end;
		goto continue;
process_ctl (8):					/* page length */
		if code ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$nonnumeric_parameter);
		     goto continue;
		end;
		if length (param) = 0
		     then pl = DEFAULT_PAGE_LENGTH;
		else if signed
		     then pl = pl + paramfb;
		else pl = paramfb;
		if ^pgno & pl < 13
		     then do;
		     pl = 13;
		     call err_reporter (fdoc_et_$page_length_lt_13);
		end;
		else if pgno & pl < 14
		     then do;
	               pl = 14;
		     call err_reporter (fdoc_et_$page_length_lt_14);
		end;
		goto continue;

process_ctl (9):					/* hyphenate default */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		hyphenating = format_document_options.hyphenation_sw;
		current_syllable_size = default_syllable_size;
		if hyphenating
		     then if hyphenation_routine_state = 0
		     then call look_for_hyphenation_routine;
		else if hyphenation_routine_state = 2
		     then hyphenating = "0"b;
		goto continue;


process_ctl (10):					/* hyphenate off */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		hyphenating = "0"b;
		goto continue;


process_ctl (11):					/* hyphenate on */

		if code ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$nonnumeric_parameter);
		     goto continue;
		end;

		if length (param) ^= 0
		     then if signed
		     then do;
		     call err_reporter (fdoc_et_$no_sign_allowed);
		     goto continue;
		end;
		
		hyphenating = "1"b;
		if hyphenation_routine_state = 0
		     then call look_for_hyphenation_routine;
		else if hyphenation_routine_state = 2
		     then hyphenating = "0"b;
		if length (param) ^= 0
		     then current_syllable_size = paramfb;
		else current_syllable_size = default_syllable_size;
		goto continue;

process_ctl (14):					/* space-format */
		if code ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$nonnumeric_parameter);
		     goto continue;
		end;
		if length (param) ^= 0
		     then if signed
		     then do;
		     call err_reporter (fdoc_et_$no_sign_allowed);
		     goto continue;
		end;
		if length (param) = 0
		     then blank_lines_to_be_written = 1;
		else blank_lines_to_be_written = paramfb;    
		goto process_break;			
			     

process_ctl (15):					/* . */
process_ctl (16):					/* .. */
process_ctl (17):					/* ... */
process_ctl (18):					/* .... */
		goto process_text;			/* these are text */		

process_ctl (19):					/* break-format */
process_ctl (20):					/* break-page */
		if length (param) ^= 0
		     then do;
		     code = 0;
		     call err_reporter (fdoc_et_$no_parameter_allowed);
		     goto continue;
		end;
		goto process_break;			/* which is currently the next statement */

process_break:		
/* We have hit a control break, must write out anything left */
		if store_len ^= 0 
		     then do;
		     store = copy (" ", ind_minus_und) || store;     /* indent */
		     call write (store);		/* write it */
		     store = "";			/* clear out save area */
		end;
		
/* NOW apply specified control */
		if ctl_index = 2			/* .in  */
		     | ctl_index = 12		/* .inl */
		     then ind = new_ind;
		else if ctl_index = 1		/* .un  */
		     | ctl_index = 13		/* .unl */
		     then und = new_und;
		else if ctl_index = 3		/* .alb */
		     | ctl_index = 4		/* .all */
		     then adjust = new_adjust;
		else if ctl_index = 5		/* .fin */
		     | ctl_index = 6		/* .fif */
		     then fill = new_fill;
		else if ctl_index = 14		/* .spf */
		     then do i = 1 to blank_lines_to_be_written;
		     call write ("");
		end;
		else if ctl_index = 20		/* .brp */
		     then if ^galley_mode
		     then do;
		     if lnctr ^= 0			/* maybe the break caused a new page already */
			then do;
			if pgno 
			     then do i = lnctr to pl - 8;
			     call write ("");		
			end;
			else if filout
			     then do;
			     lnctr = pl - 7;	
			     call write ("");
			end;
			else /* ^pgno & ^filout */ 
			     do i = lnctr to pl - 7;
			     call write ("");
			end;
		     end;				
		end;
				
		ind_minus_und = ind - und;
		goto continue;			/* go process another line */
	     end;

process_text:  
	     if search (buf, CR_or_VT) ^= 0 
		then do;				/* discard VT or CR */
		do while (index (buf, VT) ^= 0);
		     buf = decat (buf, VT, "101"b);
		end;
		do while (index (buf, CR) ^= 0);
		     buf = decat (buf, CR, "101"b);
		end;
		buf = rtrim (buf, HT_or_SP);            /* rtrim buf in case there are now blanks at the end */
	     end;

	     if search (buf, BS_or_HT) ^= 0 
		then do;				/* Input may not be canonical */
		bsndx = index (buf, BS);		/* Or may need tabs expanded */
		if bsndx = 0 
		     then goto tab_check;
		else if bsndx = 1
		     then goto call_canon;		/* BS in pos 1 is uncanonical */
		do while ("1"b);
		     if bsndx = length (buf)
			then goto call_canon;	/* As is BS in last pos */
		     if search (buf_chars (bsndx - 1), BS_or_HT_or_SP) ^= 0
			then goto call_canon;
		     if search (buf_chars (bsndx + 1), BS_or_HT_or_SP) ^= 0
			then goto call_canon;
		     bsndx1 = bsndx + index (substr (buf, bsndx + 1), BS);
		     if bsndx = bsndx1
			then goto tab_check;	/* No more BSs */
		     bsndx = bsndx1;
		end;

tab_check:	tabndx = index (buf, HT);
		do while (tabndx ^= 0);		/* While there are tabs */
		     vtabndx = tabndx;
		     do i = 2 to tabndx;		/* Determine virtual position of tab in line */
			if buf_chars (i) = BS	/* BS means line is virtually */
			     then do;		/* 2 less characters wide than seems */
			     vtabndx = vtabndx - 2;
			     i = i + 1;		/* Next char is not BS */
			end;
		     end;
		     tabfill = 11 - mod (vtabndx, 10);	/* See how many spaces to fill in */
		     if tabfill = 11 
			then tabfill = 1;	
		     buf = substr (buf, 1, tabndx - 1)	/* Fill 'em in */
			|| copy (" ", tabfill)
			|| substr (buf, tabndx + 1);
		     tabndx = index (buf, HT);
		end;
		goto dont_canon;

call_canon:	call canonicalize_ (addr (buf_chars (1)), (buf_len), addr (buf_chars (1)), buf_len21, code);
		if code ^= 0 
		     then goto done;
		buf_len = buf_len21;
dont_canon:    end;

	     line_began_with_blank = "0"b;

	     if ^fill 
		then do;				/* No fill, just write it */
		store = buf;
		store = copy (" ", ind_minus_und) || store;
		call write (store);
		store = "";
		goto check_length;
	     end;

	     else if length (buf) = 0 
		then do;				/* null line? */
		if store_len ^= 0 
		     then do;			/* if there is something left */
		     store = copy (" ", ind_minus_und) || store;     /* then indent */
		     call write (store);		/* and write it */
		end;
		call write (buf);			/* now write out null line */
		store = "";			/* clear out save area */
		goto check_length;
	     end;
	     else if buf_chars (1) = " " 
		then do;				/* leading blank cause break */
		line_began_with_blank = "1"b;
		if store_len ^= 0 
		     then do;			/* if save area not empty */
		     store = copy (" ", ind_minus_und) || store;     /* indent it */
		     call write (store);		/* and write it */
		end;
		store = buf;			/* move buffer to save area */
	     end;
	     else do;
		if component_ends_wo_NL		/* special handling */
		     then do;			/* when spanning msf */
		     component_ends_wo_NL = "0"b;	/* components */
		     store = store || buf;
		end;
		else do;				/* concatenate buffer to end of save area */
		     if store_len > 0
                              then store = store || " ";
		     store = store || buf;
		end;
	     end;

/* The following code enforces the convention of 2 spaces after certain 
   punctuation.  What appears to be a serious flirtation with stringrange is
   actually a firm knowledge that store has been rtrimmed of spaces. */

	     if ^dont_compress
		then do;
		if dont_break_indented_lines & line_began_with_blank
		     then if nlindex >= inlen		/* if next line blank or this is eof */
		     then goto check_length;		/* don't do any compression */
		else if search (in_chars (nlindex + 1), HT_or_NL_or_SP) ^= 0
		     then goto check_length;
		spindex = index (store, " ");		
		if spindex = 1			/* Don't mess with leading spaces */
		     then do;			/* Find first space after non-blank char */
		     spindex = verify (store, " ");
		     spindex1 = index (substr (store, spindex), " ");
		     if spindex1 = 0
			then spindex = 0;
		     else spindex = spindex + spindex1 - 1;
		end;
		if spindex ^= 0			
		     then do while (index (substr (store, spindex), " ") ^= 0);
		     if verify (store_char (spindex - 1), ":.!?)") = 0
			then do;
			if store_char (spindex - 1) = ")"
			     then do;
			     if spindex < 3
				then goto compress_blanks;
			     if verify (store_char (spindex - 2), "!?.") ^= 0
				then goto compress_blanks;
			end;
			if store_char (spindex + 1) ^= " " /* should be 2 spaces */
			     then store = substr (store, 1, spindex) || " " || substr (store, spindex + 1);
			else do while (store_char (spindex + 2) = " ");	/* and only 2 */
			     store = substr (store, 1, spindex + 1) || substr (store, spindex + 3);
			end;
			spindex = spindex + 2;	/* look at next char past spaces */
		     end;
		     else do;				
compress_blanks:		do while (store_char (spindex + 1) = " ");
			     store = substr (store, 1, spindex) || substr (store, spindex + 2);
			end;
			spindex = spindex + 1;	/* skip over space */
		     end;
		     spindex1 = index (substr (store, spindex), " ");
		     if spindex1 = 0
			then goto check_length;
		     else spindex = spindex + spindex1 - 1;
		end;
	     end;
	     	     	     	     
check_length:  if ll - ind_minus_und < 1		/* negative effective linelength */
		then do;
		call err_reporter (fdoc_et_$line_length_too_small);
		code = error_table_$fatal_error;
		goto done;
	     end;

	     do while (length (rtrim (store)) + ind_minus_und > ll - 1);	/* if line long enough, deal with it */

/* check for backspaces */
/* if there are backspaces in the line we got problems, and therefore branch to a special routine */
		if index (store, BS) < ll - ind_minus_und + 2 & index (store, BS) ^= 0 
		     then goto bs_rtn;
		store = copy (" ", ind_minus_und) || store;	/* indent */
		if line_began_with_blank & dont_break_indented_lines
		     then do;			/* called by Gary Palter */
		     if nlindex < inlen		/* don't break the line if is followed by a blank line */
						/* or an indented line or the end of the file */
			then if search (in_chars (nlindex + 1), HT_or_NL_or_SP) = 0
			then goto process_normally;
		     call write (store);
		     store = "";
		     goto continue;
		end;

process_normally:	if store_len = ll 
		     then do;			/* line is exactly the right size */
		     outline = rtrim (store);		/* put it in the output buffer */
		     store = "";			/* clear save area */
		     call write (outline);		/* write it out */
		end;
		else if store_char (ll + 1) = " " 
		     then do;			/* blank at ll + 1 */
		     outline = rtrim (substr (store, 1, ll)); /* put first ll chars in out buffer */
		     store = ltrim (substr (store, ll + 2)); /* let save area have the rest */
                         if outline ^= "" then do;
                              if adjust & length (outline) < ll	/* needs adjusted */
			then call adjust_line (outline, ll);
		          call write (outline);		/* and write */
                         end;
		end;
		else do;

/* find first blank counting left from ll */
		     spindex = ll - index (reverse (substr (store, 1, ll)), " ");
		     if spindex ^= ll &
			(spindex - ind) > 0		/* don't wanna go into the left margin */
			then do;
			if hyphenating
			     then if ll - spindex > current_syllable_size + 1
			     then do;
			     hyph_ptr = addr (store_char (spindex + 2));
			     hyph_len = search (substr (store, spindex + 2), " ") - 1;
			     if hyph_len = -1		/* no spaces */
				then hyph_len = store_len - spindex - 1;
			     hyph_space = ll - spindex - 1;
			     call hyphenate_word_ (hyph_word, hyph_space, hyph_point, code);
			     if code ^= 0 
				then goto done;
			     if hyph_point > current_syllable_size - 1
				then do;
				outline = rtrim (substr (store, 1, spindex + hyph_point + 1));
				outline = outline || HYPHEN;
				store = ltrim (substr (store, spindex + hyph_point + 2));
				goto adjust_check;
			     end;
			end;
			outline = rtrim (substr (store, 1, spindex)); /* save off chars up to that blank */
			store = ltrim (substr (store, spindex + 2)); /* put rest in save area */
adjust_check:		if adjust 
			     then call adjust_line (outline, ll); /* call space filling rtn */
		     end;

						/* no blanks from 1 to ll */
		     else do;

			if hyphenating		/* try hyphenating first */
			     then do;
			     hyph_ptr = addr (store_char (1));
			     hyph_len = store_len;
			     hyph_space = ll;
			     call hyphenate_word_ (hyph_word, hyph_space, hyph_point, code);
			     if code ^= 0
				then goto done;
			     if hyph_point >= current_syllable_size
				then do;
				outline = substr (store, 1, hyph_point);
				outline = outline || HYPHEN;
				store = substr (store, hyph_point + 1);
				goto write_here;
			     end;
			end;
			if breaking_words
			     then do;		/* either cut it off in mid-word */
			     outline = substr (store, 1, ll);
			     store = substr (store, ll + 1);
			end;
			else do;
			     if index (substr (store, ind + 1), " ") ^= 0
						/* or cut it off at first blank past ll */
			     then do;
			          outline = substr (store, 1, index (store, " ") - 1);
				store = ltrim (substr (store, index (store, " ") + 1));
			     end;
			     else do;		/* no blanks anywhere in line */
				outline = store;
				store = "";
			     end;
			     call err_reporter (fdoc_et_$text_too_long_for_line);	/* too much data for output line */
			end;
		     end;
write_here:	     call write (outline);		/* and finally write */
		end;
still_in_write_loop_with_more_to_process:		/* come back here from bs_rtn */
	     end;
	     goto continue;				/* branch around backspace code */

bs_rtn:

/* At this point we think we have more than ll characters, but we know we have
   backspaces.  We have to find out how many print positions we actually have
   and if it's still more than ll, we have to locate where to break the line
   apart.  vlen is the actual number of print positions. */
	     
	     store = copy (" ", ind_minus_und) || store;/* indent */
	     last_blank = 0;
	     vlen = 0;
	     bscnt = 0;
	     long_line_and_no_blank = "0"b;
	     fit = "0"b;
	     do k = 1 to store_len while (^fit);
		if store_char (k) = BS
		     then do;
		     k = k + 1;
		     bscnt = bscnt + 1;
		end;
		else vlen = vlen + 1;
		if store_char (k) = " "
		     then do;
		     if long_line_and_no_blank 
			then do;
			outline = substr (store, 1, k - 1);
			store = ltrim (substr (store, k));
			call err_reporter (fdoc_et_$text_too_long_for_line);
			call write (outline);
			goto still_in_write_loop_with_more_to_process;
		     end;
		     last_blank = k;
		     if vlen > ll
			then do;
			outline = substr (store, 1, k - 1);
			store = ltrim (substr (store, k));
			call err_reporter (fdoc_et_$text_too_long_for_line);
			call write (outline);
			goto still_in_write_loop_with_more_to_process;
		     end;
		end;
		if vlen = ll
		     then do;
		     if k < store_len
			then if store_char (k + 1) = BS
			then k = k + 2;
		     if k = store_len
			then fit = "1"b;
		     if k < store_len
			then if store_char (k + 1) = " "
			then fit = "1"b;
		     else if last_blank ^= 0
			then do;
			do h = last_blank + 1 to k - 1;
			     if store_char (h) = BS
				then bscnt = bscnt - 1;
			end;
			k = store_len;
		     end;
		     else if breaking_words
			then do;
			outline = substr (store, 1, k);
			store = substr (store, k + 1);
			call write (outline);
			goto still_in_write_loop_with_more_to_process;
		     end;
		     else long_line_and_no_blank = "1"b;
		end;
	     end;

	     if long_line_and_no_blank
		then do;
		outline = store;
		store = "";
		call err_reporter (fdoc_et_$text_too_long_for_line);
		call write (outline);
		goto continue;
	     end;
	     else if vlen < ll			/* print position count < ll */
		then do;
		store = substr (store, (ind + 1) - und);/* undo indentation */
		goto continue;			/* get another line */
	     end;
	     else if fit
		then do;
		outline = substr (store, 1, k - 1);
		if k - 1 ^= store_len
		     then store = ltrim (substr (store, k));
		else store = "";
		call write (outline);
	     end;
	     else do;
		if line_began_with_blank & dont_break_indented_lines
		     then do;			/* see the comments that proceed */
		     if nlindex < inlen		/* the label "process_normally" */
			then if search (in_chars (nlindex + 1), HT_or_NL_or_SP) = 0
			then goto process_backspaces_normally;
		     call write (store);
		     store = "";
		     goto continue;
		end;
process_backspaces_normally:
		outline = rtrim (substr (store, 1, last_blank - 1)); /* move printable portion to buffer */
		store = ltrim (substr (store, last_blank + 1)); /* make rest contents of store */
		if adjust 
		     then call adjust_line (outline, ll + bscnt * 2);  /* call space fill rtn */
		call write (outline);		/* and write */
	     end;
	     goto still_in_write_loop_with_more_to_process;

continue:
	     if nlindex ^= 0			/* if there is more data */
		then do;
		inptr = addr (in_chars (nlindex + 1));	/* move input ptr past next NL */
		inlen = inlen - nlindex;		/* change length to reflect what is left */
                    if continued_line
                           then do;
                           spindex = verify (infile, " ");
                           inptr = addr (in_chars (spindex));
                           inlen = inlen - spindex + 1;
                    end;
	     end;
	     else goto no_more_data;			/* end of component, maybe end of file */
	end;

/* Almost done, now clean up. */

no_more_data:
	if string_entry				/* input string can't be MSF */
	     then goto no_more_components;
	in_comp_no = in_comp_no + 1;			/* try next component */
	call msf_manager_$get_ptr (infcbptr, in_comp_no, "0"b, inptr, bc, code);
	if inptr = null
	     then if code = error_table_$noentry	/* we have processed last component */
	     then do;
		code = 0;
		goto no_more_components;
	     end;
	else goto done;				/* msf_manager_ crapped out */
	component_ends_wo_NL = (initial_in_chars (initial_inlen) ^= NL);
	inlen = divide (bc, 9, 21, 0);
	goto process_one_component;			/* here we go again */
	
no_more_components:
	if store_len ^= 0
	     then do;
	     store = copy (" ", ind_minus_und) || store;/* indent */
	     call write (store);			/* write out last line */
	end;
	if lnctr ^= 0 & ^galley_mode			/* if a partial */
	     then do;				/* page has been written */
	     if pgno 
		then do;
		do k = 1 to ((pl - 5) - lnctr);
		     if filout 
			then call write_file (NL);	/* add blank line */
		     else do;
			ioxbuf = NL;
			call iox_$put_chars (iocbptr, addr (ioxbuf), 1, code);
			if code ^= 0
			     then goto done;
		     end;
		end;
		pgctr = pgctr + 1;			/* bump page counter */
		pgctra = ltrim (char (pgctr));
						/* and write page number */
		if filout 
		     then call write_file (indstr 
		     || copy (" ", divide (ll - length (pgctra), 2, 17, 0))
		     || pgctra || FF);
		else do;
		     ioxbuf = indstr 
			|| copy (" ", divide (ll - length (pgctra), 2, 17, 0))
			|| pgctra || copy (NL, 5);
		     call iox_$put_chars (iocbptr, addr (ioxbuf), length (rtrim (ioxbuf)), code);
		     if code ^= 0
			then goto done;
		end;
	     end;
	     else do;
		if filout & char_cnt ^= 1
		     then do;
		     outptr = addr (out_chars (char_cnt - 1)); /* back up outptr 1 position */
		     char_cnt = char_cnt - 1;
		     call write_file (FF);		/* replace trailing NL with FF */
		end;
		else if ^filout
		     then do k = 1 to (pl - lnctr);
		     ioxbuf = NL;
		     call iox_$put_chars (iocbptr, addr (ioxbuf), 1, code);
		     if code ^= 0
			then goto done;
		end;
	     end;
	end;
	if string_entry 
	     then outlen = char_cnt - 1;

check_version_and_set_options:
	proc;
		
	if format_document_options.version_number = format_document_version_1
	     then do;				/* assign defaults */
	     dont_compress, breaking_words, maximum_line_length, 
		dont_break_indented_lines, using_sub_err, hyphenating = "0"b;
	     fill = "1"b;
	     default_syllable_size = 2;		/* old version has no syllable size, assign one */
	end;
	else if format_document_options.version_number = format_document_version_2
	     then do;				/* this guy knows what he is doing */
		dont_compress = format_document_options.switches.dont_compress_sw;
		breaking_words = format_document_options.switches.break_word_sw;
		maximum_line_length = format_document_options.switches.max_line_length_sw;
		dont_break_indented_lines = format_document_options.switches.dont_break_indented_lines_sw;
		using_sub_err = format_document_options.switches.sub_err_sw;
		fill = ^format_document_options.switches.dont_fill_sw;
		hyphenating = format_document_options.switches.hyphenation_sw;
		default_syllable_size = format_document_options.syllable_size;
	     end;
	else do;
	     code = error_table_$unimplemented_version;
	     goto done;
	end;

	adjust = format_document_options.switches.adj_sw;
	galley_mode = format_document_options.switches.galley_sw;
	initial_ind = format_document_options.indentation;
	initial_line_length = format_document_options.line_length;
	literal_mode = format_document_options.literal_sw;
	ll = format_document_options.line_length;
	pgno = format_document_options.switches.pgno_sw;

     end check_version_and_set_options;

write:	proc (line);
dcl  line char (*) varying parameter;

	und = 0;					/* get rid of undent, it only applies to one line */
	ind_minus_und = ind;
	if lnctr = 0 & ^galley_mode
	     then do;				/* BEGIN PAGE */
	     if filout 
		then call write_file (copy (NL, 3));
	     else do;
		ioxbuf = copy (NL, 6);
		call iox_$put_chars (iocbptr, addr (ioxbuf), 6, code);
		if code ^= 0
		     then goto done;
	     end;
	     lnctr = 6;
	end;

	if filout 				/* WRITE LINE */
	     then call write_file (indstr||line||NL);     /* add a newline */
	else do;
	     ioxbuf = indstr||line||NL;
	     call iox_$put_chars (iocbptr, addr (ioxbuf), length (rtrim (ioxbuf)), code);
	     if code ^= 0
		then goto done;
	end;

	if ^galley_mode				/* END PAGE */
	     then do;
	     lnctr = lnctr + 1;			/* bump line counter */
	     if pgno
		then if lnctr = (pl - 7)
		then do;
		pgctr = pgctr + 1;   		/* bump page counter */
		lnctr = 0;			/* roll the line counter */
		pgctra = ltrim (char (pgctr));


		if filout				/* write page number */
		     then call write_file (copy (NL, 2) || indstr 
		     || copy (" ", divide (ll - length (pgctra), 2, 17, 0))
		     || pgctra || FF);
		else do;
		     ioxbuf = copy (NL, 2) || indstr
			|| copy (" ", divide (ll - length (pgctra), 2, 17, 0))
			|| pgctra || copy (NL, 5);
		     call iox_$put_chars (iocbptr, addr (ioxbuf), length (rtrim (ioxbuf)), code);
		     if code ^= 0
			then goto done;
		end;
	     end;
	     else;
	     else if lnctr = (pl - 6)
		then do;
		lnctr = 0;
		if filout & char_cnt ^= 1
		     then out_chars (char_cnt - 1) = FF; /* overwrite LF with FF */
		else if ^filout
		     then do;
		     ioxbuf = copy (NL, 6);
		     call iox_$put_chars (iocbptr, addr (ioxbuf), 6, code);
		     if code ^= 0
			then goto done;
		end;
	     end;
	end;
     end write;

write_file:
     proc (text);
dcl  text char (*) parameter;

     tlen = length (text);
     char_cnt = char_cnt + tlen;

     if string_entry
	then do;
	if (char_cnt - 1) > outstringlen		/* can't write past end of string */
	     then do;
	     space_available = outstringlen + tlen + 1 - char_cnt;	/* write what you can */
	     substr (outfile, 1, space_available) = substr (text, 1, space_available);
	     outlen = outstringlen;
	     code = error_table_$smallarg;		/* and go boom */
	     goto done;
	end;
	else substr (outfile, 1, tlen) = text;		/* normal write */
     end;

     else if char_cnt > maxcnt			/* can't write past end of component */
	then do;
	space_available = tlen + maxcnt - char_cnt;	/* write what you can */
	substr (outfile, 1, space_available) = substr (text, 1, space_available);
	out_comp_no = out_comp_no + 1;		/* get another component */
	call msf_manager_$get_ptr (outfcbptr, out_comp_no, "1"b, outptr, bc, code);
	if outptr = null ()				/* msf_manager_ burped */
	     then do;
	     format_document_options.file_sw = "1"b;
	     goto done;
	end;
	initial_outptr = outptr;			/* write rest to next component */
	substr (outfile, 1, tlen - space_available) = substr (text, space_available + 1);
	char_cnt = (tlen - space_available) + 1;
     end;
     else substr (outfile, 1, tlen) = text;		/* normal write */

     outptr = addr (out_chars (char_cnt));		/* move output ptr to next available position */
end write_file;

adjust_line: proc (adj_line, linelength);

/* routine to fill spaces into line that is less than ll long */
dcl  adj_line char (508) varying parameter;
dcl  linelength fixed parameter;

	     spaces = 0;
	     adj_line_out = adj_line;
	     pads = linelength - length (adj_line);	/* how many spaces to fill */
	     do i = verify (adj_line, " ") to length (adj_line);
		spindex = index (substr (adj_line, i), " ");
		if spindex = 0
		     then i = length (adj_line);
		else do;
		     spaces = spaces + 1;		/* add to count of spaces in line */
		     i = i + spindex - 1;
		     space_pos (spaces) = i;		/* mark position of space */
		end;
	     end;

/* fill spaces in adjacent to existing spaces starting from left on first line
   (starting again on left if necessary) and then reverse the procedure to 
   start from the right the next time 
*/
	     if spaces ^= 0 
		then do;
		if left 
		     then do i = 1 to pads;		/* adjust from left */
		     j = mod (i, spaces);
		     if j = 0 
			then j = spaces;
		     adj_line_out = substr (adj_line_out, 1, space_pos (j) + j - 1)||" "||substr (adj_line_out, space_pos (j) + j);
		     space_pos (j) = space_pos (j) + j;
		     left = "0"b;
		end;
		else do;				/* adjust from right */
		     k = spaces;
		     do i = pads to 1 by -1;
			if k = 0 
			     then k = spaces;
			adj_line_out = substr (adj_line_out, 1, space_pos (k))||substr (adj_line_out, space_pos (k));
			do j = k to spaces;
			     space_pos (j) = space_pos (j) + 1;
			end;
			left = "1"b;
			k = k - 1;
		     end;
		end;
	     end;
	     adj_line = adj_line_out;
	end adjust_line;

look_for_hyphenation_routine: 
	     proc;

	     on linkage_error 
		begin;
		hyphenating = "0"b;	
		hyphenation_routine_state = 2;	/* not found */
		call err_reporter (fdoc_et_$no_hyphenate_word);
		goto reversion;
	     end;
	     hyphenate_entry = hyphenate_word_;
	     hyphenation_routine_state = 1;		/* found */
reversion:
	     revert linkage_error;
	end look_for_hyphenation_routine;

err_reporter:
	     proc (errcode);
dcl errcode fixed bin (35) parameter;

	     error = "1"b;
	     errtxt = "";

	     if format_document_options.error_sw
		then do;
		call convert_status_code_ (errcode, trash, errtxt);
		call ioa_$rs ("line ^d^-^a^[^s^;^/^a^]",
		     error_lines,
		     elen,
		     inplnctr,
		     errtxt,
		     ((^filout) & 
			((errcode = fdoc_et_$text_too_long_for_line)) | 
			(errcode = fdoc_et_$line_too_long) | 
			(errcode = fdoc_et_$no_hyphenate_word)),
		     buf);

		call iox_$put_chars (iox_$error_output, addr (error_lines), elen, code);
		if code ^= 0
		     then goto done;
	     end;
	     
	     if using_sub_err
		then do;
		if errtxt ^= ""
		     then call convert_status_code_ (errcode, trash, errtxt);
		if errcode = fdoc_et_$line_length_too_small
		     then subcode = error_table_$fatal_error;
		else subcode = error_table_$recoverable_error;
		error_info.version_number = format_document_error_version_1;
		error_info.error_code = errcode;
		error_info.line_number = inplnctr;
		if errcode = fdoc_et_$no_hyphenate_word
		     then error_info.text_line = "";
		else error_info.text_line = buf;
		call sub_err_ (subcode, 
		     "format_document_", 
		     (ACTION_CAN_RESTART | ACTION_DEFAULT_RESTART | ACTION_QUIET_RESTART),
		     addr (error_info), 
		     retval,
		     errtxt);
	     end;

	end err_reporter;

done_proc:     
	proc;					/* clean up time */

	if indptr ^= null ()
	     then free indstr;
	if code = 0 & error
	     then code = error_table_$recoverable_error;
	if infcbptr ^= null ()
	     then call msf_manager_$close (infcbptr);
	if outfcbptr ^= null ()
	     then do;
	     call tssi_$finish_file (outfcbptr, out_comp_no, ((char_cnt - 1) * 9), "101"b, aclinfoptr, temp_code);
	     if code = 0				/* don't want to clobber code so use a temporary */
		then code = temp_code;		/* and then assign it if code was zero */
	end;
     end done_proc;
     
done:
	call done_proc;
	
     end format_document_;
