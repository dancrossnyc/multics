/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */





/****^  HISTORY COMMENTS:
  1) change(87-02-17,TLNguyen), approve(87-02-17,MCR7624),
     audit(87-02-27,Lippard), install(87-03-20,MR12.1-1006):
     - Change "copy_dir_" to always set its returned code parameter before
       returning.
     - Change "copy_dir_" to properly delete the target dir when "-replace"
       is given.  It currently calls "hcs_$del_dir_tree" rather than calling
       "delete_$path".  Therefore it fails to delete Data Managment files.
     - Change "copy_dir_" to properly copy ACLs when -acl is specified.  It
       currently copies only ACLs on 2nd-Nth segments of a directory.
  2) change(88-08-30,TLNguyen), approve(88-08-30,MCR7949),
     audit(88-09-09,Parisek), install(88-11-1,MR12.2-1202):	
     - Change the copy_dir_ to do the containment check before deleting
       the contents of the target which indicated by the replace flag.
     - Change copy_dir_ so that -replace will work as documented for
       the copy_dir command.
                                                   END HISTORY COMMENTS */


/* format: style2,idind30,indcomtxt */
copy_dir_:
     procedure (whoami, source_dir, source_ename, target_dir, target_ename, pcopy_dir_options, acode);

/****

      * Most of this code is from the original copy_dir command.

      * Status:
      0) Original by LLS in 1978
      1) Modified: 11/80 by GAT to make the subroutines
      2) Gutted: 6/30/83 by Jay Pattin for extended objects
      3) 831002 BIM for extended object cleanup
      4) Modified: 12/84 by Keith Loepere to set dir_quota at append.
      5)  Modified:  2/15/85 M. Sharpe to give up if can't create target */

/**** * Entries */
	dcl     command_query_	        entry options (variable);
	dcl     copy_		        entry (ptr);
	dcl     com_err_		        entry options (variable);
	dcl     copy_acl_		        entry (char (*), char (*), char (*), char (*), bit (1), fixed bin (35));
	dcl     copy_iacl_		        entry (char (*), char (*), char (*), char (*), bit (1), fixed bin (35));
	dcl     move_names_		        entry (char (*), char (*), char (*), char (*), char (*), bit (1),
				        fixed bin (35));
	dcl     copy_names_		        entry (char (*), char (*), char (*), char (*), char (*), bit (1),
				        fixed bin (35));

	dcl     continue_to_signal_	        entry (fixed bin (35));
	dcl     expand_pathname_	        entry (char (*), char (*), char (*), fixed bin (35));
	dcl     find_condition_info_	        entry (ptr, ptr, fixed bin (35));
	dcl     get_group_id_$tag_star        entry returns (char (32));
	dcl     get_max_authorization_        entry () returns (bit (72) aligned);
	dcl     get_ring_		        entry () returns (fixed bin (3));
	dcl     get_system_free_area_	        entry returns (ptr);
	dcl     hcs_$get_dir_ring_brackets    entry (char (*), char (*), (2) fixed bin (3), fixed bin (35));
	dcl     hcs_$get_access_class	        entry (char (*), char (*), bit (72) aligned, fixed bin (35));
	dcl     hcs_$append_link	        entry (char (*), char (*), char (*), fixed bin (35));
	dcl     hcs_$create_branch_	        entry (char (*), char (*), ptr, fixed bin (35));
	dcl     hcs_$get_safety_sw	        entry (char (*), char (*), bit (1), fixed bin (35));
	dcl     hcs_$get_uid_file	        entry (char (*), char (*), bit (36) aligned, fixed bin (35));
	dcl     hcs_$get_link_target	        entry (char (*), char (*), char (*), char (*), fixed bin (35));
	dcl     hcs_$set_safety_sw	        entry (char (*), char (*), bit (1), fixed bin (35));
	dcl     hcs_$star_		        entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr,
				        fixed bin (35));
	dcl     hcs_$status_	        entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
	dcl     hcs_$status_minf	        entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
				        fixed bin (35));
	dcl     cu_$arg_list_ptr	        entry (ptr);
	dcl     cu_$arg_count	        entry (fixed bin, fixed bin (35));
	dcl     cu_$arg_ptr		        entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
	dcl     ioa_$general_rs	        entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1) aligned,
				        bit (1) aligned);
	dcl     ioa_		        entry options (variable);
	dcl     ioa_$rsnnl		        entry options (variable);
	dcl     nd_handler_		        entry (char (*), char (*), char (*), fixed bin (35));
	dcl     nd_handler_$switches	        entry (char (*), char (*), char (*), bit (36) aligned, fixed bin (35));
	dcl     delete_$path	        entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
	dcl     fs_util_$get_type	        entry (character (*), character (*), character (*), fixed binary (35));
	dcl     fs_util_$suffix_info	        entry (char (*), char (*), ptr, fixed bin (35));
	dcl     pathname_		        entry (char (*), char (*)) returns (char (168));
	dcl     sub_err_		        entry () options (variable);

/* Constants */

	dcl     no_translation	        fixed bin (35) internal static options (constant) init (1);

/*  Conditions  */

	dcl     (cleanup, sub_error_)	        condition;

/*  Based  */

	dcl     1 comp		        based (cptr),
		2 name		        char (32) varying,
		2 next		        ptr;

	dcl     area		        area based (area_ptr);

/*  Automatic  */

	dcl     acode		        fixed bin (35);
	dcl     parent_access	        bit (1);
	dcl     (source_dir, source_ename, target_dir, target_ename)
				        char (*);	/* from where to where                            */
	dcl     whoami		        char (*);	/* name of entry into code ("copy_dir" or "move_dir"). */
	dcl     (tt, type)		        fixed bin (2);
						/*  type of entry returned by hcs_$status_minf,
						   0 = link, 1 = seg, 2 = dir. */
	dcl     ln		        fixed bin (21);
						/* length of a char string returned by ioa_$rsnnl. */
	dcl     (code, code1)	        fixed bin (35);
						/* the returned error code from a system call. */
	dcl     bc		        fixed bin (24);
						/* bit count returned by hcs_$status_minf. */
	dcl     answer		        char (3) varying;
						/* answer from user via command_query_ */
	dcl     dir_rings		        (2) fixed bin (3);
						/* ring validation for a directory. */
	dcl     (
	        acl,				/* acl on copy is same as original */
	        all_entries,			/* all entries are copied */
	        all_names,				/* all names on an entry are copied */
	        brief,				/* comments are suppressed */
	        chase,				/* copy targets of links */
	        force,				/* user is not queried about existing target */
	        raw,				/* don't use object_type_ */
	        replace,				/* truncate target_dir before copying */
	        translate_links,			/* translate links */
	        update,				/* name duplications are deleted or unlinked without asking the user */
	        clink,				/* copy links. */
	        cseg,				/* copy segments. */
	        cmsf,				/* copy multisegment files. */
	        cnnl,				/* copy non-null links. */
	        cdir,				/* copy directories. */
	        errors,				/* one or more errors occurred while processing */
	        ersw,				/* used in calls to copy_ utilities to indicate which
						   entry an error occurred on. */
	        source_contains_target,		/* if "1"b, the source directory contains the target directory. */
	        target_contains_source,		/* If "1"b, the target_directory contains the source directory. */
	        safety_sw,				/* used in setting the safety_switch of a branch. */
	        same_dir,				/* se_name and te_name are in the same directory. */
	        move
	        )			        bit (1);	/* delete source_dir after copying */
	dcl     fs_util_type	        char (32);
	dcl     (entry_index, lcomp_count, scomp_count, tcomp_count, ii)
				        fixed bin;
	dcl     (dir1_uid, dir2_uid, uid)     bit (36) aligned;
	dcl     (sd_name, td_name, temp_target_dir)
                                                char (168);

	dcl     (se_name, le, userid, te_name)
				        char (32);
	dcl     (
	        area_ptr,				/* ptr on which area is based. */
	        cb_ptr,				/* ptr on which create_branch_info is based. */
	        lcomp_root,				/* Path info for link_target(lcomp). */
	        scomp_root,				/* Path info for source_dir. */
	        tcomp_root,				/* Path info for target_dir. */
	        cptr				/* Ptr on which comp is based. */
	        )			        ptr;

/*  External  */

	dcl     (
	        error_table_$action_not_performed,
	        error_table_$inconsistent,
                  error_table_$bad_ring_brackets,
	        error_table_$incorrect_access,
	        error_table_$no_dir,
	        error_table_$no_s_permission,
	        error_table_$not_seg_type,
	        error_table_$segnamedup,
	        error_table_$namedup,
	        error_table_$noentry,
	        error_table_$nomatch,
	        error_table_$notadir,
	        error_table_$sameseg,
	        error_table_$unimplemented_version
	        )			        fixed bin (35) external;

/*  Builtins  */

	dcl     (addr, index, null, reverse, rtrim, ptr, string, substr, sum)
				        builtin;


/**** ** Copy all the parameters into local variables. In the case of
      * the structure, this is unneccessary, but is convienient since this
      * did not used to be a seperate routine from the command. */

	cb_ptr = null ();
	acode = 0; /* must be initialized */

	on condition (cleanup)
	     begin;
		if cb_ptr ^= null ()
		then free cb_ptr -> create_branch_info in (area);
	     end;

	if copy_dir_options.version ^= copy_dir_options_version_0
	then do;
		call sub_err_ (error_table_$unimplemented_version, ACTION_CANT_RESTART, null (), (0),
		     "copy_dir_ has been invoked with the wrong version of the copy_dir_options structure.
The version provided was ^d, the expected version is ^d.", copy_dir_options.version, copy_dir_options_version_0);
		return;
	     end;

	userid = get_group_id_$tag_star ();
	area_ptr = get_system_free_area_ ();
	move = copy_dir_options.delete;
	if ^(copy_dir_options.link | copy_dir_options.dir | copy_dir_options.seg | copy_dir_options.msf
	     | copy_dir_options.nnlk)
	then do;
		call complain (error_table_$action_not_performed, "^/No entries specified to be ^[copied^;moved^].",
		     (^copy_dir_options.delete));
		return;
	     end;
	if (copy_dir_options.link & copy_dir_options.dir & copy_dir_options.seg & copy_dir_options.msf)
	then do;
		all_entries = "1"b;
		clink, cseg, cdir, cmsf, cnnl = "0"b;
	     end;
	else do;
		all_entries = "0"b;
		clink = copy_dir_options.link;
		cseg = copy_dir_options.seg;
		cdir = copy_dir_options.dir;
		cmsf = copy_dir_options.msf;
		cnnl = copy_dir_options.nnlk;
	     end;
	parent_access = copy_dir_options.parent_ac_sw;
	brief = copy_dir_options.brief;
	force = copy_dir_options.force;
	replace = copy_dir_options.replace;
	update = copy_dir_options.update;
	acl = copy_dir_options.acl;
	primary = copy_dir_options.primary;
	translate_links = copy_dir_options.link_translation;
	chase = copy_dir_options.chase;
	raw = copy_dir_options.raw;
	if (replace & update)
	then do;
		call complain (error_table_$inconsistent, "^/Options replace and update specified.");
		return;
	     end;

	if primary
	then all_names = "0"b;
	else all_names = "1"b;


	allocate create_branch_info in (area) set (cb_ptr);
	cb_ptr -> create_branch_info.version = create_branch_version_2;
	cb_ptr -> create_branch_info.quota = 0;
	cb_ptr -> create_branch_info.dir_quota = 0;
	cb_ptr -> create_branch_info.mode = "111"b;
	cb_ptr -> create_branch_info.switches.dir_sw = "1"b;
	cb_ptr -> create_branch_info.switches.copy_sw = "0"b;
	cb_ptr -> create_branch_info.switches.chase_sw = "1"b;
	cb_ptr -> create_branch_info.switches.parent_ac_sw = parent_access;
	cb_ptr -> create_branch_info.priv_upgrade_sw = "0"b;
	cb_ptr -> create_branch_info.userid = userid;
	cb_ptr -> create_branch_info.bitcnt = 0;

	sd_name = source_dir;			/* copy the name args to the "old" variables      */
	se_name = source_ename;			/* and proceed with existing code                 */
	td_name = target_dir;
	te_name = target_ename;

	if sd_name = td_name
	then same_dir = "1"b;
	else same_dir = (get_uid (sd_name) = get_uid (td_name));

/*  check that arg 1 is a directory. */
	call hcs_$status_minf (sd_name, se_name, 0, type, bc, code);
	if code ^= 0 & code ^= error_table_$no_s_permission
	then do;
BAD_STAT:
		call complain (code, "^/Unable to get the status of ^a^[>^]^a.", sd_name, sd_name ^= ">", se_name);
		return;
	     end;

	if type ^= Directory | bc ^= 0
	then do;
NOT_A_DIR:
		call complain (error_table_$notadir,
		     "^/The source pathname must be a directory. ^a^[>^]^a is not a directory", sd_name,
		     sd_name ^= ">", se_name);
		return;
	     end;

	if ^raw
	then do;					/* check if it is an extended object */
		call fs_util_$get_type (sd_name, se_name, fs_util_type, code);
		if fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
		then goto NOT_A_DIR;
	     end;

	call hcs_$get_uid_file (sd_name, se_name, uid, code);
	if code ^= 0
	then goto BAD_STAT;

	dir1_uid = uid;

/* if the target doesn't exist, create it. If it does exist,
   but is not a directory, complain and get next entry. */

	call hcs_$status_minf (td_name, te_name, 0, type, bc, code);
	if code ^= 0
	then if code = error_table_$noentry
	     then do;
		     if ^brief
		     then call ioa_ ("^a: Creating target directory ^a.", whoami, pathname_ (td_name, te_name));

		     call create_directory;
		     if code ^= 0
		     then goto finish;
		end;
	     else do;
BAD_TSTAT:
		     call complain (code, "^/Unable to get the status of the target directory ^a^[>^]^a.", td_name,
			td_name ^= ">", te_name);
		     return;
		end;
	else if type ^= Directory | bc ^= 0
	then do;
T_NOT_DIR:
		call nd_handler_ (whoami, td_name, te_name, code);
		if code ^= 0
		then do;
			acode = code;
			return;
		     end;

		call create_directory;
		if code ^= 0
		then goto finish;
	     end;
	else do;					/*  target_dir exists */
		if ^raw
		then do;
			call fs_util_$get_type (td_name, te_name, fs_util_type, code);
			if fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
			then goto T_NOT_DIR;
		     end;

		call hcs_$get_uid_file (td_name, te_name, dir2_uid, code);
		if code ^= 0
		then go to BAD_TSTAT;

		if dir1_uid = dir2_uid
		then do;
			call complain (error_table_$action_not_performed,
			     "Attempt to specify the same directory as both old and new");
			return;
		     end;
		if ^(force | replace)
		then do;
			query_info.version = 1;
			query_info.yes_or_no_sw = "1"b;
			query_info.suppress_name_sw = "0"b;
			query_info.status_code = 0;
			query_info.query_code = 0;
			call command_query_ (addr (query_info), answer, whoami,
			     "^a^[>^]^a  already exists.  Do you wish to continue?", td_name, td_name ^= ">",
			     te_name);
			if query_info.status_code ^= 0
			then do;
				call complain (query_info.status_code, "^/Unable to use answer from query.");
				return;
			     end;
			if answer = "no"
			then goto finish;
		     end;

                                                          /* perform the containment check */
		call contains (source_contains_target, target_contains_source, code);
		if code ^= 0
		then do;
			call complain (code,
			     "^/Unable to check containment of source and target directories, ^a^[>^]^a and ^a^[>^]^a respectively.",
			     sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name);
			return;
		     end;

		if source_contains_target             /* the source directory contains the target directory */
		then do;
			call complain (error_table_$action_not_performed,
			     "^/The source directory cannot contain the target directory;^/^a contains ^a.",
			     pathname_ (sd_name, se_name), pathname_ (td_name, te_name));
			return;
		     end;

		if target_contains_source            /* the target directory contains the source directory */
		then do;
			call complain (error_table_$action_not_performed,
			     "^/The target directory cannot contain the source directory;^/^a contains ^a.",
			     pathname_ (td_name, te_name), pathname_ (sd_name, se_name));
			return;
		     end;

		if replace                             /* want to delete the contents of the specified existent target */
		then do;
		          string (delete_options) = ""b;
			delete_options.force = force;
			delete_options.question,
			delete_options.directory,
			delete_options.segment,
			delete_options.link = "1"b;
			delete_options.chase = chase;
			delete_options.library = "0"b;
			delete_options.raw = raw;

			temp_target_dir = pathname_ (td_name, te_name);

			star_entry_count = 0;        /* initialize variable declared in star_structures.incl.pl1 */
			star_entry_ptr = null;       /* initialize variable declared in star_structures.incl.pl1 */
			star_names_ptr = null;       /* initialize variabel declared in start_structures.incl.pl1 */

                                                           /* get information on all entries in the specified existent target */
			call hcs_$star_ (temp_target_dir, "**", star_ALL_ENTRIES, area_ptr, star_entry_count, star_entry_ptr, star_names_ptr, code);
			if code ^= 0 then do;
                                                            /* if the existent target is empty (star_entry_count = 0), then keep going */
			     if code ^= error_table_$nomatch then do;
				call complain (code, "Unable to return information on all entries in target directory ^a.", temp_target_dir);
				return;
			     end;
			end;

                                                            /* delete all entries in the specified existent target */
			do entry_index = 1 to star_entry_count;
			     call delete_$path (temp_target_dir, star_names (entry_index), string (delete_options), whoami, code);
			     if code ^= 0 & code ^= error_table_$bad_ring_brackets
			     then do;
				call complain (code, "^/Unable to delete the entryname ^a in the directory ^a.",
				     rtrim (star_names (entry_index)), rtrim (temp_target_dir));
				return;
			     end;
			end;                          /* make the specified existent target directory become empty */
		     end;				/* want to delete the contents of a specified existent directory */
	     end;                                         /* case the specified target directory exists */

	errors = "0"b;				/* start fresh */

	call hcs_$get_safety_sw (sd_name, se_name, safety_sw, code);
	if code ^= 0
	then call complain (code, "^/Unable to get the safety switch for the source directory ^a^[>^]^a.", sd_name,
		sd_name ^= ">", se_name);
	else do;
		call hcs_$set_safety_sw (td_name, te_name, safety_sw, code);
		if code ^= 0
		then call complain (code, "^/Unable to set the safety switch on the target directory ^a^[>^]^a.",
			td_name, td_name ^= ">", te_name);
	     end;

	call copy_iacl_ (sd_name, se_name, td_name, te_name, ersw, code);
	if code ^= 0
	then call complain (code,
		"^/Unable to copy the initial ACL from the source directory ^a^[>^]^a to the target directory ^a^[>^]^a.
Error occurred on the ^[source^;target^] directory.",
		sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name, ^ersw);

	cpo.version = COPY_OPTIONS_VERSION_1;
	cpo.caller_name = "copy_dir_";

/* Now call the recursive procedure which does the actual copying */

	call work (sd_name, se_name, td_name, te_name, acl, move);

	if acl | move
	then do;
		call copy_acl_ (sd_name, se_name, td_name, te_name, ersw, code);
		if code ^= 0
		then call complain (code, "^/Unable to copy the ACL from  ^a^[>^]^a to  ^a^[>^]^a.
Error occurred on the ^[source^;target^].", sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name, ^ersw);

	     end;
	if all_names
	then do;
		if same_dir
		then call move_names_ (sd_name, se_name, td_name, te_name, whoami, ersw, code);

		else call copy_names_ (sd_name, se_name, td_name, te_name, whoami, ersw, code);
		if code ^= 0
		then if code ^= error_table_$segnamedup
		     then if code ^= error_table_$namedup
			then call complain (code, "^/Unable to ^[move^;copy^] names of ^a^[>^]^a to  ^a^[>^]^a.
Error occurred on the ^[source^;target^].", same_dir, sd_name, (sd_name ^= ">"), se_name, td_name, td_name ^= ">",
				te_name, ^ersw);
	     end;
	if move
	then if errors
	     then do;
		     if ^brief
		     then call com_err_ (error_table_$action_not_performed, whoami,
			     "Source directory not deleted due to error in copying.");
		     if acode = 0
		     then acode = error_table_$action_not_performed;
						/* tell caller something!                         */
		end;
	     else do;
		     string (delete_options) = ""b;
		     delete_options.question, delete_options.directory = "1"b;
		     delete_options.raw = raw;
		     call delete_$path (sd_name, se_name, string (delete_options), whoami, code);
		     if code ^= 0
		     then call complain (code, "^/Unable to delete ^a^[>^]^a.", sd_name, (sd_name ^= ">"), se_name);
		end;
finish:
	if cb_ptr ^= null ()
	then free cb_ptr -> create_branch_info in (area);
	return;
%page;
/* The directory tree is recursively followed, copying the links,
   files, and directories along the way. If a copy fails for any
   reason on a particular entry,processing continues with the next one
   and nothing is done with the failed entry. */

work:
     proc (d1, e1, d2, e2, acl, move) recursive;
	dcl     i			        fixed bin;
	dcl     (from_dir, to_dir)	        char (168);
	dcl     name		        char (32);
	dcl     names		        (500) char (32) aligned based (nptr);
						/* info from hcs_$star_ */
	dcl     nptr		        ptr;
	dcl     1 branches		        (entry_count) aligned based (sptr),
						/* info from hcs_$star_ */
	        ( 2 type		        bit (2),
		2 nnames		        fixed bin (15),
		2 nindex		        fixed bin (17)
		)		        unaligned;
	dcl     (d1, d2, e1, e2)	        char (*);
          dcl     (acl, move)                   bit (1);    /* save these flags for later reference in the "file" procedure. */
	dcl     sptr		        ptr;
	dcl     entry_count		        fixed bin;

/* construct directory pathnames */
	call ioa_$rsnnl ("^a^[>^]^a", from_dir, ln, d1, (d1 ^= ">"), e1);
	call ioa_$rsnnl ("^a^[>^]^a", to_dir, ln, d2, (d2 ^= ">"), e2);

/* set up cleanup handler */
	on condition (cleanup)
	     begin;
		if sptr ^= null
		then free branches in (area);
		if nptr ^= null
		then free nptr -> names in (area);
	     end;

/* get all of the entries in from_dir */

	call hcs_$star_ (from_dir, "**", 3, area_ptr, entry_count, sptr, nptr, code);
	if code ^= 0
	then if code = error_table_$nomatch
	     then goto finish_work;
	     else do;

		     call complain (code, "^/Unable to get the entries in the directory ^a.", from_dir);
		     return;
		end;

/* call appropriate entry copier */

	do i = 1 to entry_count;
	     name = names (branches (i).nindex);
	     if branches (i).type = "00"b
	     then do;
		     if (all_entries | clink | cnnl)
		     then call link;
		end;
	     else if branches (i).type = "01"b
	     then do;
FILE:
		     if (all_entries | cseg)
		     then call file (from_dir, name, to_dir, name, acl, move);
		end;
	     else if branches (i).type = "10"b
	     then do;
		     if ^raw
		     then do;
			     call fs_util_$get_type (from_dir, name, fs_util_type, code);
			     if code ^= error_table_$not_seg_type & substr (fs_util_type, 1, 1) ^= "-"
			     then goto FILE;
			end;

		     call hcs_$status_minf (from_dir, name, 1, tt, bc, code);
		     if code ^= 0
		     then do;
			     call complain (code, "^/Unable to get status on the file  ^a^[>^]^a.", from_dir,
				from_dir ^= ">", name);
			     return;
			end;
		     if bc ^= 0
		     then do;
			     if (all_entries | cmsf)
			     then call file (from_dir, name, to_dir, name, acl, move);
			end;
		     else do;
			     if (all_entries | cdir)
			     then call directory;
			end;
		end;
	     else do;
		     call complain (0, "Illegal branch type ""11""b ^a^[>^]^a", from_dir, from_dir ^= ">", name);
		     return;			/* tell caller something                          */
		end;
	end;

finish_work:
	if sptr ^= null
	then free sptr -> branches in (area);
	if nptr ^= null
	then free nptr -> names in (area);

	return;					/* Effective end of work. */

link:
     proc;
	dcl     pptr		        ptr;
	dcl     1 links		        aligned like status_link;
	dcl     pathname		        char (links.pathname_length) aligned based (pptr);
	dcl     (link_target, new_target, ld) char (168);

	call hcs_$status_ (from_dir, name, 0, addr (links), area_ptr, code);
	if code ^= 0
	then do;
		call complain (code, "^/Unable to get detailed status on the link ^a^[>^]^a.", from_dir,
		     from_dir ^= ">", name);
		return;
	     end;

	pptr = ptr (area_ptr, links.names_relp);
	free pptr -> names in (area);

	pptr = ptr (area_ptr, links.pathname_relp);

	link_target = pathname;

	call expand_pathname_ (link_target, ld, le, code);
	if code ^= 0
	then do;
		call complain (code, "^/Unable to expand the target pathname ^a for the link ^a^[>^]^a.", link_target,
		     from_dir, from_dir ^= ">", name);
		return;
	     end;
	if translate_links
	then do;
		call contains_target (ld, le, new_target, code);
		if code = 0
		then link_target = new_target;
		else if code = no_translation
		then code = 0;
		else do;
			call complain (code,
			     "^/Unable to analyze  ^a^[>^]^a for containment in the target directory.", ld,
			     ld ^= ">", le);
			return;
		     end;
	     end;
	free pptr -> pathname in (area);

	if chase
	then do;
		call hcs_$get_link_target (ld, le, ld, le, code);
		if code ^= 0
		then if code = error_table_$noentry | code = error_table_$no_dir
		     then do;
			     if clink
			     then goto append_link;
			     return;
			end;
		     else do;
			     call complain (code,
				"^/Unable to get the link target of  ^a^[>^]^a, with target pathname of  ^a^[>^]^a.",
				from_dir, (from_dir ^= ">"), name, ld, ld ^= ">", le);
			     return;
			end;
		call hcs_$status_minf (ld, le, 0, tt, bc, code);
		if code ^= 0
		then if code = error_table_$noentry | code = error_table_$no_dir
		     then do;
			     if clink
			     then goto append_link;
			     return;
			end;
		     else do;
			     call complain (code,
				"^/Unable to get status on  ^a^[>^]^a, the link target of  ^a^[>^]^a.", ld,
				ld ^= ">", le, from_dir, from_dir ^= ">", name);
			     return;
			end;

		if ^raw
		then do;
			call fs_util_$get_type (ld, le, fs_util_type, code);
			if code ^= error_table_$not_seg_type & substr (fs_util_type, 1, 1) ^= "-"
						/* if it is an extended object, or if it dont exist */
			then tt = 1;
		     end;

		if (tt = 1 & (cseg | all_entries)) | (tt = 2 & bc ^= 0 & (cmsf | all_entries))
		then call file (ld, le, to_dir, name, acl, move);
		else if (tt = 2 & bc = 0 & (cdir | all_entries))
		then goto append_link;
		else return;
	     end;
	else do;
		if cnnl
		then do;
			call hcs_$status_minf (ld, le, 1, tt, bc, code);
			if code ^= 0
			then if code = error_table_$noentry | code = error_table_$no_dir
			     then return;
			     else do;
				     call complain (code,
					"^/Unable to get status on ^a^[>^]^a, the link target of  ^a^[>^]^a.",
					ld, ld ^= ">", le, from_dir, from_dir ^= ">", name);
				     return;
				end;
		     end;
append_link:
		call hcs_$append_link (to_dir, name, link_target, code);
		if code ^= 0
		then if code = error_table_$namedup
		     then do;
			     string (nd_handler_options) = ""b;
			     nd_handler_options.raw = raw;
			     nd_handler_options.delete_force = update;
			     call nd_handler_$switches (whoami, to_dir, name, string (nd_handler_options), code1);
			     if code1 = 0
			     then goto append_link;
			     else if code1 = error_table_$action_not_performed
			     then return;
			     else do;
				     acode = code1;
				     errors = "1"b;
				     return;
				end;
			end;
		     else do;
			     call complain (code,
				"^/Unable to copy  from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
				from_dir, (from_dir ^= ">"), name, to_dir, (to_dir ^= ">"), name, ^ersw);
			     return;
			end;

		call copy_names_ (from_dir, name, to_dir, name, whoami, ersw, code);
		if code ^= 0 & code ^= error_table_$segnamedup & code ^= error_table_$namedup
		then do;
			call complain (code, "^/Unable to copy the names from ^a^[>^]^a to ^a^[>^]^a.
Error occurred on the ^[source^;target^] entry.", from_dir, from_dir ^= ">", name, to_dir, to_dir ^= ">", name, ^ersw);
			return;
		     end;
	     end;
     end link;
%page;
file:
     proc (from_dir, from_en, to_dir, to_en, acl, move);

	dcl     (from_dir, from_en, to_dir, to_en)
				        char (*);
          dcl     (acl, move)                   bit (1); /* They are originally received from the "copy_dir_" procedure. */

	dcl     1 local_suffix_info	        aligned like suffix_info;

	cpo.source_dir = from_dir;
	cpo.source_name = from_en;
	cpo.target_dir = to_dir;
	cpo.target_name = to_en;

	string (cpo.flags) = ""b;
	cpo.raw = raw;
	cpo.no_name_dup = update;

	string (cpo.copy_items) = ""b;
	cpo.names = all_names;
	cpo.acl = acl | move;

	local_suffix_info.version = SUFFIX_INFO_VERSION_1;

	call fs_util_$suffix_info (from_dir, from_en, addr (local_suffix_info), code);
	if code ^= 0
	then do;
		call complain (code, "^/Unable to get the suffix_info for ^a.", pathname_ (from_dir, from_en));
		return;
	     end;

	if tt = 1
	then do;
		cpo.max_length = local_suffix_info.copy_flags.max_length;
		cpo.dumper_switches = local_suffix_info.copy_flags.dumper_switches;
	     end;
	cpo.safety_switch = local_suffix_info.copy_flags.safety_switch;

	on sub_error_ call sub_err_handler ();

	call copy_ (addr (cpo));

PUNT_FILE:
	return;
%page;
sub_err_handler:
     proc ();

	ci.version = condition_info_version_1;
	call find_condition_info_ (null (), addr (ci), (0));
	sub_error_info_ptr = ci.info_ptr;

	if sub_error_info.name ^= "copy_" | copy_error_info.copy_options_ptr ^= addr (cpo)
	then do;
		call continue_to_signal_ ((0));
		return;
	     end;

	code = sub_error_info.status_code;

	call complain (code,
	     "^[^a^/^-^;^s^]^[Copying^;Unable to copy^] from ^a to ^a. Error occurred on the ^[target^;source^].",
	     sub_error_info.info_string ^= "", sub_error_info.info_string, sub_error_info.default_restart,
	     pathname_ (from_dir, from_en), pathname_ (to_dir, to_en), copy_error_info.target_err_switch);

	if sub_error_info.cant_restart
	then goto PUNT_FILE;

	return;
     end sub_err_handler;

     end file;
%page;
directory:
     proc;

	call hcs_$status_minf (to_dir, name, 1, tt, bc, code);
	if code ^= 0
	then do;
		tt = 0;
		call hcs_$get_dir_ring_brackets (from_dir, name, dir_rings, code);
		if code ^= 0
		then do;
			call complain (code, "^/Unable to get the directory ring brackets of ^a^[>^]^a.", from_dir,
			     (from_dir ^= ">"), name);
			return;
		     end;
	     end;
	else if tt ^= 2
	then do;
		call nd_handler_ (whoami, to_dir, name, code);
		if code ^= 0
		then if code = error_table_$action_not_performed
		     then return;
		     else do;
			     errors = "1"b;
			     acode = code;
			     return;
			end;

		call hcs_$get_dir_ring_brackets (from_dir, name, dir_rings, code);
		if code ^= 0
		then do;
			call complain (code, "^/Unable to get the directory ring brackets of ^a^[>^]^a.", from_dir,
			     (from_dir ^= ">"), name);
			return;
		     end;

	     end;
	if tt ^= 2
	then do;
		cb_ptr -> create_branch_info.rings (1) = dir_rings (1);
		cb_ptr -> create_branch_info.rings (2) = dir_rings (2);
		cb_ptr -> create_branch_info.rings (3) = 7;
		call hcs_$get_access_class (from_dir, name, cb_ptr -> create_branch_info.access_class, code);
		if code ^= 0
		then do;
			call complain (code, "^/Unable to get the access class of  ^a^[>^]^a.", from_dir,
			     (from_dir ^= ">"), name);
			return;
		     end;

		cb_ptr -> create_branch_info.switches.dir_sw = "1"b;
		cb_ptr -> create_branch_info.switches.copy_sw = "0"b;
		cb_ptr -> create_branch_info.switches.chase_sw = "1"b;
		cb_ptr -> create_branch_info.mode = "111"b;
		call hcs_$create_branch_ (to_dir, name, cb_ptr, code);
		if code ^= 0
		then do;
			call complain (code, "^/Unable to create the directory branch ^a^[>^]^a.", to_dir,
			     (to_dir ^= ">"), name);
			return;
		     end;

	     end;

	if all_names
	then do;
		call copy_names_ (from_dir, name, to_dir, name, whoami, ersw, code);
		if code ^= 0 & code ^= error_table_$segnamedup & code ^= error_table_$namedup
		then call complain (code,
			"^/Unable to copy the names from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
			from_dir, (from_dir ^= ">"), name, to_dir, (to_dir ^= ">"), name, ^ersw);
	     end;

	call hcs_$get_safety_sw (from_dir, name, safety_sw, code);
	if code ^= 0
	then call complain (code, "^/Unable to get the safety_switch of ^a^[>^]^a.", from_dir, (from_dir ^= ">"), name);
	else do;
		call hcs_$set_safety_sw (to_dir, name, safety_sw, code);
		if code ^= 0
		then call complain (code, "^/Unable to set the safety switch of ^a^[>^]^a.", to_dir, (to_dir ^= ">"),
			name);
	     end;


	call copy_iacl_ (from_dir, name, to_dir, name, ersw, code);
	if code ^= 0
	then call complain (code,
		"^/Unable to copy the initial ACL from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
		from_dir, from_dir ^= ">", name, to_dir, to_dir ^= ">", name, ^ersw);

	call work (from_dir, name, to_dir, name, acl, move);

	if acl | move
	then do;
		call copy_acl_ (from_dir, name, to_dir, name, ersw, code);
		if code ^= 0
		then call complain (code,
			"^/Unable to copy ACL from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
			from_dir, from_dir ^= ">", name, to_dir, to_dir ^= ">", name, ^ersw);
	     end;
     end directory;
     end work;

create_directory:
     proc;
          code = 0;

	call hcs_$get_dir_ring_brackets (sd_name, se_name, dir_rings, code);
	if code ^= 0
	then do;
		if code = error_table_$no_s_permission | code = error_table_$incorrect_access
		then do;
			cb_ptr -> create_branch_info.rings (1) = get_ring_ ();
			cb_ptr -> create_branch_info.rings (2) = cb_ptr -> create_branch_info.rings (1);
			cb_ptr -> create_branch_info.rings (3) = 7;
		     end;
		else do;
			call complain (code, "^/Unable to get the directory ring brackets of ^a^[>^]^a.", sd_name,
			     sd_name ^= ">", se_name);
			return;
		     end;
	     end;
	else do;
		cb_ptr -> create_branch_info.rings (1) = dir_rings (1);
		cb_ptr -> create_branch_info.rings (2) = dir_rings (2);
		cb_ptr -> create_branch_info.rings (3) = 7;
	     end;
	call hcs_$get_access_class (sd_name, se_name, cb_ptr -> create_branch_info.access_class, code);
	if code ^= 0
	then do;
		if code = error_table_$no_s_permission | code = error_table_$incorrect_access
		then cb_ptr -> create_branch_info.access_class = get_max_authorization_ ();
		else do;
			call complain (code, "^/Unable to get access class for ^a^[>^]^a.", sd_name, sd_name ^= ">",
			     se_name);
			return;
		     end;
	     end;
	call hcs_$create_branch_ (td_name, te_name, cb_ptr, code);
	if code ^= 0
	then do;
		call complain (code, "^/Unable to create the branch ^a^[>^]^a.", td_name, td_name ^= ">", te_name);
		return;
	     end;
	call hcs_$get_uid_file (td_name, te_name, dir2_uid, code);
	if code ^= 0
	then do;
		call complain (code, "^/Unable to get uid of the target directory  ^a^[>^]^a.", td_name,
		     td_name ^= ">", te_name);
		return;
	     end;

	call contains (source_contains_target, target_contains_source, code);
	if code ^= 0
	then do;
		call complain (code, "^/Unable to check containment of source and target directories,
^a^[>^]^a and ^a^[>^]^a respectively.", sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name);
		return;
	     end;

	if source_contains_target             /* the source directory contains the target directory */
	then do;
	     call complain (error_table_$action_not_performed,
		"^/The source directory cannot contain the target directory;^/^a contains ^a.", pathname_ (sd_name, se_name),
		pathname_ (td_name, te_name));
                                                /* indicate that error has been found */
	     code = error_table_$action_not_performed;

	     return;
	     end;

	if target_contains_source            /* the target directory contains the source directory */
	then do;
	     call complain (error_table_$action_not_performed,
		"^/The target directory cannot contain the source directory;^/^a contains ^a.", pathname_ (td_name, te_name),
		pathname_ (sd_name, se_name));
                                               /* indicate that an error has been found */
	     code = error_table_$action_not_performed;

	     return;
	     end;

	return;

     end create_directory;

contains:
     proc (p_source_contains_target, p_target_contains_source, code);

/* check of target_dir in source_dir and vice-versa. */

	dcl     (dir1, dir2)	        char (168);
	dcl     (en1, en2)		        char (32);
	dcl     p_source_contains_target      bit (1);
	dcl     p_target_contains_source      bit (1);
	dcl     code		        fixed bin (35);

          code = 0;
	p_source_contains_target = "0"b;
	p_target_contains_source = "0"b;

	call hcs_$get_link_target (sd_name, se_name, dir1, en1, code);
	if code ^= 0
	then return;

	call hcs_$get_link_target (td_name, te_name, dir2, en2, code);
	if code ^= 0
	then return;

	call path_info (dir1, en1, scomp_count, scomp_root, code);
	if code ^= 0
	then return;

	if dir1 = dir2 & en1 = en2
	then do;
	     code = error_table_$sameseg;
	     p_target_contains_source = "1"b;
	     p_source_contains_target = "1"b;
	     end;
	else do;
	     call path_info (dir2, en2, tcomp_count, tcomp_root, code);
	     if code ^= 0
		then return;

	     if scomp_count = tcomp_count
		then return;

	     else if scomp_count > tcomp_count
		then do;
		     call csub (scomp_root, tcomp_count, uid, code);
		     if code ^= 0
			then return;

		     if uid = dir2_uid
		     then p_source_contains_target = "1"b;
		     end;

	     else do;                             /* for example: source and target pathnames are ">udd>m>x" and ">udd>m>x>y", respectively */
		call csub (tcomp_root, scomp_count, uid, code);
		if code ^= 0
		     then return;

		if uid = dir1_uid
		     then p_target_contains_source = "1"b;
		end;
	end;
%page;
csub:
     proc (p_root, p_count, p_uid, p_code);

	dcl     (p, p_root)		        ptr;
	dcl     (code, p_code)	        fixed bin (35);
	dcl     dir		        char (128);
	dcl     en		        char (32);
	dcl     p_count		        fixed bin;
	dcl     comp_index		        fixed bin;
	dcl     p_uid		        bit (36) aligned;

	dir = "";
	p = p_root;
	p_code = 0;

	if p_count = 1
	then dir = ">";
	else do comp_index = 1 to p_count - 1;
		dir = rtrim (dir) || ">" || p -> comp.name;
		p = p -> comp.next;
	     end;

	en = p -> comp.name;
	call hcs_$get_uid_file (dir, en, p_uid, code);
	if code ^= 0
	then p_code = code;

     end;
     end;
path_info:
     proc (d, e, count, root, code);

/* Turn pathname into threaded list of component names. */

	dcl     code		        fixed bin (35);
	dcl     (d, e)		        char (*);
	dcl     count		        fixed bin;
	dcl     optr		        ptr;
	dcl     dirstr		        char (168);
	dcl     root		        ptr;
	count = 0;
	if d = ">"
	then dirstr = reverse (">" || rtrim (e));
	else dirstr = reverse (rtrim (d) || ">" || rtrim (e));
	ii = index (dirstr, ">");
	cptr = null;

	optr = null;
	do while (ii > 1);
	     alloc comp in (area);
	     comp.name = reverse (substr (dirstr, 1, ii - 1));
	     comp.next = optr;
	     optr = cptr;
	     dirstr = substr (dirstr, ii + 1);
	     count = count + 1;
	     ii = index (dirstr, ">");
	end;

	root = cptr;
     end;						/*						*/
						/* containment subroutine for the link copier. */

contains_target:
     proc (ld, le, new_target, code) recursive;

/* Check whether source link's target pathname is contained in the source
   directory and if so, translate the link target pathname to a pathname in the
   target directory.  Only the components of the target pathname which are
   target directory.  Only the components of the target pathname which are
   be used in the check.  If one of the components being checked is a link, contains_target
   is re-called with the new link target pathname and the unprocessed portion of the
   old one. */

	dcl     i			        fixed bin;
	dcl     en		        char (32);
	dcl     dir		        char (168);
	dcl     new_target		        char (168);
	dcl     p			        ptr;
	dcl     (ld, le)		        char (*);
	dcl     code		        fixed bin (35);
	dcl     uid		        bit (36) aligned;

	call path_info (ld, le, lcomp_count, lcomp_root, code);
	if code ^= 0
	then goto finish;

	if lcomp_count < scomp_count
	then do;
		code = no_translation;
		return;
	     end;

	p = lcomp_root;
	dir = "";

/* Catenate the 2nd through lcomp_count'th components, checking at each one
   for links or matching with unique id's. */

	do i = 1 to lcomp_count - 1;
	     dir = rtrim (dir) || ">" || p -> comp.name;
	     p = p -> comp.next;
	     en = p -> comp.name;
	     call hcs_$status_minf (dir, en, 0, type, (0), code);
	     if code ^= 0
	     then if code = error_table_$noentry | code = error_table_$no_dir
						/*  The part of the link target pathname which is non-null is not
						   contained in source_dir.  Therefore, don't translate the link. */
		then do;
			code = no_translation;
			return;
		     end;
		else do;
			code = no_translation;
			goto check_dir_level;
		     end;
	     if type = Link
	     then do;
		     code = no_translation;
		     return;
		end;
	     else if type ^= Directory
	     then do;
		     if i <= scomp_count - 1
		     then do;
			     code = no_translation;
			     return;
			end;
		end;
	     else
check_dir_level:
		call hcs_$get_uid_file (dir, en, uid, code);
	     if code ^= 0
	     then do;
		     code = no_translation;
		     return;
		end;

	     if i = scomp_count - 1
	     then if dir1_uid ^= uid
		then do;
			code = no_translation;
			return;
		     end;
		else do;
			call ioa_$rsnnl ("^a^[>^]^a", new_target, ln, td_name, (td_name ^= ">"), te_name);
			p = p -> comp.next;
			do while (p ^= null);
			     new_target = rtrim (new_target) || ">" || p -> comp.name;
			     p = p -> comp.next;
			end;
			code = 0;
			return;
		     end;
next_comp:
	end;
	new_target = rtrim (new_target) || ">" || rtrim (le);

	return;
     end contains_target;

get_uid:
     proc (p_path) returns (bit (36));
	dcl     p_path		        char (168);
	dcl     dir		        char (168);
	dcl     entry		        char (32);
	dcl     code		        fixed bin (35);
	dcl     uid		        bit (36) aligned;

	call expand_pathname_ (p_path, dir, entry, code);
	if code ^= 0
	then return ("0"b);

	call hcs_$get_uid_file (dir, entry, uid, code);
	if code ^= 0
	then return ("0"b);

	return (uid);

     end get_uid;
%page;
complain:
     proc () options (variable);
	dcl     p_code		        fixed bin (35) based (argp);
	dcl     argp		        ptr;
	dcl     argl		        fixed bin (21);
	dcl     nargs		        fixed bin;
	dcl     arg_list_ptr	        ptr;
	dcl     error_message	        char (512);
	dcl     error_message_length	        fixed bin;

	call cu_$arg_ptr (1, argp, argl, 0);
	if ^brief
	then do;
		call cu_$arg_count (nargs, 0);
		if nargs > 1
		then do;
			call cu_$arg_list_ptr (arg_list_ptr);
			call ioa_$general_rs (arg_list_ptr, 2, 3, error_message, error_message_length, "0"b, "0"b);
			call com_err_ (p_code, whoami, substr (error_message, 1, error_message_length));
		     end;
		else call com_err_ (p_code, whoami);
	     end;
	errors = "1"b;
	acode = p_code;
     end complain;

/* format: off */
%page; %include suffix_info;
%include copy_flags;
%page; %include create_branch_info;
%page; %include query_info_;
%page; %include status_structures;
%page; %include copy_dir_options;
%page; %include copy_options;
declare   1 cpo                         aligned like copy_options;
%page; %include delete_options;
%include nd_handler_options;
%page; %include copy_error_info;
%include sub_error_info;
%include condition_info_header;
%include condition_info;
declare   1 ci                          aligned like condition_info;
%include sub_err_flags;
%include star_structures;

     end copy_dir_;
