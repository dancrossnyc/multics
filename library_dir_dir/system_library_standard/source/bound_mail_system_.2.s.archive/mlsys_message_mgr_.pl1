/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *********************************************************** */

/* format: off */

/* Message management for the Multics Mail System */

/* Created:  June 1981 by G. Palter */
/* Recoded:  July 1983 by G. Palter to convert to new mail system specification */
/* Modified: April 1984 by G. Palter to fix error #0438 -- the primitives which allow a user to replace the address list
      portions of a message (eg: mail_system_$replace_from, mail_system_$replace_user_field) should not make the user's
      copy of the address list read-only.  Instead, they should copy the user's list to allow the user to continue to
      modify the list if desired for later additional use */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen,^indcomtxt */


mlsys_message_mgr_:
     procedure () options (rename ((alloc_, mlsys_storage_mgr_$allocate)));

	return;					/* not an entrypoint */


/* Parameters */

dcl  P_message_ptr pointer parameter;
dcl  P_code fixed binary (35) parameter;

dcl  P_message_version character (8) parameter;		/* create_*_message: version of message structure requested by
						      the caller */

dcl  P_im_message_info_ptr pointer parameter;		/* create_im_message, verify_im_message: -> internal
						      description of the message */

dcl  P_message_envelope_parameter_ptr pointer parameter;	/* replace_message_envelope_*: -> the new envelope */

dcl  P_address_list_ptr pointer parameter;		/* replace_from_*, replace_reply_to_*, replace_to_*,
						      replace_cc_*, replace_bcc_*: -> the new value for the
						      field */

dcl  P_subject character (*) parameter;			/* replace_subject_*: the new subject text */

dcl  P_access_class bit (72) aligned parameter;		/* set_access_class_new: the new AIM access class for the
						      message */

dcl  P_message_body_section_parameter_ptr pointer parameter;/* add_body_section_*: -> the new section to be added;
						   replace_body_*: -> the new section to replace the body;
						   replace_body_section_*: - > the new section to replace the
						      old body section */

dcl  P_message_redistribution_parameter_ptr pointer parameter;
						/* add_redistribution_*: -> the new redistribution;
						   replace_redistribution_*: -> the new redistribution to
						      replace the old redistribution */

dcl  P_referenced_message_ptr pointer parameter;		/* add_reply_reference_new: -> the in-mailbox message for
						      which a reference is to be added to the message;
						   replace_reply_reference_new: -> the in-mailbox message
						      whose reference will replace the old reference */

dcl  P_message_reference_parameter_ptr pointer parameter;	/* add_reply_reference_*: -> the in-mailbox message for which
						      a reference is to be added to the message;
						   replace_reply_reference_*: -> the in-mailbox message
						      whose reference will replace the old reference */

dcl  P_message_user_field_parameter_ptr pointer parameter;	/* add_user_field_*: -> the new user field to be added;
						   replace_user_field_*: -> the new user field to replace the
						      old field */
dcl  P_allow_duplicates bit (1) aligned parameter;	/* add_user_field_*, replace_user_field_*: ON => allow
						      multiple fields with same ID in the header */

dcl  P_position fixed binary parameter;			/* add_*: where to add the new item; set to actual position
						      where it was added;
						   delete_*, replace_* (except replace_subject_*): identifies
						      which item in the message to delete/replace */

dcl  P_date_time_created fixed binary (71) parameter;	/* verify_message, verify_new_message: set to the date/time
						      the message was created */
/**** format: indcomtxt */


/* Local copies of parameters */

dcl  access_class bit (72) aligned;

dcl  position fixed binary;

dcl  code fixed binary (35);


/* Definition of the reserved data in the various parts of a message */

dcl  1 message_reserved_data aligned based (addr (message.reserved)),
       2 info_ptr pointer,				/* -> corresponding im_message_info or new_message_info */
       2 n_body_sections_allocated,			/* actual # of body sections available in the structure */
       2 type fixed binary;				/* type of message (in-mailbox/new/incoming) */

/* format: off */
dcl (IN_MAILBOX_MESSAGE	initial (0),		/* an in-mailbox message */
     NEW_MESSAGE		initial (1))		/* a new message created by ordinary mail_system_ gate */
/*   INCOMING_MESSAGE	initial (2))		/* an incoming message created by mail_system_daemon_ gate */
	fixed binary static options (constant);
/* format: on */

dcl  1 message_references_list_reserved_data aligned based (addr (message_references_list.reserved)),
       2 message_ptr pointer,				/* -> the message of which this is a part */
       2 n_references_allocated fixed binary;		/* # of reference slots actually present */

dcl  1 message_redistributions_list_reserved_data aligned based (addr (message_redistributions_list.reserved)),
       2 message_ptr pointer,				/* -> the message of which this is a part */
       2 n_redistributions_allocated fixed binary;	/* # of redistribution slots actually present */

dcl  1 message_user_fields_list_reserved_data aligned based (addr (message_user_fields_list.reserved)),
       2 message_ptr pointer,				/* -> the message of which this is a part */
       2 n_user_fields_allocated fixed binary;		/* # of user field slots actually present */

dcl  1 message_text_field_reserved_flags unaligned based (addr (message_text_field.flags.reserved)),
       2 free_text bit (1) unaligned,			/* ON => free the text on releasing this field */
       2 pad bit (34) unaligned;

dcl  1 message_preformatted_body_section_reserved_data aligned based (addr (message_preformatted_body_section.reserved)),
       2 free_text bit (1) unaligned,			/* ON => free the text on releasing this section */
       2 pad bit (35) unaligned;

dcl  1 message_bit_string_body_section_reserved_data aligned based (addr (message_bit_string_body_section.reserved)),
       2 free_bit_string bit (1) unaligned,		/* ON => free the bit string on releasing this section */
       2 pad bit (35) unaligned;


/* Internal description of a new message */

dcl  1 new_message_info aligned based (new_message_info_ptr),
       2 date_time_created fixed binary (71);		/* date/time message body last updated */

dcl  new_message_info_ptr pointer;


/* Remaining declarations */

dcl  1 local_mrfp aligned like message_reference_parameter;

dcl  1 user_privileges aligned,
       2 privileges unaligned like aim_template.privileges,
       2 pad bit (18) unaligned;

dcl  message_type fixed binary;

dcl  (copy_subject, copy_section_content, copy_redistribution_data, copy_reference_data, copy_user_field_content)
	bit (1) aligned;

dcl  idx fixed binary;

dcl  MAX_STACK_EXTENSION fixed binary (21) static options (constant) initial (16384);

dcl  NULL_STRING character (1) static options (constant) initial (" ");

/* format: off */
dcl (SPACE     initial (" "),
     HT	     initial ("	"),
     BS	     initial (""),
     NL	     initial ("
"),
     CR	     initial (""))
	character (1) static options (constant);
/* format: on */

dcl  SPACE_SPACE character (2) static options (constant) initial ("  ");

dcl  TEN_SPACES character (10) static options (constant) initial ("          ");

/* format: off */
dcl (UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
     LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"))
	 character (26) static options (constant);
/* format: on */

dcl  SINGLE_WIDTH_CHARACTERS character (95) static options (constant)
	initial (" !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");

/* format: off */

dcl  sys_info$max_seg_size fixed binary (19) external;

dcl (error_table_$ai_restricted, error_table_$bad_index, error_table_$smallarg, error_table_$unimplemented_version,
     mlsys_et_$duplicate_reply_reference, mlsys_et_$duplicate_user_field, mlsys_et_$message_too_large,
     mlsys_et_$not_in_mailbox_message, mlsys_et_$not_message, mlsys_et_$not_new_message,
     mlsys_et_$unknown_body_section_type, mlsys_et_$unknown_user_field_type)
	fixed binary (35) external;
/* format: on */

dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  cu_$grow_stack_frame entry (fixed binary (18), pointer, fixed binary (35));
dcl  get_authorization_ entry () returns (bit (72) aligned);
dcl  get_privileges_ entry () returns (bit (36) aligned);
dcl  mlsys_address_list_mgr_$create_read_only_address_list entry (character (8), pointer, fixed binary (35));
dcl  mlsys_address_list_mgr_$copy_address_list entry (pointer, pointer, fixed binary (35));
dcl  mlsys_address_list_mgr_$decrement_reference_count entry (pointer);
dcl  mlsys_address_list_mgr_$increment_reference_count entry (pointer);
dcl  mlsys_address_list_mgr_$set_read_only entry (pointer);
dcl  mlsys_address_list_mgr_$verify_address_list entry (pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mlsys_address_mgr_$decrement_reference_count entry (pointer);
dcl  mlsys_address_mgr_$increment_reference_count entry (pointer);
dcl  mlsys_address_mgr_$verify_address entry (pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mlsys_address_route_mgr_$create_address_route entry ((*) character (256) varying, pointer);
dcl  mlsys_address_route_mgr_$decrement_reference_count entry (pointer);
dcl  mlsys_address_route_mgr_$increment_reference_count entry (pointer);
dcl  mlsys_field_id_mgr_$get_user_field_name entry (bit (36) aligned, character (*) varying, fixed binary (35));
dcl  mlsys_nit_interface_$get_fully_qualified_name entry (character (256) varying) returns (character (256) varying);
dcl  mlsys_nit_interface_$is_local_system entry (character (256) varying) returns (bit (1) aligned);
dcl  mlsys_storage_mgr_$get_temp_segment entry (pointer, fixed binary (35));
dcl  mlsys_storage_mgr_$release_temp_segment entry (pointer, fixed binary (35));

dcl  cleanup condition;

dcl  (addr, baseno, binary, clock, divide, index, length, ltrim, max, min, mod, null, rtrim, search, stackframeptr,
     string, substr, translate, verify) builtin;
%page;
/* Create an empty message */

create_im_message:					/* ... create an in-mailbox message */
     entry (P_message_version, P_im_message_info_ptr, P_message_ptr, P_code);

	message_type = IN_MAILBOX_MESSAGE;
	go to CREATE_MESSAGE_COMMON;


create_new_message:					/* ... create a new message: target of user-ring gate */
     entry (P_message_version, P_message_ptr, P_code);

	message_type = NEW_MESSAGE;


CREATE_MESSAGE_COMMON:
	if P_message_version ^= MESSAGE_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	message_n_body_sections = mlsys_data_$message_body_sections_allocation;
						/* allows some room for the body */

	allocate message in (mlsys_area) set (message_ptr);

	message.version = MESSAGE_VERSION_2;

	message_reserved_data.n_body_sections_allocated = message_n_body_sections;
	message.n_body_sections = 0;			/* the body is empty */

	message_reserved_data.type = message_type;

	if message_type = IN_MAILBOX_MESSAGE then message_reserved_data.info_ptr = P_im_message_info_ptr;
	else if message_type = NEW_MESSAGE then do;
	     allocate new_message_info in (mlsys_area) set (new_message_info_ptr);
	     message_reserved_data.info_ptr = new_message_info_ptr;
	     new_message_info.date_time_created = 0;	/* hidden copy so that formatting shows nothing */
	end;
	else message_reserved_data.info_ptr = null ();	/* incoming messages don't have hidden data */

	message.n_reply_references, message.n_user_fields, message.n_redistributions = 0;

	string (message.flags) = ""b;

	message.date_time_mailed, message.date_time_delivered = 0;
	message.sender, message.trace, message.delivered_by, message.acknowledge_to = null ();

	message.message_id = ""b;			/* will be set later for in-mailbox/incoming */

	message.access_class = get_authorization_ ();

	message.date_time_created = 0;

	call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, message.from, (0));
	call mlsys_address_list_mgr_$increment_reference_count (message.from);

	call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, message.reply_to, (0));
	call mlsys_address_list_mgr_$increment_reference_count (message.reply_to);

	call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, message.to, (0));
	call mlsys_address_list_mgr_$increment_reference_count (message.to);

	call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, message.cc, (0));
	call mlsys_address_list_mgr_$increment_reference_count (message.cc);

	call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, message.bcc, (0));
	call mlsys_address_list_mgr_$increment_reference_count (message.bcc);

	message.subject.text_ptr = addr (NULL_STRING);	/* avoid causing anyone faults */
	message.subject.text_lth = 0;
	string (message.subject.flags) = ""b;		/* this turns subject.multiline_text off */
	addr (message.subject.flags.reserved) -> message_text_field_reserved_flags.free_text = "0"b;

	message_references_list_n_references = mlsys_data_$message_references_list_allocation;
	allocate message_references_list in (mlsys_area) set (message_references_list_ptr);
	message_references_list.version = MESSAGE_REFERENCES_LIST_VERSION_2;
	message_references_list_reserved_data.n_references_allocated = message_references_list_n_references;
	message_references_list.n_references = 0;
	message.reply_references = message_references_list_ptr;
	message_references_list_reserved_data.message_ptr = message_ptr;

	message_n_user_fields = mlsys_data_$message_user_fields_allocation;
	allocate message_user_fields_list in (mlsys_area) set (message.user_fields_list);
	message_user_fields_list.version = MESSAGE_USER_FIELDS_LIST_VERSION_2;
	message_user_fields_list_reserved_data.n_user_fields_allocated = message_n_user_fields;
	message_user_fields_list.n_user_fields = 0;
	message_user_fields_list_reserved_data.message_ptr = message_ptr;

	if message_type = NEW_MESSAGE then		/* new messages can't have redistributions ... */
	     message.redistributions_list = null ();
	else do;					/* ... but in-mailbox and incoming messages do */
	     message_n_redistributions = mlsys_data_$message_redistributions_list_allocation;
	     allocate message_redistributions_list in (mlsys_area) set (message.redistributions_list);
	     message_redistributions_list.version = MESSAGE_REDISTRIBUTIONS_LIST_VERSION_2;
	     message_redistributions_list_reserved_data.n_redistributions_allocated = message_n_redistributions;
	     message_redistributions_list.n_redistributions = 0;
	     message_redistributions_list_reserved_data.message_ptr = message_ptr;
	end;

	message.body.total_lines = 0;			/* as said above: no body yet */

	P_message_ptr = message_ptr;
	P_code = 0;				/* success */

	return;
%page;
/* Free a message */

free_message:					/* ... any type of message */
     entry (P_message_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	go to FREE_MESSAGE_COMMON;


free_message_new:					/* ... a new message only: target of user-ring gate */
     entry (P_message_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;


FREE_MESSAGE_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	P_message_ptr = null ();			/* insure the caller doesn't use it anymore */

	do idx = message.n_body_sections to 1 by -1;	/* get rid of any body that's present */
	     call delete_body_section_internal (idx);
	end;

	do idx = message.n_redistributions to 1 by -1;	/* non-zero only if message.redistributions_list non-null */
	     call delete_redistribution_internal (idx);
	end;
	if message.redistributions_list ^= null () then free message_redistributions_list in (mlsys_area);
	message.redistributions_list = null ();		/* handles a cleanup during the free doing another free */

	do idx = message.n_user_fields to 1 by -1;
	     call delete_user_field_internal (idx);
	end;
	free message_user_fields_list in (mlsys_area);
	message.user_fields_list = null ();

	do idx = message.n_reply_references to 1 by -1;
	     call delete_reference_internal (message.n_reply_references, message.reply_references, idx);
	end;
	free message.reply_references -> message_references_list in (mlsys_area);
	message.reply_references = null ();

	if addr (message.subject.flags.reserved) -> message_text_field_reserved_flags.free_text then
	     if (message.subject.text_ptr ^= null ()) & (message.subject.text_ptr ^= addr (NULL_STRING)) then do;
		free message_subject in (mlsys_area);
		message.subject.text_ptr = null ();
	     end;

	if message.bcc ^= null () then call mlsys_address_list_mgr_$decrement_reference_count (message.bcc);
	if message.cc ^= null () then call mlsys_address_list_mgr_$decrement_reference_count (message.cc);
	if message.to ^= null () then call mlsys_address_list_mgr_$decrement_reference_count (message.to);
	if message.reply_to ^= null () then call mlsys_address_list_mgr_$decrement_reference_count (message.reply_to);
	if message.from ^= null () then call mlsys_address_list_mgr_$decrement_reference_count (message.from);

	call delete_envelope (addr (message.envelope));

	if message_reserved_data.info_ptr ^= null () then
	     if message_reserved_data.type = NEW_MESSAGE then
		free message_reserved_data.info_ptr -> new_message_info in (mlsys_area);
	message_reserved_data.info_ptr = null ();

	free message in (mlsys_area);

	P_code = 0;				/* all done */

	return;
%page;
/* Add a section to the body of a message */

add_body_section:					/* ... for any type of message */
     entry (P_message_ptr, P_message_body_section_parameter_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "1"b;
	go to ADD_BODY_SECTION_COMMON;


add_body_section_no_copy:				/* ... for any type of message: section content in our ring */
     entry (P_message_ptr, P_message_body_section_parameter_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "0"b;
	go to ADD_BODY_SECTION_COMMON;


add_body_section_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_message_body_section_parameter_ptr, P_position, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "1"b;


ADD_BODY_SECTION_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	message_body_section_parameter_ptr = P_message_body_section_parameter_ptr;

	if message_body_section_parameter.version ^= MESSAGE_BODY_SECTION_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	message_body_section_ptr = addr (message_body_section_parameter.section);
	if ^verify_body_section (message_body_section_ptr, P_code) then return;

	call compute_position_for_add (P_position, message.n_body_sections, position);

	call add_body_section_internal ();		/* do the actual work (also used by replace_body_*) */

	if message_reserved_data.type = NEW_MESSAGE then	/* record date/time of latest change to message body */
	     message_reserved_data.info_ptr -> new_message_info.date_time_created = clock ();

	P_message_ptr = message_ptr;			/* in case we had to expand message.body_sections */
	P_position = position;			/* let caller know where we put it */
	P_code = 0;				/* success */

	return;
%page;
/* Actually adds a section to the message body (called by several entrypoints) */

add_body_section_internal:
     procedure ();

dcl  1 the_body_section aligned like message_body_section based (the_section_ptr);
dcl  1 the_preformatted_body_section aligned like message_preformatted_body_section based (the_section_ptr);
dcl  1 the_bit_string_body_section aligned like message_bit_string_body_section based (the_section_ptr);

dcl  (new_message_ptr, the_section_ptr) pointer;
dcl  idx fixed binary;

	new_message_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if new_message_ptr ^= null () then free new_message_ptr -> message in (mlsys_area);
		new_message_ptr = null ();
	     end;

	/*** Expand the message structure if necessary */
	if (message.n_body_sections + 1) > message_reserved_data.n_body_sections_allocated then do;
	     message_n_body_sections =
		message_reserved_data.n_body_sections_allocated + mlsys_data_$message_body_sections_allocation;
	     allocate message in (mlsys_area) set (new_message_ptr);
	     new_message_ptr -> message.version = MESSAGE_VERSION_2;
	     new_message_ptr -> message.reserved = message.reserved;
	     addr (new_message_ptr -> message.reserved) -> message_reserved_data.n_body_sections_allocated =
		message_n_body_sections;
	     new_message_ptr -> message.n_reply_references = message.n_reply_references;
	     new_message_ptr -> message.n_user_fields = message.n_user_fields;
	     new_message_ptr -> message.n_redistributions = message.n_redistributions;
	     new_message_ptr -> message.n_body_sections = message.n_body_sections;
	     string (new_message_ptr -> message.flags) = string (message.flags);
	     new_message_ptr -> message.envelope = message.envelope;
	     new_message_ptr -> message.header = message.header;
	     new_message_ptr -> message.redistributions_list = message.redistributions_list;
	     new_message_ptr -> message.body.total_lines = message.body.total_lines;
	     do idx = 1 to message.n_body_sections;
		new_message_ptr -> message.body.body_sections (idx) = message.body.body_sections (idx);
	     end;
	     free message in (mlsys_area);
	     message_ptr = new_message_ptr;
	     new_message_ptr = null ();
	end;

	/*** Make room for the new section by moving any existing sections behind it up by one */
	do idx = message.n_body_sections to position by -1;
	     message.body.body_sections (idx + 1) = message.body.body_sections (idx);
	end;

	/*** Copy in the new section and, if needed, copy the actual data */
	the_section_ptr = addr (message.body.body_sections (position));
	the_body_section.header = message_body_section.header;
	go to ADD_SECTION (message_body_section.section_type);

ADD_SECTION (1):					/* preformatted text */
	string (the_preformatted_body_section.reserved) = ""b;
	if copy_section_content then do;		/* ... always copy it */
COPY_PREFORMATTED_TEXT:
	     call normalize_multiline_field (message_preformatted_body_section_text,
		the_preformatted_body_section.text_ptr, the_preformatted_body_section.text_lth);
	     addr (the_preformatted_body_section.reserved)
		-> message_preformatted_body_section_reserved_data.free_text = "1"b;
	end;
	else					/* ... copy caller's text only if it's misformatted ... */
	     if index (message_preformatted_body_section_text, HT) ^= 0 then go to COPY_PREFORMATTED_TEXT;
	else					/* ... or not in one of our temporary segments ... */
	     if ^mlsys_data_$valid_segments (binary (baseno (message_preformatted_body_section.text_ptr), 18, 0)) then
	     go to COPY_PREFORMATTED_TEXT;
	else do;					/* ... caller's text is OK */
	     the_preformatted_body_section.text_ptr = copy_ptr (message_preformatted_body_section.text_ptr);
	     the_preformatted_body_section.text_lth = message_preformatted_body_section.text_lth;
	end;
	the_body_section.section_n_lines =
	     count_lines_in_text (the_preformatted_body_section.text_ptr -> message_preformatted_body_section_text);
	go to END_ADD_SECTION_CASE;

ADD_SECTION (2):					/* bit string */
	the_body_section.section_n_lines = -1;
	the_bit_string_body_section.bit_string_lth = message_bit_string_body_section.bit_string_lth;
	string (the_bit_string_body_section.reserved) = ""b;
						/* ... above turns off the free_bit_string flag */
	if copy_section_content then do;
COPY_BIT_STRING:
	     allocate message_bit_string_body_section_bit_string in (mlsys_area)
		set (the_bit_string_body_section.bit_string_ptr);
	     the_bit_string_body_section.bit_string_ptr -> message_bit_string_body_section_bit_string =
		message_bit_string_body_section_bit_string;
	     addr (the_bit_string_body_section.reserved)
		-> message_bit_string_body_section_reserved_data.free_bit_string = "1"b;
	end;
	else					/* copy if not in one of our temporary segments */
	     if ^mlsys_data_$valid_segments (binary (baseno (message_bit_string_body_section.bit_string_ptr), 18, 0))
	then go to COPY_BIT_STRING;
	else the_bit_string_body_section.bit_string_ptr = copy_ptr (message_bit_string_body_section.bit_string_ptr);
	go to END_ADD_SECTION_CASE;

END_ADD_SECTION_CASE:
	message.n_body_sections = message.n_body_sections + 1;

	/*** Recompute the number of lines in the body */
	message.body.total_lines = 0;
	do idx = 1 to message.n_body_sections while (message.body.total_lines ^= -1);
	     if message.body.body_sections (idx).section_n_lines = -1 then
		message.body.total_lines = -1;
	     else message.body.total_lines =
		     message.body.total_lines + message.body.body_sections (idx).section_n_lines;
	end;

	if message.body.total_lines ^= -1 then		/* take the lines in between sections into account */
	     message.body.total_lines = message.body.total_lines + message.n_body_sections - 1;

	return;

     end add_body_section_internal;
%page;
/* Add a redistribution to the list of redistributions for a given message */

add_redistribution:					/* ... for any type of message */
     entry (P_message_ptr, P_message_redistribution_parameter_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_redistribution_data = "1"b;
	go to ADD_REDISTRIBUTION_COMMON;


add_redistribution_no_copy:				/* ... for any type of message; data already in our ring */
     entry (P_message_ptr, P_message_redistribution_parameter_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_redistribution_data = "0"b;


ADD_REDISTRIBUTION_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	message_redistribution_parameter_ptr = P_message_redistribution_parameter_ptr;

	if message_redistribution_parameter.version ^= MESSAGE_REDISTRIBUTION_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	message_redistribution_ptr = addr (message_redistribution_parameter.redistribution);
	if ^verify_redistribution (message_redistribution_ptr, P_code) then return;

	call compute_position_for_add (P_position, message.n_redistributions, position);

	call add_redistribution_internal ();		/* do the actual work (used by replace_redistribution_*) */

	P_position = position;			/* let caller know where we put it */
	P_code = 0;				/* success */

	return;



/* Actually adds a redistribution to the message's redistributions lists (called by several entrypoints) */

add_redistribution_internal:
     procedure ();

dcl  1 the_redistribution aligned based (the_redistribution_ptr) like message_redistribution;

dcl  (new_rl_ptr, the_redistribution_ptr) pointer;
dcl  idx fixed binary;

	new_rl_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if new_rl_ptr ^= null () then free new_rl_ptr -> message_redistributions_list in (mlsys_area);
		new_rl_ptr = null ();
	     end;

	/*** Expand the message_redistributions_list structure if necessary */
	if (message.n_redistributions + 1) > message_redistributions_list_reserved_data.n_redistributions_allocated
	then do;
	     message_n_redistributions =
		message_redistributions_list_reserved_data.n_redistributions_allocated
		+ mlsys_data_$message_redistributions_list_allocation;
	     allocate message_redistributions_list in (mlsys_area) set (new_rl_ptr);
	     new_rl_ptr -> message_redistributions_list.version = MESSAGE_REDISTRIBUTIONS_LIST_VERSION_2;
	     new_rl_ptr -> message_redistributions_list.reserved = message_redistributions_list.reserved;
	     addr (new_rl_ptr -> message_redistributions_list.reserved)
		-> message_redistributions_list_reserved_data.n_redistributions_allocated = message_n_redistributions;
	     new_rl_ptr -> message_redistributions_list.n_redistributions =
		message_redistributions_list.n_redistributions;
	     do idx = 1 to message.n_redistributions;
		new_rl_ptr -> message_redistributions_list.redistributions (idx) =
		     message_redistributions_list.redistributions (idx);
	     end;
	     free message_redistributions_list in (mlsys_area);
	     message.redistributions_list = new_rl_ptr;
	     new_rl_ptr = null ();
	end;

	/*** Make room for the new redistribution by moving any existing redistributions behind it up by one */
	do idx = message.n_redistributions to position by -1;
	     message_redistributions_list.redistributions (idx + 1) =
		message_redistributions_list.redistributions (idx);
	end;

	/*** Copy in the new redistribution */
	the_redistribution_ptr = addr (message_redistributions_list.redistributions (position));
	call set_envelope (addr (message_redistribution.envelope), addr (the_redistribution.envelope));
	the_redistribution.header = message_redistribution.header;
	if the_redistribution.from ^= null () then do;
	     if copy_redistribution_data then
		call mlsys_address_list_mgr_$copy_address_list (the_redistribution.from, the_redistribution.from, (0))
		     ;
	     else the_redistribution.from = copy_ptr (the_redistribution.from);
	     call mlsys_address_list_mgr_$set_read_only (the_redistribution.from);
	end;
	else call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2,
		the_redistribution.from, (0));
	call mlsys_address_list_mgr_$increment_reference_count (the_redistribution.from);
	if the_redistribution.to ^= null () then do;
	     if copy_redistribution_data then
		call mlsys_address_list_mgr_$copy_address_list (the_redistribution.to, the_redistribution.to, (0));
	     else the_redistribution.to = copy_ptr (the_redistribution.to);
	     call mlsys_address_list_mgr_$set_read_only (the_redistribution.to);
	end;
	else call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, the_redistribution.to,
		(0));
	call mlsys_address_list_mgr_$increment_reference_count (the_redistribution.to);

	/*** Copy the comment (if necessary) */
	string (the_redistribution.comment.flags) = ""b;	/* turns off the "free_text" flag */
	the_redistribution.comment.multiline_text = "1"b; /* always treated as multiline */
	if (message_redistribution.comment.text_ptr = null ()) | (message_redistribution.comment.text_lth = 0) then do;
	     the_redistribution.comment.text_ptr = addr (NULL_STRING);
	     the_redistribution.comment.text_lth = 0;
	end;
	else if copy_redistribution_data then do;	/* always copy the comment */
COPY_REDISTRIBUTION_COMMENT:
	     call normalize_multiline_field (message_redistribution_comment, the_redistribution.comment.text_ptr,
		the_redistribution.comment.text_lth);
	     addr (the_redistribution.comment.flags.reserved) -> message_text_field_reserved_flags.free_text = "1"b;
	end;
	else					/* copy it only if it's misformatted ... */
	     if index (message_redistribution_comment, HT) ^= 0 then go to COPY_REDISTRIBUTION_COMMENT;
	else					/* ... or not in one of our temporary segments ... */
	     if ^mlsys_data_$valid_segments (binary (baseno (message_redistribution.comment.text_ptr), 18, 0)) then
	     go to COPY_REDISTRIBUTION_COMMENT;
	else do;					/* caller's text is OK */
	     the_redistribution.comment.text_ptr = copy_ptr (message_redistribution.comment.text_ptr);
	     the_redistribution.comment.text_lth = message_redistribution.comment.text_lth;
	end;

	message_redistributions_list.n_redistributions, message.n_redistributions = message.n_redistributions + 1;

	return;

     end add_redistribution_internal;
%page;
/* Add a reference (as given or to the given message) to the list of messages for which this message is a reply */

add_reply_reference:				/* ... for any type message */
     entry (P_message_ptr, P_message_reference_parameter_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_reference_data = "1"b;
	go to ADD_REPLY_REFERENCE_COMMON;


add_reply_reference_no_copy:				/* ... for any type message: data already in our ring */
     entry (P_message_ptr, P_message_reference_parameter_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_reference_data = "0"b;
	go to ADD_REPLY_REFERENCE_COMMON;


add_reply_reference_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_referenced_message_ptr, P_position, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	if ^verify_im_message_internal (P_referenced_message_ptr, P_code) then return;
	copy_reference_data = "0"b;			/* it's already in the right place from in-mailbox message */

	message_ptr = copy_ptr (P_referenced_message_ptr);/* need to access the original temporarily */
	message_reference_parameter_ptr = addr (local_mrfp);
	message_reference_parameter.reference.message_id = message.message_id;
	message_reference_parameter.reference.date_time_created = message.date_time_created;
	message_reference_parameter.reference.from = message.from;
	message_reference_parameter.reference.subject = message.subject;
	go to ADD_REPLY_REFERENCE_NO_RP_CHECK;


ADD_REPLY_REFERENCE_COMMON:
	message_reference_parameter_ptr = P_message_reference_parameter_ptr;
	if message_reference_parameter.version ^= MESSAGE_REFERENCE_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;
	if ^verify_reference (addr (message_reference_parameter.reference), P_code) then return;

ADD_REPLY_REFERENCE_NO_RP_CHECK:
	message_ptr = copy_ptr (P_message_ptr);
	message_reference_ptr = addr (message_reference_parameter.reference);

	/*** Check for duplicate reply references */
	do idx = 1 to message.n_reply_references;
	     if message.reply_references -> message_references_list.references (idx).message_id
		= message_reference.message_id then do;
		P_position = idx;			/* let caller know where the duplicate resides */
		P_code = mlsys_et_$duplicate_reply_reference;
		return;
	     end;
	end;

	call compute_position_for_add (P_position, message.n_reply_references, position);

	call add_reference_internal (message.n_reply_references, message.reply_references);

	P_position = position;			/* let caller know where we put it */
	P_code = 0;				/* success */

	return;



/* Actually adds a reference to the message's references lists (called by several entrypoints) */

add_reference_internal:
     procedure (p_n_references, p_references_list_ptr);

dcl  p_n_references fixed binary parameter;
dcl  p_references_list_ptr pointer parameter;

dcl  1 the_reference aligned based (the_reference_ptr) like message_reference;

dcl  (new_rl_ptr, the_reference_ptr) pointer;
dcl  idx fixed binary;

	message_references_list_ptr = p_references_list_ptr;
						/* can't use like because it contains a refer extent */
	new_rl_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if new_rl_ptr ^= null () then free new_rl_ptr -> message_references_list in (mlsys_area);
		new_rl_ptr = null ();
	     end;

	/*** Expand the message_references_list structure if necessary */
	if (p_n_references + 1) > message_references_list_reserved_data.n_references_allocated then do;
	     message_references_list_n_references =
		message_references_list_reserved_data.n_references_allocated
		+ mlsys_data_$message_references_list_allocation;
	     allocate message_references_list in (mlsys_area) set (new_rl_ptr);
	     new_rl_ptr -> message_references_list.version = MESSAGE_REFERENCES_LIST_VERSION_2;
	     new_rl_ptr -> message_references_list.reserved = message_references_list.reserved;
	     addr (new_rl_ptr -> message_references_list.reserved)
		-> message_references_list_reserved_data.n_references_allocated =
		message_references_list_n_references;
	     new_rl_ptr -> message_references_list.n_references = message_references_list.n_references;
	     do idx = 1 to message.n_reply_references;
		new_rl_ptr -> message_references_list.references (idx) = message_references_list.references (idx);
	     end;
	     free message_references_list in (mlsys_area);
	     p_references_list_ptr, message_references_list_ptr = new_rl_ptr;
	     new_rl_ptr = null ();
	end;

	/*** Make room for the new reference by moving any existing references behind it up by one */
	do idx = p_n_references to position by -1;
	     message_references_list.references (idx + 1) = message_references_list.references (idx);
	end;

	/*** Copy in the new reference */
	the_reference_ptr = addr (message_references_list.references (position));
	the_reference = message_reference;		/* simple copy */
	if the_reference.from ^= null () then do;
	     if copy_reference_data then
		call mlsys_address_list_mgr_$copy_address_list (the_reference.from, the_reference.from, (0));
	     else the_reference.from = copy_ptr (the_reference.from);
	     call mlsys_address_list_mgr_$set_read_only (the_reference.from);
	     call mlsys_address_list_mgr_$increment_reference_count (the_reference.from);
	end;

	/*** Copy the subject (if necessary) */
	string (the_reference.subject.flags) = ""b;	/* turns off both multiline_text & free_text */
	if (message_reference.subject.text_ptr = null ()) | (message_reference.subject.text_lth = 0) then do;
	     the_reference.subject.text_ptr = addr (NULL_STRING);
	     the_reference.subject.text_lth = 0;
	end;
	else if copy_reference_data then do;		/* copy it no matter what */
COPY_REFERENCED_SUBJECT:
	     call normalize_single_line_field (message_reference_subject, the_reference.subject.text_ptr,
		the_reference.subject.text_lth);
	     addr (the_reference.subject.flags.reserved) -> message_text_field_reserved_flags.free_text = "1"b;
	end;
	else do;					/* copy it only if it's improperly formatted */
	     if ^mlsys_data_$valid_segments (binary (baseno (addr (message_reference_subject)), 18, 0)) then
		go to COPY_REFERENCED_SUBJECT;
	     if search (message_reference_subject, NON_SPACE_WHITESPACE) ^= 0 then go to COPY_REFERENCED_SUBJECT;
	     if verify (message_reference_subject, SPACE) ^= 1 then go to COPY_REFERENCED_SUBJECT;
	     if substr (message_reference_subject, length (message_reference_subject), 1) = SPACE then
		go to COPY_REFERENCED_SUBJECT;
	     if index (message_reference_subject, SPACE_SPACE) ^= 0 then go to COPY_REFERENCED_SUBJECT;
	     the_reference.subject.text_ptr = copy_ptr (message_reference.subject.text_ptr);
	     the_reference.subject.text_lth = message_reference.subject.text_lth;
	end;					/* ... above is executed iff caller's text is OK */

	message_references_list.n_references, p_n_references = p_n_references + 1;

	return;

     end add_reference_internal;
%page;
/* Add a user-defined field to the message */

add_user_field:					/* ... for any type of message */
     entry (P_message_ptr, P_message_user_field_parameter_ptr, P_position, P_allow_duplicates, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_user_field_content = "1"b;
	go to ADD_USER_FIELD_COMMON;


add_user_field_no_copy:				/* ... for any type of message: data already in our ring */
     entry (P_message_ptr, P_message_user_field_parameter_ptr, P_position, P_allow_duplicates, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_user_field_content = "0"b;
	go to ADD_USER_FIELD_COMMON;


add_user_field_new:					/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_message_user_field_parameter_ptr, P_position, P_allow_duplicates, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	copy_user_field_content = "1"b;


ADD_USER_FIELD_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	message_user_field_parameter_ptr = P_message_user_field_parameter_ptr;

	if message_user_field_parameter.version ^= MESSAGE_USER_FIELD_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	message_user_field_ptr = addr (message_user_field_parameter.user_field);
	if ^verify_user_field (message_user_field_ptr, P_code) then return;

	/*** Check for duplicate fields if requested */
	if ^P_allow_duplicates then do;
	     do idx = 1 to message.n_user_fields;
		if message_user_fields_list.user_fields (idx).field_id = message_user_field.field_id then do;
		     P_position = idx;		/* let caller know where the first duplicate lies */
		     P_code = mlsys_et_$duplicate_user_field;
		     return;
		end;
	     end;
	end;

	call compute_position_for_add (P_position, message.n_user_fields, position);

	call add_user_field_internal ();		/* do the actual work (also used by replace_user_field_*) */

	P_position = position;			/* let caller know where we put it */
	P_code = 0;				/* success */

	return;



/* Actually adds a user-defined field to the message (called by several entrypoints) */

add_user_field_internal:
     procedure ();

dcl  1 the_user_field aligned like message_user_field based (the_user_field_ptr);
dcl  1 the_text_user_field aligned like message_text_user_field based (the_user_field_ptr);
dcl  1 the_address_list_user_field aligned like message_address_list_user_field based (the_user_field_ptr);
dcl  1 the_date_user_field aligned like message_date_user_field based (the_user_field_ptr);
dcl  1 the_integer_user_field aligned like message_integer_user_field based (the_user_field_ptr);

dcl  (new_ufl_ptr, the_user_field_ptr) pointer;
dcl  idx fixed binary;

	new_ufl_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if new_ufl_ptr ^= null () then free new_ufl_ptr -> message_user_fields_list in (mlsys_area);
		new_ufl_ptr = null ();
	     end;

	/*** Expand the message_user_fields structure if necessary */
	if (message.n_user_fields + 1) > message_user_fields_list_reserved_data.n_user_fields_allocated then do;
	     message_n_user_fields =
		message_user_fields_list_reserved_data.n_user_fields_allocated
		+ mlsys_data_$message_user_fields_allocation;
	     allocate message_user_fields_list in (mlsys_area) set (new_ufl_ptr);
	     new_ufl_ptr -> message_user_fields_list.version = MESSAGE_USER_FIELDS_LIST_VERSION_2;
	     new_ufl_ptr -> message_user_fields_list.reserved = message_user_fields_list.reserved;
	     addr (new_ufl_ptr -> message_user_fields_list.reserved)
		-> message_user_fields_list_reserved_data.n_user_fields_allocated = message_n_user_fields;
	     new_ufl_ptr -> message_user_fields_list.n_user_fields = message_user_fields_list.n_user_fields;
	     do idx = 1 to message.n_user_fields;
		new_ufl_ptr -> message_user_fields_list.user_fields (idx) =
		     message_user_fields_list.user_fields (idx);
	     end;
	     free message_user_fields_list in (mlsys_area);
	     message.user_fields_list = new_ufl_ptr;
	     new_ufl_ptr = null ();
	end;

	/*** Make room for the new user-defined field by moving any existing fields behind it up by one */
	do idx = message.n_user_fields to position by -1;
	     message_user_fields_list.user_fields (idx + 1) = message_user_fields_list.user_fields (idx);
	end;

	/*** Copy in the new user-defined field and, if needed, copy the actual data */
	the_user_field_ptr = addr (message_user_fields_list.user_fields (position));
	the_user_field.header = message_user_field.header;
	go to ADD_USER_FIELD (message_user_field.field_type);

ADD_USER_FIELD (1):					/* user-defined text field */
	the_text_user_field.multiline_text = message_text_user_field.multiline_text;
	string (the_text_user_field.flags.reserved) = ""b;/* ... turns off the "free_text" flag */
	if (message_text_user_field.text_ptr = null ()) | (message_text_user_field.text_lth = 0) then do;
	     the_text_user_field.text_ptr = addr (NULL_STRING);
	     the_text_user_field.text_lth = 0;
	end;
	else if copy_user_field_content then do;	/* copy it no matter what */
COPY_USER_FIELD_TEXT:
	     if the_text_user_field.multiline_text then	/* ... eliminate tabs from multiline text */
		call normalize_multiline_field (message_text_user_field_text, the_text_user_field.text_ptr,
		     the_text_user_field.text_lth);
	     else call normalize_single_line_field (message_text_user_field_text, the_text_user_field.text_ptr,
		     the_text_user_field.text_lth);
	     addr (the_text_user_field.flags.reserved) -> message_text_field_reserved_flags.free_text = "1"b;
	end;
	else if ^mlsys_data_$valid_segments (binary (baseno (addr (message_text_user_field_text)), 18, 0)) then
	     go to COPY_USER_FIELD_TEXT;
	else if the_text_user_field.multiline_text then	/* copy it only if it's improperly formatted */
	     if index (message_text_user_field_text, HT) ^= 0 then
		go to COPY_USER_FIELD_TEXT;		/* ... have to "canonicalize" tabs */
	     else do;				/* ... caller's text is OK */
		the_text_user_field.text_ptr = copy_ptr (message_text_user_field.text_ptr);
		the_text_user_field.text_lth = message_text_user_field.text_lth;
	     end;
	else /*** if ^the_text_user_field.multiline_text then */
	     do;					/* copy it only if it's improperly formatted */
	     if search (message_text_user_field_text, NON_SPACE_WHITESPACE) ^= 0 then go to COPY_USER_FIELD_TEXT;
	     if verify (message_text_user_field_text, SPACE) ^= 1 then go to COPY_USER_FIELD_TEXT;
	     if substr (message_text_user_field_text, length (message_text_user_field_text), 1) = SPACE then
		go to COPY_USER_FIELD_TEXT;
	     if index (message_text_user_field_text, SPACE_SPACE) ^= 0 then go to COPY_USER_FIELD_TEXT;
	     the_text_user_field.text_ptr = copy_ptr (message_text_user_field.text_ptr);
	     the_text_user_field.text_lth = message_text_user_field.text_lth;
	end;					/* ... above is executed iff caller's text is OK */
	go to END_ADD_USER_FIELD_CASE;

ADD_USER_FIELD (2):					/* user-defined address list field */
	the_address_list_user_field.address_list_ptr = copy_ptr (message_address_list_user_field.address_list_ptr);
	if the_address_list_user_field.address_list_ptr ^= null () then do;
	     if copy_user_field_content then
		call mlsys_address_list_mgr_$copy_address_list (the_address_list_user_field.address_list_ptr,
		     the_address_list_user_field.address_list_ptr, (0));
	     call mlsys_address_list_mgr_$set_read_only (the_address_list_user_field.address_list_ptr);
	     call mlsys_address_list_mgr_$increment_reference_count (the_address_list_user_field.address_list_ptr);
	end;
	go to END_ADD_USER_FIELD_CASE;

ADD_USER_FIELD (3):					/* user-defined date field */
	the_date_user_field.date_time = message_date_user_field.date_time;
	go to END_ADD_USER_FIELD_CASE;

ADD_USER_FIELD (4):					/* user-defined integer field */
	the_integer_user_field.value = message_integer_user_field.value;
	go to END_ADD_USER_FIELD_CASE;

END_ADD_USER_FIELD_CASE:
	message_user_fields_list.n_user_fields, message.n_user_fields = message.n_user_fields + 1;

	return;

     end add_user_field_internal;
%page;
/* Delete the specified section of the message body */

delete_body_section:				/* ... for any type of message */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	go to DELETE_BODY_SECTION_COMMON;


delete_body_section_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;


DELETE_BODY_SECTION_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;

	if (position < 1) | (position > message.n_body_sections) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	call delete_body_section_internal (position);

	if message_reserved_data.type = NEW_MESSAGE then	/* record date/time of latest change to message body */
	     message_reserved_data.info_ptr -> new_message_info.date_time_created = clock ();

	P_code = 0;				/* success */

	return;



/* Actually deletes a message body section (called by several entrypoints) */

delete_body_section_internal:
     procedure (p_position);

dcl  p_position fixed binary parameter;
dcl  idx fixed binary;

	message_body_section_ptr = addr (message.body.body_sections (p_position));

	if message_body_section.section_type = MESSAGE_PREFORMATTED_BODY_SECTION then
	     if message_preformatted_body_section_reserved_data.free_text then
		if (message_preformatted_body_section.text_ptr ^= null ())
		     & (message_preformatted_body_section.text_ptr ^= addr (NULL_STRING)) then do;
		     free message_preformatted_body_section_text in (mlsys_area);
		     message_preformatted_body_section.text_ptr = null ();
		end;
		else ;
	     else ;

	else if message_body_section.section_type = MESSAGE_BIT_STRING_BODY_SECTION then
	     if message_bit_string_body_section_reserved_data.free_bit_string then
		if (message_bit_string_body_section.bit_string_ptr ^= null ())
		     & (message_bit_string_body_section.bit_string_ptr ^= addr (NULL_STRING)) then do;
		     free message_bit_string_body_section_bit_string in (mlsys_area);
		     message_bit_string_body_section.bit_string_ptr = null ();
		end;

	do idx = (p_position + 1) to message.n_body_sections;
	     message.body.body_sections (idx - 1) = message.body.body_sections (idx);
	end;

	message.n_body_sections = message.n_body_sections - 1;

	/*** Recompute the number of lines in the body */
	message.body.total_lines = 0;
	do idx = 1 to message.n_body_sections while (message.body.total_lines ^= -1);
	     if message.body.body_sections (idx).section_n_lines = -1 then
		message.body.total_lines = -1;
	     else message.body.total_lines =
		     message.body.total_lines + message.body.body_sections (idx).section_n_lines;
	end;

	if message.body.total_lines ^= -1 then		/* take the lines in between sections into account */
	     message.body.total_lines = message.body.total_lines + max (message.n_body_sections, 1) - 1;

	return;

     end delete_body_section_internal;
%page;
/* Delete the specified redistribution from the message's redistributions list */

delete_redistribution:				/* ... for any type of message */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	go to DELETE_REDISTRIBUTION_COMMON;


delete_redistribution_no_copy:			/* ... for any type of message */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;


DELETE_REDISTRIBUTION_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;

	if (position < 1) | (position > message.n_redistributions) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	call delete_redistribution_internal (position);

	P_code = 0;				/* success */

	return;



/* Actually deletes a redistribution (called by several entrypoints) */

delete_redistribution_internal:
     procedure (p_position);

dcl  p_position fixed binary parameter;
dcl  idx fixed binary;

	message_redistribution_ptr = addr (message_redistributions_list.redistributions (p_position));

	call delete_envelope (addr (message_redistribution.envelope));
						/* release all possible data in the envelope */

	if message_redistribution.from ^= null () then
	     call mlsys_address_list_mgr_$decrement_reference_count (message_redistribution.from);

	if message_redistribution.to ^= null () then
	     call mlsys_address_list_mgr_$decrement_reference_count (message_redistribution.to);

	if addr (message_redistribution.comment.flags.reserved) -> message_text_field_reserved_flags.free_text then
	     if (message_redistribution.comment.text_ptr ^= null ())
		& (message_redistribution.comment.text_ptr ^= addr (NULL_STRING)) then do;
		free message_redistribution_comment in (mlsys_area);
		message_redistribution.comment.text_ptr = null ();
	     end;

	do idx = (p_position + 1) to message.n_redistributions;
	     message_redistributions_list.redistributions (idx - 1) =
		message_redistributions_list.redistributions (idx);
	end;

	message_redistributions_list.n_redistributions, message.n_redistributions = message.n_redistributions - 1;

	return;

     end delete_redistribution_internal;
%page;
/* Delete the specified message reference from the message's list of reply references */

delete_reply_reference:				/* ... for any type message */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	go to DELETE_REPLY_REFERENCE_COMMON;


delete_reply_reference_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;


DELETE_REPLY_REFERENCE_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;

	if (position < 1) | (position > message.n_reply_references) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	call delete_reference_internal (message.n_reply_references, message.reply_references, position);

	P_code = 0;				/* success */

	return;



/* Actually deletes a reference (called by several entrypoints) */

delete_reference_internal:
     procedure (p_n_references, p_references_ptr, p_position);

dcl  p_n_references fixed binary parameter;
dcl  p_references_ptr pointer parameter;
dcl  p_position fixed binary parameter;
dcl  idx fixed binary;

	message_references_list_ptr = p_references_ptr;
	message_reference_ptr = addr (message_references_list.references (p_position));

	if message_reference.from ^= null () then
	     call mlsys_address_list_mgr_$decrement_reference_count (message_reference.from);

	if addr (message_reference.subject.flags.reserved) -> message_text_field_reserved_flags.free_text then
	     if (message_reference.subject.text_ptr ^= null ())
		& (message_reference.subject.text_ptr ^= addr (NULL_STRING)) then do;
		free message_reference_subject in (mlsys_area);
		message_reference.subject.text_ptr = null ();
	     end;

	do idx = (p_position + 1) to p_n_references;
	     message_references_list.references (idx - 1) = message_references_list.references (idx);
	end;

	message_references_list.n_references, p_n_references = p_n_references - 1;

	return;

     end delete_reference_internal;
%page;
/* Delete the specified user-defined field from the message */

delete_user_field:					/* ... for any type of message */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	go to DELETE_USER_FIELD_COMMON;


delete_user_field_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_position, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;


DELETE_USER_FIELD_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;

	if (position < 1) | (position > message.n_user_fields) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	call delete_user_field_internal (position);

	P_code = 0;				/* success */

	return;



/* Actually deletes a user field (called from several entrypoints) */

delete_user_field_internal:
     procedure (p_position);

dcl  p_position fixed binary parameter;
dcl  idx fixed binary;

	message_user_field_ptr = addr (message_user_fields_list.user_fields (p_position));

	if message_user_field.field_type = MESSAGE_TEXT_USER_FIELD then
	     if addr (message_text_user_field.flags.reserved) -> message_text_field_reserved_flags.free_text then
		if (message_text_user_field.text_ptr ^= null ())
		     & (message_text_user_field.text_ptr ^= addr (NULL_STRING)) then do;
		     free message_text_user_field_text in (mlsys_area);
		     message_text_user_field.text_ptr = null ();
		end;
		else ;
	     else ;

	else if message_user_field.field_type = MESSAGE_ADDRESS_LIST_USER_FIELD then
	     if message_address_list_user_field.address_list_ptr ^= null () then
		call mlsys_address_list_mgr_$decrement_reference_count (message_address_list_user_field
		     .address_list_ptr);

	do idx = (p_position + 1) to message.n_user_fields;
	     message_user_fields_list.user_fields (idx - 1) = message_user_fields_list.user_fields (idx);
	end;

	message_user_fields_list.n_user_fields, message.n_user_fields = message.n_user_fields - 1;

	return;

     end delete_user_field_internal;
%page;
/* Replace the message envelope (if any) with the new, supplied envelope */

replace_message_envelope:				/* ... for any type of message */
     entry (P_message_ptr, P_message_envelope_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;

	message_ptr = copy_ptr (P_message_ptr);
	message_envelope_parameter_ptr = P_message_envelope_parameter_ptr;

	if message_envelope_parameter.version ^= MESSAGE_ENVELOPE_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	message_envelope_ptr = addr (message_envelope_parameter.envelope);
	if ^verify_envelope (message_envelope_ptr, P_code) then return;

	call delete_envelope (addr (message.envelope));	/* get rid of whatever might be there now */
	call set_envelope (message_envelope_ptr, addr (message.envelope));

	P_code = 0;				/* success */

	return;



/* Copy the data from the caller's message envelope into the specified envelope */

set_envelope:
     procedure (p_source_envelope_ptr, p_target_envelope_ptr);

dcl  1 source_envelope aligned based (p_source_envelope_ptr) like message_envelope;
dcl  p_source_envelope_ptr pointer parameter;

dcl  1 target_envelope aligned based (p_target_envelope_ptr) like message_envelope;
dcl  p_target_envelope_ptr pointer parameter;

	target_envelope = source_envelope;		/* copy the data exactly as it stands */

	if target_envelope.sender ^= null () then do;
	     target_envelope.sender = copy_ptr (target_envelope.sender);
	     call mlsys_address_mgr_$increment_reference_count (target_envelope.sender);
	end;

	if source_envelope.trace ^= null () then call set_trace (source_envelope.trace, target_envelope.trace);

	if target_envelope.delivered_by ^= null () then do;
	     target_envelope.delivered_by = copy_ptr (target_envelope.delivered_by);
	     call mlsys_address_mgr_$increment_reference_count (target_envelope.delivered_by);
	end;

	if target_envelope.acknowledge_to ^= null () then do;
	     target_envelope.acknowledge_to = copy_ptr (target_envelope.acknowledge_to);
	     call mlsys_address_mgr_$increment_reference_count (target_envelope.acknowledge_to);
	end;

	return;



/* Internal to set_envelope: copy the caller's message_trace */

set_trace:
	procedure (p_source_trace_ptr, p_target_trace_ptr);

dcl  (p_source_trace_ptr, p_target_trace_ptr) pointer parameter;
dcl  idx fixed binary;

	     message_trace_n_relays = p_source_trace_ptr -> message_trace.n_relays;

	     allocate message_trace in (mlsys_area) set (p_target_trace_ptr);

	     p_target_trace_ptr -> message_trace.version = MESSAGE_TRACE_VERSION_2;
	     p_target_trace_ptr -> message_trace.reserved, p_target_trace_ptr -> message_trace.pad = ""b;

	     address_route_ptr = copy_ptr (p_source_trace_ptr -> message_trace.implicit_route);
	     if address_route_ptr ^= null () then	/* there's an implicit route */
		if mlsys_data_$valid_segments (binary (baseno (address_route_ptr), 18, 0)) then
		     p_target_trace_ptr -> message_trace.implicit_route = address_route_ptr;
		else call mlsys_address_route_mgr_$create_address_route (address_route.relays,
			p_target_trace_ptr -> message_trace.implicit_route);
	     else p_target_trace_ptr -> message_trace.implicit_route = null ();
	     if p_target_trace_ptr -> message_trace.implicit_route ^= null () then
		call mlsys_address_route_mgr_$increment_reference_count (p_target_trace_ptr
		     -> message_trace.implicit_route);

	     do idx = 1 to p_target_trace_ptr -> message_trace.n_relays;
		p_target_trace_ptr -> message_trace.relays (idx) = p_source_trace_ptr -> message_trace.relays (idx);
		if (idx = p_target_trace_ptr -> message_trace.n_relays)
		     &
		     mlsys_nit_interface_$is_local_system (p_target_trace_ptr
		     -> message_trace.relays (idx).receiving_host) then do;
		     p_target_trace_ptr -> message_trace.relays (idx).sending_host =
			mlsys_nit_interface_$get_fully_qualified_name (p_target_trace_ptr
			-> message_trace.relays (idx).sending_host);
		     p_target_trace_ptr -> message_trace.relays (idx).receiving_host =
			mlsys_nit_interface_$get_fully_qualified_name (p_target_trace_ptr
			-> message_trace.relays (idx).receiving_host);
		end;
		else do;
		     p_target_trace_ptr -> message_trace.relays (idx).sending_host =
			translate (p_target_trace_ptr -> message_trace.relays (idx).sending_host, UPPERCASE,
			LOWERCASE);
		     p_target_trace_ptr -> message_trace.relays (idx).receiving_host =
			translate (p_target_trace_ptr -> message_trace.relays (idx).receiving_host, UPPERCASE,
			LOWERCASE);
		end;
		if p_target_trace_ptr -> message_trace.relays (idx).relay_recipient ^= null () then do;
		     p_target_trace_ptr -> message_trace.relays (idx).relay_recipient =
			copy_ptr (p_target_trace_ptr -> message_trace.relays (idx).relay_recipient);
		     call mlsys_address_mgr_$increment_reference_count (p_target_trace_ptr
			-> message_trace.relays (idx).relay_recipient);
		end;
	     end;

	     return;

	end set_trace;

     end set_envelope;



/* Delete the given message envelope by freeing all data it references */

delete_envelope:
     procedure (p_envelope_ptr);

dcl  1 p_envelope aligned based (p_envelope_ptr) like message_envelope;
dcl  p_envelope_ptr pointer parameter;			/* might belong to a redistribution */

	if p_envelope.acknowledge_to ^= null () then
	     call mlsys_address_mgr_$decrement_reference_count (p_envelope.acknowledge_to);

	if p_envelope.delivered_by ^= null () then
	     call mlsys_address_mgr_$decrement_reference_count (p_envelope.delivered_by);

	if p_envelope.trace ^= null () then call delete_trace (p_envelope.trace);

	if p_envelope.sender ^= null () then call mlsys_address_mgr_$decrement_reference_count (p_envelope.sender);

	return;



/* Internal to delete_envelope: delete a message trace and all referenced substructure */

delete_trace:
	procedure (p_trace_ptr);

dcl  p_trace_ptr pointer parameter;
dcl  idx fixed binary;

	     message_trace_ptr = p_trace_ptr;		/* can't use like because of refer extent */

	     do idx = 1 to message_trace.n_relays;
		if message_trace.relays (idx).relay_recipient ^= null () then
		     call mlsys_address_mgr_$decrement_reference_count (message_trace.relays (idx).relay_recipient);
	     end;

	     if message_trace.implicit_route ^= null () then
		call mlsys_address_route_mgr_$decrement_reference_count (message_trace.implicit_route);

	     free message_trace in (mlsys_area);
	     p_trace_ptr = null ();			/* it's gone now */

	     return;

	end delete_trace;

     end delete_envelope;
%page;
/* Replace the From field of the message with the supplied address list */

replace_from_no_copy:				/* ... for any type of message */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.from, P_address_list_ptr, "0"b, P_code);
	return;


replace_from_new:					/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.from, P_address_list_ptr, "1"b, P_code);
	return;



/* Replace the Reply-To field of the message with the supplied address list */

replace_reply_to_no_copy:				/* ... for any type of message */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.reply_to, P_address_list_ptr, "0"b, P_code);
	return;


replace_reply_to_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.reply_to, P_address_list_ptr, "1"b, P_code);
	return;
%page;
/* Replace the To field of the message with the supplied address list */

replace_to_no_copy:					/* ... for any type of message */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.to, P_address_list_ptr, "0"b, P_code);
	return;


replace_to_new:					/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.to, P_address_list_ptr, "1"b, P_code);
	return;



/* Replace the cc field of the message with the supplied address list */

replace_cc_no_copy:					/* ... for any type of message */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.cc, P_address_list_ptr, "0"b, P_code);
	return;


replace_cc_new:					/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.cc, P_address_list_ptr, "1"b, P_code);
	return;
%page;
/* Replace the bcc field of the message with the supplied address list */

replace_bcc_no_copy:				/* ... for any type of message */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.bcc, P_address_list_ptr, "0"b, P_code);
	return;


replace_bcc_new:					/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_address_list_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	message_ptr = copy_ptr (P_message_ptr);
	call replace_address_list_field (message.bcc, P_address_list_ptr, "1"b, P_code);
	return;



/* Actually replaces the given address list field (From, Reply-To, To, cc, bcc) in the message */

replace_address_list_field:
     procedure (p_field, p_address_list_ptr, p_copy_address_list, p_code);

dcl  (p_field, p_address_list_ptr) pointer parameter;
dcl  p_copy_address_list bit (1) aligned parameter;	/* ON => make a copy of the caller's address list */
dcl  p_code fixed binary (35) parameter;

	if p_address_list_ptr = null () then do;	/* caller wants the new value of the field to be empty */
	     call mlsys_address_list_mgr_$create_read_only_address_list (ADDRESS_LIST_VERSION_2, address_list_ptr,
		p_code);
	     if p_code ^= 0 then return;
	end;
	else do;
	     if ^mlsys_address_list_mgr_$verify_address_list (p_address_list_ptr, p_code) then return;
	     if p_copy_address_list then do;
		call mlsys_address_list_mgr_$copy_address_list (p_address_list_ptr, address_list_ptr, p_code);
		if p_code ^= 0 then return;
	     end;
	     else address_list_ptr = copy_ptr (p_address_list_ptr);
	end;

	if p_field ^= null () then			/* get rid of the old one ... */
	     call mlsys_address_list_mgr_$decrement_reference_count (p_field);

	p_field = address_list_ptr;
	call mlsys_address_list_mgr_$set_read_only (p_field);
	call mlsys_address_list_mgr_$increment_reference_count (p_field);

	p_code = 0;				/* success */

	return;

     end replace_address_list_field;
%page;
/* Replace the subject of the message with the supplied text */

replace_subject:					/* ... for any type of message */
     entry (P_message_ptr, P_subject, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_subject = "1"b;
	go to REPLACE_SUBJECT_COMMON;


replace_subject_no_copy:				/* ... for any type of message: subject text in our ring */
     entry (P_message_ptr, P_subject, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_subject = "0"b;
	go to REPLACE_SUBJECT_COMMON;


replace_subject_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_subject, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	copy_subject = "1"b;
	go to REPLACE_SUBJECT_COMMON;


REPLACE_SUBJECT_COMMON:
	message_ptr = copy_ptr (P_message_ptr);

	if addr (message.subject.flags.reserved) -> message_text_field_reserved_flags.free_text then
	     if (message.subject.text_ptr ^= null ()) & (message.subject.text_ptr ^= addr (NULL_STRING)) then do;
		free message_subject in (mlsys_area);
		message.subject.text_ptr = null ();
	     end;

	string (message.subject.flags) = ""b;		/* turns off both multiline_text & free_text */

	if length (P_subject) = 0 then do;		/* new subject is empty */
	     message.subject.text_ptr = addr (NULL_STRING);
	     message.subject.text_lth = 0;
	end;

	else if copy_subject then do;			/* copy the caller's subject */
COPY_SUBJECT_TEXT:
	     call normalize_single_line_field (P_subject, message.subject.text_ptr, message.subject.text_lth);
	     addr (message.subject.flags.reserved) -> message_text_field_reserved_flags.free_text = "1"b;
	end;

	else do;					/* copy it only if it's improperly formatted */
	     message.subject.text_ptr = addr (P_subject);
	     message.subject.text_ptr = copy_ptr (message.subject.text_ptr);
	     message.subject.text_lth = length (P_subject);
	     if ^mlsys_data_$valid_segments (binary (baseno (addr (message_subject)), 18, 0)) then
		go to COPY_SUBJECT_TEXT;
	     if search (message_subject, NON_SPACE_WHITESPACE) ^= 0 then go to COPY_SUBJECT_TEXT;
	     if verify (message_subject, SPACE) ^= 1 then go to COPY_SUBJECT_TEXT;
	     if substr (message_subject, length (message_subject), 1) = SPACE then go to COPY_SUBJECT_TEXT;
	     if index (message_subject, SPACE_SPACE) ^= 0 then go to COPY_SUBJECT_TEXT;
	end;

	P_code = 0;				/* success */

	return;
%page;
/* Set the AIM access class of the message:  If the access class is less than or isolated from the user's process
   authorization, this entrypoint will check for ring-1 privilege */

set_access_class_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_access_class, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;

	message_ptr = copy_ptr (P_message_ptr);
	access_class = P_access_class;

	P_code = 0;				/* assume success */

	if aim_check_$greater_or_equal (access_class, get_authorization_ ()) then
	     message.access_class = access_class;	/* access class is OK without privilege */

	else do;					/* user will need ring-1 privilege to send this message */
	     string (user_privileges) = get_privileges_ ();
	     if user_privileges.ring1 then
		message.access_class = access_class;
	     else P_code = error_table_$ai_restricted;
	end;

	return;
%page;
/* Replace the entire message body with the single, new, supplied section */

replace_body:					/* ... for any type of message */
     entry (P_message_ptr, P_message_body_section_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "1"b;
	go to REPLACE_BODY_COMMON;


replace_body_no_copy:				/* ... for any type of message: section content in our ring */
     entry (P_message_ptr, P_message_body_section_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "0"b;
	go to REPLACE_BODY_COMMON;


replace_body_new:					/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_message_body_section_parameter_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "1"b;


REPLACE_BODY_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	message_body_section_parameter_ptr = P_message_body_section_parameter_ptr;

	if message_body_section_parameter.version ^= MESSAGE_BODY_SECTION_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if ^verify_body_section (addr (message_body_section_parameter.section), P_code) then return;

	/*** Delete the entire old body */
	do idx = message.n_body_sections to 1 by -1;
	     call delete_body_section_internal (idx);
	end;

	position = 1;				/* since there's nothing else left now */
	message_body_section_ptr = addr (message_body_section_parameter.section);
	call add_body_section_internal ();

	if message_reserved_data.type = NEW_MESSAGE then	/* record date/time of latest change to message body */
	     message_reserved_data.info_ptr -> new_message_info.date_time_created = clock ();

	P_message_ptr = message_ptr;			/* in case we had to expand message.body_sections */
	P_code = 0;				/* success */

	return;
%page;
/* Replace a section of the message body with the new, supplied section */

replace_body_section:				/* ... for any type of message */
     entry (P_message_ptr, P_position, P_message_body_section_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "1"b;
	go to REPLACE_BODY_SECTION_COMMON;


replace_body_section_no_copy:				/* ... for any type of message: section content in our ring */
     entry (P_message_ptr, P_position, P_message_body_section_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "0"b;
	go to REPLACE_BODY_SECTION_COMMON;


replace_body_section_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_position, P_message_body_section_parameter_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	copy_section_content = "1"b;


REPLACE_BODY_SECTION_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;
	message_body_section_parameter_ptr = P_message_body_section_parameter_ptr;

	if message_body_section_parameter.version ^= MESSAGE_BODY_SECTION_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if ^verify_body_section (addr (message_body_section_parameter.section), P_code) then return;

	if (position < 1) | (position > message.n_body_sections) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	call delete_body_section_internal (position);	/* get rid of the old one ... */
	message_body_section_ptr = addr (message_body_section_parameter.section);
	call add_body_section_internal ();		/* ... and put in the new one */

	if message_reserved_data.type = NEW_MESSAGE then	/* record date/time of latest change to message body */
	     message_reserved_data.info_ptr -> new_message_info.date_time_created = clock ();

	P_message_ptr = message_ptr;			/* in case we had to expand message.body_sections */
	P_code = 0;				/* success */

	return;
%page;
/* Replace a redistribution in the message's redistributions list with the new, supplied redistribution */

replace_redistribution:				/* ... for any type of message */
     entry (P_message_ptr, P_position, P_message_redistribution_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_redistribution_data = "1"b;
	go to REPLACE_REDISTRIBUTION_COMMON;


replace_redistribution_no_copy:			/* ... for any type of message; data already in our ring */
     entry (P_message_ptr, P_position, P_message_redistribution_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_redistribution_data = "0"b;


REPLACE_REDISTRIBUTION_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;
	message_redistribution_parameter_ptr = P_message_redistribution_parameter_ptr;

	if message_redistribution_parameter.version ^= MESSAGE_REDISTRIBUTION_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if ^verify_redistribution (addr (message_redistribution_parameter.redistribution), P_code) then return;

	if (position < 1) | (position > message.n_redistributions) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	call delete_redistribution_internal (position);	/* get rid of the old one ... */
	message_redistribution_ptr = addr (message_redistribution_parameter.redistribution);
	call add_redistribution_internal ();		/* ... and add the new one */

	P_code = 0;				/* success */

	return;
%page;
/* Replace a message reference in the message's list of reply references with the new, supplied message reference */

replace_reply_reference:				/* ... for any type message */
     entry (P_message_ptr, P_position, P_message_reference_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_reference_data = "1"b;
	go to REPLACE_REPLY_REFERENCE_COMMON;


replace_reply_reference_no_copy:			/* ... for any type message: data already in our ring */
     entry (P_message_ptr, P_position, P_message_reference_parameter_ptr, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_reference_data = "0"b;
	go to REPLACE_REPLY_REFERENCE_COMMON;


replace_reply_reference_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_position, P_referenced_message_ptr, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	if ^verify_im_message_internal (P_referenced_message_ptr, P_code) then return;
	copy_reference_data = "0"b;			/* it's already in the right place from in-mailbox message */

	message_ptr = copy_ptr (P_referenced_message_ptr);/* need to access the original message temporarily */
	message_reference_parameter_ptr = addr (local_mrfp);
	message_reference_parameter.reference.message_id = message.message_id;
	message_reference_parameter.reference.date_time_created = message.date_time_created;
	message_reference_parameter.reference.from = message.from;
	message_reference_parameter.reference.subject = message.subject;
	go to REPLACE_REPLY_REFERENCE_NO_RP_CHECK;


REPLACE_REPLY_REFERENCE_COMMON:
	message_reference_parameter_ptr = P_message_reference_parameter_ptr;
	if message_reference_parameter.version ^= MESSAGE_REFERENCE_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;
	if ^verify_reference (addr (message_reference_parameter.reference), P_code) then return;

REPLACE_REPLY_REFERENCE_NO_RP_CHECK:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;

	if (position < 1) | (position > message.n_reply_references) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	/*** Check for duplicate reply references (except, of course, for the one about to be deleted) */
	do idx = 1 to (position - 1), (position + 1) to message.n_reply_references;
	     if message.reply_references -> message_references_list.references (idx).message_id
		= message_reference_parameter.reference.message_id then do;
		P_position = idx;			/* let caller know where the duplicate resides */
		P_code = mlsys_et_$duplicate_reply_reference;
		return;
	     end;
	end;

	call delete_reference_internal (message.n_reply_references, message.reply_references, position);
	message_reference_ptr = addr (message_reference_parameter.reference);
	call add_reference_internal (message.n_reply_references, message.reply_references);

	P_code = 0;				/* success */

	return;
%page;
/* Replace a user-defined field in the message with the new, supplied user-defined field */

replace_user_field:					/* ... for any type of message */
     entry (P_message_ptr, P_position, P_message_user_field_parameter_ptr, P_allow_duplicates, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_user_field_content = "1"b;
	go to REPLACE_USER_FIELD_COMMON;


replace_user_field_no_copy:				/* ... for any type of message: data already in our ring */
     entry (P_message_ptr, P_position, P_message_user_field_parameter_ptr, P_allow_duplicates, P_code);

	if ^verify_message_internal (P_message_ptr, P_code) then return;
	copy_user_field_content = "0"b;
	go to REPLACE_USER_FIELD_COMMON;


replace_user_field_new:				/* ... for a new message: target of user-ring gate */
     entry (P_message_ptr, P_position, P_message_user_field_parameter_ptr, P_allow_duplicates, P_code);

	if ^verify_new_message_internal (P_message_ptr, P_code) then return;
	copy_user_field_content = "1"b;


REPLACE_USER_FIELD_COMMON:
	message_ptr = copy_ptr (P_message_ptr);
	position = P_position;
	message_user_field_parameter_ptr = P_message_user_field_parameter_ptr;

	if message_user_field_parameter.version ^= MESSAGE_USER_FIELD_PARAMETER_VERSION_2 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	if ^verify_user_field (addr (message_user_field_parameter.user_field), P_code) then return;

	if (position < 1) | (position > message.n_user_fields) then do;
	     P_code = error_table_$bad_index;
	     return;
	end;

	/*** Check for duplicate fields if requested */
	if ^P_allow_duplicates then do;
	     do idx = 1 to (position - 1), (position + 1) to message.n_user_fields;
		if message_user_fields_list.user_fields (idx).field_id
		     = message_user_field_parameter.user_field.field_id then do;
		     P_position = idx;		/* let caller know where the duplicate resides */
		     P_code = mlsys_et_$duplicate_user_field;
		     return;
		end;
	     end;
	end;

	call delete_user_field_internal (position);	/* delete the old one ... */
	message_user_field_ptr = addr (message_user_field_parameter.user_field);
	call add_user_field_internal ();		/* ... and add the new one */

	P_code = 0;				/* success */

	return;
%page;
/* Verify that the caller supplied a message structure */

verify_message:
     entry (P_message_ptr, P_date_time_created, P_code) returns (bit (1) aligned);

	if verify_message_internal (P_message_ptr, P_code) then do;
						/* this call will set the status code */
	     if addr (P_message_ptr -> message.reserved) -> message_reserved_data.type = NEW_MESSAGE then
		P_date_time_created =
		     addr (P_message_ptr -> message.reserved) -> message_reserved_data.info_ptr
		     -> new_message_info.date_time_created;
	     else P_date_time_created = P_message_ptr -> message.date_time_created;
	     return ("1"b);
	end;

	else return ("0"b);



/* Actually verifies a message */

verify_message_internal:
     procedure (p_message_ptr, p_code) returns (bit (1) aligned);

dcl  p_message_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	if p_message_ptr = null () then p_code = mlsys_et_$not_message;

	else if ^mlsys_data_$valid_segments (binary (baseno (p_message_ptr), 18, 0)) then
	     p_code = mlsys_et_$not_message;		/* supplied structure wasn't allocated by us */

	else if p_message_ptr -> message.version ^= MESSAGE_VERSION_2 then p_code = mlsys_et_$not_message;
						/* not an message structure */

	else p_code = 0;				/* supplied structure passes all tests */

	return ((p_code = 0));

     end verify_message_internal;
%page;
/* Verify that the caller supplied a pointer to a properly constructed message structure which is an in-mailbox message */

verify_im_message:
     entry (P_message_ptr, P_im_message_info_ptr, P_code) returns (bit (1) aligned);

	if verify_im_message_internal (P_message_ptr, P_code) then do;
						/* above call will set the status code */
	     P_im_message_info_ptr =
		copy_ptr (addr (P_message_ptr -> message.reserved) -> message_reserved_data.info_ptr);
	     return ("1"b);
	end;

	else return ("0"b);



/* Actually verifies an in-mailbox message */

verify_im_message_internal:
     procedure (p_message_ptr, p_code) returns (bit (1) aligned);

dcl  p_message_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	if ^verify_message_internal (p_message_ptr, p_code) then ;
						/* not a message */

	else if addr (p_message_ptr -> message.reserved) -> message_reserved_data.type ^= IN_MAILBOX_MESSAGE then
	     p_code = mlsys_et_$not_in_mailbox_message;	/* not an in-mailbox message */

	else p_code = 0;				/* supplied structure passes all tests */

	return ((p_code = 0));

     end verify_im_message_internal;
%page;
/* Verify that the caller supplied a pointer to a properly constructed message structure which may be modified by
   user-ring software via the mail_system_ gate */

verify_new_message:
     entry (P_message_ptr, P_date_time_created, P_code) returns (bit (1) aligned);

	if verify_new_message_internal (P_message_ptr, P_code) then do;
						/* above call will set the status code */
	     P_date_time_created =
		addr (P_message_ptr -> message.reserved) -> message_reserved_data.info_ptr
		-> new_message_info.date_time_created;
	     return ("1"b);
	end;

	else return ("0"b);



/* Actually verifies a new message */

verify_new_message_internal:
     procedure (p_message_ptr, p_code) returns (bit (1) aligned);

dcl  p_message_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	if ^verify_message_internal (p_message_ptr, p_code) then ;
						/* not a message */

	else if addr (p_message_ptr -> message.reserved) -> message_reserved_data.type ^= NEW_MESSAGE then
	     p_code = mlsys_et_$not_new_message;	/* not a message which user-ring can modify */

	else p_code = 0;				/* supplied structure passes all tests */

	return ((p_code = 0));

     end verify_new_message_internal;
%page;
/* Verify the the supplied message trace contains valid data */

verify_trace:
     procedure (p_trace_ptr, p_code) returns (bit (1) aligned);

dcl  p_trace_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;
dcl  ignore bit (1) aligned;
dcl  idx fixed binary;

	if p_trace_ptr -> message_trace.version ^= MESSAGE_TRACE_VERSION_2 then
	     p_code = error_table_$unimplemented_version;

	else do;
	     p_code = 0;				/* assume success for now */

	     if p_trace_ptr -> message_trace.implicit_route ^= null () then
		if p_trace_ptr -> message_trace.implicit_route -> address_route.version ^= ADDRESS_ROUTE_VERSION_1
		then p_code = error_table_$unimplemented_version;

	     do idx = 1 to p_trace_ptr -> message_trace.n_relays while (p_code = 0);
		if p_trace_ptr -> message_trace.relays (idx).relay_recipient ^= null () then
		     ignore =
			mlsys_address_mgr_$verify_address (p_trace_ptr
			-> message_trace.relays (idx).relay_recipient, p_code);
	     end;
	end;

	return ((p_code = 0));

     end verify_trace;
%page;
/* Verify that the supplied message envelope contains valid data */

verify_envelope:
     procedure (p_envelope_ptr, p_code) returns (bit (1) aligned);

dcl  1 envelope aligned based (p_envelope_ptr) like message_envelope;
dcl  p_envelope_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;
dcl  ignore bit (1) aligned;

	if envelope.sender ^= null () then ignore = mlsys_address_mgr_$verify_address (envelope.sender, p_code);

	if (p_code = 0) & (envelope.trace ^= null ()) then ignore = verify_trace (envelope.trace, p_code);

	if (p_code = 0) & (envelope.delivered_by ^= null ()) then
	     ignore = mlsys_address_mgr_$verify_address (envelope.delivered_by, p_code);

	if (p_code = 0) & (envelope.acknowledge_to ^= null ()) then
	     ignore = mlsys_address_mgr_$verify_address (envelope.acknowledge_to, p_code);

	return ((p_code = 0));

     end verify_envelope;



/* Verify that the supplied message redistribution contains valid data */

verify_redistribution:
     procedure (p_redistribution_ptr, p_code) returns (bit (1) aligned);

dcl  1 redistribution aligned based (p_redistribution_ptr) like message_redistribution;
dcl  p_redistribution_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;
dcl  ignore bit (1) aligned;

	ignore = verify_envelope (addr (redistribution.envelope), p_code);

	if (p_code = 0) & (redistribution.from ^= null ()) then
	     ignore = mlsys_address_list_mgr_$verify_address_list (redistribution.from, p_code);

	if (p_code = 0) & (redistribution.to ^= null ()) then
	     ignore = mlsys_address_list_mgr_$verify_address_list (redistribution.to, p_code);

	return ((p_code = 0));

     end verify_redistribution;
%page;
/* Verify that the supplied user-defined field contains valid data */

verify_user_field:
     procedure (p_user_field_ptr, p_code) returns (bit (1) aligned);

dcl  1 user_field aligned based (p_user_field_ptr) like message_user_field;
dcl  1 address_list_user_field aligned based (p_user_field_ptr) like message_address_list_user_field;
dcl  p_user_field_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;
dcl  ignore bit (1) aligned;

	call mlsys_field_id_mgr_$get_user_field_name (user_field.field_id, (""), p_code);
	if p_code = error_table_$smallarg then p_code = 0;/* the ID is OK: we didn't supply space for the name */

	if (p_code = 0)
	     & ((user_field.field_type < MESSAGE_TEXT_USER_FIELD)
	     | (user_field.field_type > MESSAGE_INTEGER_USER_FIELD)) then
	     p_code = mlsys_et_$unknown_user_field_type;

	if (p_code = 0) & (user_field.field_type = MESSAGE_ADDRESS_LIST_USER_FIELD) then
	     if address_list_user_field.address_list_ptr ^= null () then
		ignore =
		     mlsys_address_list_mgr_$verify_address_list (address_list_user_field.address_list_ptr, p_code);

	return ((p_code = 0));

     end verify_user_field;



/* Verify that the supplied message reference contains valid data */

verify_reference:
     procedure (p_reference_ptr, p_code) returns (bit (1) aligned);

dcl  1 reference aligned based (p_reference_ptr) like message_reference;
dcl  p_reference_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;
dcl  ignore bit (1) aligned;

	if reference.from ^= null () then
	     ignore = mlsys_address_list_mgr_$verify_address_list (reference.from, p_code);

	else p_code = 0;				/* looks OK */

	return ((p_code = 0));

     end verify_reference;
%page;
/* Verify that the supplied body section contains valid data */

verify_body_section:
     procedure (p_body_section_ptr, p_code) returns (bit (1) aligned);

dcl  p_body_section_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	if (p_body_section_ptr -> message_body_section.section_type < MESSAGE_PREFORMATTED_BODY_SECTION)
	     | (p_body_section_ptr -> message_body_section.section_type > MESSAGE_BIT_STRING_BODY_SECTION) then
	     p_code = mlsys_et_$unknown_body_section_type;

	else p_code = 0;				/* it passes */

	return ((p_code = 0));

     end verify_body_section;
%page;
/* Computes the position where to add a body section, redistribution, etc.:  If the input position is positive, the object
   is added at the given position (ie: if input position is 1, the object is added at the front of the list); if the input
   position is negative, it is added at the given position from the end (ie: if input position is -1, the object is made
   the last one in the list) */

compute_position_for_add:
     procedure (p_input_position, p_n_in_list, p_actual_position);

dcl  (p_input_position, p_n_in_list, p_actual_position) fixed binary parameter;

	if p_input_position = 0 then			/* a position of zero is equivalent to a value of 1 */
	     p_actual_position = 1;

	else if p_input_position > 0 then		/* add it at the given position from the beginning */
	     p_actual_position = min (p_input_position, (p_n_in_list + 1));

	else /*** if p_input_position < 0 then */
	     p_actual_position = max (1, (p_n_in_list + p_input_position + 2));
						/* add it at the given position from the end */

	return;

     end compute_position_for_add;
%page;
/* Count the lines in a piece of text */

count_lines_in_text:
     procedure (p_text) returns (fixed binary (21));

dcl  p_text character (*) parameter;
dcl  (text_lth, n_lines, used, idx) fixed binary (21);

	text_lth = length (p_text);

	n_lines, used = 0;

	do while (used < text_lth);

	     begin;

dcl  rest_of_text character (text_lth - used) unaligned defined (p_text) position (used + 1);

		idx = index (rest_of_text, NL);
		if idx = 0 then idx = length (rest_of_text) + 1;

		n_lines = n_lines + 1;
		used = used + idx;
	     end;
	end;

	return (n_lines);

     end count_lines_in_text;
%page;
/* Convert a text field which must be a single line into its canonical form: translate all whitespace in the text to
   spaces, strip leading and trailing whitespace, and compress all multi-character sequences of whitespace into a single
   space */

normalize_single_line_field:
     procedure (p_text, p_text_ptr, p_text_lth) options (non_quick);

dcl  p_text character (*) unaligned parameter;
dcl  p_text_ptr pointer parameter;
dcl  p_text_lth fixed binary (21) parameter;

dcl  work_string character (work_string_lth) varying based (work_string_ptr);
dcl  work_string_ptr pointer;
dcl  work_string_lth fixed binary (21);

dcl  result_string character (length (work_string)) unaligned based (result_string_ptr);
dcl  result_string_ptr pointer;

dcl  idx fixed binary (21);


	work_string_lth = length (p_text);

	work_string_ptr = null ();			/* for cleanup handler */
	on condition (cleanup)
	     begin;
		if work_string_ptr ^= null () then
		     if baseno (work_string_ptr) ^= baseno (stackframeptr ()) then
			call mlsys_storage_mgr_$release_temp_segment (work_string_ptr, (0));
	     end;

	if work_string_lth > MAX_STACK_EXTENSION then do; /* too big for the stack */
	     call mlsys_storage_mgr_$get_temp_segment (work_string_ptr, code);
	     if code ^= 0 then call abort_normalize_field (code);
	end;
	else call cu_$grow_stack_frame ((divide ((work_string_lth + 3), 4, 18, 0) + 1), work_string_ptr, (0));

	work_string = ltrim (rtrim (translate (p_text, "", NON_SPACE_WHITESPACE)));
						/* strips leading/trailing whitespace leaving just spaces */

	idx = index (work_string, SPACE_SPACE);		/* need do until ... */
	do while (idx ^= 0);
	     work_string = substr (work_string, 1, idx) || substr (work_string, (idx + 2));
	     idx = index (work_string, SPACE_SPACE);
	end;

	allocate result_string in (mlsys_area) set (result_string_ptr);
	result_string = work_string;

	if baseno (work_string_ptr) ^= baseno (stackframeptr ()) then
	     call mlsys_storage_mgr_$release_temp_segment (work_string_ptr, (0));

	p_text_ptr = addr (result_string);		/* tell the caller where it is ... */
	p_text_lth = length (work_string);		/* ... and how long it is */

	return;

     end normalize_single_line_field;
%page;
/* Convert a multiline text field (or body section) to its canonical form:  The canonical form of a multiline field is
   simply the text of said field with all horizontal tabs expanded into the appropriate number of spaces */

normalize_multiline_field:
     procedure (p_text, p_text_ptr, p_text_lth) options (non_quick);

dcl  p_text character (*) parameter;
dcl  p_text_ptr pointer parameter;
dcl  p_text_lth fixed binary (21);

dcl  work_string character (work_string_lth) unaligned based (work_string_ptr);
dcl  (work_string_lth, work_string_used) fixed binary (21);
dcl  work_string_ptr pointer;

dcl  result_string character (work_string_used) unaligned based (result_string_ptr);
dcl  result_string_ptr pointer;

dcl  the_character character (1) aligned;
dcl  (text_used, column, n_spaces, idx) fixed binary (21);
dcl  stack_increment fixed binary (18);


	stack_increment = 16 * divide ((divide ((length (p_text) + 3), 4, 18, 0) + 15), 16, 18, 0);

	work_string_lth = 4 * stack_increment;		/* initial work space ... */
	work_string_used = 0;			/* ... isn't used yet */

	work_string_ptr = null ();			/* for cleanup handler */
	on condition (cleanup)
	     begin;
		if work_string_ptr ^= null () then
		     if baseno (work_string_ptr) ^= baseno (stackframeptr ()) then
			call mlsys_storage_mgr_$release_temp_segment (work_string_ptr, (0));
	     end;

	if work_string_lth > MAX_STACK_EXTENSION then do;
	     call mlsys_storage_mgr_$get_temp_segment (work_string_ptr, code);
	     if code ^= 0 then call abort_normalize_field (code);
	     work_string_lth = 4 * sys_info$max_seg_size;
	end;
	else call cu_$grow_stack_frame (stack_increment, work_string_ptr, (0));

	column = 1;				/* where we are right now */
	text_used = 0;

	do while (text_used < length (p_text));

	     begin;
dcl  rest_of_text character (length (p_text) - text_used) unaligned defined (p_text) position (text_used + 1);

		idx = verify (rest_of_text, SINGLE_WIDTH_CHARACTERS);
		if idx = 0 then idx = length (rest_of_text) + 1;

		call add_to_work_string (addr (rest_of_text), (idx - 1));
		column = column + idx - 1;		/* update where we are */
		text_used = text_used + idx - 1;
	     end;

	     if text_used < length (p_text) then do;	/* we did find a special character */
		the_character = substr (p_text, (text_used + 1), 1);
		text_used = text_used + 1;

		if the_character = HT then do;	/* a tab: we must change it to spaces ... */
		     if mod (column, 10) = 0 then	/* ... at the column just before a tab stop ... */
			n_spaces = 1;		/* ... the following computation fails */
		     else n_spaces = 11 - mod (column, 10);
		     call add_to_work_string (addr (TEN_SPACES), n_spaces);
		     column = column + n_spaces;
		end;

		else do;				/* some other special char */
		     call add_to_work_string (addr (the_character), 1);
		     if the_character = BS then column = max ((column - 1), 1);
		     else if (the_character = NL) | (the_character = CR) | (the_character = VT) | (the_character = FF)
		     then column = 1;
		     else ;			/* ... all others are non-printing */
		end;
	     end;
	end;

	allocate result_string in (mlsys_area) set (result_string_ptr);
	result_string = substr (work_string, 1, work_string_used);

	if baseno (work_string_ptr) ^= baseno (stackframeptr ()) then
	     call mlsys_storage_mgr_$release_temp_segment (work_string_ptr, (0));

	p_text_ptr = addr (result_string);		/* tell caller where it is ... */
	p_text_lth = length (result_string);		/* ... and how long it is */

	return;



/* Internal to normalize_multiline_field: adds a piece of text to the work string, expanding it if necessary */

add_to_work_string:
	procedure (p_piece_ptr, p_piece_lth);

dcl  p_piece character (p_piece_lth) unaligned based (p_piece_ptr);
dcl  p_piece_ptr pointer parameter;
dcl  p_piece_lth fixed binary (21) parameter;

	     if (work_string_used + p_piece_lth) > work_string_lth then do;
		if baseno (work_string_ptr) ^= baseno (stackframeptr ()) then
		     call abort_normalize_field (mlsys_et_$message_too_large);
		else if (work_string_used + p_piece_lth) > MAX_STACK_EXTENSION then do;
		     call mlsys_storage_mgr_$get_temp_segment (work_string_ptr, code);
		     if code ^= 0 then call abort_normalize_field (code);
		     work_string_lth = 4 * sys_info$max_seg_size;
		end;
		else do;
		     do while (work_string_lth < (work_string_used + p_piece_lth));
			call cu_$grow_stack_frame (stack_increment, (null ()), (0));
			work_string_lth = work_string_lth + (4 * stack_increment);
		     end;
		end;
	     end;

	     substr (work_string, (work_string_used + 1), p_piece_lth) = p_piece;
	     work_string_used = work_string_used + p_piece_lth;

	     return;

	end add_to_work_string;

     end normalize_multiline_field;



/* Aborts a call to either normalize_single_line_field or normalize_multiline_field by aborting the entire operation */

abort_normalize_field:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	P_code = p_code;				/* set caller's status code */
	go to ABORT_THE_OPERATION;

     end abort_normalize_field;

ABORT_THE_OPERATION:
	return;
%page;
%include mlsys_copy_ptr;
%page;
%include mlsys_message;
%page;
%include mlsys_address_list;
%page;
%include mlsys_address_route;
%page;
%include mlsys_internal_data;
%page;
%include aim_template;
%page;
/* Various whitespace constants are placed here as they generate so many blank pages ... */

dcl  VT character (1) static options (constant) initial ("");
dcl  FF character (1) static options (constant) initial ("");

dcl  NON_SPACE_WHITESPACE character (4) static options (constant) initial ("	
");						/* horizontal tab, newline, vertical tab, formfeed */

     end mlsys_message_mgr_;
