/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1983-07-01,Palter), approve(), audit(), install():
     Pre-hcom comments:
     Created:  July 1983 by G. Palter from mlsys_cv_old_r1_msg_ and mlsys_parse_
     Modified: March 1984 by G. Palter to fix the following mail system errors:
           #0415 -- read_mail, print_mail, and have_mail do not reject starnames as invalid mailbox specifications
           #0417 -- the offset within the message text of an invalid field as returned by mlsys_utils_$parse_message_text does
              not take into account the blank lines which the parser allows to appear before the message header.  As a result,
              error messages produced by send_mail, etc. will appear to truncate the contents of the invalid field
           #0432 -- when converting a forwarded message from its canonical representation, the mail system incorrectly parses
              the Delivery-By field using the sender's system as the default system for the Delivery-By address.  The local
              system should always be used as the default for the Delivery-By field
           #0436 -- if a forum meeting is not found in the "forum" search list, the mail system will treat it as a version 1
              forum in the working directory
           #0437 -- if a message contains an empty multi-line field (eg: Redistributed-Comment), the parser will either take a
              fault or cause a fatal process error
           #0438 -- the primitives which allow a user to replace the address list portions of a message
              (eg: mail_system_$replace_from, mail_system_$replace_user_field) should not make the user's copy of the address
              list read-only.  Instead, they should copy the user's list to allow the user to continue to modify the list if
              desired for later additional use
  2) change(1987-04-09,Lippard), approve(1986-11-24,MCR7576),
     audit(1987-04-21,Dickson), install(1987-04-26,MR12.1-1026):
     Modified to use time_names.incl.pl1 instead of time_zones_.incl.pl1.
  3) change(1988-05-16,Blair), approve(1988-05-16,MCR7842),
     audit(1988-06-30,Lippard), install(1988-07-26,MR12.2-1069):
     Update parse_address to use the new search path mechanism so that
     unexpanded mailbox pathnames of the form {keyword PATH} can be located.
  4) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */


/* format: off */

/* Mail System Utilities which convert the printed representation of various mail system objects (messages, addresses,
   etc.) into their internal form */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


mlsys_parse_text_:
     procedure ();

	return;					/* not an entrypoint */


/* Common Parameters */

dcl  P_code fixed binary (35) parameter;

dcl  P_representation character (*) parameter;		/* the text to be parsed */
dcl  P_parse_text_options_ptr pointer parameter;		/* -> user's parsing options */
dcl  P_parse_text_error_list_ptr pointer parameter;	/* set -> list of errors detected during parse */


/* parse_im_message_text and parse_new_message_text Parameters */

dcl  P_message_version character (8) parameter;		/* version of message structure desired by caller */
dcl  P_message_ptr pointer parameter;			/* set -> the message */


/* parse_im_message_text Parameters */

dcl  P_im_message_info_ptr pointer parameter;		/* -> im_message_info describing the in-mailbox message */
dcl  P_last_delivered_by pointer;			/* -> address of user ring-1 claims delivered the message */
dcl  P_last_date_time_delivered fixed binary (71) parameter;/* date/time when ring-1 delivered the message */
dcl  P_requests_acknowledgement bit (1) aligned parameter;	/* ON => the message expects an acknowledgement */
dcl  P_multics_format bit (1) aligned parameter;		/* ON => message is in standard Multics format */


/* parse_mailing_list_text and parse_address_list_text Parameters */

dcl  P_address_list_version character (8) parameter;	/* version of address_list structure desired by caller */
dcl  P_address_list_ptr pointer parameter;		/* set -> the address_list */


/* parse_address_text Parameters */

dcl  P_address_ptr pointer parameter;			/* set -> the address */


/* Local copies of parameters */

dcl  code fixed binary (35);

dcl  representation character (representation_lth) unaligned based (representation_ptr);
dcl  representation_ptr pointer;
dcl  (representation_lth, representation_used) fixed binary (21);

dcl  1 local_pto aligned like parse_text_options;

dcl  address_ptr pointer;


/* Remaining declarations */

dcl  new_message bit (1) aligned;			/* ON => creating a new message; OFF => in-mailbox/incoming */
dcl  message_parse_fails bit (1) aligned;

dcl  1 message_type_specific_operations aligned,		/* in-mailbox/new/incoming messages use different entries */
       2 add_address entry (pointer, pointer, character (8), fixed binary (35)) variable,
       2 add_body_section entry (pointer, pointer, fixed binary, fixed binary (35)) variable,
       2 add_redistribution entry (pointer, pointer, fixed binary, fixed binary (35)) variable,
       2 add_reply_reference entry (pointer, pointer, fixed binary, fixed binary (35)) variable,
       2 add_user_field entry (pointer, pointer, fixed binary, bit (1) aligned, fixed binary (35)) variable,
       2 create_address_list entry (character (8), pointer, fixed binary (35)) variable,
       2 delete_address entry (pointer, fixed binary, fixed binary (35)) variable,
       2 encode_foreign_id entry (character (*), character (256) varying, bit (72) aligned) variable,
       2 encode_local_id entry (fixed binary (71), bit (72) aligned) variable,
       2 encode_psuedo_id entry (fixed binary (71), pointer, character (256) varying, bit (72) aligned) variable,
       2 free_address_list entry (pointer, fixed binary (35)) variable,
       2 free_message entry (pointer, fixed binary (35)) variable,
       2 replace_bcc entry (pointer, pointer, fixed binary (35)) variable,
       2 replace_cc entry (pointer, pointer, fixed binary (35)) variable,
       2 replace_from entry (pointer, pointer, fixed binary (35)) variable,
       2 replace_message_envelope entry (pointer, pointer, fixed binary (35)) variable,
       2 replace_reply_to entry (pointer, pointer, fixed binary (35)) variable,
       2 replace_subject entry (pointer, character (*), fixed binary (35)) variable,
       2 replace_to entry (pointer, pointer, fixed binary (35)) variable,
       2 set_address_implicit_route entry (pointer, pointer, fixed binary (35)) variable,
       2 set_date_time_created entry (pointer, fixed binary (71), fixed binary (35)) variable,
       2 set_message_id entry (pointer, bit (72) aligned, fixed binary (35)) variable;

dcl  1 internal_parse_options aligned,
       2 default_system_name character (256) varying,	/* system name for addresses without explicit name/route */
       2 last_delivered_by pointer,			/* -> address of process that actually delivered message */
       2 last_date_time_delivered fixed binary (71),	/* date/time it was delivered */
       2 flags,
         3 default_system_is_local bit (1) unaligned,	/* ON => the default system is this system */
         3 multics_format bit (1) unaligned,		/* ON => use standard Multics formatting */
         3 no_copy bit (1) unaligned,			/* ON => do not copy text where possible */
         3 requests_acknowledgement bit (1) unaligned,	/* ON => put an Acknowledge-To field into last mailing */
         3 pad bit (14) unaligned,
       2 delimiters,				/* valid delimiters for this parse ... */
         3 eos bit (1) unaligned,			/* ... end of the string */
         3 comma bit (1) unaligned,			/* ... comma */
         3 angle_bracket bit (1) unaligned,		/* ... angle bracket (>) */
         3 semicolon bit (1) unaligned,			/* ... semi-colon */
         3 pad bit (14) unaligned;

dcl  1 mrps (forwarding_info_list.n_forwarding_infos) aligned based (mrps_ptr) like message_redistribution_parameter;
dcl  1 the_mrp aligned based (the_mrp_ptr) like message_redistribution_parameter;
dcl  (mrps_ptr, the_mrp_ptr) pointer;

dcl  mr_sort (forwarding_info_list.n_forwarding_infos) fixed binary based (mr_sort_ptr);
dcl  mr_sort_ptr pointer;

dcl  1 local_mep aligned like message_envelope_parameter;
dcl  1 local_mrp aligned like message_reference_parameter;
dcl  1 local_mufp aligned like message_user_field_parameter;
dcl  1 local_mbsp aligned like message_body_section_parameter;

dcl  1 local_mtf aligned like message_text_field;

dcl  system_area area aligned based (system_area_ptr);
dcl  system_area_ptr pointer;

dcl  user_area area aligned based (user_area_ptr);
dcl  user_area_ptr pointer;

dcl  forum_search_list_ptr pointer;

dcl  (stack_extension_ptr, stack_truncation_ptr) pointer;
dcl  stack_extension_used fixed binary (18);

dcl  full_fieldname character (256) varying;
dcl  (address_list_field, trace_address, comment_sender, redistribution_sender, acknowledge_to, implicit_route) pointer;

dcl  (date_time_created, comment_date_time_created, date_time_last_relayed) fixed binary (71);
dcl  message_id bit (72) aligned;

dcl  (eol_idx, next_eol_idx, amount_good, line_start, line_end, used) fixed binary (21);
dcl  (current_field_list_idx, first_field_idx) fixed binary;
dcl  (n_sorted, sort_idx, idx, position) fixed binary;

dcl  STACK_EXTENSION fixed binary (18) static options (constant) initial (1024);

dcl  HTSP_COMMA character (3) static options (constant) initial ("	 ,");

dcl  LINE_DELIMITERS character (4) static options (constant) initial ("
");

/* format: off */
dcl  MULTIPLE_FIELDS_PER_REDISTRIBUTION (18) bit (1) aligned static options (constant) initial (
	"0"b,	"0"b,	"0"b,	"1"b,	"0"b,	"0"b,	"0"b,	"0"b,	"1"b,
	"0"b,	"0"b,	"1"b,	"0"b,	"0"b,	"0"b,	"0"b,	"1"b,	"0"b);

dcl  MULTIPLE_FIELDS_PER_COMMENT (18) bit (1) aligned static options (constant) initial (
	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,
	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"0"b,	"1"b,	"0"b);

dcl (UPPERCASE	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
     LOWERCASE	initial ("abcdefghijklmnopqrstuvwxyz"))
	character (26) static options (constant);

dcl (error_table_$bad_subr_arg, error_table_$entlong, error_table_$nostars, error_table_$smallarg,
     error_table_$unimplemented_version, mlsys_et_$address_pathname_expected, mlsys_et_$cant_determine_dtc,
     mlsys_et_$cant_determine_msgid, mlsys_et_$cant_determine_sender, mlsys_et_$cant_parse_irt_field,
     mlsys_et_$comment_ignored, mlsys_et_$empty_address_text, mlsys_et_$extra_restricted_field,
     mlsys_et_$in_mailbox_only_field, mlsys_et_$incomplete_address_list_text, mlsys_et_$incomplete_address_text,
     mlsys_et_$incomplete_comment, mlsys_et_$incomplete_named_group_text, mlsys_et_$invalid_address_list_syntax,
     mlsys_et_$invalid_address_syntax, mlsys_et_$invalid_named_group_text, mlsys_et_$invalid_relayed_field_syntax,
     mlsys_et_$invalid_route_field_syntax, mlsys_et_$missing_host_name, mlsys_et_$multiple_address_routes,
     mlsys_et_$no_comment_redistribution, mlsys_et_$no_message_header, mlsys_et_$obsolete_address_syntax,
     mlsys_et_$only_address_route_allowed, mlsys_et_$recursive_named_addresses, mlsys_et_$text_follows_address,
     mlsys_et_$text_follows_route, mlsys_et_$text_parse_failed, mlsys_et_$unbalanced_braces,
     mlsys_et_$unbalanced_parentheses, mlsys_et_$unbalanced_quotes, mlsys_et_$unknown_structured_address_type)
	fixed binary (35) external;
/* format: on */

dcl  check_star_name_$entry entry (character (*), fixed binary (35));
dcl  convert_date_to_binary_ entry (character (*), fixed binary (71), fixed binary (35));
dcl  cu_$grow_stack_frame entry (fixed binary (18), pointer, fixed binary (35));
dcl  cu_$shrink_stack_frame entry (pointer, fixed binary (35));
dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl  encode_clock_value_
	entry (fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary (71),
	fixed binary, character (4), fixed binary (71), fixed binary (35));
dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
dcl  expand_pathname_$add_suffix entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl  expand_pathname_$component_add_suffix
	entry (character (*), character (*), character (*), character (*), character (*), fixed binary (35));
dcl  forum_$get_forum_path entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl  get_system_free_area_ entry () returns (pointer);
dcl  mail_system_$add_address entry (pointer, pointer, character (8), fixed binary (35));
dcl  mail_system_$add_body_section entry (pointer, pointer, fixed binary, fixed binary (35));
dcl  mail_system_$add_user_field entry (pointer, pointer, fixed binary, bit (1) aligned, fixed binary (35));
dcl  mail_system_$compare_addresses entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mail_system_$create_address_list entry (character (8), pointer, fixed binary (35));
dcl  mail_system_$create_foreign_address
	entry (character (*) varying, character (256) varying, pointer, character (*) varying, character (*) varying,
	pointer, fixed binary (35));
dcl  mail_system_$create_forum_address
	entry (character (*), character (*), character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_invalid_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_logbox_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_mail_table_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_mailbox_address
	entry (character (*), character (*), character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_mailing_list_address
	entry (character (*), character (*), character (*), character (*) varying, character (*) varying, pointer,
	fixed binary (35));
dcl  mail_system_$create_message entry (character (8), pointer, fixed binary (35));
dcl  mail_system_$create_named_group_address
	entry (character (*) varying, pointer, bit (1) aligned, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$create_savebox_address
	entry (character (*) varying, character (*), character (*), character (*) varying, character (*) varying,
	pointer, fixed binary (35));
dcl  mail_system_$create_user_mailbox_address
	entry (character (*) varying, character (*) varying, character (*) varying, pointer, fixed binary (35));
dcl  mail_system_$delete_address entry (pointer, fixed binary, fixed binary (35));
dcl  mail_system_$free_address entry (pointer, fixed binary (35));
dcl  mail_system_$free_address_list entry (pointer, fixed binary (35));
dcl  mail_system_$free_message entry (pointer, fixed binary (35));
dcl  mail_system_$get_address_route entry (pointer, character (8), pointer, fixed binary (35));
dcl  mail_system_$get_address_system entry (pointer, character (256) varying, fixed binary (35));
dcl  mail_system_$get_address_type entry (pointer, fixed binary, fixed binary (35));
dcl  mail_system_$get_user_field_id entry (character (*), bit (36) aligned, character (*) varying, fixed binary (35));
dcl  mail_system_$get_user_field_name entry (bit (36) aligned, character (*) varying, fixed binary (35));
dcl  mail_system_$replace_bcc entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_cc entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_from entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_reply_to entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$replace_subject entry (pointer, character (*), fixed binary (35));
dcl  mail_system_$replace_to entry (pointer, pointer, fixed binary (35));
dcl  mail_system_$validate_address entry (pointer, bit (1) aligned, fixed binary (35));
dcl  mlsys_address_list_mgr_$add_address entry (pointer, pointer, character (8), fixed binary (35));
dcl  mlsys_address_list_mgr_$create_read_only_address_list entry (character (8), pointer, fixed binary (35));
dcl  mlsys_address_list_mgr_$create_user_freeable_address_list entry (character (8), pointer, fixed binary (35));
dcl  mlsys_address_list_mgr_$delete_address entry (pointer, fixed binary, fixed binary (35));
dcl  mlsys_address_list_mgr_$free_address_list entry (pointer, fixed binary (35));
dcl  mlsys_address_mgr_$set_address_implicit_route entry (pointer, pointer, fixed binary (35));
dcl  mlsys_field_id_mgr_$get_system_field_type entry (character (*), fixed binary, fixed binary (35));
dcl  mlsys_message_id_mgr_$encode_foreign_id entry (character (*), character (256) varying, bit (72) aligned);
dcl  mlsys_message_id_mgr_$encode_local_id entry (fixed binary (71), bit (72) aligned);
dcl  mlsys_message_id_mgr_$encode_psuedo_id entry (fixed binary (71), pointer, character (256) varying, bit (72) aligned);
dcl  mlsys_message_mgr_$add_body_section_no_copy entry (pointer, pointer, fixed binary, fixed binary (35));
dcl  mlsys_message_mgr_$add_redistribution_no_copy entry (pointer, pointer, fixed binary, fixed binary (35));
dcl  mlsys_message_mgr_$add_reply_reference entry (pointer, pointer, fixed binary, fixed binary (35));
dcl  mlsys_message_mgr_$add_user_field_no_copy entry (pointer, pointer, fixed binary, bit (1) aligned, fixed binary (35));
dcl  mlsys_message_mgr_$create_im_message entry (character (8), pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$free_message entry (pointer, fixed binary (35));
dcl  mlsys_message_mgr_$replace_bcc_no_copy entry (pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$replace_cc_no_copy entry (pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$replace_from_no_copy entry (pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$replace_message_envelope entry (pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$replace_reply_to_no_copy entry (pointer, pointer, fixed binary (35));
dcl  mlsys_message_mgr_$replace_subject_no_copy entry (pointer, character (*), fixed binary (35));
dcl  mlsys_message_mgr_$replace_to_no_copy entry (pointer, pointer, fixed binary (35));
dcl  mlsys_nit_interface_$get_local_system_name entry () returns (character (256) varying);
dcl  mlsys_nit_interface_$is_local_system entry (character (256) varying) returns (bit (1) aligned);
dcl  mlsys_psp_$forum_not_available entry () returns (bit (1) aligned);
dcl  mlsys_user_mte_syntax_$classify_and_validate
	entry (character (*) varying, bit (1) aligned, character (*) varying, character (*) varying, fixed binary (35));
dcl  search_paths_$get
	entry (character (*), bit (36), character (*), pointer, pointer, fixed binary, pointer, fixed binary (35));

dcl  cleanup condition;

dcl  (abs, addr, addcharno, addwordno, baseno, before, charno, hbound, index, lbound, length, max, min, mod, null,
     reverse, rtrim, search, size, stackframeptr, string, substr, translate, verify) builtin;
%page;
/* Results of scanning the text of a message for header fields */

dcl  1 message_scan aligned,
       2 header_offset fixed binary (21),		/* offset of header in message ignoring leading NLs */
       2 body,					/* the message body  */
         3 body_ptr pointer,
         3 body_lth fixed binary (21),
       2 n_header_fields_allocated fixed binary,		/* size of several arrays below */
       2 array_pointers,				/* makes setup simpler */
         3 header_field_list_ptr pointer,		/* -> the list defining the actual header fields */
         3 field_by_type_lists_ptr pointer,		/* -> the list breaking the fields down by type */
         3 forwarding_info_list_ptr pointer,		/* -> the list of forwarding fields */
         3 comment_info_list_ptr pointer,		/* -> the list of comment fields */
         3 user_field_list_ptr pointer;			/* -> the list of user-defined fields */


dcl  1 header_field_list aligned based (message_scan.header_field_list_ptr),
       2 n_fields fixed binary,			/* # of fields actually found */
       2 fields (message_scan.n_header_fields_allocated),	/* the actual fields */
         3 field_value_ptr pointer,			/* -> start of textual content of the field */
         3 field_value_lth fixed binary (21),		/* length of the field in characters */
         3 complete_field_start fixed binary (21),	/* offset/length of the entire field (including header) ... */
         3 complete_field_lth fixed binary (21);		/* ... for use in error reporting */

dcl  header_field_value character (header_field_list.fields (field_idx).field_value_lth) unaligned
	based (header_field_list.fields (field_idx).field_value_ptr);
dcl  field_idx fixed binary;				/* index of field whose value is above declaration */


dcl  1 field_by_type_lists aligned based (message_scan.field_by_type_lists_ptr),
       2 types (N_ORDINARY_FIELDS),			/* one array element for each type */
         3 n_fields fixed binary,			/* # of fields of this type found */
         3 field_idxs (message_scan.n_header_fields_allocated) fixed binary;
						/* index into header_field_list.fields of each field found */


dcl  1 forwarding_info_list aligned based (message_scan.forwarding_info_list_ptr),
       2 n_forwarding_infos fixed binary,		/* # of separate forwarding infos actually found */
       2 forwarding_info_ptrs (message_scan.n_header_fields_allocated) pointer;
						/* -> field_by_type_lists for each forwarding */

dcl  1 forwarding_info aligned based (forwarding_info_ptr) like field_by_type_lists;
dcl  forwarding_info_ptr pointer;


dcl  1 comment_info_list aligned based (message_scan.comment_info_list_ptr),
       2 n_comment_infos fixed binary,			/* # of separate comment infos actually found */
       2 comment_info_ptrs (message_scan.n_header_fields_allocated) pointer;
						/* -> field_by_type_lists for each comment */

dcl  1 comment_info aligned based (comment_info_ptr) like field_by_type_lists;
dcl  comment_info_ptr pointer;

dcl  1 user_field_list aligned based (message_scan.user_field_list_ptr),
       2 n_user_fields fixed binary,			/* # of user fields found */
       2 user_fields (message_scan.n_header_fields_allocated),
         3 field_id bit (36) aligned,			/* ID assigned to group all similar user fields */
         3 field_value_idx fixed binary;		/* index into header_field_list of this field */
%page;
/* Declarations used to convert the input text into a series of tokens */

dcl  original_text character (original_text_lth) unaligned based (original_text_ptr);
dcl  original_text_lth fixed binary (21);
dcl  original_text_ptr pointer;

dcl  1 lex_and_parse_pointers aligned,			/* allows easy setting of all these pointers */
       2 all_but_sel_ptr,
         3 token_list_ptr pointer,
         3 unquoted_text_ptr pointer,
         3 host_indeces_ptr pointer,
         3 address_string_ptr pointer,
         3 address_name_ptr pointer,
         3 address_comment_ptr pointer,
       2 sel_ptr pointer;

dcl  unquoted_text character (original_text_lth) unaligned based (lex_and_parse_pointers.unquoted_text_ptr);
						/* used by lex when processing quoted strings */

dcl  1 token aligned based (token_ptr),			/* a single token from the string */
       2 token_ptr pointer,				/* -> the text */
       2 token_lth fixed binary (21),			/* length of text in characters */
       2 original_start fixed binary (21),		/* index in caller's text of start of token */
       2 original_lth fixed binary (21),		/* length of the original (maybe quoted) version of token */
       2 type fixed binary,				/* type of token (see below) */
       2 flags,
         3 in_unquoted bit (1) unaligned,		/* ON => text was reconstructed (quoted or something) */
         3 pad bit (35) unaligned;
dcl  token_ptr pointer;

dcl  1 current aligned like token based (current_token_ptr);/* the token under examination */
dcl  current_token_ptr pointer;
dcl  token_idx fixed binary (21);			/* index of current token in the token list */

dcl  current_token character (current.token_lth) unaligned based (current.token_ptr);
						/* the actual text of the token */

dcl  1 token_list aligned based (lex_and_parse_pointers.token_list_ptr),
       2 n_tokens_allocated fixed binary (21),		/* # of tokens below */
       2 n_tokens_used fixed binary (21),		/* # of tokens in use */
       2 tokens (0:(original_text_lth + 1) refer (token_list.n_tokens_allocated)) like token;

/* format: off */

/* Token types common to all forms of lexical analysis */

dcl (START_OF_TEXT_TOKEN	initial (-3),		/* start of text: always the first token in the list */
     END_OF_TEXT_TOKEN	initial (-2),		/* end of the text: always the last token in the list */
     WORD_TOKEN		initial (-1),		/* a piece of text (it might have been quoted) */
     COMMENT_TOKEN		initial (0),		/* the text of a comment */

     COMMA_TOKEN	initial (1),			/* comma and colon delimiters are common to both lex's */
     COLON_TOKEN	initial (2),


/* Token types for parsing address, address-list, and message-id fields */

     SEMICOLON_TOKEN	initial (3),	     LEFTBRACE_TOKEN	initial (4),
     RIGHTBRACE_TOKEN	initial (5),	     LEFTBRACKET_TOKEN	initial (6),
     RIGHTBRACKET_TOKEN	initial (7),	     AT_TOKEN		initial (8),


/* Token types for parsing date/time fields */

     PLUS_TOKEN		initial (3),	     HYPHEN_TOKEN		initial (4))
	fixed binary static options (constant);
/* format: on */


/* Declarations used for parsing addresses and address lists */

dcl  1 sel (original_text_lth) aligned based (lex_and_parse_pointers.sel_ptr),
       2 text_start fixed binary (21),			/* index in original text of substring in error */
       2 text_lth fixed binary (21),			/* ... and the length of said substring */
       2 code fixed binary (35);			/* error code describing problem */
dcl  n_syntax_errors fixed binary (21);			/* # of errors detected by the parse */

dcl  host_indeces (original_text_lth) fixed binary (21) based (lex_and_parse_pointers.host_indeces_ptr);
dcl  n_hosts fixed binary;				/* # of host names in the address */
dcl  n_reversed_hosts fixed binary;			/* # of host names in RFC822 style route */

dcl  address_string character (original_text_lth + 1) varying based (lex_and_parse_pointers.address_string_ptr);
dcl  address_name character (original_text_lth + 1) varying based (lex_and_parse_pointers.address_name_ptr);
dcl  address_comment character (original_text_lth + 1) varying based (lex_and_parse_pointers.address_comment_ptr);


/* Declarations used for parsing date/times */

dcl  ONE_MINUTE fixed binary (71) static options (constant) initial (60000000);

/* format: off */
dcl  DAY_OF_WEEKS (14) character (32) static options (constant) initial (
	"SUNDAY",	     "SUN",	"MONDAY",	     "MON",	"TUESDAY",     "TUE",	"WEDNESDAY",   "WED",
	"THURSDAY",    "THU",	"FRIDAY",	     "FRI",	"SATURDAY",    "SAT");
dcl  DAY_OF_WEEK_VALUES (14) fixed binary static options (constant) initial (
	(2) 7,			(2) 1,			(2) 2,			(2) 3,
	(2) 4,			(2) 5,			(2) 6);

dcl  MONTHS (23) character (32) static options (constant) initial (
	"JANUARY",     "JAN",	"FEBRUARY",    "FEB",	"MARCH",	     "MAR",	"APRIL",	     "APR",
	"MAY",			"JUNE",	     "JUN",	"JULY",	     "JUL",	"AUGUST",	     "AUG",
	"SEPTEMBER",   "SEP",	"OCTOBER",     "OCT",	"NOVEMBER",    "NOV",	"DECEMBER",    "DEC");
dcl  MONTH_VALUES (23) fixed binary static options (constant) initial (
	(2) 1,			(2) 2,			(2) 3,			(2) 4,
	5,			(2) 6,			(2) 7,			(2) 8,
	(2) 9,			(2) 10,			(2) 11,			(2) 12);

dcl  RFC822_ZONES (35) character (4) static options (constant) initial (
	"GMT",	"UT",	"EST",	"EDT",	"CST",	"CDT",	"MST",	"MDT",	"PST",	"PDT",
	"Z",	"A",	"B",	"C",	"D",	"E",	"F",	"G",	"H",	"I",
	"K",	"L",	"M",	"N",	"O",	"P",	"Q",	"R",	"S",	"T",
	"U",	"V",	"W",	"X",	"Y");
dcl  RFC822_ZONE_OFFSETS (35) fixed binary static options (constant) initial (
	   0,	   0,	-300,	-240,	-360,	-300,	-420,	-360,	-480,	-420,
	   0,	 -60,	-120,	-180,	-240,	-300,	-360,	-420,	-480,	-540,
	-600,	-660,	-720,	  60,	 120,	 180,	 240,	 300,	 360,	 420,
	 480,	 540,	 600,	 660,	 720);
/* format: on */
%page;
/* Convert the printed representation of an in-mailbox message into its internal representation */

parse_im_message_text:
     entry (P_representation, P_message_version, P_im_message_info_ptr, P_last_delivered_by, P_last_date_time_delivered,
	P_requests_acknowledgement, P_multics_format, P_message_ptr, P_code);

	new_message = "0"b;				/* building an in-mailbox message */

	local_pto.version = PARSE_TEXT_OPTIONS_VERSION_1; /* setup common parse options */
	local_pto.area_ptr = null ();
	string (local_pto.flags) = ""b;		/* ... don't list errors or validate addresses */
	local_pto.include_invalid_addresses = "1"b;	/* ... but include everything possible in the message */
	parse_text_options_ptr = addr (local_pto);

	string (internal_parse_options.flags) = ""b;	/* ... will determine the default system later */
	internal_parse_options.multics_format = P_multics_format;
						/* ... use new-style formatting if necessary */
	internal_parse_options.no_copy = "1"b;		/* ... use the actual message text when possible */

	internal_parse_options.last_delivered_by = P_last_delivered_by;
	internal_parse_options.last_date_time_delivered = P_last_date_time_delivered;
	internal_parse_options.requests_acknowledgement = P_requests_acknowledgement;

	add_address = mlsys_address_list_mgr_$add_address;
	add_body_section = mlsys_message_mgr_$add_body_section_no_copy;
	add_redistribution = mlsys_message_mgr_$add_redistribution_no_copy;
	add_reply_reference = mlsys_message_mgr_$add_reply_reference;
	add_user_field = mlsys_message_mgr_$add_user_field_no_copy;
	create_address_list = mlsys_address_list_mgr_$create_read_only_address_list;
	delete_address = mlsys_address_list_mgr_$delete_address;
	encode_foreign_id = mlsys_message_id_mgr_$encode_foreign_id;
	encode_local_id = mlsys_message_id_mgr_$encode_local_id;
	encode_psuedo_id = mlsys_message_id_mgr_$encode_psuedo_id;
	free_address_list = mlsys_address_list_mgr_$free_address_list;
	free_message = mlsys_message_mgr_$free_message;
	replace_bcc = mlsys_message_mgr_$replace_bcc_no_copy;
	replace_cc = mlsys_message_mgr_$replace_cc_no_copy;
	replace_from = mlsys_message_mgr_$replace_from_no_copy;
	replace_message_envelope = mlsys_message_mgr_$replace_message_envelope;
	replace_reply_to = mlsys_message_mgr_$replace_reply_to_no_copy;
	replace_subject = mlsys_message_mgr_$replace_subject_no_copy;
	replace_to = mlsys_message_mgr_$replace_to_no_copy;
	set_address_implicit_route = mlsys_address_mgr_$set_address_implicit_route;
	set_date_time_created = set_date_time_created_directly;
	set_message_id = set_message_id_directly;

	call mlsys_message_mgr_$create_im_message (P_message_version, P_im_message_info_ptr, message_ptr, code);
	if code ^= 0 then do;			/* wrong version? */
	     P_code = code;
	     return;
	end;

	go to PARSE_MESSAGE_TEXT_COMMON;
%page;
/* Convert the printed representation of a new message into its internal representation */

parse_new_message_text:
     entry (P_representation, P_parse_text_options_ptr, P_message_version, P_message_ptr, P_parse_text_error_list_ptr,
	P_code);

	new_message = "1"b;				/* building a new message */

	parse_text_options_ptr = P_parse_text_options_ptr;
	if parse_text_options.version ^= PARSE_TEXT_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;
	if parse_text_options.mbz ^= ""b then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	if parse_text_options.area_ptr = null () then
	     user_area_ptr = get_system_free_area_ ();
	else user_area_ptr = parse_text_options.area_ptr;

	string (internal_parse_options.flags) = ""b;
	internal_parse_options.multics_format = "1"b;	/* use standard Multics formatting conventions */
	internal_parse_options.no_copy = "0"b;		/* can't use supplied text directly */

	internal_parse_options.default_system_is_local = "1"b;
	internal_parse_options.default_system_name = mlsys_nit_interface_$get_local_system_name ();

	internal_parse_options.last_delivered_by = null ();
	internal_parse_options.last_date_time_delivered = 0;
	internal_parse_options.requests_acknowledgement = "0"b;
						/* message has never been sent anywhere */

	add_address = mail_system_$add_address;
	add_body_section = mail_system_$add_body_section;
	add_user_field = mail_system_$add_user_field;
	create_address_list = mail_system_$create_address_list;
	delete_address = mail_system_$delete_address;
	free_address_list = mail_system_$free_address_list;
	free_message = mail_system_$free_message;
	replace_bcc = mail_system_$replace_bcc;
	replace_cc = mail_system_$replace_cc;
	replace_from = mail_system_$replace_from;
	replace_reply_to = mail_system_$replace_reply_to;
	replace_subject = mail_system_$replace_subject;
	replace_to = mail_system_$replace_to;

	call mail_system_$create_message (P_message_version, message_ptr, code);
	if code ^= 0 then do;			/* wrong version? */
	     P_code = code;
	     return;
	end;

	go to PARSE_MESSAGE_TEXT_COMMON;
%page;
/* The Message Parser */

PARSE_MESSAGE_TEXT_COMMON:
	representation_ptr = addr (P_representation);
	representation_lth = length (P_representation);

	string (internal_parse_options.delimiters) = ""b; /* end of string is only address/address list delimiter */
	internal_parse_options.delimiters.eos = "1"b;

	message_parse_fails = "0"b;			/* assume no errors are detected */

	system_area_ptr = get_system_free_area_ ();

	call initialize_message_parse_data ();		/* for cleanup handler */

	on condition (cleanup)
	     begin;
	     call cleanup_message_parse_data ();
	     if message_ptr ^= null () then call free_message (message_ptr, (0));
	end;


/* Find and classify all header fields */

	call scan_message_text (parse_text_options, internal_parse_options);


/* Add the body to the message: whatever body is present is treated as a single, preformatted section */

	local_mbsp.version = MESSAGE_BODY_SECTION_PARAMETER_VERSION_2;

	message_body_section_ptr = addr (local_mbsp.section);
	message_preformatted_body_section.section_type = MESSAGE_PREFORMATTED_BODY_SECTION;
	message_preformatted_body_section.text_ptr = message_scan.body_ptr;
	message_preformatted_body_section.text_lth = message_scan.body_lth;

	call add_body_section (message_ptr, addr (local_mbsp), (-1), code);
	if code ^= 0 then call message_parse_error_fatal (code);


	if new_message then do;

/* New Message -- Parse the From field and mark all "restricted" header fields and all field in the envelope as errors */

	     call parse_address_list_field (parse_text_options, internal_parse_options, FROM_FIELDNAME,
		addr (field_by_type_lists.types (FROM_FIELD)), address_list_field);
	     if address_list_field ^= null () then do;	/* ... there's something in the From field */
		call replace_from (message_ptr, address_list_field, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		if address_list_field = message.from then
		     address_list_field = null ();
		else call free_address_list (address_list_field, (0));
	     end;

	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (ACCESS_CLASS_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (ACKNOWLEDGE_TO_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (DATE_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (DELIVERY_BY_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (DELIVERY_DATE_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (MESSAGE_ID_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (POSTED_DATE_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (RELAYED_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (ROUTE_FIELD)));
	     call mark_as_in_mailbox_field (addr (field_by_type_lists.types (SENDER_FIELD)));
	end;

	else do;

/* In-mailbox/Incoming Message -- Parse the message envelope:  However, the envelope is not added to the message at this
   time as it is possible that either the message trace or Acknowledge-To field or both which appear to be part of the
   envelope are actually part of one of the message redistributions.  As part of parsing the envelope, we also parse the
   Date and From fields in the header as we may need their values to complete the envelope parse; we may also need their
   values to construct a unique ID for the message if there's no Message-ID field */

	     first_field_idx = 1;			/* message starts at the beginning ... */

	     local_mep.version = MESSAGE_ENVELOPE_PARAMETER_VERSION_2;

	     call parse_envelope (parse_text_options, internal_parse_options, "0"b,
		message_scan.field_by_type_lists_ptr, addr (local_mep.envelope), date_time_created,
		address_list_field);		/* takes care of both Date and From fields also */

	     call set_date_time_created (message_ptr, date_time_created, code);
	     if code ^= 0 then call message_parse_error_fatal (code);

	     if address_list_field ^= null () then do;	/* ... there's something in the From field */
		call replace_from (message_ptr, address_list_field, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		if address_list_field = message.from then
		     address_list_field = null ();
		else call free_address_list (address_list_field, (0));
	     end;


/* In-mailbox/Incoming Message -- Determine the unique ID of the message:  If there is exactly one Message-ID field,
   convert it into the ID; if there is no Message-ID field, construct a psuedo-ID from the Date and From fields; if there
   is more than one Message-ID field, flag them all as errors */

	     message_id = ""b;			/* assume we don't get one */

	     if field_by_type_lists.types (MESSAGE_ID_FIELD).n_fields = 1 then do;
		field_idx = field_by_type_lists.types (MESSAGE_ID_FIELD).field_idxs (1);
		call parse_message_id_text (parse_text_options, internal_parse_options, header_field_value,
		     message_id);			/* text can always be converted to a message ID */
	     end;

	     else if field_by_type_lists.types (MESSAGE_ID_FIELD).n_fields > 1 then do;
		do idx = 1 to field_by_type_lists.types (MESSAGE_ID_FIELD).n_fields;
		     field_idx = field_by_type_lists.types (MESSAGE_ID_FIELD).field_idxs (idx);
		     call message_parse_error (parse_text_options, mlsys_et_$extra_restricted_field,
			header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "");
		end;
	     end;

	     else do;				/* must construct a psudeo ID */
		if (message.date_time_created ^= 0) & (message.from -> address_list.n_addresses > 0) then
		     call encode_psuedo_id (message.date_time_created, message.from,
			internal_parse_options.default_system_name, message_id);
		else call message_parse_error (parse_text_options, mlsys_et_$cant_determine_msgid,
			header_field_list.fields (1).complete_field_start,
			header_field_list.fields (1).complete_field_lth, "The message which starts with:");
	     end;

	     if message_id ^= ""b then do;		/* found an ID ... */
		call set_message_id (message_ptr, message_id, code);
		if code ^= 0 then call message_parse_error_fatal (code);
	     end;
	end;


/* Parse the Reply-To, To, cc, and bcc fields */

	if field_by_type_lists.types (REPLY_TO_FIELD).n_fields > 0 then do;
	     call parse_address_list_field (parse_text_options, internal_parse_options, REPLY_TO_FIELDNAME,
		addr (field_by_type_lists.types (REPLY_TO_FIELD)), address_list_field);
	     if address_list_field ^= null () then do;	/* ... there's something in the Reply-To field */
		call replace_reply_to (message_ptr, address_list_field, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		if address_list_field = message.reply_to then
		     address_list_field = null ();
		else call free_address_list (address_list_field, (0));
	     end;
	end;

	if field_by_type_lists.types (TO_FIELD).n_fields > 0 then do;
	     call parse_address_list_field (parse_text_options, internal_parse_options, TO_FIELDNAME,
		addr (field_by_type_lists.types (TO_FIELD)), address_list_field);
	     if address_list_field ^= null () then do;	/* ... there's something in the To field */
		call replace_to (message_ptr, address_list_field, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		if address_list_field = message.to then
		     address_list_field = null ();
		else call free_address_list (address_list_field, (0));
	     end;
	end;

	if field_by_type_lists.types (CC_FIELD).n_fields > 0 then do;
	     call parse_address_list_field (parse_text_options, internal_parse_options, CC_FIELDNAME,
		addr (field_by_type_lists.types (CC_FIELD)), address_list_field);
	     if address_list_field ^= null () then do;	/* ... there's something in the cc field */
		call replace_cc (message_ptr, address_list_field, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		if address_list_field = message.cc then
		     address_list_field = null ();
		else call free_address_list (address_list_field, (0));
	     end;
	end;

	if field_by_type_lists.types (BCC_FIELD).n_fields > 0 then do;
	     call parse_address_list_field (parse_text_options, internal_parse_options, BCC_FIELDNAME,
		addr (field_by_type_lists.types (BCC_FIELD)), address_list_field);
	     if address_list_field ^= null () then do;	/* ... there's something in the bcc field */
		call replace_bcc (message_ptr, address_list_field, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		if address_list_field = message.bcc then
		     address_list_field = null ();
		else call free_address_list (address_list_field, (0));
	     end;
	end;


/* Parse the Subject field: if there are several Subject fields in the message, merge them into a single field */

	if field_by_type_lists.types (SUBJECT_FIELD).n_fields > 0 then do;
	     call prepare_single_line_field (local_mtf, addr (field_by_type_lists.types (SUBJECT_FIELD)));
	     begin;
dcl  message_subject character (local_mtf.text_lth) unaligned based (local_mtf.text_ptr);
		call replace_subject (message_ptr, message_subject, code);
		if field_by_type_lists.types (SUBJECT_FIELD).n_fields > 1 then
		     if message.subject.text_ptr ^= addr (message_subject) then free message_subject in (system_area);
		if code ^= 0 then call message_parse_error_fatal (code);
	     end;
	end;


	if field_by_type_lists.types (IN_REPLY_TO_FIELD).n_fields > 0 then
	     if new_message then do;

/* New Message -- Mark all In-Reply-To fields as errors:  Privileged operations are required to convert the printed
   representation of a message reference into its internal form */

		do idx = 1 to field_by_type_lists.types (IN_REPLY_TO_FIELD).n_fields;
		     field_idx = field_by_type_lists.types (IN_REPLY_TO_FIELD).field_idxs (idx);
		     call message_parse_error (parse_text_options, mlsys_et_$cant_parse_irt_field,
			header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "");
		end;
	     end;

	     else do;

/* In-mailbox/Incoming Message -- Parse the In-Reply-To fields:  We can not actually parse the In-Reply-To field as the
   format of the printed representation is not complete enough for parsing.  Therefore, we take each separate line of the
   In-Reply-To fields and treat it as a separate reference; a message ID is generated for each line based on its text so
   that there will be something available to convert back into the printed form */

		local_mrp.version = MESSAGE_REFERENCE_PARAMETER_VERSION_2;
		local_mrp.date_time_created = 0;	/* there's never any date/time, authors, or subject */
		local_mrp.from, local_mrp.subject.text_ptr = null ();
		local_mrp.subject.text_lth = 0;

		do idx = 1 to field_by_type_lists.types (IN_REPLY_TO_FIELD).n_fields;
		     field_idx = field_by_type_lists.types (IN_REPLY_TO_FIELD).field_idxs (idx);

		     used = 0;
		     do while (used < length (header_field_value));
			begin;
dcl  rest_of_field char (length (header_field_value) - used) unaligned defined (header_field_value) position (used + 1);
			     eol_idx = index (rest_of_field, NL);
			     if eol_idx = 0 then eol_idx = length (rest_of_field) + 1;
			end;
			begin;			/* have the next line to convert ... */
dcl  next_line character (eol_idx - 1) unaligned defined (header_field_value) position (used + 1);
			     line_start = verify (next_line, HTSP_COMMA);
			     if line_start ^= 0 then do;
						/* ... something on the line */
				line_end = length (rtrim (next_line, HTSP_COMMA));
				begin;
dcl  the_line character (line_end - line_start + 1) unaligned defined (header_field_value) position (used + line_start);
				     call encode_foreign_id (the_line,
					mlsys_nit_interface_$get_local_system_name (), local_mrp.message_id);
				     call add_reply_reference (message_ptr, addr (local_mrp), (-1), code);
				     if code ^= 0 then call message_parse_error_fatal (code);
				end;
			     end;
			end;
			used = used + eol_idx;	/* on to the next line */
		     end;
		end;
	     end;


/* Convert the user-defined fields:  Until messages are stored in binary, we must assume that all user-defined fields are
   text fields */

	local_mufp.version = MESSAGE_USER_FIELD_PARAMETER_VERSION_2;
	message_user_field_ptr = addr (local_mufp.user_field);
	message_user_field.field_type = MESSAGE_TEXT_USER_FIELD;

	do idx = 1 to user_field_list.n_user_fields;
	     field_idx = user_field_list.user_fields (idx).field_value_idx;
	     message_user_field.field_id = user_field_list.user_fields (idx).field_id;

	     message_text_user_field.multiline_text = (search (header_field_value, LINE_DELIMITERS) ^= 0);
	     if message_text_user_field.multiline_text then do;
		call mail_system_$get_user_field_name (message_text_user_field.field_id, full_fieldname, (0));
		message_text_user_field.text_ptr = null ();
		message_text_user_field.text_lth = 0;
		call prepare_multiline_field_from_text (length (full_fieldname), message_text_user_field.text,
		     header_field_value);
	     end;
	     else do;
		message_text_user_field.text_ptr = addr (header_field_value);
		message_text_user_field.text_lth = length (header_field_value);
	     end;

	     position = -1;				/* add it to the end, please */
	     call add_user_field (message_ptr, addr (local_mufp), position, "1"b, code);
	     if code ^= 0 then do;
		if message_text_user_field.multiline_text then free message_text_user_field_text in (system_area);
		call message_parse_error_fatal (code);
	     end;

	     if message_text_user_field.multiline_text then
		if message_text_user_field.text_ptr
		     ^= addr (message_user_fields_list.user_fields (position)) -> message_text_user_field.text_ptr
		     then
		     free message_text_user_field_text in (system_area);
	end;


/* Convert all free-standing comment fields into user-defined fields:  A free-standing comment is any Comment text field
   in the message for which the scanner didn't find matching Comment-Date and Comment-By fields */

	local_mufp.version = MESSAGE_USER_FIELD_PARAMETER_VERSION_2;
	message_user_field_ptr = addr (local_mufp.user_field);

	call mail_system_$get_user_field_id ("X-Comments", message_user_field.field_id, (""), code);
	if (code ^= 0) & (code ^= error_table_$smallarg) then call message_parse_error_fatal (code);
						/* must use above name to avoid conflicts */

	message_user_field.field_type = MESSAGE_TEXT_USER_FIELD;
	message_text_user_field.multiline_text = "1"b;
	message_text_user_field.text_ptr = null ();	/* no previous text */
	message_text_user_field.text_lth = 0;

	current_field_list_idx = 1;

	do while (current_field_list_idx <= comment_info_list.n_comment_infos);

	     comment_info_ptr = comment_info_list.comment_info_ptrs (current_field_list_idx);

	     if (comment_info.types (DATE_FIELD).n_fields = 0) & (comment_info.types (SENDER_FIELD).n_fields = 0)
	     then do;				/* this "commenting" should be a user field */
		call prepare_multiline_field_from_list (length ("X-Comments"), message_text_user_field.text,
		     addr (comment_info.types (COMMENT_FIELD)));
		free comment_info in (system_area);	/* we don't need it anymore */
		do idx = (current_field_list_idx + 1) to comment_info_list.n_comment_infos;
		     comment_info_list.comment_info_ptrs (idx - 1) = comment_info_list.comment_info_ptrs (idx);
		end;
		comment_info_list.n_comment_infos = comment_info_list.n_comment_infos - 1;
	     end;

	     else current_field_list_idx = current_field_list_idx + 1;
	end;					/* a real commenting operation */

	if message_text_user_field.text_ptr ^= null () then do;
	     position = -1;				/* found some: add them to the message */
	     call add_user_field (message_ptr, addr (local_mufp), position, "1"b, code);
	     if code ^= 0 then do;
		free message_text_user_field_text in (system_area);
		call message_parse_error_fatal (code);
	     end;
	     if message_text_user_field.text_ptr
		^= addr (message_user_fields_list.user_fields (position)) -> message_text_user_field.text_ptr then
		free message_text_user_field_text in (system_area);
	end;


	if new_message then do;

/* New Message -- Mark any redistributions and any remaining comments as errors */

	     do current_field_list_idx = 1 to forwarding_info_list.n_forwarding_infos;
		forwarding_info_ptr = forwarding_info_list.forwarding_info_ptrs (current_field_list_idx);
		do idx = 1 to N_ORDINARY_FIELDS;
		     call mark_as_in_mailbox_field (addr (forwarding_info.types (idx)));
		end;
	     end;

	     do current_field_list_idx = 1 to comment_info_list.n_comment_infos;
		comment_info_ptr = comment_info_list.comment_info_ptrs (current_field_list_idx);
		do idx = 1 to N_ORDINARY_FIELDS;
		     call mark_as_in_mailbox_field (addr (comment_info.types (idx)));
		end;
	     end;
	end;


	else do;					/* in-mailbox/incoming */
	     if (forwarding_info_list.n_forwarding_infos = 0) & (comment_info_list.n_comment_infos > 0) then do;
		do current_field_list_idx = 1 to comment_info_list.n_comment_infos;
		     comment_info_ptr = comment_info_list.comment_info_ptrs (current_field_list_idx);
		     call find_first_field_in_list (comment_info_ptr, field_idx);
		     call message_parse_error (parse_text_options, mlsys_et_$no_comment_redistribution,
			header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "The comment which starts with:");
		end;
	     end;


/* In-mailbox/Incoming Message -- Parse the redistributions list */

	     if forwarding_info_list.n_forwarding_infos > 0 then do;

		allocate mr_sort in (system_area) set (mr_sort_ptr);
		allocate mrps in (system_area) set (mrps_ptr);

		mrps (*).version = MESSAGE_REDISTRIBUTION_PARAMETER_VERSION_2;
		mrps (*).sender, mrps (*).trace, mrps (*).delivered_by, mrps (*).acknowledge_to, mrps (*).from,
		     mrps (*).to, mrps (*).comment.text_ptr = null ();

		do current_field_list_idx = 1 to forwarding_info_list.n_forwarding_infos;
		     the_mrp_ptr = addr (mrps (current_field_list_idx));

		     forwarding_info_ptr = forwarding_info_list.forwarding_info_ptrs (current_field_list_idx);
		     call find_first_field_in_list (forwarding_info_ptr, first_field_idx);

		     call parse_envelope (parse_text_options, internal_parse_options, "1"b, forwarding_info_ptr,
			addr (the_mrp.envelope), the_mrp.date_time_created, the_mrp.from);

		     if field_by_type_lists.types (MESSAGE_ID_FIELD).n_fields = 1 then do;
			field_idx = field_by_type_lists.types (MESSAGE_ID_FIELD).field_idxs (1);
			call parse_message_id_text (parse_text_options, internal_parse_options, header_field_value,
			     the_mrp.message_id);
		     end;
		     else if field_by_type_lists.types (MESSAGE_ID_FIELD).n_fields > 1 then do;
			do idx = 1 to field_by_type_lists.types (MESSAGE_ID_FIELD).n_fields;
			     field_idx = field_by_type_lists.types (MESSAGE_ID_FIELD).field_idxs (idx);
			     call message_parse_error (parse_text_options, mlsys_et_$extra_restricted_field,
				header_field_list.fields (field_idx).complete_field_start,
				header_field_list.fields (field_idx).complete_field_lth, "");
			end;
		     end;
		     else do;			/* must construct a psudeo ID */
			if (the_mrp.date_time_created ^= 0) & (the_mrp.from -> address_list.n_addresses > 0) then
			     call encode_psuedo_id (the_mrp.date_time_created, the_mrp.from,
				internal_parse_options.default_system_name, the_mrp.message_id);
			else call message_parse_error (parse_text_options, mlsys_et_$cant_determine_msgid,
				header_field_list.fields (first_field_idx).complete_field_start,
				header_field_list.fields (first_field_idx).complete_field_lth,
				"The redistribution which starts with:");
		     end;

		     full_fieldname = REDISTRIBUTED_PREFIX || TO_FIELDNAME;
		     if forwarding_info.types (TO_FIELD).n_fields > 0 then
			call parse_address_list_field (parse_text_options, internal_parse_options, full_fieldname,
			     addr (forwarding_info.types (TO_FIELD)), the_mrp.to);

		     if forwarding_info.types (COMMENT_FIELD).n_fields > 0 then
			call prepare_multiline_field_from_list (length (REDISTRIBUTED_COMMENT_FIELDNAME),
			     the_mrp.comment, addr (forwarding_info.types (COMMENT_FIELD)));
		end;


/* In-mailbox/Incoming message -- Find any old-style redistribution comments (Comment-Date/Comment-By/Comment) and place
   their text into the appropriate redistribution */

		internal_parse_options.default_system_name = mlsys_nit_interface_$get_local_system_name ();
		internal_parse_options.default_system_is_local = "1"b;

		do current_field_list_idx = 1 to comment_info_list.n_comment_infos;
		     comment_info_ptr = comment_info_list.comment_info_ptrs (current_field_list_idx);
		     call find_first_field_in_list (comment_info_ptr, first_field_idx);

		     if (comment_info.types (DATE_FIELD).n_fields = 0)
			| (comment_info.types (SENDER_FIELD).n_fields = 0) then
			call message_parse_error (parse_text_options, mlsys_et_$incomplete_comment,
			     header_field_list.fields (first_field_idx).complete_field_start,
			     header_field_list.fields (first_field_idx).complete_field_lth,
			     "The comment which starts with:");

		     else do;
			/*** Message scanner guarentees at most one Comment-Date and Comment-By */
			field_idx = comment_info.types (DATE_FIELD).field_idxs (1);
			call parse_date_time_text (parse_text_options, internal_parse_options, header_field_value,
			     comment_date_time_created, code);
			if code ^= 0 then do;
			     call message_parse_error (parse_text_options, code,
				header_field_list.fields (field_idx).complete_field_start,
				header_field_list.fields (field_idx).complete_field_lth, "");
			     call message_parse_error (parse_text_options, mlsys_et_$comment_ignored,
				header_field_list.fields (first_field_idx).complete_field_start,
				header_field_list.fields (first_field_idx).complete_field_lth,
				"The comment which starts with:");
			     go to TRY_NEXT_COMMENT_OPERATION;
			end;

			field_idx = comment_info.types (SENDER_FIELD).field_idxs (1);
			call parse_address_text_internal (parse_text_options, internal_parse_options,
			     header_field_value, comment_sender, code);
			if code ^= 0 then do;
			     call message_parse_error (parse_text_options, code,
				header_field_list.fields (field_idx).complete_field_start,
				header_field_list.fields (field_idx).complete_field_lth, "");
			     call message_parse_error (parse_text_options, mlsys_et_$comment_ignored,
				header_field_list.fields (first_field_idx).complete_field_start,
				header_field_list.fields (first_field_idx).complete_field_lth,
				"The comment which starts with:");
			     go to TRY_NEXT_COMMENT_OPERATION;
			end;

			do idx = 1 to forwarding_info_list.n_forwarding_infos;
			     if mrps (idx).sender = null () then
				redistribution_sender = mrps (idx).from -> address_list.addresses (1);
			     else redistribution_sender = mrps (idx).sender;
			     if date_time_equal (comment_date_time_created, mrps (idx).date_time_created)
				& mail_system_$compare_addresses (comment_sender, redistribution_sender, (0))
			     then do;
				if comment_info.types (COMMENT_FIELD).n_fields > 0 then
				     call prepare_multiline_field_from_list (length ("Comment"),
					mrps (idx).comment, addr (comment_info.types (COMMENT_FIELD)));
				call mail_system_$free_address (comment_sender, (0));
				go to TRY_NEXT_COMMENT_OPERATION;
			     end;
			end;

			/*** Control arrives here iff we couldn't find the matching redistribution */
			call message_parse_error (parse_text_options, mlsys_et_$no_comment_redistribution,
			     header_field_list.fields (first_field_idx).complete_field_start,
			     header_field_list.fields (first_field_idx).complete_field_lth,
			     "The comment which starts with:");
		     end;

TRY_NEXT_COMMENT_OPERATION:
		end;


/* In-mailbox/Incoming Message -- Sort the redistributions into chronological order; redistributions whose date/time
   created is unkown will be placed at the beginning of the list */

		n_sorted = 0;			/* nothing's sorted yet */

		do current_field_list_idx = 1 to forwarding_info_list.n_forwarding_infos;
		     the_mrp_ptr = addr (mrps (current_field_list_idx));

		     sort_idx = 0;
		     do idx = 1 to n_sorted while (sort_idx = 0);
			if date_time_before (the_mrp.date_time_created, mrps (mr_sort (idx)).date_time_created) then
			     sort_idx = idx;
		     end;
		     if sort_idx = 0 then		/* this is the oldest one now */
			sort_idx = n_sorted + 1;

		     do idx = n_sorted to sort_idx by -1;
			mr_sort (idx + 1) = mr_sort (idx);
		     end;				/* move older fields up */

		     mr_sort (sort_idx) = current_field_list_idx;
		     n_sorted = n_sorted + 1;
		end;
	     end;


/* In-mailbox/Incoming Message -- Determine where the "original" message trace belongs as only Multics uses the
   "Redistributed-" forms of the message trace fields */

	     if (local_mep.trace ^= null ()) & (forwarding_info_list.n_forwarding_infos > 0) then
		if local_mep.trace -> message_trace.n_relays > 0 then do;
		     message_trace_ptr = local_mep.trace;
		     date_time_last_relayed = message_trace.relays (message_trace.n_relays).date_time_relayed;

		     do current_field_list_idx = 1 to forwarding_info_list.n_forwarding_infos;
			idx = mr_sort (current_field_list_idx);
			if date_time_before (date_time_last_relayed, mrps (idx).date_time_created) then do;
			     if idx = 1 then go to ORIGINAL_TRACE_PROPERLY_PLACED;
			     if mrps (idx - 1).date_time_created = 0 then go to ORIGINAL_TRACE_PROPERLY_PLACED;
			     if mrps (idx - 1).trace ^= null () then go to ORIGINAL_TRACE_PROPERLY_PLACED;
			     mrps (idx - 1).trace = local_mep.trace;
			     local_mep.trace = null ();
			     go to ORIGINAL_TRACE_PROPERLY_PLACED;
			end;
		     end;

		     /*** Control arrives here iff the trace should be attached to the last redistribution */
		     if (mrps (forwarding_info_list.n_forwarding_infos).date_time_created ^= 0)
			& (mrps (forwarding_info_list.n_forwarding_infos).trace = null ()) then do;
			mrps (forwarding_info_list.n_forwarding_infos).trace = local_mep.trace;
			local_mep.trace = null ();
		     end;

ORIGINAL_TRACE_PROPERLY_PLACED:
		end;


/* In-mailbox/Incoming Message -- Set the Acknowledge-To fields */

	     acknowledge_to = null ();

	     if internal_parse_options.requests_acknowledgement then do;
		do current_field_list_idx = forwarding_info_list.n_forwarding_infos to 1 by -1
		     while (acknowledge_to = null ());
		     idx = mr_sort (current_field_list_idx);
		     if mrps (idx).acknowledge_to ^= null () then acknowledge_to = mrps (idx).acknowledge_to;
		end;

		if acknowledge_to = null () then acknowledge_to = local_mep.acknowledge_to;
		if acknowledge_to = null () then acknowledge_to = internal_parse_options.last_delivered_by;
	     end;

	     if forwarding_info_list.n_forwarding_infos = 0 then do;
		if (local_mep.acknowledge_to ^= null ()) & (local_mep.acknowledge_to ^= acknowledge_to) then
		     call mail_system_$free_address (local_mep.acknowledge_to, (0));
		local_mep.acknowledge_to = acknowledge_to;
	     end;

	     else do;				/* put it in the last redistribution */
		idx = mr_sort (forwarding_info_list.n_forwarding_infos);
		if (mrps (idx).acknowledge_to ^= null ()) & (mrps (idx).acknowledge_to ^= acknowledge_to) then
		     call mail_system_$free_address (mrps (idx).acknowledge_to, (0));

		mrps (idx).acknowledge_to = acknowledge_to;

		do current_field_list_idx = 1 to (forwarding_info_list.n_forwarding_infos - 1);
		     idx = mr_sort (current_field_list_idx);
		     if (mrps (idx).acknowledge_to ^= null ()) & (mrps (idx).acknowledge_to ^= acknowledge_to) then
			call mail_system_$free_address (mrps (idx).acknowledge_to, (0));
		     else mrps (idx).acknowledge_to = null ();
		end;

		if (local_mep.acknowledge_to ^= null ()) & (local_mep.acknowledge_to ^= acknowledge_to) then
		     call mail_system_$free_address (local_mep.acknowledge_to, (0));
		else local_mep.acknowledge_to = null ();/* message should hve only one Acknowledge-To field */
	     end;


/* In-mailbox/Incoming Message -- If supplied, set the last delivery date and address to the values from ring-1 and then
   place the envelope and redistributions list into the message */

	     if internal_parse_options.last_delivered_by ^= null () then
		if forwarding_info_list.n_forwarding_infos = 0 then do;
		     local_mep.date_time_delivered = internal_parse_options.last_date_time_delivered;
		     if local_mep.delivered_by ^= null () then
			call mail_system_$free_address (local_mep.delivered_by, (0));
		     if local_mep.sender ^= null () then
			if mail_system_$compare_addresses (local_mep.sender,
			     internal_parse_options.last_delivered_by, (0)) then
			     ;
			else local_mep.delivered_by = internal_parse_options.last_delivered_by;
		     else /*** if local_mep.sender = null () then */
			if
			mail_system_$compare_addresses (message.from -> address_list.addresses (1),
			internal_parse_options.last_delivered_by, (0)) then
			;
		     else local_mep.delivered_by = internal_parse_options.last_delivered_by;
		end;

		else do;
		     the_mrp_ptr = addr (mrps (mr_sort (forwarding_info_list.n_forwarding_infos)));
		     the_mrp.date_time_delivered = internal_parse_options.last_date_time_delivered;
		     if the_mrp.delivered_by ^= null () then
			call mail_system_$free_address (the_mrp.delivered_by, (0));
		     if the_mrp.sender ^= null () then
			if mail_system_$compare_addresses (the_mrp.sender, internal_parse_options.last_delivered_by,
			     (0)) then
			     ;
			else the_mrp.delivered_by = internal_parse_options.last_delivered_by;
		     else /*** if the_mrp.sender = null () then */
			if
			mail_system_$compare_addresses (the_mrp.from -> address_list.addresses (1),
			internal_parse_options.last_delivered_by, (0)) then
			;
		     else the_mrp.delivered_by = internal_parse_options.last_delivered_by;
		end;

	     call replace_message_envelope (message_ptr, addr (local_mep), code);
	     if code ^= 0 then call message_parse_error_fatal (code);
	     local_mep.sender, local_mep.delivered_by, local_mep.acknowledge_to = null ();

	     do current_field_list_idx = 1 to forwarding_info_list.n_forwarding_infos;
		idx = mr_sort (current_field_list_idx);
		the_mrp_ptr = addr (mrps (idx));
		position = -1;			/* add it to the end please */
		call add_redistribution (message_ptr, the_mrp_ptr, position, code);
		if code ^= 0 then call message_parse_error_fatal (code);
		the_mrp.sender, the_mrp.delivered_by, the_mrp.acknowledge_to = null ();
		message_redistribution_ptr = addr (message_redistributions_list.redistributions (position));
		if the_mrp.from = message_redistribution.from then the_mrp.from = null ();
		if the_mrp.to = message_redistribution.to then the_mrp.to = null ();
		if the_mrp.comment.text_ptr = message_redistribution.comment.text_ptr then
		     the_mrp.comment.text_ptr = null ();/* don't leave it to be freed if it's used directly */
	     end;


/* In-mailbox/Incoming Message -- Set the implicit route for all addresses as appropriate */

	     if message.envelope.trace ^= null () then
		if message.envelope.trace -> message_trace.implicit_route ^= null () then do;
		     implicit_route = message.envelope.trace -> message_trace.implicit_route;
		     call set_implicit_route (message.from, implicit_route);
		     call set_implicit_route (message.reply_to, implicit_route);
		     call set_implicit_route (message.to, implicit_route);
		     call set_implicit_route (message.cc, implicit_route);
		     call set_implicit_route (message.bcc, implicit_route);
		     do idx = 1 to message.n_user_fields;
			message_user_field_ptr = addr (message_user_fields_list.user_fields (idx));
			if message_user_field.field_type = MESSAGE_ADDRESS_LIST_USER_FIELD then
			     call set_implicit_route (message_address_list_user_field.address_list_ptr,
				implicit_route);
		     end;
		end;

	     do idx = 1 to message.n_redistributions;
		message_redistribution_ptr = addr (message_redistributions_list.redistributions (idx));
		if message_redistribution.envelope.trace ^= null () then
		     if message_redistribution.envelope.trace -> message_trace.implicit_route ^= null () then do;
			implicit_route = message_redistribution.envelope.trace -> message_trace.implicit_route;
			call set_implicit_route (message_redistribution.from, implicit_route);
			call set_implicit_route (message_redistribution.to, implicit_route);
		     end;
	     end;
	end;


/* Control arrives here iff the message parse succeeded */

	call cleanup_message_parse_data ();		/* get rid of all temporaries */

	P_message_ptr = message_ptr;			/* pass the message back to our caller */

	if parse_text_options.list_errors then		/* will never be set by entries without this parameter */
	     P_parse_text_error_list_ptr = parse_text_error_list_ptr;

	if message_parse_fails then			/* some types of errors were detected ... */
	     P_code = mlsys_et_$text_parse_failed;	/* ... even though we might return a message structure */
	else P_code = 0;

	return;
%page;
/* Convert the external form of a mailing list (an ASCII segment/archive component containing the printed representation
   of addresses) into its internal representation:  This operation is identical to parse_address_list_text except that
   each line in a mailing list is considered a separate list unless, of course, a single address spans multiple lines; in
   addition, the lines in a mailing list may contain an optional trailing comma */

parse_mailing_list_text:
     entry (P_representation, P_address_list_version, P_address_list_ptr, P_code);

	local_pto.area_ptr = null ();			/* setup standard parse options */
	string (local_pto.flags) = ""b;
	local_pto.list_errors = "1"b;			/* see below */
	local_pto.include_invalid_addresses = "1"b;
	parse_text_options_ptr = addr (local_pto);

	string (internal_parse_options.flags) = ""b;
	internal_parse_options.multics_format = "1"b;	/* use standard Multics formatting conventions */
	internal_parse_options.no_copy = "0"b;		/* can't use supplied text directly (sigh) */

	internal_parse_options.default_system_is_local = "1"b;
	internal_parse_options.default_system_name = mlsys_nit_interface_$get_local_system_name ();

	string (internal_parse_options.delimiters) = ""b; /* terminate corectly only at the end of the string */
	internal_parse_options.delimiters.eos = "1"b;

	system_area_ptr = get_system_free_area_ ();

	add_address = mlsys_address_list_mgr_$add_address;
	create_address_list = mlsys_address_list_mgr_$create_user_freeable_address_list;
	delete_address = mlsys_address_list_mgr_$delete_address;
	free_address_list = mlsys_address_list_mgr_$free_address_list;

	address_list_ptr,				/* for cleanup handler */
	     lex_and_parse_pointers, forum_search_list_ptr = null ();

	on condition (cleanup)
	     begin;
	     if address_list_ptr ^= null () then call mlsys_address_list_mgr_$free_address_list (address_list_ptr, (0));
	     call lex_and_parse_epilogue ("1"b);
	     if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
	     forum_search_list_ptr = null ();
	end;

	call mlsys_address_list_mgr_$create_user_freeable_address_list (P_address_list_version, address_list_ptr, code);
	if code ^= 0 then do;			/* probably asked for the wrong version */
	     P_code = code;
	     return;
	end;

	representation_ptr = addr (P_representation);
	representation_lth = length (P_representation);
	representation_used = 0;			/* haven't parsed any of it yet */

	eol_idx = index (representation, NL);		/* start with first line in the mailing list */
	if eol_idx = 0 then eol_idx = length (representation) + 1;

	do while (representation_used < representation_lth);

	     begin;				/* try to parse the next section (usually a line) */

dcl  text_to_parse character (eol_idx - 1) unaligned defined (representation) position (representation_used + 1);

		if verify (text_to_parse, WHITESPACE) = 0 then
		     n_syntax_errors = 0;		/* ingore blank lines */
		else call parse_address_list_text_internal (parse_text_options, internal_parse_options, text_to_parse,
			address_list_ptr, code);

		if (n_syntax_errors > 0) & ((representation_used + eol_idx) < representation_lth) then do;

		     /*** Check for errors which can be generated if the last address in this section is incomplete */
		     if (sel (1).code = mlsys_et_$unbalanced_braces) | (sel (1).code = mlsys_et_$unbalanced_quotes)
			| (sel (1).code = mlsys_et_$unbalanced_parentheses) then do;
			call mlsys_address_list_mgr_$delete_address (address_list_ptr, address_list.n_addresses,
			     (0));
			amount_good = 0;		/* try entire section again with next line */
		     end;

		     else if sel (n_syntax_errors).code = mlsys_et_$invalid_named_group_text then
			if (sel (n_syntax_errors).text_start + sel (n_syntax_errors).text_lth)
			     >= length (text_to_parse) then do;
			     call mlsys_address_list_mgr_$delete_address (address_list_ptr,
				address_list.n_addresses, (0));
			     amount_good = sel (n_syntax_errors).text_start - 1;
			end;			/* try bad named group again with next line */
			else amount_good = length (text_to_parse);

		     else if sel (n_syntax_errors).code = mlsys_et_$empty_address_text then do;
			if (sel (n_syntax_errors).text_start + sel (n_syntax_errors).text_lth)
			     >= length (text_to_parse) then do;
			     begin;
dcl  empty_text character (sel (n_syntax_errors).text_lth) unaligned defined (representation)
	position (representation_used + sel (n_syntax_errors).text_start);
				if verify (empty_text, WHITESPACE) = 0 then
				     call mlsys_address_list_mgr_$delete_address (address_list_ptr,
					address_list.n_addresses, (0));
			     end;
			     amount_good = length (text_to_parse);
			end;

			else amount_good = length (text_to_parse);
		     end;

		     else amount_good = length (text_to_parse);
		end;

		else amount_good = length (text_to_parse);
	     end;

	     if (representation_used + amount_good) < representation_lth then do;
		begin;				/* find end of next line beyond current section */
dcl  rest_of_representation character (representation_lth - representation_used - eol_idx) unaligned
	defined (representation) position (representation_used + eol_idx);
		     next_eol_idx = index (rest_of_representation, NL);
		     if next_eol_idx = 0 then next_eol_idx = length (rest_of_representation) + 1;
		end;
		eol_idx = eol_idx - amount_good + next_eol_idx;
		representation_used = representation_used + amount_good;
	     end;
	     else representation_used = representation_lth;

	     call lex_and_parse_epilogue ("1"b);	/* get rid of syntax error list */
	end;

	P_address_list_ptr = address_list_ptr;		/* success */
	P_code = 0;

	return;
%page;
/* Convert the printed representation of an address list into its internal representation */

parse_address_list_text:
     entry (P_representation, P_parse_text_options_ptr, P_address_list_version, P_address_list_ptr,
	P_parse_text_error_list_ptr, P_code);

	parse_text_options_ptr = P_parse_text_options_ptr;
	if parse_text_options.version ^= PARSE_TEXT_OPTIONS_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;
	if parse_text_options.mbz ^= ""b then do;
	     P_code = error_table_$bad_subr_arg;
	     return;
	end;

	add_address = mail_system_$add_address;
	create_address_list = mail_system_$create_address_list;
	delete_address = mail_system_$delete_address;
	free_address_list = mail_system_$free_address_list;

	system_area_ptr = get_system_free_area_ ();

	if parse_text_options.area_ptr = null () then
	     user_area_ptr = get_system_free_area_ ();
	else user_area_ptr = parse_text_options.area_ptr;

	string (internal_parse_options.flags) = ""b;
	internal_parse_options.multics_format = "1"b;	/* use standard Multics formatting conventions */
	internal_parse_options.no_copy = "0"b;		/* can't use supplied text directly */

	internal_parse_options.default_system_is_local = "1"b;
	internal_parse_options.default_system_name = mlsys_nit_interface_$get_local_system_name ();

	string (internal_parse_options.delimiters) = ""b; /* terminate corectly only at the end of the string */
	internal_parse_options.delimiters.eos = "1"b;

	address_list_ptr,				/* for cleanup handler */
	     lex_and_parse_pointers, forum_search_list_ptr = null ();

	on condition (cleanup)
	     begin;
	     if address_list_ptr ^= null () then call mail_system_$free_address_list (address_list_ptr, (0));
	     call lex_and_parse_epilogue ("1"b);
	     if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
	     forum_search_list_ptr = null ();
	end;

	call mail_system_$create_address_list (P_address_list_version, address_list_ptr, code);
	if code ^= 0 then do;			/* probably asked for the wrong version */
	     P_code = code;
	     return;
	end;

	call parse_address_list_text_internal (parse_text_options, internal_parse_options, P_representation,
	     address_list_ptr, code);

	if code ^= 0 then				/* iff caller requested an error free list */
	     call mail_system_$free_address_list (address_list_ptr, (0));

	if parse_text_options.list_errors & (n_syntax_errors > 0) then do;
	     parse_text_error_list_n_errors = n_syntax_errors;
	     allocate parse_text_error_list in (system_area) set (parse_text_error_list_ptr);
	     do idx = 1 to parse_text_error_list.n_errors;
		parse_text_error_list.errors (idx).text_start = sel (idx).text_start;
		parse_text_error_list.errors (idx).text_lth = sel (idx).text_lth;
		parse_text_error_list.errors (idx).code = sel (idx).code;
		parse_text_error_list.errors (idx).additional_info = "";
	     end;
	end;
	else parse_text_error_list_ptr = null ();

	call lex_and_parse_epilogue ("1"b);		/* get rid of syntax error list now */

	P_address_list_ptr = address_list_ptr;
	P_parse_text_error_list_ptr = parse_text_error_list_ptr;

	if n_syntax_errors > 0 then			/* something went wrong: let caller know ... */
	     P_code = mlsys_et_$text_parse_failed;	/* ... even though they might still be getting a list back */
	else P_code = 0;

	return;



/* Actually lexically analyze and parse the address list text (called from several different entrypoints) */

parse_address_list_text_internal:
     procedure (p_pto, p_ipo, p_representation, p_address_list_ptr, p_code) /* options (quick) */;

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_representation character (*) parameter;
dcl  p_address_list_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

dcl  bad_address pointer;

	call lex_and_parse_prologue (p_representation, "1"b, "1"b);
						/* lex of an address with syntax list */

	call lex_address (p_pto, p_ipo, p_code);	/* convert it into a token list */

	if p_code = 0 then				/* lex worked: try parsing it */
	     call parse_address_list (p_pto, p_ipo, 0, p_address_list_ptr, p_code);
	else do;					/* lex failed: record one error */
	     n_syntax_errors = 1;
	     if p_pto.list_errors then do;
		sel (1).text_start = 1;
		sel (1).text_lth = length (p_representation);
		sel (1).code = p_code;
	     end;
	     if p_pto.include_invalid_addresses then do;
		call mail_system_$create_invalid_address ((p_representation), "", "", bad_address, (0));
		call add_address (p_address_list_ptr, bad_address, ADDRESS_LIST_VERSION_2, (0));
		p_code = 0;			/* claim success */
	     end;
	end;

	call lex_and_parse_epilogue ("0"b);		/* cleanup */

	return;

     end parse_address_list_text_internal;
%page;
/* Convert the printed representation of an address into its internal representation */

parse_address_text:
     entry (P_representation, P_address_ptr, P_code);

	add_address = mail_system_$add_address;
	create_address_list = mail_system_$create_address_list;
	delete_address = mail_system_$delete_address;
	free_address_list = mail_system_$free_address_list;

	system_area_ptr = get_system_free_area_ ();

	parse_text_options_ptr = addr (local_pto);	/* caller doesn't supply this structure */
	string (local_pto.flags) = ""b;		/* ... don't list, validate, or create invalid addresses */

	internal_parse_options.multics_format = "1"b;	/* use standard Multics formatting conventions */
	internal_parse_options.no_copy = "0"b;		/* can't use supplied text directly */

	internal_parse_options.default_system_is_local = "1"b;
	internal_parse_options.default_system_name = mlsys_nit_interface_$get_local_system_name ();

	string (internal_parse_options.delimiters) = ""b; /* terminate corectly only at the end of the string */
	internal_parse_options.delimiters.eos = "1"b;

	lex_and_parse_pointers,			/* for cleanup handler */
	     forum_search_list_ptr = null ();

	on condition (cleanup)
	     begin;
	     call lex_and_parse_epilogue ("1"b);
	     if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
	     forum_search_list_ptr = null ();
	end;

	call parse_address_text_internal (parse_text_options, internal_parse_options, P_representation, address_ptr,
	     code);

	if code = 0 then				/* successfully parsed an address from the string */
	     P_address_ptr = address_ptr;

	P_code = code;

	return;



/* Actually lexically analyze and parse the address text (called from several different entrypoints) */

parse_address_text_internal:
     procedure (p_pto, p_ipo, p_representation, p_address_ptr, p_code) /* options (quick) */;

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_representation character (*) parameter;
dcl  p_address_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	call lex_and_parse_prologue (p_representation, "1"b, "0"b);
						/* lex of an address without syntax list */

	call lex_address (p_pto, p_ipo, p_code);	/* convert it into a token list */

	if p_code = 0 then				/* lex worked: try parsing it */
	     call parse_address (p_pto, p_ipo, 0, p_address_ptr, p_code);

	call lex_and_parse_epilogue ("1"b);		/* cleanup */
	call cu_$shrink_stack_frame (stack_extension_ptr, (0));

	return;

     end parse_address_text_internal;
%page;
/* Initialize data structures used during parsing of a message */

initialize_message_parse_data:
     procedure ();

	message_scan.array_pointers, lex_and_parse_pointers, parse_text_error_list_ptr, mrps_ptr, mr_sort_ptr,
	     trace_address, comment_sender, local_mep.sender, local_mep.trace, local_mep.delivered_by,
	     local_mep.acknowledge_to, address_list_field, forum_search_list_ptr = null ();

	return;

     end initialize_message_parse_data;



/* Release interim data structures created during parsing of a message */

cleanup_message_parse_data:
     procedure ();

dcl  (idx, jdx) fixed binary;

	if forum_search_list_ptr ^= null () then free forum_search_list_ptr -> sl_info in (system_area);
	forum_search_list_ptr = null ();

	if address_list_field ^= null () then call free_address_list (address_list_field, (0));

	if local_mep.sender ^= null () then call mail_system_$free_address (local_mep.sender, (0));
	if local_mep.trace ^= null () then do;
	     if local_mep.trace -> message_trace.implicit_route ^= null () then
		free local_mep.trace -> message_trace.implicit_route -> address_route in (system_area);
	     do idx = 1 to local_mep.trace -> message_trace.n_relays;
		if local_mep.trace -> message_trace.relays (idx).relay_recipient ^= null () then
		     call mail_system_$free_address (local_mep.trace -> message_trace.relays (idx).relay_recipient,
			(0));
	     end;
	     free local_mep.trace -> message_trace in (system_area);
	     local_mep.trace = null ();
	end;
	if local_mep.delivered_by ^= null () then call mail_system_$free_address (local_mep.delivered_by, (0));
	if local_mep.acknowledge_to ^= null () then call mail_system_$free_address (local_mep.acknowledge_to, (0));

	if mrps_ptr ^= null () then do;
	     do idx = 1 to forwarding_info_list.n_forwarding_infos;
		if mrps (idx).sender ^= null () then call mail_system_$free_address (mrps (idx).sender, (0));
		if mrps (idx).trace ^= null () then do;
		     if mrps (idx).trace -> message_trace.implicit_route ^= null () then
			free mrps (idx).trace -> message_trace.implicit_route -> address_route in (system_area);
		     do jdx = 1 to mrps (idx).trace -> message_trace.n_relays;
			if mrps (idx).trace -> message_trace.relays (jdx).relay_recipient ^= null () then
			     call mail_system_$free_address (mrps (idx).trace
				-> message_trace.relays (jdx).relay_recipient, (0));
		     end;
		     free mrps (idx).trace -> message_trace in (system_area);
		     mrps (idx).trace = null ();
		end;
		if mrps (idx).delivered_by ^= null () then
		     call mail_system_$free_address (mrps (idx).delivered_by, (0));
		if mrps (idx).acknowledge_to ^= null () then
		     call mail_system_$free_address (mrps (idx).acknowledge_to, (0));
		if mrps (idx).from ^= null () then call free_address_list (mrps (idx).from, (0));
		if mrps (idx).to ^= null () then call free_address_list (mrps (idx).to, (0));
		if mrps (idx).comment.text_ptr ^= null () then
						/* there's some text ... */
		     begin;
dcl  the_comment character (mrps (idx).comment.text_lth) unaligned based (mrps (idx).comment.text_ptr);
		     free the_comment in (system_area);
		     mrps (idx).comment.text_ptr = null ();
		end;
	     end;
	     free mrps in (system_area);
	     mrps_ptr = null ();
	end;

	if mr_sort_ptr ^= null () then do;
	     free mr_sort in (system_area);
	     mr_sort_ptr = null ();
	end;

	if trace_address ^= null () then call mail_system_$free_address (trace_address, (0));

	if comment_sender ^= null () then call mail_system_$free_address (comment_sender, (0));

	call cleanup_message_scan ();			/* cleanup straight-forward data */
	call lex_and_parse_epilogue ("1"b);

	return;

     end cleanup_message_parse_data;
%page;
/* Scan the complete text of a message: isolate the message header and body; locate and classify each header field in the
   message */

scan_message_text:
     procedure (p_pto, p_ipo);

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;

dcl  message_header character (message_header_lth) unaligned based (message_header_ptr);
dcl  message_header_lth fixed binary (21);
dcl  message_header_ptr pointer;

dcl  message_body character (message_body_lth) unaligned based (message_body_ptr);
dcl  message_body_lth fixed binary (21);
dcl  message_body_ptr pointer;

dcl  field_name character (field_name_lth) unaligned based (field_name_ptr);
dcl  field_name_lth fixed binary (21);			/* current header field being examined */
dcl  field_name_ptr pointer;

dcl  (continuation_found, in_forwarding_info, in_comment_info) bit (1) aligned;

dcl  (start, eol_idx, idx, idx2, field_name_start, field_value_start) fixed binary (21);

dcl  (total_field_count, field_type) fixed binary;


	message_body_ptr,				/* examine entire message initially */
	     message_header_ptr = representation_ptr;
	message_body_lth, message_header_lth = representation_lth;
	message_scan.header_offset = 0;

	idx = verify (message_header, NL);		/* strip leading newlines added by defective FTP mailers */
	if idx ^= 0 then
	     if idx ^= 1 then do;
		message_body_ptr, message_header_ptr = addcharno (message_body_ptr, (idx - 1));
		message_body_lth, message_header_lth = message_header_lth - (idx - 1);
	     end;
	     else ;				/* no leading newlines */
	else go to NO_HEADER_FOUND_IN_MESSAGE;		/* all newlines: no header */

	message_scan.header_offset = charno (message_header_ptr) - charno (representation_ptr);

	idx = index (message_header, NLNL);		/* search for header delimiter (double newline) */
	if idx ^= 0 then				/* seems to have a header: adjust length ... */
	     message_header_lth = idx;		/* ... if <NL><NL> is missing, assume messageless header */

	idx = index (message_header, NL);		/* the header must have at least one newline in it */
	if idx = 0 then go to NO_HEADER_FOUND_IN_MESSAGE;

	idx = index (substr (message_header, 1, idx), COLON);
						/* header must have colon on first line */
	if idx = 0 then go to NO_HEADER_FOUND_IN_MESSAGE;


/* The message appears to have a header: tentatively set the location and size of the message body */

	message_body_ptr = addcharno (message_body_ptr, message_header_lth);
	message_body_lth = message_body_lth - message_header_lth;

	if message_body_lth <= 0 then do;		/* appears to be no body in the message, just a header */
	     message_scan.body_ptr = addr (NL);
	     message_scan.body_lth = 0;
	end;

	else do;					/* something there: strip leading newlines */
	     idx = verify (message_body, NL);
	     if (idx = 0) then message_body_lth = 0;	/* nothing but blank lines */
	     else if (idx ^= 1) then do;		/* some leading blank lines */
		message_body_ptr = addcharno (message_body_ptr, (idx - 1));
		message_body_lth = message_body_lth - (idx - 1);
	     end;
	     if (message_body_lth = 0) then do;		/* bodyless message */
		message_scan.body_ptr = addr (NL);
		message_scan.body_lth = 0;
	     end;
	     else do;				/* really do have body */
		message_scan.body_ptr = message_body_ptr;
		message_scan.body_lth = message_body_lth;
	     end;
	end;


/* Setup structures used to indicate results of the scan */

	message_scan.n_header_fields_allocated =	/* can't be more fields than lines in the header */
	     count_lines_in_text (message_header_ptr, message_header_lth);

	allocate header_field_list in (system_area) set (message_scan.header_field_list_ptr);
	header_field_list.n_fields = 0;		/* nothing examined yet */

	allocate field_by_type_lists in (system_area) set (message_scan.field_by_type_lists_ptr);
	field_by_type_lists.types (*).n_fields = 0;

	allocate forwarding_info_list in (system_area) set (message_scan.forwarding_info_list_ptr);
	forwarding_info_list.n_forwarding_infos = 0;

	allocate comment_info_list in (system_area) set (message_scan.comment_info_list_ptr);
	comment_info_list.n_comment_infos = 0;

	allocate user_field_list in (system_area) set (message_scan.user_field_list_ptr);
	user_field_list.n_user_fields = 0;


/* Now examine the purported header: find each field and classify it */

	start = 1;

	total_field_count = 0;			/* no fields yet */

	in_forwarding_info = "0"b;			/* not in the middle of a forwarding description */
	in_comment_info = "0"b;			/* ... ditto for comments */


	do while (start < message_header_lth);

	     eol_idx = index (substr (message_header, start), NL);
						/* find the end of this line */
	     if eol_idx = 0 then go to NO_HEADER_FOUND_IN_MESSAGE;
						/* fields must end in newline */

	     idx = index (substr (message_header, start, eol_idx), COLON);
	     if idx = 0 then go to NO_HEADER_FOUND_IN_MESSAGE;
						/* field name MUST be on first line */

	     field_name_ptr = addcharno (message_header_ptr, (start - 1));
	     field_name_start = start;		/* record where the field starts (for error messages) */
	     field_name_lth = idx - 1;		/* initially everything up to the colon */

	     idx2 = verify (field_name, HTSP);		/* field name must start at left margin */
	     if idx2 ^= 1 then go to NO_HEADER_FOUND_IN_MESSAGE;

	     field_name_lth = length (rtrim (field_name, HTSP));
						/* strip trailing whitespace from name */

	     start = start + idx;			/* skip to first character after the colon */

	     idx = verify (substr (message_header, start), HTSP);
	     if idx = 0 then go to NO_HEADER_FOUND_IN_MESSAGE;
						/* nothing after the colon (even a newline) */

	     start = start + idx - 1;			/* skip over the intervening whitespace */
	     field_value_start = start;		/* and remember where it is */

	     continuation_found = "1"b;		/* look for continuation lines */
	     do while (continuation_found);
		eol_idx = index (substr (message_header, start), NL);
		if eol_idx = 0 then go to NO_HEADER_FOUND_IN_MESSAGE;
		start = start + eol_idx;		/* skip to the next line */
		if index (HTSP, substr (message_header, start, 1)) ^= 0 then
		     continuation_found = "1"b;	/* this line is a continuation of the current field */
		else continuation_found = "0"b;	/* a new field */
	     end;

	     header_field_list.n_fields,		/* here's a new field */
		field_idx = header_field_list.n_fields + 1;

	     header_field_list.fields (field_idx).field_value_ptr =
		addcharno (message_header_ptr, (field_value_start - 1));
						/* where it starts ... */
	     header_field_list.fields (field_idx).field_value_lth = start - (field_value_start + 1);
						/* ... and how long excluding the trailing newline ... */
	     header_field_list.fields (field_idx).field_value_lth = length (rtrim (header_field_value, HTSP));
						/* ... and trailing whitespace */

	     header_field_list.fields (field_idx).complete_field_start = field_name_start;
	     header_field_list.fields (field_idx).complete_field_lth =
		field_value_start - field_name_start + header_field_list.fields (field_idx).field_value_lth;
						/* record location/size of entire field for error reporting */

	     call mlsys_field_id_mgr_$get_system_field_type (field_name, field_type, code);
	     if code ^= 0 then do;			/* field name is reserved for future expansion ... */
		call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
		header_field_list.n_fields, field_idx = header_field_list.n_fields - 1;
		go to PROCESS_NEXT_FIELD;
	     end;


	     if field_type = USER_DEFINED_FIELD then do;	/* unrecognized field name */
TREAT_AS_USER_DEFINED_FIELD:
		in_forwarding_info, in_comment_info = "0"b;
						/* force a new grouping */
		user_field_list.n_user_fields,	/* another one */
		     idx = user_field_list.n_user_fields + 1;
		user_field_list.user_fields (idx).field_value_idx = header_field_list.n_fields;
		call mail_system_$get_user_field_id ((field_name), user_field_list.user_fields (idx).field_id, (""),
		     code);
		if (code ^= 0) & (code ^= error_table_$smallarg) then call message_parse_error_fatal (code);
	     end;					/* ... get_user_field_id shouldn't fail */

	     else if (field_type > ORDINARY_FIELDS_BASE) & (field_type <= N_ORDINARY_FIELDS) then do;
						/* an ordinary field */
		in_forwarding_info, in_comment_info = "0"b;
		field_by_type_lists.types (field_type).n_fields, idx =
		     field_by_type_lists.types (field_type).n_fields + 1;
		field_by_type_lists.types (field_type).field_idxs (idx) = header_field_list.n_fields;
	     end;

	     else if (field_type > REDISTRIBUTED_FIELDS_BASE)
		& (field_type <= (REDISTRIBUTED_FIELDS_BASE + N_ORDINARY_FIELDS)) then do;
						/* part of a forwarding description */
		field_type = field_type - REDISTRIBUTED_FIELDS_BASE;
		if ^in_forwarding_info then call create_forwarding_info ();
		else if (forwarding_info.types (field_type).n_fields > 0)
		     & ^MULTIPLE_FIELDS_PER_REDISTRIBUTION (field_type) then
		     call create_forwarding_info ();
		else if forwarding_info.types (MESSAGE_ID_FIELD).n_fields > 0 then call create_forwarding_info ();
		in_forwarding_info = "1"b;		/* ... in the middle of one now */
		in_comment_info = "0"b;		/* ... can't be doing this anymore */
		forwarding_info.types (field_type).n_fields, idx = forwarding_info.types (field_type).n_fields + 1;
		forwarding_info.types (field_type).field_idxs (idx) = header_field_list.n_fields;
	     end;					/* ... set index of this field */

	     else if (field_type > COMMENT_FIELDS_BASE) & (field_type <= (COMMENT_FIELDS_BASE + N_ORDINARY_FIELDS))
	     then do;				/* part of a comment description */
		field_type = field_type - COMMENT_FIELDS_BASE;
		if ^in_comment_info then call create_comment_info ();
		else if (comment_info.types (field_type).n_fields > 0) & ^MULTIPLE_FIELDS_PER_COMMENT (field_type)
		     then
		     call create_comment_info ();
		in_comment_info = "1"b;		/* ... in the middle of one now */
		in_forwarding_info = "0"b;		/* ... can't be doing this anymore */
		comment_info.types (field_type).n_fields, idx = comment_info.types (field_type).n_fields + 1;
		comment_info.types (field_type).field_idxs (idx) = header_field_list.n_fields;
	     end;					/* ... set index of this field */

	     else go to TREAT_AS_USER_DEFINED_FIELD;	/* shouldn't get here, of course */

	     total_field_count = total_field_count + 1;	/* another field taken care of */

PROCESS_NEXT_FIELD:
	end;					/* of scan loop */

	return;


/* Control arives here if and only if a valid header is not found in the message */

NO_HEADER_FOUND_IN_MESSAGE:
	call message_parse_error_fatal (mlsys_et_$no_message_header);

	return;					/* will never get here, but ... */



/* Internal to scan_message_text: count the lines in a piece of text */

count_lines_in_text:
	procedure (p_text_ptr, p_text_lth) returns (fixed binary (21));

dcl  the_text character (p_text_lth) unaligned based (p_text_ptr);
dcl  p_text_ptr pointer parameter;
dcl  p_text_lth fixed binary (21) parameter;

dcl  (n_lines, used, idx) fixed binary (21);

	     n_lines, used = 0;

	     do while (used < p_text_lth);

		begin;

dcl  rest_of_text character (p_text_lth - used) unaligned defined (the_text) position (used + 1);

		     idx = index (rest_of_text, NL);
		     if idx = 0 then idx = length (rest_of_text) + 1;

		     n_lines = n_lines + 1;
		     used = used + idx;
		end;
	     end;

	     return (n_lines);

	end count_lines_in_text;



/* Internal to scan_message_text: start the description of a new forwarding operation */

create_forwarding_info:
	procedure ();

	     forwarding_info_list.n_forwarding_infos = forwarding_info_list.n_forwarding_infos + 1;

	     allocate forwarding_info in (system_area) set (forwarding_info_ptr);
	     forwarding_info_list.forwarding_info_ptrs (forwarding_info_list.n_forwarding_infos) = forwarding_info_ptr;

	     forwarding_info.types (*).n_fields = 0;

	     return;

	end create_forwarding_info;



/* Internal to scan_message_text: start the description of a new commenting operation */

create_comment_info:
	procedure ();

	     comment_info_list.n_comment_infos = comment_info_list.n_comment_infos + 1;

	     allocate comment_info in (system_area) set (comment_info_ptr);
	     comment_info_list.comment_info_ptrs (comment_info_list.n_comment_infos) = comment_info_ptr;

	     comment_info.types (*).n_fields = 0;

	     return;

	end create_comment_info;

     end scan_message_text;
%page;
/* Cleanup the results of a message scan */

cleanup_message_scan:
     procedure ();

dcl  idx fixed binary;

	if message_scan.header_field_list_ptr ^= null () then free header_field_list in (system_area);

	if message_scan.field_by_type_lists_ptr ^= null () then free field_by_type_lists in (system_area);

	if message_scan.forwarding_info_list_ptr ^= null () then do;
	     do idx = 1 to forwarding_info_list.n_forwarding_infos;
		forwarding_info_ptr = forwarding_info_list.forwarding_info_ptrs (idx);
		free forwarding_info in (system_area);
	     end;
	     free forwarding_info_list in (system_area);
	end;

	if message_scan.comment_info_list_ptr ^= null () then do;
	     do idx = 1 to comment_info_list.n_comment_infos;
		comment_info_ptr = comment_info_list.comment_info_ptrs (idx);
		free comment_info in (system_area);
	     end;
	     free comment_info_list in (system_area);
	end;

	if message_scan.user_field_list_ptr ^= null () then free user_field_list in (system_area);

	message_scan.array_pointers = null ();		/* don't try to free them again */

	return;

     end cleanup_message_scan;
%page;
/* Report an error in the message parse: aborts the parse if required */

message_parse_error:
     procedure (p_pto, p_code, p_text_start, p_text_lth, p_additional_info);

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  p_code fixed binary (35) parameter;
dcl  (p_text_start, p_text_lth) fixed binary (21) parameter;
dcl  p_additional_info character (*) varying parameter;

dcl  new_ptel_ptr pointer;
dcl  idx fixed binary;

	if ^p_pto.list_errors then			/* any error is fatal if caller doesn't want list or errors */
	     call message_parse_error_fatal (p_code);

	message_parse_fails = "1"b;			/* set global flag to force correct returned status code */

	if parse_text_error_list_ptr = null () then
	     parse_text_error_list_n_errors = 1;
	else parse_text_error_list_n_errors = parse_text_error_list.n_errors + 1;

	allocate parse_text_error_list in (user_area) set (new_ptel_ptr);

	do idx = 1 to (parse_text_error_list_n_errors - 1);
	     new_ptel_ptr -> parse_text_error_list.errors (idx) = parse_text_error_list.errors (idx);
	end;

	if parse_text_error_list_ptr ^= null () then free parse_text_error_list in (user_area);
	parse_text_error_list_ptr = new_ptel_ptr;

	idx = parse_text_error_list_n_errors;		/* it's a shorter name ... */

	parse_text_error_list.errors (idx).text_start = p_text_start + message_scan.header_offset;
	parse_text_error_list.errors (idx).text_lth = p_text_lth;
	parse_text_error_list.errors (idx).code = p_code;
	parse_text_error_list.errors (idx).additional_info = p_additional_info;

	return;

     end message_parse_error;
%page;
/* Handler for fatal errors during the parsing of a message */

message_parse_error_fatal:
     procedure (p_code);

dcl  p_code fixed binary (35) parameter;

	call cleanup_message_parse_data ();		/* get rid of everything we've created */

	if message_ptr ^= null () then call free_message (message_ptr, (0));

	if parse_text_error_list_ptr ^= null () then	/* release the error description we setup */
	     free parse_text_error_list in (user_area);

	if parse_text_options.list_errors then do;	/* caller wants to see the actual reason */
	     parse_text_error_list_n_errors = 1;
	     allocate parse_text_error_list in (user_area) set (parse_text_error_list_ptr);
	     parse_text_error_list.errors (1).text_start = 1;
	     parse_text_error_list.errors (1).text_lth = 0;
	     parse_text_error_list.errors (1).code = p_code;
	     parse_text_error_list.errors (1).additional_info = "";
	     P_parse_text_error_list_ptr = parse_text_error_list_ptr;
	end;

	P_message_ptr = null ();			/* informs the caller that error too severe to bypass */
	P_code = mlsys_et_$text_parse_failed;		/* use standard global error code */

	go to RETURN_FROM_MESSAGE_PARSE_AFTER_FAILURE;

     end message_parse_error_fatal;


RETURN_FROM_MESSAGE_PARSE_AFTER_FAILURE:
	return;
%page;
/* Mark all fields of a given type as being reserved for in-mailbox messages only (only called from main procedure) */

mark_as_in_mailbox_field:
     procedure (p_field_list_ptr);

dcl  p_field_list_ptr pointer parameter;

dcl  1 field_list aligned based (p_field_list_ptr) like field_by_type_lists.types;
dcl  idx fixed binary;

	do idx = 1 to field_list.n_fields;
	     field_idx = field_list.field_idxs (idx);
	     call message_parse_error (parse_text_options, mlsys_et_$in_mailbox_only_field,
		header_field_list.fields (field_idx).complete_field_start,
		header_field_list.fields (field_idx).complete_field_lth, "");
	end;

	return;

     end mark_as_in_mailbox_field;



/* Find the index of the first field in a given set of fields (redistributions/comments) for possible error reporting */

find_first_field_in_list:
     procedure (p_field_lists_ptr, p_first_field_idx);

dcl  p_field_lists_ptr pointer parameter;
dcl  p_first_field_idx fixed binary parameter;

dcl  1 field_lists aligned based (p_field_lists_ptr) like field_by_type_lists;
dcl  (idx, jdx) fixed binary;

	p_first_field_idx = message_scan.n_header_fields_allocated + 1;

	do idx = 1 to N_ORDINARY_FIELDS;
	     do jdx = 1 to field_lists.types (idx).n_fields;
		p_first_field_idx = min (p_first_field_idx, field_lists.types (idx).field_idxs (jdx));
	     end;
	end;

	return;

     end find_first_field_in_list;
%page;
/* Set the implicit route for all the addresses in the given list */

set_implicit_route:
     procedure (p_address_list_ptr, p_implicit_route);

dcl  p_address_list_ptr pointer parameter;
dcl  p_implicit_route pointer parameter;

dcl  idx fixed binary;

	do idx = 1 to p_address_list_ptr -> address_list.n_addresses;
	     call set_address_implicit_route (p_address_list_ptr -> address_list.addresses (idx), p_implicit_route, (0))
		;
	end;

	return;

     end set_implicit_route;



/* Set the message date/time created and Message-ID directly as we are in the mail system ring: used only by the
   parse_im_message_text entrypoint (as the appropriate "primitives") */

set_date_time_created_directly:
     procedure (p_message_ptr, p_date_time_created, p_code);

dcl  p_message_ptr pointer parameter;
dcl  p_date_time_created fixed binary (71) parameter;
dcl  p_code fixed binary (35) parameter;

	message.date_time_created = p_date_time_created;
	p_code = 0;

	return;

     end set_date_time_created_directly;


set_message_id_directly:
     procedure (p_message_ptr, p_message_id, p_code);

dcl  p_message_ptr pointer parameter;
dcl  p_message_id bit (72) aligned parameter;
dcl  p_code fixed binary (35) parameter;

	message.message_id = p_message_id;
	p_code = 0;

	return;

     end set_message_id_directly;
%page;
/* Prepare a group of text fields for inclusion into the message as a single line field */

prepare_single_line_field:
     procedure (p_tf, p_field_list_ptr);

dcl  1 p_tf aligned parameter like message_text_field;
dcl  p_field_list_ptr pointer parameter;

dcl  1 field_list aligned based (p_field_list_ptr) like field_by_type_lists.types;

dcl  total_text character (total_text_lth) unaligned based (total_text_ptr);
dcl  total_text_ptr pointer;
dcl  (total_text_lth, total_text_used) fixed binary (21);

dcl  idx fixed binary;


	p_tf.multiline_text = "0"b;			/* just to be sure */

	if field_list.n_fields = 0 then do;		/* nothing there */
	     p_tf.text_ptr = null ();
	     p_tf.text_lth = 0;
	end;

	else if field_list.n_fields = 1 then do;	/* one field: return it directly */
	     field_idx = field_list.field_idxs (1);
	     p_tf.text_ptr = addr (header_field_value);
	     p_tf.text_lth = length (header_field_value);
	end;

	else do;					/* multiple fields: merge them */
	     total_text_lth = -1;			/* ... following loop computes a value that's one off */
	     do idx = 1 to field_list.n_fields;
		field_idx = field_list.field_idxs (idx);
		total_text_lth = total_text_lth + length (header_field_value) + 1;
	     end;
	     allocate total_text in (system_area) set (total_text_ptr);
	     total_text_used = 0;
	     do idx = 1 to field_list.n_fields;
		if idx > 1 then do;			/* ... separate them by a single space */
		     substr (total_text, (total_text_used + 1), 1) = SP;
		     total_text_used = total_text_used + 1;
		end;
		field_idx = field_list.field_idxs (idx);
		substr (total_text, (total_text_used + 1), length (header_field_value)) = header_field_value;
		total_text_used = total_text_used + length (header_field_value);
	     end;
	     p_tf.text_ptr = total_text_ptr;
	     p_tf.text_lth = total_text_lth;
	end;

	return;

     end prepare_single_line_field;
%page;
/* Prepare one or more text fields for inclusion in the message as a multiline field */

prepare_multiline_field:
     procedure () options (non_quick);

	return;					/* not an entrypoint */

dcl  p_fieldname_lth fixed binary parameter;
dcl  1 p_tf aligned parameter like message_text_field;
dcl  p_field_value character (*) parameter;
dcl  p_field_list_ptr pointer parameter;

dcl  1 field_list aligned based (p_field_list_ptr) like field_by_type_lists.types;

dcl  total_text character (total_text_lth) unaligned based (total_text_ptr);
dcl  total_text_ptr pointer;
dcl  (total_text_lth, total_text_used) fixed binary (21);

dcl  work_string character (work_string_lth) unaligned based (work_string_ptr);
dcl  work_string_ptr pointer;
dcl  (work_string_lth, work_string_used) fixed binary (21);

dcl  previous_text character (p_tf.text_lth) unaligned based (p_tf.text_ptr);

dcl  idx fixed binary;

dcl  STACK_EXTENSION fixed binary (18) static options (constant) initial (128);

dcl  FIELDNAME_SUFFIX character (3) static options (constant) initial (":  ");
dcl  STANDARD_MULTILINE_INDENTATION fixed binary static options (constant) initial (10);
dcl  CONTINUATION_INDICATOR character (2) static options (constant) initial ("--");


prepare_multiline_field_from_text:			/* prepare a single field */
     entry (p_fieldname_lth, p_tf, p_field_value);

	call cu_$grow_stack_frame (STACK_EXTENSION, work_string_ptr, (0));
	work_string_lth = 4 * STACK_EXTENSION;
	work_string_used = 0;

	call prepare_single_field_for_multiline (p_field_value);

	go to PREPARE_MULTILINE_FIELD_COMMON;


prepare_multiline_field_from_list:			/* prepare a list of fields */
     entry (p_fieldname_lth, p_tf, p_field_list_ptr);

	call cu_$grow_stack_frame (STACK_EXTENSION, work_string_ptr, (0));
	work_string_lth = 4 * STACK_EXTENSION;
	work_string_used = 0;

	do idx = 1 to field_list.n_fields;
	     field_idx = field_list.field_idxs (idx);
	     call prepare_single_field_for_multiline (header_field_value);
	end;

	go to PREPARE_MULTILINE_FIELD_COMMON;


/* Input fields have been properly prepared: combine them with any prior text and return the new text */

PREPARE_MULTILINE_FIELD_COMMON:
	p_tf.multiline_text = "1"b;			/* just in case */
	if p_tf.text_ptr = null () then p_tf.text_lth = 0;

	if work_string_used = 0 then return;		/* the input fields are empty */

	total_text_lth = p_tf.text_lth + work_string_used - 1;
	if p_tf.text_lth > 0 then total_text_lth = total_text_lth + 1;

	allocate total_text in (system_area) set (total_text_ptr);

	if p_tf.text_lth > 0 then do;			/* copy prior text */
	     substr (total_text, 1, length (previous_text)) = previous_text;
	     substr (total_text, (length (previous_text) + 1), 1) = NL;
	     total_text_used = length (previous_text) + 1;
	     free previous_text in (system_area);
	end;
	else total_text_used = 0;

	substr (total_text, (total_text_used + 1), (work_string_used - 1)) =
	     substr (work_string, 1, (work_string_used - 1));
						/* all except the trailing new line */

	p_tf.text_ptr = addr (total_text);
	p_tf.text_lth = length (total_text);

	return;



/* Internal to prepare_multiline_field: processes a single field.  All leading whitespace before the indent column is
   removed; any line which has "--" in the last two columns before the indent column is made a blank line */

prepare_single_field_for_multiline:
	procedure (p_text) /* options (quick) */;

dcl  p_text character (*) parameter;
dcl  (text_column, text_used, line_lth, start_of_text, column, used) fixed binary (21);

	     if verify (before (p_text, NL), HTSP) = 0 then do;
		text_column = STANDARD_MULTILINE_INDENTATION + 1;
		text_used = index (p_text, NL);	/* special case if first line blank: it's indented 10 */
	     end;
	     else do;
		text_column = p_fieldname_lth + length (FIELDNAME_SUFFIX) + 1;
		text_used = 0;
	     end;

	     do while (text_used < length (p_text));
		begin;
dcl  rest_of_text character (length (p_text) - text_used) unaligned defined (p_text) position (text_used + 1);
		     line_lth = index (rest_of_text, NL) - 1;
		     if line_lth = -1 then		/* last line */
			line_lth = length (rest_of_text);
		end;

		if line_lth > 0 then
		     begin;
dcl  line character (line_lth) unaligned defined (p_text) position (text_used + 1);
		     start_of_text = verify (line, HTSP);
		     if start_of_text = 0 then	/* it's blank? */
			start_of_text = line_lth + 1;

		     begin;
dcl  whitespace character (start_of_text - 1) unaligned defined (p_text) position (text_used + 1);
			column = 1;
			used = 0;
			do while ((used < length (whitespace)) & (column < text_column));
			     used = used + 1;
			     if substr (whitespace, used, 1) = SP then column = column + 1;
			     else if mod (column, 10) = 0 then column = column + 1;
			     else column = column + 11 - mod (column, 10);
			end;
			if (column < (text_column - 1)) & (start_of_text < line_lth) then
			     if substr (line, start_of_text, 2) = CONTINUATION_INDICATOR then
				if verify (substr (line, (start_of_text + 2)), HTSP) = 0 then
				     go to LINE_IS_ACTUALLY_BLANK;
			if used < length (whitespace) then
			     start_of_text = start_of_text - (length (whitespace) - used);
		     end;

		     begin;
dcl  text character (line_lth - start_of_text + 1) unaligned defined (p_text) position (text_used + start_of_text);
			call add_to_work_string (addr (text), length (text));
		     end;
		end;

LINE_IS_ACTUALLY_BLANK:
		call add_to_work_string (addr (NL), 1);

		text_used = text_used + line_lth + 1;
	     end;

	     return;



/* Internal to prepare_single_field_for_multiline: adds a piece of text to the output buffer */

add_to_work_string:
	     procedure (p_text_ptr, p_text_lth) /* options (quick) */;

dcl  p_text_ptr pointer parameter;
dcl  p_text_lth fixed binary (21) parameter;

dcl  p_text character (p_text_lth) unaligned based (p_text_ptr);

		do while (work_string_lth < (work_string_used + p_text_lth));
		     call cu_$grow_stack_frame (STACK_EXTENSION, (null ()), (0));
		     work_string_lth = work_string_lth + 4 * STACK_EXTENSION;
		end;

		substr (work_string, (work_string_used + 1), p_text_lth) = p_text;

		work_string_used = work_string_used + p_text_lth;

		return;

	     end add_to_work_string;

	end prepare_single_field_for_multiline;

     end prepare_multiline_field;
%page;
/* Parse a message/redistribution envelope:  This entrypoint also parses the Date and From fields of the
   message/redistribution as they may be needed to supply defaults for the envelope and the message/redistribution ID */

parse_envelope:
     procedure (p_pto, p_ipo, p_is_redistribution, p_field_lists_ptr, p_envelope_ptr, p_date_time_created, p_from)
	/* options (quick) */;

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_is_redistribution bit (1) aligned parameter;
dcl  (p_field_lists_ptr, p_envelope_ptr, p_from) pointer parameter;
dcl  p_date_time_created fixed binary (71) parameter;

dcl  1 field_lists aligned like field_by_type_lists based (p_field_lists_ptr);
dcl  1 envelope aligned like message_envelope based (p_envelope_ptr);

dcl  1 local_pto aligned like parse_text_options;
dcl  additional_info character (128) varying;
dcl  saved_default_system character (256) varying;
dcl  saved_default_system_is_local bit (1) aligned;
dcl  address_type fixed binary;
dcl  idx fixed binary;


	p_date_time_created, envelope.date_time_mailed, envelope.date_time_delivered = 0;
	envelope.sender, envelope.trace, envelope.delivered_by, envelope.acknowledge_to = null ();

	if p_is_redistribution then
	     additional_info = "The redistribution which starts with:";
	else additional_info = "The message which starts with:";


/* First parse the Date, Posted-Date, and Delivery-Date fields: there can be at most one of each of these fields and all
   of them must parse.  If the Posted-Date field is missing, it is set to the value of the Date field; if the
   Delivery-Date field is missing, it is set to the value of the Posted-Date field */

	if (field_lists.types (DATE_FIELD).n_fields = 0) & (field_lists.types (POSTED_DATE_FIELD).n_fields = 0)
	     & (field_lists.types (DELIVERY_DATE_FIELD).n_fields = 0) then
	     call message_parse_error (p_pto, mlsys_et_$cant_determine_dtc,
		header_field_list.fields (first_field_idx).complete_field_start,
		header_field_list.fields (first_field_idx).complete_field_lth, additional_info);

	if field_lists.types (DATE_FIELD).n_fields = 1 then do;
	     field_idx = field_lists.types (DATE_FIELD).field_idxs (1);
	     call parse_date_time_text (p_pto, p_ipo, header_field_value, p_date_time_created, code);
	     if code ^= 0 then
		call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	end;
	else if field_lists.types (DATE_FIELD).n_fields > 1 then do;
	     do idx = 1 to field_lists.types (DATE_FIELD).n_fields;
		field_idx = field_lists.types (DATE_FIELD).field_idxs (idx);
		call message_parse_error (p_pto, mlsys_et_$extra_restricted_field,
		     header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	     end;
	end;

	if field_lists.types (POSTED_DATE_FIELD).n_fields = 1 then do;
	     field_idx = field_lists.types (POSTED_DATE_FIELD).field_idxs (1);
	     call parse_date_time_text (p_pto, p_ipo, header_field_value, envelope.date_time_mailed, code);
	     if code ^= 0 then
		call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	end;
	else if field_lists.types (POSTED_DATE_FIELD).n_fields > 1 then do;
	     do idx = 1 to field_lists.types (POSTED_DATE_FIELD).n_fields;
		field_idx = field_lists.types (POSTED_DATE_FIELD).field_idxs (idx);
		call message_parse_error (p_pto, mlsys_et_$extra_restricted_field,
		     header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	     end;
	end;

	if field_lists.types (DELIVERY_DATE_FIELD).n_fields = 1 then do;
	     field_idx = field_lists.types (DELIVERY_DATE_FIELD).field_idxs (1);
	     call parse_date_time_text (p_pto, p_ipo, header_field_value, envelope.date_time_delivered, code);
	     if code ^= 0 then
		call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	end;
	else if field_lists.types (DELIVERY_DATE_FIELD).n_fields > 1 then do;
	     do idx = 1 to field_lists.types (DELIVERY_DATE_FIELD).n_fields;
		field_idx = field_lists.types (DELIVERY_DATE_FIELD).field_idxs (idx);
		call message_parse_error (p_pto, mlsys_et_$extra_restricted_field,
		     header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	     end;
	end;

	if p_date_time_created = 0 then		/* Date really should be there but ... */
	     if envelope.date_time_mailed ^= 0 then	/* ... so supply one */
		p_date_time_created = envelope.date_time_mailed;
	     else p_date_time_created = envelope.date_time_delivered;

	if envelope.date_time_mailed = 0 then		/* Posted-Date defaults to Date */
	     envelope.date_time_mailed = p_date_time_created;

	if envelope.date_time_delivered = 0 then	/* Delivery-Date defaults to Posted-Date */
	     envelope.date_time_delivered = envelope.date_time_mailed;


/* Parse the From and Sender fields: both must contain only valid addresses; in addition, there may only be one Sender
   field and it is allowed to contain only a single address.  After parsing, determine the default system to be used to
   parse other addresses in the header or redistribution */

	p_ipo.default_system_name = mlsys_nit_interface_$get_local_system_name ();
	p_ipo.default_system_is_local = "1"b;		/* local system is the default default system */

	string (local_pto.flags) = ""b;		/* requires it to parse properly */

	if field_lists.types (SENDER_FIELD).n_fields = 1 then do;
	     field_idx = field_lists.types (SENDER_FIELD).field_idxs (1);
	     call parse_address_text_internal (local_pto, p_ipo, header_field_value, envelope.sender, code);
	     if code ^= 0 then
		call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	end;
	else if field_lists.types (SENDER_FIELD).n_fields > 1 then do;
	     do idx = 1 to field_lists.types (SENDER_FIELD).n_fields;
		field_idx = field_lists.types (SENDER_FIELD).field_idxs (idx);
		call message_parse_error (p_pto, mlsys_et_$extra_restricted_field,
		     header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	     end;
	end;

	if envelope.sender ^= null () then do;		/* we have a Sender: extract the default system */
	     call mail_system_$get_address_type (envelope.sender, address_type, (0));
	     if address_type = FOREIGN_ADDRESS then do;	/* ... only if it's foreign, however */
		call mail_system_$get_address_system (envelope.sender, p_ipo.default_system_name, (0));
		p_ipo.default_system_is_local = mlsys_nit_interface_$is_local_system (p_ipo.default_system_name);
	     end;
	end;

	if p_is_redistribution then
	     full_fieldname = REDISTRIBUTED_PREFIX || FROM_FIELDNAME;
	else full_fieldname = FROM_FIELDNAME;

	call parse_address_list_field (p_pto, p_ipo, full_fieldname, addr (field_lists.types (FROM_FIELD)), p_from);

	if envelope.sender = null () then		/* no Sender: use From field to get default system */
	     if p_from -> address_list.n_addresses = 1 then do;
		call mail_system_$get_address_type (p_from -> address_list.addresses (1), address_type, (0));
		if address_type = FOREIGN_ADDRESS then do;
		     call mail_system_$get_address_system (p_from -> address_list.addresses (1),
			p_ipo.default_system_name, (0));
		     p_ipo.default_system_is_local = mlsys_nit_interface_$is_local_system (p_ipo.default_system_name);
		end;
	     end;

	     else do;				/* no Sender and the From field has multiple addresses */
		call message_parse_error (p_pto, mlsys_et_$cant_determine_sender,
		     header_field_list.fields (first_field_idx).complete_field_start,
		     header_field_list.fields (first_field_idx).complete_field_lth, additional_info);
	     end;					/* ... so continue to claim local system is the default */


/* Parse the Delivery-By and Acknowledge-To fields (if present): each must appear only once and contain exactly one valid
   address */

	saved_default_system = p_ipo.default_system_name;
	saved_default_system_is_local = p_ipo.default_system_is_local;
	p_ipo.default_system_name = mlsys_nit_interface_$get_local_system_name ();
	p_ipo.default_system_is_local = "1"b;		/* Delivery-By must be an absolute address */

	if field_lists.types (DELIVERY_BY_FIELD).n_fields = 1 then do;
	     field_idx = field_lists.types (DELIVERY_BY_FIELD).field_idxs (1);
	     call parse_address_text_internal (local_pto, p_ipo, header_field_value, envelope.delivered_by, code);
	     if code ^= 0 then
		call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	end;
	else if field_lists.types (DELIVERY_BY_FIELD).n_fields > 1 then do;
	     do idx = 1 to field_lists.types (DELIVERY_BY_FIELD).n_fields;
		field_idx = field_lists.types (DELIVERY_BY_FIELD).field_idxs (idx);
		call message_parse_error (p_pto, mlsys_et_$extra_restricted_field,
		     header_field_list.fields (field_idx).complete_field_start,
		     header_field_list.fields (field_idx).complete_field_lth, "");
	     end;
	end;

	p_ipo.default_system_name = saved_default_system;
	p_ipo.default_system_is_local = saved_default_system_is_local;

	if p_ipo.requests_acknowledgement then		/* don't both to look unless it's going to be acknowledged */
	     if field_lists.types (ACKNOWLEDGE_TO_FIELD).n_fields = 1 then do;
		field_idx = field_lists.types (ACKNOWLEDGE_TO_FIELD).field_idxs (1);
		call parse_address_text_internal (local_pto, p_ipo, header_field_value, envelope.acknowledge_to, code)
		     ;
		if code ^= 0 then
		     call message_parse_error (p_pto, code, header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "");
	     end;
	     else if field_lists.types (ACKNOWLEDGE_TO_FIELD).n_fields > 1 then do;
		do idx = 1 to field_lists.types (ACKNOWLEDGE_TO_FIELD).n_fields;
		     field_idx = field_lists.types (ACKNOWLEDGE_TO_FIELD).field_idxs (idx);
		     call message_parse_error (p_pto, mlsys_et_$extra_restricted_field,
			header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "");
		end;
	     end;


/* Supply a default From field (equal to the Sender) and eliminate redundant Sender and/or Delivery-By addresses */

	if p_from -> address_list.n_addresses = 0 then do;/* no From field supplied */
	     call add_address (p_from, envelope.sender, ADDRESS_LIST_VERSION_2, code);
	     if code ^= 0 then call message_parse_error_fatal (code);
	     envelope.sender = null ();		/* ... let's not be redundant */
	end;

	if p_from -> address_list.n_addresses = 1 then do;/* try to eliminate redundant Sender/Delivery-By */
	     if envelope.sender ^= null () then
		if mail_system_$compare_addresses (p_from -> address_list.addresses (1), envelope.sender, (0)) then
		     call mail_system_$free_address (envelope.sender, (0));
	     if envelope.delivered_by ^= null () then
		if mail_system_$compare_addresses (p_from -> address_list.addresses (1), envelope.delivered_by, (0))
		     then
		     call mail_system_$free_address (envelope.delivered_by, (0));
	end;					/* ... OK to free as parser never reuses addresses */

	if envelope.sender ^= null () then		/* check for redundant Delivery-By */
	     if envelope.delivered_by ^= null () then
		if mail_system_$compare_addresses (envelope.sender, envelope.delivered_by, (0)) then
		     call mail_system_$free_address (envelope.delivered_by, (0));


/* Finally, parse the message trace if present */

	if (field_lists.types (ROUTE_FIELD).n_fields > 0) | (field_lists.types (RELAYED_FIELD).n_fields > 0) then
	     call parse_trace ();

	return;
%page;
/* Internal to parse_envelope: parses the fields in a message trace; any errors in a message trace are considered
   non-fatal and the information in the trace is thrown away */

parse_trace:
	procedure () /* options (quick) */;

dcl  1 current_relay aligned based (current_relay_ptr) like message_trace.relays;
dcl  current_relay_ptr pointer;

dcl  1 local_ipo aligned like internal_parse_options;

dcl  the_route_ptr pointer;
dcl  address_system character (256) varying;
dcl  (start_of_id_string, end_of_id_string, bracket_level, message_id_string_lth, date_time_string_start) fixed
	binary (21);
dcl  (relay_idx, idx) fixed binary;


	     message_trace_n_relays = max (field_lists.types (RELAYED_FIELD).n_fields, 1);
						/* PL/I abhors a vacuum */

	     allocate message_trace in (system_area) set (message_trace_ptr);

	     message_trace.version = MESSAGE_TRACE_VERSION_2;
	     message_trace.implicit_route = null ();
	     message_trace.relays (*).date_time_relayed = 0;
	     message_trace.relays (*).sending_host = "";
	     message_trace.relays (*).receiving_host = "";
	     message_trace.relays (*).communications_media = "";
	     message_trace.relays (*).communications_protocol = "";
	     message_trace.relays (*).mail_protocol = "";
	     message_trace.relays (*).relay_id = ""b;
	     message_trace.relays (*).relay_recipient = null ();

	     envelope.trace = message_trace_ptr;	/* cleanup handler will now work OK */


/* Find the route by which this message/redistribution arrived at this system by parsing the Route field:  If there are
   multiple Route fields, all but the first are ignored as many systems add extraneous Route fields during transmission */

	     trace_address = null ();			/* for cleanup handler */

	     if field_lists.types (ROUTE_FIELD).n_fields ^= 0 then do;

		field_idx = field_lists.types (ROUTE_FIELD).field_idxs (1);

		call lex_and_parse_prologue (header_field_value, "1"b, "0"b);
						/* no cleanup handler here: caller's set one up already */

		call lex_address (p_pto, p_ipo, code);	/* convert into tokens */
		if code ^= 0 then call bypass_implicit_route (code, "1"b);

		token_idx = 0;			/* start at the first non-comment token */
		call next_real_token ();

		if current.type = LEFTBRACKET_TOKEN then do;
		     /*** RFC822 style route -- Return-Path: <@HOST,@HOST,...:STRING@HOST> */
		     call parse_address (p_pto, p_ipo, (token_idx - 1), trace_address, code);
		     call lex_and_parse_epilogue ("1"b);/* ... won't need the token list any longer ... */
		     call cu_$shrink_stack_frame (stack_extension_ptr, (0));
		     if code ^= 0 then call bypass_implicit_route (code, "1"b);
		     call mail_system_$get_address_route (trace_address, ADDRESS_ROUTE_VERSION_1, the_route_ptr, code)
			;
		     if code ^= 0 then call bypass_implicit_route (code, "0"b);
		     call mail_system_$get_address_system (trace_address, address_system, code);
		     if code ^= 0 then call bypass_implicit_route (code, "0"b);
		     address_route_n_relays = the_route_ptr -> address_route.n_relays + 1;
		     allocate address_route in (system_area) set (address_route_ptr);
		     message_trace.implicit_route = address_route_ptr;
		     address_route.version = ADDRESS_ROUTE_VERSION_1;
		     do idx = 1 to address_route.n_relays - 1;
			address_route.relays (idx) = the_route_ptr -> address_route.relays (idx);
		     end;
		     address_route.relays (address_route.n_relays) = address_system;
		     call mail_system_$free_address (trace_address, (0));
		end;

		else if current.type = AT_TOKEN then do;
		     /*** Multics style route:  [via RelayN ...] via Relay1 */
		     address_route_n_relays = 0;
		     do while (current.type = AT_TOKEN);
			address_route_n_relays = address_route_n_relays + 1;
			call next_real_token ();	/* ... to the system name */
			if current.type ^= WORD_TOKEN then
			     call bypass_implicit_route (mlsys_et_$missing_host_name, "1"b);
			host_indeces (address_route_n_relays) = token_idx;
			call next_real_token ();	/* ... to the next "via" or the end of the string */
		     end;
		     if current.type ^= END_OF_TEXT_TOKEN then
			call bypass_implicit_route (mlsys_et_$text_follows_route, "1"b);
		     allocate address_route in (system_area) set (address_route_ptr);
		     message_trace.implicit_route = address_route_ptr;
		     address_route.version = ADDRESS_ROUTE_VERSION_1;
		     do idx = 1 to address_route_n_relays;
			call make_token_current (host_indeces (idx));
			address_route.relays (address_route_n_relays - idx + 1) = current_token;
		     end;				/* ... the printed representation is backward */
		     call lex_and_parse_epilogue ("1"b);
		     call cu_$shrink_stack_frame (stack_extension_ptr, (0));
		end;

		else call bypass_implicit_route (mlsys_et_$invalid_route_field_syntax, "1"b);
	     end;


/* Determine the set of relay operations which took place to get the message here by parsing the Relayed fields */

BYPASS_IMPLICIT_ROUTE:
	     relay_idx = 1;				/* in case we have to bypass some fields */

	     do idx = 1 to field_lists.types (RELAYED_FIELD).n_fields;

		field_idx = field_lists.types (RELAYED_FIELD).field_idxs (idx);
		current_relay_ptr = addr (message_trace.relays (relay_idx));

		call lex_and_parse_prologue (header_field_value, "1"b, "0"b);
		call lex_address (p_pto, p_ipo, code);
		if code ^= 0 then call bypass_relay_operation (code, "1"b);

		token_idx = 0;			/* start at the beginning */
		call next_real_token ();

		do while (current.type ^= SEMICOLON_TOKEN);
		     if current.type = WORD_TOKEN then
			if translate (current_token, UPPERCASE, LOWERCASE) = "FROM" then do;
			     call next_real_token ();
			     if current.type = WORD_TOKEN then
				current_relay.sending_host = current_token;
			     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			end;
			else if (translate (current_token, UPPERCASE, LOWERCASE) = "BY")
			     | (translate (current_token, UPPERCASE, LOWERCASE) = "TO") then do;
			     call next_real_token ();
			     if current.type = WORD_TOKEN then
				current_relay.receiving_host = current_token;
			     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			end;
			else if translate (current_token, UPPERCASE, LOWERCASE) = "USING" then do;
			     call next_real_token ();
			     if current.type = WORD_TOKEN then
				current_relay.mail_protocol = current_token;
			     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			end;
			else if translate (current_token, UPPERCASE, LOWERCASE) = "WITH" then do;
			     call next_real_token ();
			     if current.type = WORD_TOKEN then
				current_relay.communications_protocol = current_token;
			     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			end;
			else if translate (current_token, UPPERCASE, LOWERCASE) = "VIA" then do;
			     call next_real_token ();
			     if current.type = WORD_TOKEN then
				current_relay.communications_media = current_token;
			     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			end;
			else if translate (current_token, UPPERCASE, LOWERCASE) = "ID" then do;
			     /*** ID <message-id> */
			     if current_relay.receiving_host = "" then
				call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			     call next_real_token ();
			     start_of_id_string = token_idx;
			     if current.type = WORD_TOKEN then end_of_id_string = token_idx;
			     else if current.type = LEFTBRACKET_TOKEN then do;
				bracket_level = 1;
				do while (bracket_level > 1);
				     call next_real_token ();
				     if current.type = LEFTBRACKET_TOKEN then bracket_level = bracket_level + 1;
				     else if current.type = RIGHTBRACKET_TOKEN then
					bracket_level = bracket_level - 1;
				end;
				end_of_id_string = token_idx;
			     end;
			     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
			     message_id_string_lth =
				token_list.tokens (end_of_id_string).original_start
				- token_list.tokens (start_of_id_string).original_start
				+ token_list.tokens (end_of_id_string).original_lth;
			     begin;
dcl  message_id_string character (message_id_string_lth) unaligned defined (header_field_value)
	position (token_list.tokens (start_of_id_string).original_start);
				call encode_foreign_id (message_id_string, current_relay.receiving_host,
				     current_relay.relay_id);
			     end;
			end;
			else if translate (current_token, UPPERCASE, LOWERCASE) = "FOR" then do;
			     /*** FOR <address>: must be last thing before semicolon */
			     local_ipo = p_ipo;
			     string (local_ipo.delimiters) = ""b;
			     call parse_address (p_pto, local_ipo, (token_idx + 1), current_relay.relay_recipient,
				code);
			     if code ^= 0 then call bypass_relay_operation (code, "1"b);
			     go to HAVE_FOUND_DATE_TIME_RELAYED;
			end;
			else do;			/* kludge: assume other word is proceeded by WITH */
			     current_relay.communications_protocol = current_token;
			end;
		     else call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);
		     call next_real_token ();
		end;

HAVE_FOUND_DATE_TIME_RELAYED:
		if (current_relay.sending_host = "") | (current_relay.receiving_host = "") then
		     call bypass_relay_operation (mlsys_et_$invalid_relayed_field_syntax, "1"b);

		/*** Have everything now but the date/time relayed which uses a different lex/parse */
		date_time_string_start = current.original_start + 1;

		call lex_and_parse_epilogue ("1"b);	/* get rid of the old token list */
		call cu_$shrink_stack_frame (stack_extension_ptr, (0));

		begin;
dcl  date_time_string character (length (header_field_value) - date_time_string_start + 1) unaligned
	defined (header_field_value) position (date_time_string_start);
		     call parse_date_time_text (p_pto, p_ipo, date_time_string, current_relay.date_time_relayed, code)
			;
		     if code ^= 0 then call bypass_relay_operation (code, "1"b);
		end;

		relay_idx = relay_idx + 1;		/* success */

BYPASS_RELAY_OPERATION:
	     end;

	     relay_idx = relay_idx - 1;		/* above loop sets this value one too high */


/* Insure that the trace isn't empty */

	     if (message_trace.implicit_route = null ()) & (relay_idx = 0) then do;
		free message_trace in (system_area);
		envelope.trace = null ();		/* nothing in it */
	     end;

	     else message_trace.n_relays = relay_idx;	/* insure it claims the right # of relays */

	     return;


/* Internal to parse_trace: aborts the parse of the Route field and continues to the parse of the Relayed fields */

bypass_implicit_route:
	     procedure (p_code, p_list_error) /* options (quick) */;

dcl  p_code fixed binary (35) parameter;
dcl  p_list_error bit (1) aligned;

		call lex_and_parse_epilogue ("1"b);	/* most likely we interrupted something */
		call cu_$shrink_stack_frame (stack_extension_ptr, (0));

		if trace_address ^= null () then call mail_system_$free_address (trace_address, (0));

		if message_trace.implicit_route ^= null () then
		     free message_trace.implicit_route -> address_route in (system_area);

		if p_list_error & p_pto.list_errors then
		     call message_parse_error (p_pto, p_code,
			header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "");

		go to BYPASS_IMPLICIT_ROUTE;

	     end bypass_implicit_route;



/* Internal to parse_trace: aborts the parse of the current Relayed field and proceeds to the next one */

bypass_relay_operation:
	     procedure (p_code, p_list_error) /* options (quick) */;

dcl  p_code fixed binary (35);
dcl  p_list_error bit (1) aligned parameter;

		call lex_and_parse_epilogue ("1"b);	/* most likely we interrupted something */
		call cu_$shrink_stack_frame (stack_extension_ptr, (0));

		if trace_address ^= null () then call mail_system_$free_address (trace_address, (0));

		if current_relay.relay_recipient ^= null () then
		     call mail_system_$free_address (current_relay.relay_recipient, (0));

		if p_list_error & p_pto.list_errors then
		     call message_parse_error (p_pto, p_code,
			header_field_list.fields (field_idx).complete_field_start,
			header_field_list.fields (field_idx).complete_field_lth, "");

		go to BYPASS_RELAY_OPERATION;

	     end bypass_relay_operation;

	end parse_trace;

     end parse_envelope;
%page;
/* Parse the address lists in the header corresponding to the given field */

parse_address_list_field:
     procedure (p_pto, p_ipo, p_fieldname, p_field_list_ptr, p_address_list_ptr);

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_fieldname character (*) varying parameter;
dcl  p_field_list_ptr pointer parameter;
dcl  p_address_list_ptr pointer parameter;

dcl  1 field_list aligned based (p_field_list_ptr) like field_by_type_lists.types;
dcl  idx fixed binary;


	call create_address_list (ADDRESS_LIST_VERSION_2, p_address_list_ptr, code);
	if code ^= 0 then call message_parse_error_fatal (code);
						/* all our software assumes address lists are never null */

	do idx = 1 to field_list.n_fields;
	     field_idx = field_list.field_idxs (idx);
	     call parse_address_list_text_internal (p_pto, p_ipo, header_field_value, p_address_list_ptr, code);
	     if code ^= 0 then call message_parse_error_fatal (code);
						/* only happens if caller asked not to continue on error */
	     call merge_error_lists (p_fieldname);	/* if listing errors: add any errors we find to the list */
	end;

	return;



/* Internal to parse_address_list_field: merge the results of an address list parse into the running results for the
   message parse */

merge_error_lists:
	procedure (p_fieldname);

dcl  p_fieldname character (*) varying parameter;

dcl  new_ptel_ptr pointer;
dcl  (n_previous_errors, text_offset, idx, offset_idx) fixed binary;

	     if parse_text_options.list_errors & (lex_and_parse_pointers.sel_ptr ^= null ()) & (n_syntax_errors > 0)
	     then do;				/* something did go wrong */
		message_parse_fails = "1"b;		/* ... be sure global code will be set properly */

		if parse_text_error_list_ptr = null () then
		     parse_text_error_list_n_errors = n_syntax_errors;
		else parse_text_error_list_n_errors = parse_text_error_list.n_errors + n_syntax_errors;
		n_previous_errors = parse_text_error_list_n_errors - n_syntax_errors;

		allocate parse_text_error_list in (user_area) set (new_ptel_ptr);

		do idx = 1 to n_previous_errors;
		     new_ptel_ptr -> parse_text_error_list.errors (idx) = parse_text_error_list.errors (idx);
		end;

		if parse_text_error_list_ptr ^= null () then free parse_text_error_list in (user_area);
		parse_text_error_list_ptr = new_ptel_ptr;

		text_offset = charno (addr (header_field_value)) - charno (representation_ptr);

		do idx = 1 to n_syntax_errors;
		     offset_idx = idx + n_previous_errors;
						/* ... get right place in the complete list */
		     parse_text_error_list.errors (offset_idx).text_start = sel (idx).text_start + text_offset;
		     parse_text_error_list.errors (offset_idx).text_lth = sel (idx).text_lth;
		     parse_text_error_list.errors (offset_idx).code = sel (idx).code;
		     if length (p_fieldname) > 0 then
			parse_text_error_list.errors (offset_idx).additional_info =
			     "In the " || p_fieldname || " field:";
		     else parse_text_error_list.errors (offset_idx).additional_info = "";
		end;
	     end;

	     call lex_and_parse_epilogue ("1"b);	/* get rid of syntax error list */

	     return;

	end merge_error_lists;

     end parse_address_list_field;
%page;
/* Parse a single address */

parse_address:
     procedure (p_pto, p_ipo, p_token_idx, p_address_ptr, p_code);

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_token_idx fixed binary (21) parameter;		/* where the address starts/stops */
dcl  p_address_ptr pointer parameter;			/* set -> the address generated (if any) */
dcl  p_code fixed binary (35) parameter;

dcl  1 saved_p_ipo aligned like internal_parse_options;

dcl  foreign_system_name character (256) varying;
dcl  address_pathname character (200);
dcl  address_dirname character (168);
dcl  (address_ename, address_component) character (32);
dcl  trimmed_address_ename character (32) varying;
dcl  new_host_indeces_ptr pointer;
dcl  (first_token_in_address, last_token_in_address, delimiting_token, address_name_start, address_name_end, idx)
	fixed binary (21);
dcl  (in_named_address, seen_route, address_is_local, is_mte, done) bit (1) aligned;
dcl  error_table_$noentry fixed bin(35) ext static;
dcl  search_paths_$find_dir entry (char(*), ptr, char(*), char(*), char(*), fixed bin(35));
dcl  suffixed_name_$make entry (char(*), char(*), char(32), fixed bin(35));
          

	p_address_ptr = null ();			/* in case it fails */

	saved_p_ipo = p_ipo;			/* for cleanup handler */
	new_host_indeces_ptr, address_route_ptr = null ();

	on condition (cleanup)
	     begin;
	     p_ipo = saved_p_ipo;
	     if new_host_indeces_ptr ^= null () then free new_host_indeces_ptr -> host_indeces in (system_area);
	     if address_route_ptr ^= null () then free address_route in (system_area);
	end;

	call make_token_current (p_token_idx);
	delimiting_token = 0;			/* haven't gotten that far yet */

	address_name_start, address_name_end = 0;	/* no address name as yet */
	in_named_address = "0"b;

	seen_route = "0"b;				/* no RFC822 address route */


START_ADDRESS_PARSE:
	n_hosts, n_reversed_hosts = 0;		/* haven't seen any routing information */

	first_token_in_address = token_idx + 1;

	call next_real_token ();			/* move to the first token */

START_ADDRESS_PARSE_WITH_ROUTE:
	if ^in_named_address & end_of_address () then
	     /*** No non-comment tokens in the address (sigh) */
	     call bad_address_syntax (mlsys_et_$empty_address_text);

	else if current.type = COLON_TOKEN then
	     /*** an RFC733 structured address: no one understands them anymore */
	     call bad_address_syntax (mlsys_et_$obsolete_address_syntax);

	else if in_named_address & (current.type = AT_TOKEN) then
	     /*** RFC822-style explicit route (@HOST,@HOST,...:ADDR) */
	     if seen_route then
		call bad_address_syntax (mlsys_et_$multiple_address_routes);
	     else do;
		seen_route = "1"b;			/* don't let this happen again */
		done = "0"b;
		do while (^done);
		     n_hosts, n_reversed_hosts = n_hosts + 1;
		     host_indeces (n_hosts) = token_idx;
		     call next_real_token ();
		     if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$missing_host_name);
		     call next_real_token ();		/* skip past the host name */
		     if current.type = COLON_TOKEN then done = "1"b;
		     else if current.type = COMMA_TOKEN then do;
						/* more of the route follows */
			call next_real_token ();
			if current.type ^= AT_TOKEN then
			     call bad_address_syntax (mlsys_et_$only_address_route_allowed);
		     end;
		     else call bad_address_syntax (mlsys_et_$only_address_route_allowed);
		end;
		first_token_in_address = token_idx + 1; /* address starts after the colon */
		call next_real_token ();		/* skip over the colon to the address itself */
		go to START_ADDRESS_PARSE_WITH_ROUTE;
	     end;

	else if current.type = LEFTBRACE_TOKEN then do;
	     /*** A structured address */
	     do while (current.type ^= RIGHTBRACE_TOKEN); /* lex has guarenteed that the braces balance */
		call next_real_token ();		/* move to the end of the structured part */
	     end;
	     call next_real_token ();			/* move past the } */
	     do while (^end_of_address ());		/* may be followed by routing information only */
		if current.type ^= AT_TOKEN then call bad_address_syntax (mlsys_et_$only_address_route_allowed);
		n_hosts = n_hosts + 1;
		host_indeces (n_hosts) = token_idx;
		call next_real_token ();		/* past the AT ... */
		if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$missing_host_name);
		call next_real_token ();		/* ... and the host name following it */
	     end;
	end;

	else do;

	     /*** Simple address, named address, or a named group address */
	     do while (^end_of_address ());

		if current.type = LEFTBRACKET_TOKEN then
		     /*** A named address */
		     if in_named_address then
			call bad_address_syntax (mlsys_et_$recursive_named_addresses);
		     else do;			/* ... looks OK: start parse over terminating at ">" */
			address_name_start = first_token_in_address;
			address_name_end = token_idx - 1;
			in_named_address = "1"b;
			string (p_ipo.delimiters) = ""b;
			p_ipo.delimiters.angle_bracket = "1"b;
			go to START_ADDRESS_PARSE;
		     end;

		else if current.type = COLON_TOKEN then
		     /*** A named group */
		     if in_named_address then
			call bad_address_syntax (mlsys_et_$recursive_named_addresses);
		     else do;
			call parse_named_group ();
			go to RETURN_FROM_PARSE_ADDRESS;
		     end;				/* ... the internal procedure does all the necessary work */

		else if current.type = AT_TOKEN then do;
		     /*** A possible host name: remember it for later */
		     n_hosts = n_hosts + 1;
		     host_indeces (n_hosts) = token_idx;
		     call next_real_token ();
		     if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$missing_host_name);
		end;

		else if current.type = WORD_TOKEN
		/*** Part of the address proper */
		     then
		     ;

		else call bad_address_syntax (mlsys_et_$invalid_address_syntax);

		call next_real_token ();		/* move right along */
	     end;
	end;

	if in_named_address then do;
	     /*** End of named address processing: insure that proper delimiter follows the ">" */
	     last_token_in_address = token_idx - 1;	/* ... don't include the ">" as part of the address */
	     in_named_address = "0"b;
	     p_ipo = saved_p_ipo;
	     call next_real_token ();
	     if ^end_of_address () then call bad_address_syntax (mlsys_et_$text_follows_address);
	end;
	else last_token_in_address = 0;		/* don't know where it ends yet */


/* Determine the system of residence and construct the address route */

	delimiting_token = token_idx;

	if n_hosts = 0 then do;			/* no system/route given: use the default */
	     if last_token_in_address = 0 then		/* ... haven't seen the end because of a named address ... */
		last_token_in_address = token_idx - 1;	/* ... so it's all address */
	     address_is_local = p_ipo.default_system_is_local;
	     foreign_system_name = p_ipo.default_system_name;
	end;

	else do;					/* have system and/or route */
	     address_is_local = "0"b;			/* ... can't be sure until we try to validate it */
	     if n_reversed_hosts > 0 then do;		/* ... need to put host names into proper order */
		allocate host_indeces in (system_area) set (new_host_indeces_ptr);
		do idx = 1 to n_reversed_hosts;
		     new_host_indeces_ptr -> host_indeces (n_hosts - idx + 1) = host_indeces (idx);
		end;
		do idx = (n_reversed_hosts + 1) to n_hosts;
		     new_host_indeces_ptr -> host_indeces (idx - n_reversed_hosts) = host_indeces (idx);
		end;
		if baseno (lex_and_parse_pointers.host_indeces_ptr) ^= baseno (stackframeptr ()) then
		     free host_indeces in (system_area);
		lex_and_parse_pointers.host_indeces_ptr = new_host_indeces_ptr;
		new_host_indeces_ptr = null ();
	     end;
	     last_token_in_address = host_indeces (1) - 1;
	     call make_token_current (host_indeces (1));
	     call next_real_token ();			/* ... first host name is the foreign system */
	     foreign_system_name = current_token;	/* ... above code insured this is the right kind of token */
	     do idx = 2 to n_hosts;			/* ... move the remaining hosts (the route) down by 1 */
		host_indeces (idx - 1) = host_indeces (idx);
	     end;
	     n_hosts = n_hosts - 1;
	end;

	if n_hosts = 0 then				/* no explicit route */
	     address_route_ptr = null ();
	else do;
	     address_route_n_relays = n_hosts;
	     allocate address_route in (system_area) set (address_route_ptr);
	     address_route.version = ADDRESS_ROUTE_VERSION_1;
	     do idx = 1 to n_hosts;
		call make_token_current (host_indeces (idx));
		call next_real_token ();
		address_route.relays (n_hosts - idx + 1) = current_token;
	     end;					/* ... the printed representation is backward */
	end;


/* Get the address name and comment */

	if address_name_start = 0 then
	     address_name = "";			/* no address name */
	else call build_string (address_name_start, address_name_end, "1"b, "0"b, "1"b, address_name);

	call build_string ((p_token_idx + 1), (delimiting_token - 1), "0"b, "1"b, "1"b, address_comment);


/* Construct the actual address */

	if address_is_local then do;			/* a local address */
	     call make_token_current (first_token_in_address);
						/* back to the beginning */

	     if current.type = COMMENT_TOKEN then	/* skip past comment to the first real token */
		call next_real_token ();

	     if token_idx > last_token_in_address then	/* a null address */
		call bad_address_syntax (mlsys_et_$empty_address_text);

	     else if current.type = LEFTBRACE_TOKEN then do;
		/*** A structued address: validate it ... */
		call next_real_token ();		/* should be followed by the type of address */
		if current.type ^= WORD_TOKEN then
		     call bad_address_syntax (mlsys_et_$unknown_structured_address_type);

		if translate (current_token, UPPERCASE, LOWERCASE) = "LOGBOX" then do;
		     /*** The user's logbox ... */
		     call next_real_token ();		/* should be the close brace */
		     if current.type ^= RIGHTBRACE_TOKEN then
			call bad_address_syntax (mlsys_et_$text_follows_address);
		     call mail_system_$create_logbox_address (mlsys_data_$user_id, address_name, address_comment,
			p_address_ptr, code);
		     if code ^= 0 then call bad_address_syntax (code);
		end;

		else if translate (current_token, UPPERCASE, LOWERCASE) = "SAVE" then do;
		     /*** One of the user's saveboxes ... */
		     call next_real_token ();		/* should be the savebox pathname */
		     if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$address_pathname_expected);
		     if has_suffix (current_token, ".sv") then
			address_pathname = substr (current_token, 1, (length (current_token) - length (".sv")));
		     else address_pathname = current_token;
		     call next_real_token ();		/* should be the closing brace */
		     if current.type ^= RIGHTBRACE_TOKEN then
			call bad_address_syntax (mlsys_et_$text_follows_address);
		     if search (address_pathname, "<>") = 0 then do;
			call suffixed_name_$make (address_pathname, "sv.mbx", address_ename, code);
			if code ^= 0 then call bad_address_syntax (code);
			call search_paths_$find_dir ("mlsys", null(), address_ename, "", address_dirname, code);
			if code = error_table_$noentry then 
			     call expand_pathname_$add_suffix (address_pathname, "sv.mbx", address_dirname, address_ename, code);
			if code ^= 0 then address_dirname = "";
			end;
		     else
			call expand_pathname_$add_suffix (address_pathname, "sv.mbx", address_dirname, address_ename,
			code);
		     if code ^= 0 then call bad_address_syntax (code);
		     call reject_starnames (address_ename, "");
		     call mail_system_$create_savebox_address (mlsys_data_$user_id, address_dirname, address_ename,
			address_name, address_comment, p_address_ptr, code);
		     if code ^= 0 then call bad_address_syntax (code);
		end;

		else if translate (current_token, UPPERCASE, LOWERCASE) = "MBX" then do;
		     /*** A random mailbox ... */
		     call next_real_token ();		/* should be the mailbox pathname */
		     if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$address_pathname_expected);
		     address_pathname = current_token;
		     call next_real_token ();		/* should be the closing brace */
		     if current.type ^= RIGHTBRACE_TOKEN then
			call bad_address_syntax (mlsys_et_$text_follows_address);
     		     if search (address_pathname, "<>") = 0 then do;
			call suffixed_name_$make (address_pathname, "mbx", address_ename, code);
			if code ^= 0 then call bad_address_syntax (code);
			call search_paths_$find_dir ("mlsys", null(), address_ename, "", address_dirname, code);
			if code = error_table_$noentry then 
			     call expand_pathname_$add_suffix (address_pathname, "mbx", address_dirname, address_ename, code);
			if code ^= 0 then address_dirname = "";
			end;
		     else
			call expand_pathname_$add_suffix (address_pathname, "mbx", address_dirname, address_ename, code);
		     if code ^= 0 then call bad_address_syntax (code);
		     call reject_starnames (address_ename, "");
		     call mail_system_$create_mailbox_address (address_dirname, address_ename, address_name,
			address_comment, p_address_ptr, code);
		     if code ^= 0 then call bad_address_syntax (code);
		end;

		else if translate (current_token, UPPERCASE, LOWERCASE) = "FORUM" then do;
		     /*** A forum meeting ... */
		     call next_real_token ();		/* should be the meeting pathname */
		     if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$address_pathname_expected);
		     address_pathname = current_token;
		     call next_real_token ();		/* should be the closing brace */
		     if current.type ^= RIGHTBRACE_TOKEN then
			call bad_address_syntax (mlsys_et_$text_follows_address);
		     if search (address_pathname, "<>") = 0 then do;
			/*** ... not a pathname: must find the meeting by search list */
			if length (rtrim (address_pathname)) > length (address_ename) then
			     call bad_address_syntax (error_table_$entlong);
			address_ename = substr (address_pathname, 1, length (address_ename));
			if ^(has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control")) then
			     if length (rtrim (address_ename)) > (length (address_ename) - length (".forum")) then
				call bad_address_syntax (error_table_$entlong);
			call reject_starnames (address_ename, "");
			if mlsys_psp_$forum_not_available () then
			     /*** ... Forum PSP not here: we've done all we can; mlsys_transmit_ will do the rest */
			     address_dirname = "";
			else do;
			     /*** ... time to scan the search list */
			     if forum_search_list_ptr = null () then do;
				call search_paths_$get ("forum", sl_control_default, "", null (), system_area_ptr,
				     sl_info_version_1, forum_search_list_ptr, code);
				if code ^= 0 then call bad_address_syntax (code);
			     end;
			     if has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control") then
				call search_forum_list (address_ename, address_dirname, code);
			     else do;		/* ... try version 2 then version 1 meeting ... */
				trimmed_address_ename = rtrim (address_ename);
				call search_forum_list ((trimmed_address_ename || ".forum"), address_dirname,
				     code);
				if code = 0 then
				     address_ename = trimmed_address_ename || ".forum";
				else do;
				     call search_forum_list ((trimmed_address_ename || ".control"),
					address_dirname, code);
				     if code = 0 then address_ename = trimmed_address_ename || ".control";
				end;
			     end;
			     if code ^= 0 then	/* ... couldn't be found */
				address_dirname = "";
			end;
		     end;
		     else do;
			/*** .... a pathname */
			call expand_pathname_ (address_pathname, address_dirname, address_ename, code);
			if code ^= 0 then call bad_address_syntax (code);
			if ^(has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control")) then
			     if length (rtrim (address_ename)) > (length (address_ename) - length (".forum")) then
				call bad_address_syntax (error_table_$entlong);
			call reject_starnames (address_ename, "");
			if mlsys_psp_$forum_not_available () then
			     ;			/* ... no Forum PSP: we've done all we can */
			else do;
			     if ^(has_suffix (address_ename, ".forum") | has_suffix (address_ename, ".control"))
			     then do;
				/*** ... must determine the meeting version */
				trimmed_address_ename = rtrim (address_ename);
				address_ename = trimmed_address_ename || ".forum";
				call forum_$get_forum_path (address_dirname, address_ename, ((168)" "), ((32)" "),
				     code);
				if code ^= 0 then	/* ... not version 2 */
				     if (length (trimmed_address_ename) + length (".control"))
					<= length (address_ename) then
					address_ename = trimmed_address_ename || ".control";
			     end;
			end;
		     end;
		     call mail_system_$create_forum_address (address_dirname, address_ename, address_name,
			address_comment, p_address_ptr, code);
		     if code ^= 0 then call bad_address_syntax (code);
		end;

		else if translate (current_token, UPPERCASE, LOWERCASE) = "LIST" then do;
		     /*** A mailing list ... */
		     call next_real_token ();		/* should be the mailing list pathname */
		     if current.type ^= WORD_TOKEN then call bad_address_syntax (mlsys_et_$address_pathname_expected);
		     address_pathname = current_token;
		     call next_real_token ();		/* should be the closing brace */
		     if current.type ^= RIGHTBRACE_TOKEN then
			call bad_address_syntax (mlsys_et_$text_follows_address);
		     call expand_pathname_$component_add_suffix (address_pathname, "mls", address_dirname,
			address_ename, address_component, code);
		     if code ^= 0 then call bad_address_syntax (code);
     		     if search (address_pathname, "<>") = 0 then do;
			address_dirname = "";
			call search_paths_$find_dir ("mlsys", null(), address_ename, "", address_dirname, code);
			if code = error_table_$noentry then 
			     call expand_pathname_$component_add_suffix (address_pathname, "mls", address_dirname,
			     address_ename, address_component, code);
			if code ^= 0 then address_dirname = "";
			end;
		     if code ^= 0 then call bad_address_syntax (code);
		     call reject_starnames (address_ename, address_component);
		     call mail_system_$create_mailing_list_address (address_dirname, address_ename, address_component,
			address_name, address_comment, p_address_ptr, code);
		     if code ^= 0 then call bad_address_syntax (code);
		end;

		else call bad_address_syntax (mlsys_et_$unknown_structured_address_type);
	     end;

	     else do;				/* all text: user or mail table */
		call build_string (first_token_in_address, last_token_in_address, "1"b, "0"b, "1"b, address_string);
		call mlsys_user_mte_syntax_$classify_and_validate (address_string, is_mte, ((32)" "), ((32)" "), code)
		     ;
		if code ^= 0 then call bad_address_syntax (code);
		if is_mte then
		     call mail_system_$create_mail_table_address (address_string, address_name, address_comment,
			p_address_ptr, code);
		else call mail_system_$create_user_mailbox_address (address_string, address_name, address_comment,
			p_address_ptr, code);
		if code ^= 0 then call bad_address_syntax (code);
	     end;
	end;

	else do;					/* a foreign address */
	     call build_string (first_token_in_address, last_token_in_address, "1"b, "0"b, "1"b, address_string);
	     call mail_system_$create_foreign_address (address_string, foreign_system_name, address_route_ptr,
		address_name, address_comment, p_address_ptr, code);
	     if code ^= 0 then call bad_address_syntax (code);
	end;

	if p_pto.validate_addresses then do;		/* caller wants to be sure we can send it mail */
	     call mail_system_$validate_address (p_address_ptr, "1"b, code);
	     if code ^= 0 then do;			/* ... invalid */
		if ^p_pto.include_invalid_addresses then call mail_system_$free_address (p_address_ptr, (0));
		call bad_address_syntax (code);
	     end;
	end;

	code = 0;					/* success */


/* Parse completed */

RETURN_FROM_PARSE_ADDRESS:
	p_ipo = saved_p_ipo;			/* cleanup */
	if new_host_indeces_ptr ^= null () then free new_host_indeces_ptr -> host_indeces in (system_area);
	if address_route_ptr ^= null () then free address_route in (system_area);

	call make_token_current (delimiting_token);	/* show the delimiter to our caller */
	p_token_idx = delimiting_token;

	p_code = code;

	return;



/* Internal to parse_address: reports syntax errors in the address */

bad_address_syntax:
	procedure (p_code);

dcl  p_code fixed binary (35) parameter;

dcl  (brace_level, bracket_level, group_level) fixed binary (21);
dcl  string_lth fixed binary (21);

	     if delimiting_token = 0 then do;		/* must determine last token now */
		brace_level, bracket_level, group_level = 0;
		call make_token_current (first_token_in_address);
		if current.type = COMMENT_TOKEN then	/* skip to the first real token */
		     call next_real_token ();
		if (current.type = COLON_TOKEN) then do;/* an RFC733 structured address */
		     call next_real_token ();
		     call next_real_token ();		/* past the structure type ... */
		     call next_real_token ();		/* ... and the other colon */
		end;
		do while ((current.type ^= END_OF_TEXT_TOKEN) & (delimiting_token = 0));
		     if (brace_level <= 0) & (bracket_level <= 0) & (group_level <= 0) then
			if end_of_address () then	/* found the end of the address */
			     delimiting_token = token_idx;
		     if (current.type = LEFTBRACE_TOKEN) then
						/* keep track of nesting in order to find proper terminator */
			brace_level = brace_level + 1;
		     else if (current.type = RIGHTBRACE_TOKEN) then brace_level = brace_level - 1;
		     else if (current.type = LEFTBRACKET_TOKEN) then bracket_level = bracket_level + 1;
		     else if (current.type = RIGHTBRACKET_TOKEN) then bracket_level = bracket_level - 1;
		     else if (current.type = COLON_TOKEN) then group_level = group_level + 1;
		     else if (current.type = SEMICOLON_TOKEN) then group_level = group_level - 1;
		     call next_real_token ();		/* keep looking */
		end;
		if delimiting_token = 0 then		/* hit the end */
		     delimiting_token = token_idx;
	     end;

	     string_lth =				/* may use this value in several places ... */
		token_list.tokens (delimiting_token - 1).original_start
		- token_list.tokens (p_token_idx + 1).original_start
		+ token_list.tokens (delimiting_token - 1).original_lth;
	     string_lth = max (string_lth, 0);		/* ... above is negative if original_text is a null string */

	     n_syntax_errors = n_syntax_errors + 1;
	     if p_pto.list_errors then do;		/* caller wants to see the bad text */
		sel (n_syntax_errors).text_start = token_list.tokens (p_token_idx + 1).original_start;
		sel (n_syntax_errors).text_lth = string_lth;
		sel (n_syntax_errors).code = p_code;
	     end;

	     if p_pto.include_invalid_addresses & (p_address_ptr = null ()) then do;
		begin;				/* caller wants it in the address list and it isn't already */
dcl  the_string char (string_lth) defined (original_text) position (token_list.tokens (p_token_idx + 1).original_start);
		     call mail_system_$create_invalid_address ((the_string), "", "", p_address_ptr, (0));
		end;
	     end;

	     code = p_code;				/* set parse_address's output value */

	     go to RETURN_FROM_PARSE_ADDRESS;

	end bad_address_syntax;



/* Internal to parse_address: determines if the end of the address has been reached */

end_of_address:
	procedure () returns (bit (1) aligned);

	     if p_ipo.delimiters.eos & (current.type = END_OF_TEXT_TOKEN) then return ("1"b);

	     else if (current.type = END_OF_TEXT_TOKEN) then do;
						/* shouldn't have reached the end: syntax error */
		delimiting_token = token_idx;		/* clearly the address stops here */
		call bad_address_syntax (mlsys_et_$incomplete_address_text);
	     end;

	     else if p_ipo.delimiters.comma & (current.type = COMMA_TOKEN) then return ("1"b);

	     else if p_ipo.delimiters.angle_bracket & (current.type = RIGHTBRACKET_TOKEN) then return ("1"b);

	     else if p_ipo.delimiters.semicolon & (current.type = SEMICOLON_TOKEN) then return ("1"b);

	     else return ("0"b);

	end end_of_address;



/* Internal to parse_address: parses a named group */

parse_named_group:
	procedure ();

dcl  1 local_pto aligned like parse_text_options;
dcl  1 local_ipo aligned like internal_parse_options;

dcl  an_address_list_ptr pointer;
dcl  (saved_n_syntax_errors, second_half_comment_start) fixed binary (21);

	     address_name_start = first_token_in_address;
	     address_name_end = token_idx - 1;		/* up to but not including the ":" */

	     an_address_list_ptr = null ();		/* parse_address_list will set it up */

	     string (local_pto.flags) = ""b;		/* don't list errors, etc. */

	     local_ipo = p_ipo;			/* copy most internal options */
	     string (local_ipo.delimiters) = ""b;	/* ... except only stop on a semi-colon */
	     local_ipo.delimiters.semicolon = "1"b;

	     saved_n_syntax_errors = n_syntax_errors;	/* we'll convert all errors into a single error */
	     call parse_address_list (local_pto, local_ipo, token_idx, an_address_list_ptr, code);
	     n_syntax_errors = saved_n_syntax_errors;

	     if code ^= 0 then			/* named group is bad: report a single, global error */
		if code = mlsys_et_$incomplete_address_list_text then
		     call bad_address_syntax (mlsys_et_$incomplete_named_group_text);
		else call bad_address_syntax (mlsys_et_$invalid_named_group_text);

	     second_half_comment_start = token_idx + 1;	/* any comment after the semicolon is global */

	     call next_real_token ();			/* must be at the end now */
	     if ^end_of_address () then do;
		call free_address_list (an_address_list_ptr, (0));
		call bad_address_syntax (mlsys_et_$text_follows_address);
	     end;

	     delimiting_token = token_idx;		/* for cleanup */

	     call build_string (address_name_start, address_name_end, "1"b, "0"b, "1"b, address_name);
	     call build_string (address_name_start, address_name_end, "0"b, "1"b, "1"b, address_comment);
	     call build_string (second_half_comment_start, (delimiting_token - 1), "0"b, "1"b, "0"b, address_comment);
						/* pick up any remaining comment text */

	     call mail_system_$create_named_group_address (address_name, an_address_list_ptr, "1"b, address_comment,
		p_address_ptr, code);
	     if code ^= 0 then call bad_address_syntax (code);

	     return;

	end parse_named_group;



/* Internal to parse_address: construct the text string consisting of all the tokens within the specified range */

build_string:
	procedure (p_first_token, p_last_token, p_include_non_comments, p_include_comments, p_initialize_string,
	     p_string);

dcl  (p_first_token, p_last_token) fixed binary (21) parameter;
dcl  (p_include_non_comments, p_include_comments, p_initialize_string) bit (1) aligned parameter;
dcl  p_string character (*) varying parameter;
dcl  saved_current_token fixed binary (21);

	     if p_initialize_string then p_string = "";

	     saved_current_token = token_idx;		/* want to get back here when done */
	     call make_token_current (p_first_token);	/* start here please */

	     do while (token_idx <= p_last_token);	/* for all tokens in the string */
		if current.type = COMMENT_TOKEN then
		     if p_include_comments then do;
			p_string = p_string || current_token;
			p_string = p_string || " ";
		     end;
		     else ;
		else do;
		     if p_include_non_comments then do;
			p_string = p_string || current_token;
			p_string = p_string || " ";
		     end;
		     else ;
		end;
		call next_token ();			/* next, please */
	     end;

	     if length (p_string) > 0 then		/* it's one larger than it should be */
		p_string = substr (p_string, 1, (length (p_string) - 1));

	     call make_token_current (saved_current_token);
						/* back to where we were */

	     return;

	end build_string;



/* Internal to parse_address: rejects pathnames containing starnames */

reject_starnames:
	procedure (p_ename, p_component);

dcl  (p_ename, p_component) character (32) parameter;
dcl  code fixed binary (35);

	     call check_star_name_$entry (p_ename, code); /* first check the entryname */
	     if code = 0 then			/* ... entryname OK: check the component name (if present) */
		if p_component ^= "" then call check_star_name_$entry (p_component, code);

	     if (code = 1) | (code = 2) then code = error_table_$nostars;

	     if code ^= 0 then			/* either a starname or invalid syntax */
		call bad_address_syntax (code);

	     return;

	end reject_starnames;



/* Internal to parse_address: returns "1"b if the given suffix is present on the supplied name */

has_suffix:
	procedure (p_name, p_suffix) returns (bit (1) aligned);

dcl  (p_name, p_suffix) character (*) parameter;

	     return ((index (reverse (rtrim (p_name)), reverse (p_suffix)) = 1));

	end has_suffix;



/* Internal to parse_address: scans the forum search list (already obtained above) for the given entryname */

search_forum_list:
	procedure (p_ename, p_dirname, p_code);

dcl  (p_ename, p_dirname) character (*) parameter;
dcl  p_code fixed binary (35) parameter;

dcl  ename character (32) initial ("");
dcl  idx fixed binary;

	     if length (rtrim (p_ename)) > length (ename) then do;
		p_code = error_table_$entlong;	/* ... constructed entry name is too long */
		return;
	     end;

	     p_code = 1;				/* need do until ... */

	     do idx = 1 to forum_search_list_ptr -> sl_info.num_paths while (p_code ^= 0);
		if forum_search_list_ptr -> sl_info.paths (idx).code = 0 then
		     call forum_$get_forum_path (forum_search_list_ptr -> sl_info.paths (idx).pathname, p_ename,
			((168)" "), ((32)" "), p_code);
		if p_code = 0 then p_dirname = forum_search_list_ptr -> sl_info.paths (idx).pathname;
	     end;

	     return;

	end search_forum_list;

     end parse_address;
%page;
/* Parse an address list */

parse_address_list:
     procedure (p_pto, p_ipo, p_token_idx, p_address_list_ptr, p_code);

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_token_idx fixed binary (21) parameter;
dcl  p_address_list_ptr pointer;
dcl  p_code fixed binary (35) parameter;

dcl  1 local_ipo aligned like internal_parse_options;

dcl  an_address pointer;
dcl  (first_token_in_address_list, last_token_in_address_list) fixed binary (21);
dcl  (previous_n_addresses) fixed binary;
dcl  (created_address_list, done) bit (1) aligned;


	local_ipo = p_ipo;				/* use caller's options ... */
	local_ipo.delimiters.comma = "1"b;		/* ... but also allow a comma delimter */

	if p_address_list_ptr = null () then do;	/* must create the list */
	     call create_address_list (ADDRESS_LIST_VERSION_2, p_address_list_ptr, code);
	     if code ^= 0 then do;
		p_code = code;
		return;
	     end;
	     created_address_list = "1"b;
	end;
	else do;					/* already something in the list ... */
	     created_address_list = "0"b;
	     previous_n_addresses = p_address_list_ptr -> address_list.n_addresses;
	end;					/* ... in case we have to flush what we add */

	call make_token_current (p_token_idx);		/* peek ahead to the first token of the list ... */
	call next_token ();				/* ... to see if it's an empty list: only if at end-of-list */

	first_token_in_address_list = token_idx;	/* here's where the list starts ... */
	last_token_in_address_list = token_idx;		/* ... and for now: it also ends here */

	done = end_of_address_list ();		/* check for end-of-list before the first address */

	do while (^done);

	     call parse_address (p_pto, local_ipo, p_token_idx, an_address, code);
	     last_token_in_address_list = token_idx - 1;	/* ... the list now goes at least this far */

	     if an_address ^= null () then do;		/* have an address */
		call add_address (p_address_list_ptr, an_address, ADDRESS_LIST_VERSION_2, code);
		if code ^= 0 then call bad_address_list_syntax (code);
	     end;

	     else if ^p_pto.list_errors & ^p_pto.include_invalid_addresses then
		if code = 0 then			/* caller hasn't asked us to continue */
		     call bad_address_list_syntax (mlsys_et_$invalid_address_list_syntax);
		else if code = mlsys_et_$incomplete_address_text then
		     call bad_address_list_syntax (mlsys_et_$incomplete_address_list_text);
		else call bad_address_list_syntax (code);

	     done = end_of_address_list ();		/* check if we're done yet */
	end;

	code = 0;					/* success: caller will really set the code */

RETURN_FROM_PARSE_ADDRESS_LIST:
	p_code = code;
	return;


/* Internal to parse_address_list: reports syntax errors in the address list */

bad_address_list_syntax:
	procedure (p_code);

dcl  p_code fixed binary (35) parameter;

dcl  string_lth fixed binary (21);
dcl  idx fixed binary;

	     if created_address_list then		/* we created it; we destroy it */
		call free_address_list (p_address_list_ptr, (0));
	     else do;				/* we didn't create it: delete what we added */
		do idx = p_address_list_ptr -> address_list.n_addresses to (previous_n_addresses + 1) by -1;
		     call delete_address (p_address_list_ptr, idx, (0));
		end;
	     end;

	     string_lth =				/* may use this value in several places ... */
		token_list.tokens (last_token_in_address_list).original_start
		- token_list.tokens (first_token_in_address_list).original_start
		+ token_list.tokens (last_token_in_address_list).original_lth;
	     string_lth = max (string_lth, 0);		/* ... above is negative if original_text is a null string */

	     n_syntax_errors = n_syntax_errors + 1;
	     if p_pto.list_errors then do;		/* caller wants to see the bad text */
		sel (n_syntax_errors).text_start = token_list.tokens (first_token_in_address_list).original_start;
		sel (n_syntax_errors).text_lth = string_lth;
		sel (n_syntax_errors).code = p_code;
	     end;

	     code = p_code;				/* set parse_address_list's output value */

	     go to RETURN_FROM_PARSE_ADDRESS_LIST;

	end bad_address_list_syntax;



/* Internal to parse_address_list: determines if the end of the address list has been reached */

end_of_address_list:
	procedure () returns (bit (1) aligned);

	     if p_ipo.delimiters.eos & (current.type = END_OF_TEXT_TOKEN) then return ("1"b);

	     else if current.type = END_OF_TEXT_TOKEN then do;
		last_token_in_address_list = token_idx - 1;
		call bad_address_list_syntax (mlsys_et_$incomplete_address_list_text);
	     end;

	     else if p_ipo.delimiters.comma & (current.type = COMMA_TOKEN) then return ("1"b);

	     else if p_ipo.delimiters.angle_bracket & (current.type = RIGHTBRACKET_TOKEN) then return ("1"b);

	     else if p_ipo.delimiters.semicolon & (current.type = SEMICOLON_TOKEN) then return ("1"b);

	     else return ("0"b);

	end end_of_address_list;

     end parse_address_list;
%page;
/* Convert the printed representation of a date/time into its internal form */

parse_date_time_text:
     procedure (p_pto, p_ipo, p_date_time_text, p_date_time, p_code) /* options (quick) */;

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_date_time_text character (*) parameter;
dcl  p_date_time fixed binary (71) parameter;
dcl  p_code fixed binary (35) parameter;

dcl  date_time fixed binary (71);

dcl  zone_name character (4);
dcl  zone_offset fixed binary (71);
dcl  (recognized_zone, standard_multics_zone, negative_offset) bit (1) aligned;

dcl  code fixed binary (35);
dcl  start fixed binary (21);
dcl  (day_of_week, day_of_month, month, year, hour, minute, second, hour_offset, minute_offset, idx) fixed binary;


	call lex_and_parse_prologue (p_date_time_text, "0"b, "0"b);
						/* no cleanup handler here: caller's set one up already */

	call lex_date_time (p_pto, p_ipo, code);	/* "-", "+", ":", and whitespace are delimiters */
	if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;


/* Syntax of a date is:  [ <day-of-week> [ "," ] ] <date> [ "," ] <time> */

	token_idx = 0;				/* start at beginning */
	call next_token ();

	if current.type ^= WORD_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;

	day_of_week = 0;				/* assume not a day of week */
	do idx = lbound (DAY_OF_WEEKS, 1) to hbound (DAY_OF_WEEKS, 1) while (day_of_week = 0);
	     if translate (current_token, UPPERCASE, LOWERCASE) = DAY_OF_WEEKS (idx) then
		day_of_week = DAY_OF_WEEK_VALUES (idx);
	end;

	if day_of_week ^= 0 then do;			/* a day of week is present */
	     call next_token ();			/* ... next token may be a comma */
	     if current.type = COMMA_TOKEN then call next_token ();
	end;


/* Syntax of <date> is:  1*2<digits> [ "-" ] <month> [ "-" ] { 2<digits> | 4<digits> } */

	if current.type ^= WORD_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;
	if (current.token_lth < 1) | (current.token_lth > 2) then go to TRY_CONVERT_DATE_TO_BINARY;
						/* digits will appear as a 2 or 4 character word */
	day_of_month = cv_dec_check_ (current_token, code);
	if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;

	call next_token ();				/* may be followed by an optional hyphen ... */
	if current.type = HYPHEN_TOKEN then call next_token ();

	if current.type ^= WORD_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;
	month = 0;				/* must be a month name */
	do idx = lbound (MONTHS, 1) to hbound (MONTHS, 1) while (month = 0);
	     if translate (current_token, UPPERCASE, LOWERCASE) = MONTHS (idx) then month = MONTH_VALUES (idx);
	end;
	if month = 0 then go to TRY_CONVERT_DATE_TO_BINARY;

	call next_token ();				/* may be followed by an optional hyphen ... */
	if current.type = HYPHEN_TOKEN then call next_token ();

	if current.type ^= WORD_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;
	if (current.token_lth ^= 2) & (current.token_lth ^= 4) then go to TRY_CONVERT_DATE_TO_BINARY;
						/* year must be two or four digits ... */
	if current.token_lth = 2 then			/* ... assume 20th century if 2 digits */
	     year = cv_dec_check_ (current_token, code) + 1900;
	else year = cv_dec_check_ (current_token, code);
	if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;

	call next_token ();				/* an optional comma may appear here */
	if current.type = COMMA_TOKEN then call next_token ();


/* Syntax of <time> is:  <hour> <zone> */

/* Syntax of <hour> is:  <1*2digits> [ ":" ] <1*2digits> [ ":" <1*2digits> ] */

	if current.type ^= WORD_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;
	if current.token_lth <= 2 then do;		/* hour is separate */
	     hour = cv_dec_check_ (current_token, code);
	     if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;
	     call next_token ();			/* ... skip to the minute/second and/or ":" */
	     if current.type = COLON_TOKEN then call next_token ();
	     start = 1;				/* ... minute starts at the beginning of the word */
	end;
	else if (current.token_lth >= 3) & (current.token_lth <= 6) then do;
						/* hour, minute, and seconds all in one word */
	     if mod (current.token_lth, 2) = 1 then do;	/* a single digit hour ... */
		hour = cv_dec_check_ ((substr (current_token, 1, 1)), code);
		start = 2;			/* ... minute starts in the middle of the word */
	     end;
	     else do;
		hour = cv_dec_check_ ((substr (current_token, 1, 2)), code);
		start = 3;			/* ... minute starts in the middle of the word */
	     end;
	     if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;
	end;
	else go to TRY_CONVERT_DATE_TO_BINARY;		/* can't be part of the time */

	if current.type ^= WORD_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;
	if (current.token_lth - start + 1) <= 2 then do;	/* minute ends this token */
	     minute = cv_dec_check_ ((substr (current_token, start)), code);
	     if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;
	     call next_token ();			/* ... skip to the seconds (maybe) */
	     if current.type = COLON_TOKEN then call next_token ();
	     start = 1;				/* ... try it as seconds */
	end;
	else if (current.token_lth - start + 1) <= 4 then do;
						/* minutes and seconds together */
	     if mod ((current.token_lth - start + 1), 2) = 1 then do;
		minute = cv_dec_check_ ((substr (current_token, start, 1)), code);
		start = start + 1;			/* ... skip to the seconds */
	     end;
	     else do;				/* two digit minutes */
		minute = cv_dec_check_ ((substr (current_token, start, 2)), code);
		start = start + 2;			/* ... skip to the seconds */
	     end;
	     if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;
	end;
	else go to TRY_CONVERT_DATE_TO_BINARY;		/* can't be a time */

	if current.type = WORD_TOKEN then		/* there may be seconds here */
	     if (current.token_lth - start + 1) <= 2 then do;
						/* ... it's the right length */
		second = cv_dec_check_ ((substr (current_token, start)), code);
		if code = 0 then call next_token ();	/* ... it worked */
		else if start ^= 1 then		/* ... middle of a word: bad syntax */
		     go to TRY_CONVERT_DATE_TO_BINARY;
		else second = 0;			/* ... probably a time zone */
	     end;
	     else if start ^= 1 then			/* ... wrong length for seconds in the middle of a word */
		go to TRY_CONVERT_DATE_TO_BINARY;
	     else second = 0;			/* ... probably a time zone */
	else second = 0;				/* ... hopefully a time zone */


/* Syntax of <zone> is:  { [ "-" ] <zone-name> } | { { "+" | "-" } 4<digits> } */

	if current.type = WORD_TOKEN then do;		/* must be a time zone */
TRY_AS_TIME_ZONE_NAME:
	     if current.token_lth > 4 then		/* ... too long to be a time zone name */
		go to TRY_CONVERT_DATE_TO_BINARY;
	     zone_name = translate (current_token, UPPERCASE, LOWERCASE);
	     recognized_zone, standard_multics_zone = "0"b;
	     if p_ipo.multics_format then do;		/* ... try the Multics time zones first */
		call lookup_multics_zone_name ();
		if ^recognized_zone then call lookup_rfc822_zone_name ();
	     end;
	     else do;				/* ... try the RFC822 zone names first */
		call lookup_rfc822_zone_name ();
		if ^recognized_zone then call lookup_multics_zone_name ();
	     end;
	     if ^recognized_zone then go to TRY_CONVERT_DATE_TO_BINARY;
	end;

	else if (current.type = PLUS_TOKEN) | (current.type = HYPHEN_TOKEN) then do;
	     negative_offset = (current.type = HYPHEN_TOKEN);
	     call next_token ();			/* ... could be an explicit offset or a zone name */
	     if current.type ^= WORD_TOKEN then		/* ... sorry: must be digits or a zone name */
		go to TRY_CONVERT_DATE_TO_BINARY;
	     if current.token_lth ^= 4 then		/* ... an offset is exactly four digits ... */
		if negative_offset then
		     go to TRY_AS_TIME_ZONE_NAME;	/* ... preceeded by a "-": assume it's a time zone name */
		else go to TRY_CONVERT_DATE_TO_BINARY;	/* ... preceeded by a "+": can't be a zone name either */
	     hour_offset = cv_dec_check_ ((substr (current_token, 1, 2)), code);
	     if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;
	     minute_offset = cv_dec_check_ ((substr (current_token, 3, 2)), code);
	     if code ^= 0 then go to TRY_CONVERT_DATE_TO_BINARY;
	     if ((hour_offset < 12) & (minute_offset > 59)) | ((hour_offset = 12) & (minute_offset ^= 0)) then
		go to TRY_CONVERT_DATE_TO_BINARY;	/* ... offset isn't valid */
	     standard_multics_zone = "0"b;		/* ... might be a standard zone but don't bother to check */
	     zone_offset = ((60 * hour_offset) + minute_offset) * ONE_MINUTE;
	     if negative_offset then zone_offset = -zone_offset;
	end;					/* ... west of GMT */

	else go to TRY_CONVERT_DATE_TO_BINARY;		/* bad zone */

	call next_token ();				/* shouldn't be anything else left ... */
	if current.type ^= END_OF_TEXT_TOKEN then go to TRY_CONVERT_DATE_TO_BINARY;

	call lex_and_parse_epilogue ("1"b);
	call cu_$shrink_stack_frame (stack_extension_ptr, (0));


/* Control arrives here if the date string parsed properly: try to convert the results into an actual clock reading */

	if ^standard_multics_zone then		/* will add offset later...  */
	     zone_name = "GMT";			/* ... so act like it's universal time */

	call encode_clock_value_ (month, day_of_month, year, hour, minute, second, 0, day_of_week, zone_name, date_time,
	     code);

	if code = 0 then				/* it converted ... */
	     if standard_multics_zone then		/* ... and it's a recognized time zone */
		p_date_time = date_time;
	     else p_date_time = date_time - zone_offset;	/* ... zone known only to us: offset alreay applied once */

	p_code = code;				/* reflect success or failure */

	return;


/* Control arrives here if and only if the date/time string wasn't parseable: try the Multics standard encoding routine
   just to be certain */

TRY_CONVERT_DATE_TO_BINARY:
	call lex_and_parse_epilogue ("1"b);
	call cu_$shrink_stack_frame (stack_extension_ptr, (0));

	call convert_date_to_binary_ (p_date_time_text, p_date_time, p_code);

	return;



/* Internal to parse_date_time_text: determines if the given zone name is a Multics standard time zone */

lookup_multics_zone_name:
	procedure ();

dcl  (idx, jdx) fixed binary;

	     standard_multics_zone = "0"b;		/* need do until */

	     do idx = 1 to ti_zone.number_lang while (^standard_multics_zone);
		do jdx = 1 to ti_zone.number_zone while (^standard_multics_zone);
		     if zone_name = translate (ti_zone.short (idx, jdx), UPPERCASE, LOWERCASE) then
			recognized_zone, standard_multics_zone = "1"b;
		end;
	     end;

	     return;

	end lookup_multics_zone_name;



/* Internal to parse_date_time_text: determines if the given zone name is an RFC822 standard time zone */

lookup_rfc822_zone_name:
	procedure ();

dcl  (zone_idx, idx) fixed binary;

	     zone_idx = 0;

	     do idx = lbound (RFC822_ZONES, 1) to hbound (RFC822_ZONES, 1) while (zone_idx = 0);
		if zone_name = RFC822_ZONES (idx) then zone_idx = idx;
	     end;

	     if zone_idx ^= 0 then do;		/* found it */
		recognized_zone = "1"b;
		zone_offset = RFC822_ZONE_OFFSETS (zone_idx) * ONE_MINUTE;
	     end;

	     return;

	end lookup_rfc822_zone_name;

     end parse_date_time_text;
%page;
/* Convert the printed representation of a Message-ID into its internal form */

parse_message_id_text:
     procedure (p_pto, p_ipo, p_message_id_text, p_message_id) /* options (quick) */;

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_message_id_text character (*) parameter;
dcl  p_message_id bit (72) aligned;

dcl  1 request_id aligned,				/* a request ID broken into its component parts */
       2 year character (2) unaligned,
       2 month character (2) unaligned,
       2 day_of_month character (2) unaligned,
       2 hour character (2) unaligned,
       2 minute character (2) unaligned,
       2 second character (2) unaligned,
       2 period character (1) unaligned,		/* a "." must be in here */
       2 microsecond character (6) unaligned;

dcl  system_name character (256) varying;
dcl  (system_is_local, continue) bit (1) aligned;
dcl  (date_time, microsecond) fixed binary (71);
dcl  (start_of_string, end_of_string) fixed binary (21);
dcl  (day_of_month, month, year, hour, minute, second) fixed binary;


	call lex_and_parse_prologue (p_message_id_text, "1"b, "0"b);
						/* no cleanup handler here: caller's set one up already */

	call lex_message_id (p_pto, p_ipo, code);	/* standard address breaks without preserving comments */

	if code ^= 0 then do;			/* unable to lexically analyze the string */
CANT_INTERPRET_MESSAGE_ID:				/* ... most errors during the parse will come here */
	     call encode_foreign_id (p_message_id_text, p_ipo.default_system_name, p_message_id);
	     call lex_and_parse_epilogue ("1"b);
	     call cu_$shrink_stack_frame (stack_extension_ptr, (0));
	     return;
	end;


/* format: off */
/* The general syntax of a message identifier is

		< STRING at HOST >

   If the HOST is the local system or is ommitted and the default host is the local system, the STRING is expected to be a
   standard Multics request identifier (ie: YYMMDDHHMMSS.FFFFFF) */
/* format: on */

	token_idx = 0;				/* start at the beginning */
	call next_token ();

	if current.type ^= LEFTBRACKET_TOKEN then go to CANT_INTERPRET_MESSAGE_ID;
	call next_token ();

	start_of_string = token_idx;			/* the string portion starts here if all goes well */

	continue = "1"b;
	do while (continue);
	     if current.type = END_OF_TEXT_TOKEN then go to CANT_INTERPRET_MESSAGE_ID;
	     else if current.type = RIGHTBRACKET_TOKEN then continue = "0"b;
	     else if current.type = AT_TOKEN then continue = "0"b;
	     else call next_token ();			/* part of the string ... */
	end;

	end_of_string = token_idx - 1;		/* string part is everything up to here ... */

	if current.type = AT_TOKEN then do;		/* a host name should follow */
	     call next_token ();
	     if current.type ^= WORD_TOKEN then go to CANT_INTERPRET_MESSAGE_ID;
	     system_name = current_token;
	     call next_token ();
	end;
	else system_name = "";			/* we'll use the default system here */

	if current.type ^= RIGHTBRACKET_TOKEN then go to CANT_INTERPRET_MESSAGE_ID;

	call next_token ();
	if current.type ^= END_OF_TEXT_TOKEN then go to CANT_INTERPRET_MESSAGE_ID;


/* Have the text portion of the ID and its system name */

	address_string = "";			/* build the actual text portion of the ID */
	call make_token_current (start_of_string);
	do while (token_idx <= end_of_string);
	     if token_idx > start_of_string then	/* ... 1 space between tokens */
		address_string = address_string || " ";
	     address_string = address_string || current_token;
	     call next_token ();
	end;

	if system_name = "" then do;			/* no explicit system name: use the default */
	     system_name = p_ipo.default_system_name;
	     system_is_local = p_ipo.default_system_is_local;
	end;
	else system_is_local = mlsys_nit_interface_$is_local_system (system_name);

	if system_is_local & (length (address_string) = length (string (request_id))) then do;
	     string (request_id) = address_string;	/* should be a Multics request ID */
	     if request_id.period ^= PERIOD then go to ENCODE_FOREIGN_ID;
	     year = cv_dec_check_ (request_id.year, code) + 1900;
	     if code = 0 then month = cv_dec_check_ (request_id.month, code);
	     if code = 0 then day_of_month = cv_dec_check_ (request_id.day_of_month, code);
	     if code = 0 then hour = cv_dec_check_ (request_id.hour, code);
	     if code = 0 then minute = cv_dec_check_ (request_id.minute, code);
	     if code = 0 then second = cv_dec_check_ (request_id.second, code);
	     if code = 0 then microsecond = cv_dec_check_ (request_id.microsecond, code);
	     if code = 0 then
		call encode_clock_value_ (month, day_of_month, year, hour, minute, second, microsecond, 0, "GMT",
		     date_time, code);
	     if code ^= 0 then			/* wasn't really a request ID */
		go to ENCODE_FOREIGN_ID;
	     call encode_local_id (date_time, p_message_id);
	end;

	else					/* either not a request ID or not local */
ENCODE_FOREIGN_ID:
	     call encode_foreign_id ((address_string), system_name, p_message_id);

	call lex_and_parse_epilogue ("1"b);
	call cu_$shrink_stack_frame (stack_extension_ptr, (0));

	return;

     end parse_message_id_text;
%page;
/* Initialize data required to lex/parse a given string */

lex_and_parse_prologue:
     procedure (p_original_text, p_address_parse, p_address_list_parse);

dcl  p_original_text character (*) parameter;
dcl  p_address_parse bit (1) aligned parameter;		/* ON => create data necessary to parse an address */
dcl  p_address_list_parse bit (1) aligned parameter;	/* ON => create data necessary to parse an address list */

	original_text_ptr = addr (p_original_text);
	original_text_lth = length (p_original_text);

	lex_and_parse_pointers = null ();		/* be sure the ones we don't set here are null */

	call cu_$grow_stack_frame (STACK_EXTENSION, stack_extension_ptr, (0));
	stack_extension_used = 0;

	call get_space (size (token_list), lex_and_parse_pointers.token_list_ptr);

	call get_space (size (unquoted_text), lex_and_parse_pointers.unquoted_text_ptr);

	if p_address_parse then do;			/* need host name list and a work string */
	     call get_space (size (host_indeces), lex_and_parse_pointers.host_indeces_ptr);
	     call get_space (size (address_string), lex_and_parse_pointers.address_string_ptr);
	     call get_space (size (address_name), lex_and_parse_pointers.address_name_ptr);
	     call get_space (size (address_comment), lex_and_parse_pointers.address_comment_ptr);
	end;

	if p_address_list_parse then			/* need list of syntax errors for caller */
	     call get_space (size (sel), lex_and_parse_pointers.sel_ptr);

	stack_truncation_ptr =
	     addwordno (stack_extension_ptr, (stack_extension_used + 16 - mod (stack_extension_used, 16)));
	call cu_$shrink_stack_frame (stack_truncation_ptr, (0));

	n_syntax_errors = 0;			/* count errors in the string no matter what */

	return;



/* Internal to lex_and_parse_prologue: gets the requested amount of space on the stack or in the system free area */

get_space:
	procedure (p_n_words, p_pointer);

dcl  p_n_words fixed binary (18) parameter;
dcl  p_pointer pointer parameter;
dcl  words (p_n_words) bit (36) aligned based (p_pointer);

	     if (p_n_words + stack_extension_used) <= STACK_EXTENSION then do;
		p_pointer = addwordno (stack_extension_ptr, stack_extension_used);
		stack_extension_used = stack_extension_used + p_n_words + mod (p_n_words, 2);
	     end;

	     else allocate words in (system_area) set (p_pointer);

	     return;

	end get_space;

     end lex_and_parse_prologue;
%page;
/* Cleanup after a lex/parse operation */

lex_and_parse_epilogue:
     procedure (p_release_sel);

dcl  p_release_sel bit (1) aligned;

	if lex_and_parse_pointers.token_list_ptr ^= null () then
	     if baseno (lex_and_parse_pointers.token_list_ptr) ^= baseno (stackframeptr ()) then
		free token_list in (system_area);

	if lex_and_parse_pointers.unquoted_text_ptr ^= null () then
	     if baseno (lex_and_parse_pointers.unquoted_text_ptr) ^= baseno (stackframeptr ()) then
		free unquoted_text in (system_area);

	if lex_and_parse_pointers.host_indeces_ptr ^= null () then
	     if baseno (lex_and_parse_pointers.host_indeces_ptr) ^= baseno (stackframeptr ()) then
		free host_indeces in (system_area);

	if lex_and_parse_pointers.address_string_ptr ^= null () then
	     if baseno (lex_and_parse_pointers.address_string_ptr) ^= baseno (stackframeptr ()) then
		free address_string in (system_area);
	if lex_and_parse_pointers.address_name_ptr ^= null () then
	     if baseno (lex_and_parse_pointers.address_name_ptr) ^= baseno (stackframeptr ()) then
		free address_name in (system_area);
	if lex_and_parse_pointers.address_comment_ptr ^= null () then
	     if baseno (lex_and_parse_pointers.address_comment_ptr) ^= baseno (stackframeptr ()) then
		free address_comment in (system_area);

	lex_and_parse_pointers.all_but_sel_ptr = null (); /* don't free the above more than once */

	if p_release_sel & (lex_and_parse_pointers.sel_ptr ^= null ()) then do;
	     if baseno (lex_and_parse_pointers.sel_ptr) ^= baseno (stackframeptr ()) then free sel in (system_area);
	     lex_and_parse_pointers.sel_ptr = null ();	/* caller doesn't want to use the list */
	end;

	return;

     end lex_and_parse_epilogue;
%page;
/* Lexical analysis */

lex_string:
     procedure (p_pto, p_ipo, p_code);

	return;					/* not an entrypoint */

dcl  1 p_pto aligned like parse_text_options parameter;
dcl  1 p_ipo aligned like internal_parse_options parameter;
dcl  p_code fixed binary (35) parameter;

dcl  remaining_text character (original_text_lth - text_used) unaligned based (addcharno (original_text_ptr, text_used));
dcl  text_used fixed binary (21);			/* amount of text already lex'ed */

dcl  unquoted_used fixed binary (21);			/* amount of workspace occupied by unquoting quoted strings */

dcl  use_date_time_breaks bit (1) aligned;		/* ON => use special breaks for date/time sequences */
dcl  save_comments bit (1) aligned;			/* ON => make tokens for any comments */
dcl  braces_special bit (1) aligned;			/* ON => treat braces as structured delimiters */

dcl  (original_start, unquoted_start, parenthesis_level, brace_level, idx) fixed binary (21);


/* Lexical analysis for address and address-list strings: the accepted delimiters are whitespace, comments, and the
   address break characters (",", ":", ";", "{", "}", "<", ">". and "@"); quoted strings are also recognized; braces are
   treated as balanced delimiters which may be nested; comments are placed in the token list to aid in the construction of
   the address's printed representation */

lex_address:
     entry (p_pto, p_ipo, p_code);

	use_date_time_breaks = "0"b;
	save_comments = "1"b;			/* comments are preserved for printed representations */
	braces_special = "1"b;			/* braces nest */
	go to LEXICAL_ANALYSIS_SETUP;


/* Lexical analysis for date/time strings: the accepted delimiters are whitespace, comments, ",", "-", "+", and ":";
   quoted strings are also recognized; comments are not placed in the token list, however */

lex_date_time:
     entry (p_pto, p_ipo, p_code);

	use_date_time_breaks = "1"b;			/* use special break characters */
	save_comments = "0"b;
	braces_special = "0"b;
	go to LEXICAL_ANALYSIS_SETUP;


/* Lexical analysis for message-id strings: the accepted delimiters are whitespace, comments, and the address breaks (see
   above); quoted strings are also recognized; comments are not placed in the token list, however */

lex_message_id:
     entry (p_pto, p_ipo, p_code);

	use_date_time_breaks = "0"b;			/* use the normal address break characters */
	save_comments = "0"b;
	braces_special = "0"b;
	go to LEXICAL_ANALYSIS_SETUP;


LEXICAL_ANALYSIS_SETUP:
	token_list.n_tokens_used = -1;		/* haven't found anything yet */

	call make_token (0, 0);			/* the start of text marker */
	token.type = START_OF_TEXT_TOKEN;
	token.token_ptr = addr (NL);
	token.token_lth = 0;

	unquoted_used = 0;
	text_used = 0;

	brace_level = 0;				/* at top level of the parse */

	do while (text_used < original_text_lth);	/* while there's something left */

	     idx = verify (remaining_text, WHITESPACE);	/* skip leading whitespace */

	     if idx = 0 then			/* end of the meaningfull text */
		text_used = original_text_lth;

	     else do;				/* something still there */

		text_used = text_used + idx - 1;	/* pass the whitespace, please */

		if substr (remaining_text, 1, 1) = OPEN_PAREN then call collect_comment ();
						/* start of a comment */

		else if substr (remaining_text, 1, 1) = CLOSE_PAREN then go to UNBALANCED_COMMENT_DELIMITERS;
						/* end of comment without a beginning */

		else if braces_special & (substr (remaining_text, 1, 1) = LEFT_BRACE) then do;
						/* another level of structured addresses */
		     brace_level = brace_level + 1;
		     call make_token ((text_used + 1), 1);
						/* make a token for it */
		     token.token_ptr = addr (substr (remaining_text, 1, 1));
		     token.token_lth = 1;
		     token.type = LEFTBRACE_TOKEN;
		     text_used = text_used + 1;	/* skip the open brace */
		end;

		else if braces_special & (substr (remaining_text, 1, 1) = RIGHT_BRACE) then
		     if brace_level = 0 then		/* end of structured address without a beginning */
			go to UNBALANCED_BRACES;
		     else do;			/* end of a level of structuring */
			brace_level = brace_level - 1;
			call make_token ((text_used + 1), 1);
			token.token_ptr = addr (substr (remaining_text, 1, 1));
			token.token_lth = 1;
			token.type = RIGHTBRACE_TOKEN;
			text_used = text_used + 1;
		     end;

		else if substr (remaining_text, 1, 1) = QUOTE then call collect_word ();
						/* a word starting with a quote */

		else				/* a word or a delimiter clearly follows ... */
		     if use_date_time_breaks then	/* date/time strings have strange break characters */
		     if index (DATE_TIME_BREAKS, substr (remaining_text, 1, 1)) ^= 0 then do;
						/* a date/time string delimiter: make a token */
			call make_token ((text_used + 1), 1);
			token.token_ptr = addr (substr (remaining_text, 1, 1));
			token.token_lth = 1;	/* by definition */
			token.type = index (DATE_TIME_BREAKS, substr (remaining_text, 1, 1));
			text_used = text_used + 1;	/* skip over it */
		     end;
		     else call collect_word ();	/* simple token */

		else				/* non-date/time string */
		     if (brace_level = 0) & (index (NORMAL_BREAKS, substr (remaining_text, 1, 1)) ^= 0) then do;
						/* a normal delimiter: make a token for it */
		     call make_token ((text_used + 1), 1);
		     token.token_ptr = addr (substr (remaining_text, 1, 1));
		     token.token_lth = 1;		/* by definition */
		     token.type = index (NORMAL_BREAKS, substr (remaining_text, 1, 1));
		     text_used = text_used + 1;	/* skip over it */
		end;

		else call collect_word ();		/* simple token */
	     end;
	end;

	if brace_level > 0 then			/* started a structured address and never finished it */
	     go to UNBALANCED_BRACES;


/* Lex is complete: add a final token to represent the end of the string */

	call make_token ((original_text_lth + 1), 0);	/* this token isn't really in the string at all */
	token.token_ptr = addr (NL);			/* need to point somewhere ... */
	token.token_lth = 0;			/* ... even though it doesn't comprise anything */
	token.type = END_OF_TEXT_TOKEN;		/* obviously */

	p_code = 0;				/* it parsed */

	return;


/* Control arrives at one of the following labels when some form of unbalanced delimiter is found in the string */

UNBALANCED_BRACES:
	p_code = mlsys_et_$unbalanced_braces;
	return;

UNBALANCED_COMMENT_DELIMITERS:
	p_code = mlsys_et_$unbalanced_parentheses;
	return;

UNBALANCED_QUOTES:
	p_code = mlsys_et_$unbalanced_quotes;
	return;
%page;
/* Internal to lex_string: add a new token to the token list */

make_token:
	procedure (p_original_start, p_original_lth);

dcl  p_original_start fixed binary (21) parameter;	/* where it starts in the input string */
dcl  p_original_lth fixed binary (21) parameter;		/* and how long it is */

	     token_list.n_tokens_used = token_list.n_tokens_used + 1;

	     token_ptr = addr (token_list.tokens (token_list.n_tokens_used));

	     token.original_start = p_original_start;
	     token.original_lth = p_original_lth;
	     string (token.flags) = ""b;		/* be nice to caller */

	     return;

	end make_token;



/* Internal to lex_string: collect the text which comprises a comment; ie: any text between balanced parentheses */

collect_comment:
	procedure ();

	     original_start = text_used + 1;		/* the supplied form starts at the ( */
	     unquoted_start = unquoted_used + 1;

	     parenthesis_level = 1;			/* in first level of parens */
	     text_used = text_used + 1;		/* and move past the starting ( */

	     do while ((parenthesis_level > 0) & (text_used < original_text_lth));

		if p_ipo.multics_format then
		     idx = search (remaining_text, QUOTE_PARENS_NL);
		else idx = search (remaining_text, BACKSLASH_PARENS_NL);
						/* find next delimiter */

		if idx = 0 then			/* doesn't terminate properly: punt */
		     go to UNBALANCED_COMMENT_DELIMITERS;

		if idx > 1 then do;			/* something to put into the comment */
		     substr (unquoted_text, (unquoted_used + 1), (idx - 1)) = substr (remaining_text, 1, (idx - 1));
		     unquoted_used = unquoted_used + idx - 1;
		     text_used = text_used + idx - 1;	/* skip to the "delimiter" */
		end;

		if substr (remaining_text, 1, 1) = OPEN_PAREN then do;
						/* nested parens (sigh) */
		     substr (unquoted_text, (unquoted_used + 1), 1) = OPEN_PAREN;
						/* include it */
		     unquoted_used = unquoted_used + 1;
		     text_used = text_used + 1;
		     parenthesis_level = parenthesis_level + 1;
						/* need another ) now */
		end;

		else if substr (remaining_text, 1, 1) = CLOSE_PAREN then do;
						/* end of comment (or a nesting) */
		     if parenthesis_level > 1 then do;	/* nested ): put it into comment text */
			substr (unquoted_text, (unquoted_used + 1), 1) = CLOSE_PAREN;
			unquoted_used = unquoted_used + 1;
		     end;
		     text_used = text_used + 1;	/* move on by */
		     parenthesis_level = parenthesis_level - 1;
		end;

		else if substr (remaining_text, 1, 1) = NL then do;
						/* newline: must be followed by whitespace (folding) */
NEWLINE_EMBEDDED_IN_COMMENT_TEXT:
		     substr (unquoted_text, (unquoted_used + 1), 1) = NL;
						/* add the newline */
		     unquoted_used = unquoted_used + 1;
		     text_used = text_used + 1;	/* skip past the newline */
		     if text_used = original_text_lth then go to UNBALANCED_COMMENT_DELIMITERS;
		     idx = verify (remaining_text, HTSP);
						/* try to skip past whitespace */
		     if (idx = 0) | (idx = 1) then	/* all whitespace (no close paren) or no ... */
			go to UNBALANCED_COMMENT_DELIMITERS;
						/* ... whitespace after newline */
		     text_used = text_used + idx - 1;	/* move over the whitespace */
		end;

		else if substr (remaining_text, 1, 1) = BACKSLASH then do;
						/* one character is quoted */
		     text_used = text_used + 1;	/* past the \ */
		     if text_used = original_text_lth then go to UNBALANCED_COMMENT_DELIMITERS;
		     if substr (remaining_text, 1, 1) = NL then
						/* special case newlines */
			go to NEWLINE_EMBEDDED_IN_COMMENT_TEXT;
		     substr (unquoted_text, (unquoted_used + 1), 1) = substr (remaining_text, 1, 1);
		     unquoted_used = unquoted_used + 1;
		     text_used = text_used + 1;	/* past the quoted character */
		end;

		else call collect_quoted_piece ();	/* must be a quote: start of a quoted string in the comment */
	     end;

	     if parenthesis_level > 0 then		/* comment never ended */
		go to UNBALANCED_COMMENT_DELIMITERS;

	     if save_comments then do;		/* caller wants comments made into tokens */
		call make_token (original_start, (text_used - original_start + 1));
		token.token_ptr = addr (substr (unquoted_text, unquoted_start, 1));
		token.token_lth = unquoted_used - unquoted_start + 1;
		token.type = COMMENT_TOKEN;
		if p_ipo.no_copy then
		     begin;			/* try to use original if possible */
dcl  the_original_text character (token.original_lth) unaligned defined (original_text) position (token.original_start);
dcl  the_unquoted_text character (token.token_lth) unaligned based (token.token_ptr);
		     if the_unquoted_text = the_original_text then do;
			unquoted_used = unquoted_start - 1;
			token.token_ptr = addr (the_original_text);
			token.token_lth = length (the_original_text);
			token.in_unquoted = "0"b;
		     end;
		     else token.in_unquoted = "1"b;
		end;
		else token.in_unquoted = "1"b;	/* not the original text */
	     end;

	     else unquoted_used = unquoted_start - 1;	/* don't save the comment anywhere */

	     return;

	end collect_comment;



/* format: off */
/* Internal to lex_string: collect the text which comprises a single word; a word is composed of one or more pieces of
   juxtaposed text, some of which may be quoted strings.  EG:
		foo"bar bar"mumble
   is a single word */
/* format: on */

collect_word:
	procedure ();

dcl  (in_unquoted, done) bit (1) aligned;

	     unquoted_start = unquoted_used + 1;	/* might need this */
	     in_unquoted = "0"b;			/* but it starts out using caller's text */

	     original_start = text_used + 1;		/* starts at the first character */

	     done = "0"b;				/* have some work to do */

	     do while (^done & (text_used < original_text_lth));

		if use_date_time_breaks then		/* find the end of this piece */
		     if p_ipo.multics_format then
			idx = search (remaining_text, DATE_TIME_DELIMITERS);
		     else idx = search (remaining_text, DATE_TIME_RFC822_DELIMITERS);
		else if brace_level = 0 then		/* parsing at top level */
		     if p_ipo.multics_format then
			idx = search (remaining_text, NORMAL_DELIMITERS);
		     else idx = search (remaining_text, NORMAL_RFC822_DELIMITERS);
		else				/* in the middle of a structred address */
		     if p_ipo.multics_format then idx = search (remaining_text, STRUCTURED_DELIMITERS);
		else idx = search (remaining_text, STRUCTURED_RFC822_DELIMITERS);
		if idx = 0 then			/* rest of the input is this word ... */
		     idx = original_text_lth - text_used + 1;
						/* ... so it's delimited by something over the edge */

		if idx > 1 then do;			/* something before the delimiter */
		     if in_unquoted then do;		/* must copy it over */
			substr (unquoted_text, (unquoted_used + 1), (idx - 1)) =
			     substr (remaining_text, 1, (idx - 1));
			unquoted_used = unquoted_used + idx - 1;
		     end;
		     text_used = text_used + idx - 1;
		end;

		if text_used = original_text_lth then done = "1"b;
						/* used up the remainder of the string */

		else if ^p_ipo.multics_format & (substr (remaining_text, 1, 1) = BACKSLASH) then do;
						/* RFC822 escapes the next character */
		     if ^in_unquoted then call make_unquoted ();
						/* must copy the original now */
		     text_used = text_used + 1;	/* skip the escape character */
		     if text_used = original_text_lth then go to UNBALANCED_QUOTES;
		     substr (unquoted_text, (unquoted_used + 1), 1) = substr (remaining_text, 1, 1);
		     unquoted_used = unquoted_used + 1;
		     if substr (remaining_text, 1, 1) = NL then do;
						/* quoted char is a newline: insure proper folding */
			text_used = text_used + 1;	/* ... go past it */
			idx = verify (remaining_text, HTSP);
						/* skip leading whitespace: it doesn't count */
			if (idx = 0) | (idx = 1) then /* no whitespace or all whitespace */
			     go to UNBALANCED_QUOTES;
			text_used = text_used + idx - 1;
		     end;
		end;

		else if substr (remaining_text, 1, 1) = QUOTE then do;
						/* a piece of quoted text in the middle */
		     if ^in_unquoted then call make_unquoted ();
		     call collect_quoted_piece ();
		end;

		else done = "1"b;			/* something which terminates the word */
	     end;

	     if text_used > original_text_lth then	/* normalize me please */
		text_used = original_text_lth;

	     call make_token (original_start, (text_used - original_start + 1));

	     if in_unquoted then do;			/* had to copy the text */
		token.token_ptr = addr (substr (unquoted_text, unquoted_start, 1));
		token.token_lth = unquoted_used - unquoted_start + 1;
	     end;
	     else do;				/* text stayed in the original */
		token.token_ptr = addcharno (original_text_ptr, (original_start - 1));
		token.token_lth = text_used - original_start + 1;
	     end;

	     token.type = WORD_TOKEN;
	     token.in_unquoted = in_unquoted;

	     if ^token.in_unquoted & (token.token_lth = 2) & ^use_date_time_breaks then
		if translate (substr (original_text, token.original_start, 2), UPPERCASE, LOWERCASE) = "AT" then do;
						/* special case "host" delimiter */
		     token.type = AT_TOKEN;
		     token.in_unquoted = "1"b;	/* flags it as ordinary text for later */
		end;

	     if ^token.in_unquoted & (token.token_lth = 3) & ^use_date_time_breaks then
		if translate (substr (original_text, token.original_start, 3), UPPERCASE, LOWERCASE) = "VIA" then do;
		     token.type = AT_TOKEN;
		     token.in_unquoted = "1"b;
		end;

	     return;



/* Internal to collect_word: place what exists so far into the unquoted area */

make_unquoted:
	     procedure ();

		in_unquoted = "1"b;

		substr (unquoted_text, (unquoted_used + 1), (text_used - original_start + 1)) =
		     substr (original_text, original_start, (text_used - original_start + 1));

		unquoted_used = unquoted_used + text_used - original_start + 1;

		return;

	     end make_unquoted;

	end collect_word;



/* Internal to lex_string: gather a piece of quoted text and add it to the current token */

collect_quoted_piece:
	procedure ();

dcl  done bit (1) aligned;

	     done = "0"b;				/* haven't reached the end of the string */

	     text_used = text_used + 1;		/* skip the leading quote */

	     do while (^done & (text_used < original_text_lth));

		if p_ipo.multics_format then
		     idx = search (remaining_text, QUOTE_NL);
		else idx = search (remaining_text, BACKSLASH_QUOTE_NL);
						/* find the end or a quoted character */

		if idx = 0 then			/* quoted string never terminates */
		     go to UNBALANCED_QUOTES;

		if idx > 1 then do;			/* some ordinary text to gather in */
		     substr (unquoted_text, (unquoted_used + 1), (idx - 1)) = substr (remaining_text, 1, (idx - 1));
		     unquoted_used = unquoted_used + idx - 1;
		     text_used = text_used + idx - 1;	/* past the good stuff */
		end;

		if substr (remaining_text, 1, 1) = NL then do;
						/* newline: must ensure proper folding */
NEWLINE_EMBEDDED_IN_QUOTED_STRING:
		     substr (unquoted_text, (unquoted_used + 1), 1) = NL;
						/* add it to the string */
		     unquoted_used = unquoted_used + 1;
		     text_used = text_used + 1;	/* past the newline */
		     if text_used = original_text_lth then go to UNBALANCED_QUOTES;
		     idx = verify (remaining_text, HTSP);
						/* leading space on next line is ignored */
		     if (idx = 0) | (idx = 1) then	/* no whitespace or all whitespace ... */
			go to UNBALANCED_QUOTES;
		     text_used = text_used + idx - 1;
		end;

		else if substr (remaining_text, 1, 1) = BACKSLASH then do;
						/* RFC822 convention for an escaped character */
		     text_used = text_used + 1;
		     if text_used = original_text_lth then go to UNBALANCED_QUOTES;
		     if substr (remaining_text, 1, 1) = NL then
						/* newline is special cased */
			go to NEWLINE_EMBEDDED_IN_QUOTED_STRING;
		     substr (unquoted_text, (unquoted_used + 1), 1) = substr (remaining_text, 1, 1);
		     unquoted_used = unquoted_used + 1;
		     text_used = text_used + 1;
		end;

		else if ^p_ipo.multics_format then do;	/* end of an RFC822 quoted string */
		     text_used = text_used + 1;	/* ... past the last quote in the string */
		     done = "1"b;
		end;

		else do;				/* normal quoted string */
		     text_used = text_used + 1;	/* past the quote */
		     if text_used = original_text_lth then done = "1"b;
						/* end of the input: quoted string terminated OK */
		     else if substr (remaining_text, 1, 1) = QUOTE then do;
						/* a literal quote is part of the string */
			substr (unquoted_text, (unquoted_used + 1), 1) = QUOTE;
			unquoted_used = unquoted_used + 1;
			text_used = text_used + 1;	/* past the second quote */
		     end;
		     else done = "1"b;		/* end of the quoted piece */
		end;
	     end;

	     if ^done then				/* ran off the end */
		go to UNBALANCED_QUOTES;

	     return;

	end collect_quoted_piece;

     end lex_string;
%page;
/* Move to the next token (including comments) in the string: do not move past the end-of-text token, however */

next_token:
     procedure ();

	if token_idx = token_list.n_tokens_used then return;
						/* at the last token */

	token_idx = token_idx + 1;			/* to the next one please */

	current_token_ptr = addr (token_list.tokens (token_idx));

	return;

     end next_token;



/* Move to the next token in the string: do not move past the end-of-text token and ignore comment tokens */

next_real_token:
     procedure ();

	if token_idx = token_list.n_tokens_used then return;
						/* at the last token */

	token_idx = token_idx + 1;			/* to the next one please */
	current_token_ptr = addr (token_list.tokens (token_idx));

	do while (current.type = COMMENT_TOKEN);	/* ignore comments */
	     token_idx = token_idx + 1;
	     current_token_ptr = addr (token_list.tokens (token_idx));
	end;

	return;

     end next_real_token;



/* Make the specified token be the current token */

make_token_current:
     procedure (p_token_idx);

dcl  p_token_idx fixed binary (21) parameter;

	token_idx = min (token_list.n_tokens_used, max (p_token_idx, lbound (token_list.tokens, 1)));
						/* make it a valid index */

	current_token_ptr = addr (token_list.tokens (token_idx));

	return;

     end make_token_current;
%page;
/* Compare two date/times for equality with appropriate fuzz factor */

date_time_equal:
     procedure (p_date_time_1, p_date_time_2) returns (bit (1) aligned);

dcl  (p_date_time_1, p_date_time_2) fixed binary (71) parameter;

	return (abs ((p_date_time_1 - p_date_time_2)) < ONE_MINUTE);

     end date_time_equal;



/* Compare two date/times to see if the first occurred before the second */

date_time_before:
     procedure (p_date_time_1, p_date_time_2) returns (bit (1) aligned);

dcl  (p_date_time_1, p_date_time_2) fixed binary (71) parameter;

	return ((p_date_time_1 < p_date_time_2) & ^date_time_equal (p_date_time_1, p_date_time_2));

     end date_time_before;
%page;
%include mlsys_parse_txt_options;
%page;
%include mlsys_data;
%page;
%include mlsys_internal_data;
%page;
%include mlsys_address_types;
%page;
%include mlsys_field_types;
%page;
%include mlsys_field_names;
%page;
%include mlsys_message;
%page;
%include mlsys_address_route;
%page;
%include mlsys_address_list;
%page;
%include sl_info;

%include sl_control_s;
%page;
%include time_names;
%page;
%include mlsys_special_chars;

     end mlsys_parse_text_;
