
/****^  HISTORY COMMENTS:
  1) change(2017-01-10,Hurst), approve(2017-01-10,MCR10027),
     audit(2017-01-10,Swenson), install(2017-01-10,MR12.6f-0013):
     Change mis-spelled "direcotry" to "directory".
                                                   END HISTORY COMMENTS */

/* ***********************************************************
   *						 *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *						 *
   *********************************************************** */

/*  DESCRIPTION:

	Utility for initializing per-system segments (actually, they are
     per-AIM authorization segments, but they appear to most everyone else
     as per-system segments).  All entries use the sub_err_ program to
     report any errors that occur.  It is recommended that callers wishing
     to catch non-fatal errors handle the sub_error_ condition.  None of
     the entries called only at system initialization time produce
     recoverable errors.

	There are three types of entries to this program: DM
     initialization and shutdown, per-system file/table handling, and DM
     directory utilities.  The entries are described in these groups below;
     see dm_per_system_.info for more help.

	NOTE:  the system_low AIM classification is special cased to use
     the "system_low" dir under the DM system dir.  This code should be
     removed when all sites wanting to use DM from system_low have
     installed the MR11 version of convert_access_class_; it is being left
     in currently for our controlled release sites.


     Initialization & Shutdown Entries:

     init: create the per-bootload directory with the name of the enabled
	per-bootload directory with a ".init" suffix, create the segment
	dm_system_data_ in the new dir, and populate it with the contents
	of dm_system_data_template_ as found via (DM ring) search rules.
	If an active DM bootload exists, try to take over the Daemon
	caretaker function.  If we takeover an existing system, either a
	running or partially shutdown one, we reset any administratively
	set shutdown information (i.e., the Daemon will use the Multics
	shutdown time as the sole source of DM shutdown scheduling after
	takeover) and make sure transactions can be started.

     enable:  make the per-bootload directory accessible, by deleting the
	".init" suffix from the name.

     cleanup:  called if there is an error between initialization and enable.
	Deletes the temporary initialization directory if it was created.

     set_system_state:  called to set the current state of a DMS if the
	process doing the setting is outside the DM ring.  Programs
	executing in the DM ring will directly set the state.

     File/Table Handling Entries:

     create:  creates a segment in the per-bootload directory, and makes
	it known.

     alloc:  allocates a block in the area located in dm_system_data_.

     initiate:  used in per-process initialization to make a segment known
	which was created by the create entry in per-system initialization.

     Directory Handling Entries:  (NOTE: these entries are in
	dm_per_system_ because of their ties with the $init and $enable
	entries.)

     get_aim_dir: gets the DM directory under the DM system directory for
	the calling process' AIM authorization.

     get_bootload_dir: get the DM bootload directory under the AIM dir for
	the current process.  The name is taken from the Multics system
	up time and can have a .init suffix if the Daemon uses it and is
	in the process of booting a system.  For normal users, the
	returned name will never have .init added.

     get_enabled_bootload_dirname: returns the entryname portion of the
	bootload directory pathname that will be used when a DMS is
	enabled, regardless of the current state of the DMS.  This is
	useful for things like part two before journal manager per-system
	initialization which must store the entryname of the bootload
	directory before the .init suffix has been removed (e.g., the
	location of the default system before journal.

     get_system_dir:  current system directory for the calling process.

     set_system_dir:  to set the system dir for the calling process.  Only
	recommended for development and testing, but is unprivileged.
*/

/*  HISTORY:

Written by J. Bongiovanni, 08/15/82.
Modified:
11/11/82 by L. A. Newcomb: to add in the recovery entrypoint and have init,
	  enable, and recovery set dm_system_data_$current_dm_state,
	  and change the name given to the bootload dirs.
12/08/82 by M. Pandolf: to tune dm_system_data_ with site generated parameters.
03/09/83 by L. A. Newcomb: create directory & files write brackets of the
	  DMS ring and read brackets of ring 5.
03/15/83 by L. A. Newcomb: fill in dm_system_data_$initializer_name.
04/22/83 by L. A. Newcomb:  changed the per-bootload dir name to work off of
            the request_id_ subr and fixed problem of needing to know the name
            of the enabled per-bootload dir name in part-2 initialization
            BEFORE it is renamed.  For less problems, we truncate the seconds
	  and microseconds off the request ID generated.
05/17/83 by L. A. Newcomb:  Removed the recovery entrypoint (dm_initializer_
            calls dm_recovery_ directly).  Started integration of
            per-AIM control file parameters and merging dm_aim_dir_util_ into
            this program for consistency.  All code parameters are now
            obsolete as sub_err_ is used, and are being purged.
06/13/83 by L. A. Newcomb:  Added creation of the privileged command message
            segment for passing abitrary commands to a running Daemon.
03/05/84 by L. A. Newcomb:  changed to use the include file dm_system_states
            (renamed from dm_statuses); also changed creation of the
            per-bootload directory and tables to have ring brackets of the DM
            ring instead of DM ring, 5, 5 as it was for debugging.
04/06/84 by Lindsey L. Spratt:  Added handling of the intermediate shutdown
            system states to the takeover procedure, TRY_DM_SYSTEM_TAKEOVER.
05/29/84 by Lindsey L. Spratt:  Changed to use version 2 of dm_system_config.
            Added use of the CHECK_VERSION proc.
08/02/84 by Lee A. Newcomb:  added the entries $set_system_state and
	  $start_shutdown.
08/13/84 by Lee A. Newcomb:  removed understanding of all DMS shutdown states
	  from the TRY_DM_SYSTEM_TAKEOVER int. proc. except final shutdown.
09/05/84 by Lee A. Newcomb:  Renamed dm_system_data_$initializer_shutdown_time
	  to be $user_shutdown_time to agree with dm_system_data_ changes.
09/27/84 by Lee A. Newcomb:  moved $start_shutdown to
            dm_dmn_system_shutdown_$schedule and fixed error of not always
            calling cu_$level_set before returning.
11/05/84 by Lindsey L. Spratt:  Changed to use dm_system_data_template_ and 
	  old_dm_system_data_, instead of just dm_system_data_.  Changed to
	  use ERROR_RETURN, and to build pathnames for error msgs using
	  pathname_.  Changed to only establish the cleanup handler once in
	  the $init entry, changed CLEAN_UP_INIT to use FINISH_INIT.
11/20/84 by Lee A. Newcomb:  moved all DM directory handling to this module,
	  obsoleting dm_aim_dir_util_, at the same time, removing the notion
	  of an AIM control segment and using convert_authorization_$encode
	  to find per-AIM dirs; changed ERROR_RETURN to be "options
	  (variable)" (kudos to CLJones), changed to always use
	  dm_misc_util_ to get to the directory entries, and made internal
	  proc variables use a prefix of the proc's initials as per project
	  standards.
12/02/84 by Lee A. Newcomb:  fixed a bug in takeover of an active DMS where we
	  only used the enabled bootload dir name, not its path, to find the
	  per-bootload tables; removed obsolete p_initializer_event_channel
	  parameter from $enable.
12/07/84 by Lee A. Newcomb:  Changed myname to the constant MYNAME as sub_err_
	  only allows 32 chars. for the module name and octal garbage was
	  resulting from the char varying; added the entryname variable
	  for use in reporting errors.
12/09/84 by Lee A. Newcomb:  Fixed to report process id's in octal (had
	  used ^a instead of ^.3b in ioa_ strings).
12/12/84 by Lindsey Spratt:  Fixed to everywhere use DM_SYSTEM_STATE_RUNNING
	  to test and indicate  a successful takeover, even when the actual
	  state is one of the intermediate shutdown states.
02/19/85 by Lee A. Newcomb:  Fixed TRY_DM_SYSTEM_TAKEOVER to allow rebooting
            if the system was partially shutdown and to reset the
            administratively set shutdown information on ANY takeover; fixed
            so we can boot a new DMS in the same Multics bootload if the
            previous bootload completely finished; changed to use ^w instead
            of ^.3b in ioa_ strings for octal output; fixed special case of
            system_low per-AIM dir to use "system_low" instead of per-system
            dir.
03/05/85 by Steve Herbst: Replaced dm_log_ with dm_misc_util_$log.
03/20/85 by R. Michael Tague: Removed the daemon message segment creation.
04/09/85 by Lee A. Newcomb:  To use convert_access_class_ and not the obsolete
            convert_authorization_.
*/

/* format: style2,ll79,ind3,^indprocbody,ifthendo,ifthen,^indnoniterdo */
/* format: ^inddcls,dclind5,idind35,linecom */
%page;
dm_per_system_$init:
   proc (p_initializer_event_channel) returns (char (4) aligned);

/* START OF DECLARATIONS */

/* Parameter */
dcl  (
     p_aim_directory		char (*),		/* per-AIM dir for current process */
     p_block_ptr			ptr,		/* Pointer to allocated block */
     p_bootload_dir			char (*),		/* Bootload directory name */
     p_initializer_event_channel	fixed bin (71),	/* event channel to talk to Daemon on */
     p_n_words			fixed bin (18),	/* Size of block to allocate */
     p_new_system_state		char (4) aligned,	/* for $set_system_state */
     p_reference_name		char (*),		/* Reference name */
     p_segment_name			char (*),		/* Name of segment to create */
     p_seg_ptr			ptr,		/* Pointer to created segment */
     p_system_directory		char (*)		/* Current system dir for DMS */
     )				parameter;

/* Automatic */

dcl  (
     aim_dir			char (168),	/* current DM AIM dir. for this process */
     aim_dir_name			char (32),	/* current AIM dir ename */
     areap			ptr,		/* $alloc, ptr to area in dm_system_data_ */
     block_ptr			ptr,		/* $alloc, ptr to allocation in dm_system_data_ area */
     bit_count			fixed bin (24),	/* $init, for setting bit count on dm_system_data_ */
     bootload_dir_name		char (32),
     code				fixed bin (35),	/* status/error code returned from some calls */
     current_bootload_directory	char (168),
     dm_system_copyp		ptr,		/* $init, loc. of per-bootload copy of dm_system_data_ */
     dm_system_data_template_ptr	ptr,		/* loc. of installed dm_system_data_ to copy */
     enabled_bootload_dir_name	char (32),
     entrypoint_name		char (32) varying,	/* globally used by ERROR_RETURN */
     initialization_bootload_dir_name	char (32),
     initialization_bootload_directory			/* $init, curr. name of per-bootload dir. */
				char (168),
     level			fixed bin,	/* saved validation level */
     1 local_area_info		aligned like area_info,
     n_words			fixed bin (18),	/* $init, for making copy of installed dm_system_data_ */
						/* $alloc, block size to allocate */
     ring_brackets			dim (3) fixed bin (3),
						/* $init & $create, so seg. creation works in testing */
     seg_ptr			ptr,
     segname			char (32),
     system_dir			char (168),
     temp_dir			char (168),
     temp_dir_name			char (32)
     )				automatic;

/* Based */
dcl  based_area			area based (areap),
     block			dim (n_words) bit (36) aligned
				based (block_ptr),
     seg_array			dim (n_words) bit (36) aligned based;

/* Builtin */
dcl  (addr, bin, bit, clock, divide, null, ptr, substr, unspec)
				builtin;

/* Condition */
dcl  (area, cleanup, sub_error_)	condition;

/* Constant */
dcl  (
     ACL_ID			char (32) unaligned init ("*.*.*"),
     ENABLED_BOOTLOAD_DIR_NAME	bit (1) aligned init ("0"b),
						/* for GET_BOOTLOAD_DIR_NAME int proc */
     INITIALIZATION_BOOTLOAD_DIR_NAME	bit (1) aligned init ("1"b),
						/* for GET_BOOTLOAD_DIR_NAME int proc */
     IOA_GENERAL_RS_NO_NEW_LINE	bit (1) aligned init ("0"b),
     IOA_GENERAL_RS_DONT_PAD		bit (1) aligned init ("1"b),
     UNLOCK_CONFIG			bit (1) aligned init ("1"b),
						/* for FINISH_INIT int. proc.*/
     DONT_UNLOCK_CONFIG		bit (1) aligned init ("0"b),
						/* for FINISH_INIT int. proc.*/
     MYNAME			char (32) init ("dm_per_system_"),
     OLD_SYS_SEG			char (19) init ("old_dm_system_data_"),
     SYS_SEG			char (15) init ("dm_system_data_"),
     SYS_SEG_TEMPLATE		char (24)
				init ("dm_system_data_template_")
     )				internal static options (constant);

/* Entry */

dcl  (
     convert_access_class_$encode	entry (bit (72) aligned, char (*)),
     cu_$arg_list_ptr		entry (ptr),
     cu_$level_get			entry (fixed bin),
     cu_$level_set			entry (fixed bin),
     define_area_			entry (ptr, fixed bin (35)),
     delete_$path			entry (char (*), char (*), bit (6),
				char (*), fixed bin (35)),
     delete_$ptr			entry (ptr, bit (6), char (*),
				fixed bin (35)),
     dm_check_configuration_		entry (ptr),
     dm_find_configuration_		entry () returns (ptr),
     dm_find_configuration_$terminate	entry (ptr),
     dm_load_configuration_		entry (ptr),
     dm_lock_configuration_		entry (ptr),
     dm_lock_configuration_$unlock	entry (ptr),
     dm_misc_util_$log		entry () options (variable),
     dm_misc_util_$get_aim_dir	entry (char (*)),
     dm_misc_util_$get_bootload_dir	entry (char (*)),
     dm_misc_util_$get_enabled_bootload_dirname
				entry () returns (char (32)),
     dm_misc_util_$get_system_dir	entry (char (*)),
     dm_misc_util_$is_process_using_dm	entry () returns (bit (1) aligned),
     expand_pathname_		entry (char (*), char (*), char (*),
				fixed bin (35)),
     get_authorization_		entry () returns (bit (72) aligned),
     get_group_id_$tag_star		entry () returns (char (32)),
     get_process_id_		entry () returns (bit (36)),
     get_ring_			entry () returns (fixed bin (3)),
     hcs_$append_branchx		entry (char (*), char (*),
				fixed bin (5), (3) fixed bin (3),
				char (*), fixed bin (1), fixed bin (1),
				fixed bin (24), fixed bin (35)),
     hcs_$chname_file		entry (char (*), char (*), char (*),
				char (*), fixed bin (35)),
     hcs_$initiate			entry (char (*), char (*), char (*),
				fixed bin (1), fixed bin (2), ptr,
				fixed bin (35)),
     hcs_$set_bc_seg		entry (ptr, fixed bin (24),
				fixed bin (35)),
     hcs_$status_minf		entry (char (*), char (*),
				fixed bin (1), fixed bin (2),
				fixed bin (24), fixed bin (35)),
     hcs_$status_mins		entry (ptr, fixed bin (2),
				fixed bin (24), fixed bin (35)),
     hcs_$validate_processid		entry (bit (36) aligned,
				fixed bin (35)),
     ioa_$general_rs		entry (ptr, fixed bin, fixed bin,
				char (*), fixed bin (21),
				bit (1) aligned, bit (1) aligned),
     pathname_			entry (char (*), char (*))
				returns (char (168)),
     request_id_			entry (fixed bin (71))
				returns (char (19)),
     sub_err_			entry options (variable),
     system_info_$timeup		entry (fixed bin (71)),
     term_$seg_ptr			entry (ptr, fixed bin (35)),
     term_$single_refname		entry (char (*), fixed bin (35)),
     transaction_manager_$begins_on	entry ()
     )				external;

/* External */
dcl  (
     (
     dm_error_$area_overflow,
     dm_error_$per_system_not_init
     )				fixed bin (35),
     dm_system_data_template_$,
     dm_system_data_$,
     dm_system_data_$area_rel		bit (18) aligned,
     dm_system_data_$command_ms_name	char (32),
     dm_system_data_$current_dm_state	char (4) aligned,
     dm_system_data_$initialized	bit (1) aligned,
     dm_system_data_$initializer_name	char (32),
     dm_system_data_$initializer_processid
				bit (36) aligned,
     (
     dm_system_data_$bootload_time,
     dm_system_data_$initializer_event_chn,
     dm_system_data_$initialization_time,
     dm_system_data_$saved_begin_shutdown_time,
     dm_system_data_$saved_daemon_logout_time,
     dm_system_data_$saved_user_bump_time,
     dm_system_data_$saved_user_shutdown_time,
     dm_system_data_$saved_user_warning_time
     )				fixed bin (71),
     dm_system_data_$saved_shutdown_reason
				char (64) aligned,
     (
     error_table_$namedup,
     error_table_$segknown,
     error_table_$unimplemented_version
     )				fixed bin (35),
     old_dm_system_data_$initializer_processid
				bit (36) aligned,
     old_dm_system_data_$initializer_name
				char (32),
     old_dm_system_data_$current_dm_state
				char (4) aligned,
     sys_info$max_seg_size		fixed bin (19)
     )				external static;

/* Static */
dcl  (
     dms_initializer_process		bit (1) aligned init (""b),
						/* are we doing per-system initialization */
     multics_bootload_request_id_str	char (17) unaligned init (""),
						/* for per-bootload dir. naming */
     system_dir_in_static		char (168)
				init (">site>Data_Management")
     )				internal static;

/* END OF DECLARATIONS */
%page;
/*  dm_per_system_$init: proc (p_initializer_event_channel) returns (char (4) aligned);

 - Find the per-AIM directory
 - Make sure the per-bootload directory does not already exist (try to adopt
     if one does)
 - Create a directory subordinate to it with a unique name, so that
	it cannot be accessed (yet) by Data Management users.
 - Copy dm_system_data_template_ to this directory with the name
	dm_system_data_ and make it known with ref. name dm_system_data_.
 - Initialize dm_system_data_ values.
*/

   entrypoint_name = "init";

   dm_system_data_template_ptr = null ();		/* don't know where installed dm_system_data_template_ is */
   dm_system_copyp = null ();				/* haven't made dm_system_data_ copy yet */
   dm_system_config_ptr = null ();			/* have not found per-AIM control file */

   dms_initializer_process = ""b;			/* assume the system is running for the moment */

   call cu_$level_get (level);
   on cleanup call CLEAN_UP_INIT ();
   call cu_$level_set (get_ring_ ());

   call dm_misc_util_$get_aim_dir (aim_dir);

/* get ptr to the per-AIM configuration file and lock it.  This is our */
/* main defense against multiple processes attempting to bootload a DMS */
/* at the same AIM level in the same Multics bootload. */

   dm_system_config_ptr = dm_find_configuration_ ();
   call CHECK_VERSION (dm_system_config.version, DM_CONFIG_VERSION_2,
        "dm_system_config");

   call dm_lock_configuration_ (dm_system_config_ptr);
   call dm_check_configuration_ (dm_system_config_ptr);

/* The configuration file is now locked.  See if a current bootload exists */

   enabled_bootload_dir_name = dm_misc_util_$get_enabled_bootload_dirname ();
   call hcs_$status_minf (aim_dir, enabled_bootload_dir_name, 0, (0), (0),
        code);
   if code = 0 then do;				/* if exists, try to adopt */
						/* takeover will fail with sub_err_ call if system has */
						/* a caretaker Daemon already */
      if TRY_DM_SYSTEM_TAKEOVER (p_initializer_event_channel,
	 pathname_ (aim_dir, enabled_bootload_dir_name))
	 = DM_SYSTEM_STATE_RUNNING then do;		/* successful takeover */
         call FINISH_INIT (UNLOCK_CONFIG);
         return (DM_SYSTEM_STATE_RUNNING);		/* Must be the running state if we took over */
      end;
   end;

   dms_initializer_process = "1"b;			/* no takeover to do, we will do initialization */
   ring_brackets (1), ring_brackets (2), ring_brackets (3) = get_ring_ ();
						/* DMS ring */

%page;
/* Create a temporary initialization bootload directory for the */
/* DMS tables in the per-AIM directory */

   initialization_bootload_dir_name =
        GET_BOOTLOAD_DIR_NAME (INITIALIZATION_BOOTLOAD_DIR_NAME);
   call hcs_$append_branchx (aim_dir, initialization_bootload_dir_name,
        SMA_ACCESS_BIN, ring_brackets, ACL_ID, 1, 0, 0, code);
   if code = error_table_$namedup then do;		/* delete old, dead one and start fresh */
      call delete_$path (aim_dir, initialization_bootload_dir_name,
	 "101000"b /* force,dir */, MYNAME, code);
      if code ^= 0 then
         call ERROR_RETURN (code,
	    "Could not delete old initialization bootload directory ^a.",
	    pathname_ (aim_dir, initialization_bootload_dir_name));
						/* start fresh */
      call hcs_$append_branchx (aim_dir, initialization_bootload_dir_name,
	 SMA_ACCESS_BIN, ring_brackets, ACL_ID, 1, 0, 0, code);
   end;
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Could not create initialization bootload directory ^a.",
	 pathname_ (aim_dir, initialization_bootload_dir_name));

   call dm_misc_util_$get_bootload_dir (initialization_bootload_directory);

/* Now create a segment to be dm_system_data_, initiate it with the	*/
/* required reference name, and copy the template system data segment	*/
/* to the newly created one.  Note we find the template via search	*/
/* rules in the DM ring.					*/

   call hcs_$append_branchx (initialization_bootload_directory, SYS_SEG,
        RW_ACCESS_BIN, ring_brackets, ACL_ID, 0, 0, 0, code);
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Cannot create system data segment (^a) for this bootload in ^a.",
	 SYS_SEG, initialization_bootload_directory);

   call hcs_$initiate (initialization_bootload_directory, SYS_SEG, SYS_SEG, 0,
        0, dm_system_copyp, code);
   if code ^= 0 & code ^= error_table_$segknown then
      call ERROR_RETURN (code,
	 "Cannot initiate system data segment ^a for this bootload, with reference name ^a.",
	 pathname_ (initialization_bootload_directory, SYS_SEG), SYS_SEG);

   dm_system_data_template_ptr = addr (dm_system_data_template_$);
   call hcs_$status_mins (dm_system_data_template_ptr, (0), bit_count, code);
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Cannot find out bit count of system data segment template ^a.",
	 SYS_SEG_TEMPLATE);

   n_words = divide (bit_count + 35, 36, 17);		/* copy installed to bootload version */
   unspec (dm_system_copyp -> seg_array) =
        unspec (dm_system_data_template_ptr -> seg_array);


   call hcs_$set_bc_seg (dm_system_copyp, bit_count, code);
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Cannot set bit count on bootload version of system data segment: ^a.",
	 pathname_ (initialization_bootload_directory, SYS_SEG));

   dm_system_data_$current_dm_state = DM_SYSTEM_STATE_INITIALIZING;
   dm_system_data_$initialization_time = clock ();
   call system_info_$timeup (dm_system_data_$bootload_time);
   dm_system_data_$initializer_processid = get_process_id_ ();
   dm_system_data_$initializer_name = get_group_id_$tag_star ();
   dm_system_data_$initializer_event_chn = p_initializer_event_channel;
   dm_system_data_$area_rel =
        bit (bin (divide (n_words + 1, 2, 17) * 2, 18), 18);

   unspec (local_area_info) = ""b;
   local_area_info.version = area_info_version_1;
   local_area_info.control.zero_on_alloc = "1"b;
   local_area_info.owner = SYS_SEG;
   local_area_info.size =
        sys_info$max_seg_size - bin (dm_system_data_$area_rel, 18);
   local_area_info.areap = ptr (dm_system_copyp, dm_system_data_$area_rel);

   call define_area_ (addr (local_area_info), code);
   if code ^= 0 then
      call ERROR_RETURN (code, "Cannot create area in system data segment ^a.",
	 pathname_ (initialization_bootload_directory, SYS_SEG));

   call dm_load_configuration_ (dm_system_config_ptr);	/* tune dm_system_data_ */

   call FINISH_INIT (DONT_UNLOCK_CONFIG);

   return (dm_system_data_$current_dm_state);

/* end dm_per_system_$init; */
%page;
dm_per_system_$enable:
   entry ();

   entrypoint_name = "enable";			/* for error reporting */

/* Now we let the users at the system, but finish some housecleaning first. */
/* We must set the indicators in the system data segment to show that */
/* initialization has finished, rename the initialization bootload directory */
/* so users can find it, and unlock the per-AIM control file */

   if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
        | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
        then
      call ERROR_RETURN (dm_error_$per_system_not_init,
	 "Current Data Management state = ^a.",
	 (dm_system_data_$current_dm_state));

   dm_system_data_$initialized = "1"b;
   dm_system_data_$current_dm_state = DM_SYSTEM_STATE_RUNNING;

   call dm_misc_util_$get_aim_dir (aim_dir);

/* change bootload dir name to findable one */
/* if this call works, users may use the system */

   enabled_bootload_dir_name = dm_misc_util_$get_enabled_bootload_dirname ();
   initialization_bootload_dir_name =
        GET_BOOTLOAD_DIR_NAME (INITIALIZATION_BOOTLOAD_DIR_NAME);

   call cu_$level_get (level);
   on cleanup call RESET_VALIDATION_LEVEL ();
   call cu_$level_set (get_ring_ ());

   call hcs_$chname_file (aim_dir, initialization_bootload_dir_name,
        initialization_bootload_dir_name, enabled_bootload_dir_name, code);
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Cannot rename initialization bootload directory to an enabled name: ^a to ^a.",
	 pathname_ (aim_dir, initialization_bootload_dir_name),
	 enabled_bootload_dir_name);

   dm_system_config_ptr = dm_find_configuration_ ();	/* find control file for unlocking and termination */
   call dm_lock_configuration_$unlock (dm_system_config_ptr);
						/* free up the control file */
   call dm_find_configuration_$terminate (dm_system_config_ptr);
						/* cleanup address space */

   dms_initializer_process = "0"b;			/* at least we better be */

   call RESET_VALIDATION_LEVEL ();

   call RETURN ();

/* end dm_per_system_$enable; */
%page;
dm_per_system_$create:
   entry (p_segment_name, p_seg_ptr);

   entrypoint_name = "create";

/*  Create a segment in the per-bootload directory, make it known, and */
/*  return a pointer to it. */

   segname = p_segment_name;
   p_seg_ptr = null ();

   if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
        | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
        then
      call ERROR_RETURN (dm_error_$per_system_not_init,
	 "Current Data Management state = ^a.",
	 (dm_system_data_$current_dm_state));


   call dm_misc_util_$get_bootload_dir (current_bootload_directory);
						/* external entry in this program */

   ring_brackets (1), ring_brackets (2), ring_brackets (3) = get_ring_ ();
						/* DMS ring */
   call cu_$level_get (level);
   on cleanup call RESET_VALIDATION_LEVEL ();
   call cu_$level_set (get_ring_ ());

   call hcs_$append_branchx (current_bootload_directory, segname,
        RW_ACCESS_BIN, ring_brackets, ACL_ID, 0, 0, 0, code);
   if code ^= 0 then
      call ERROR_RETURN (code, "Cannot create system segment ^a.",
	 pathname_ (current_bootload_directory, segname));

   call hcs_$initiate (current_bootload_directory, segname, "", 0, 0, seg_ptr,
        code);
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Cannot initiate newly created system segment ^a.",
	 pathname_ (current_bootload_directory, segname));

   call RESET_VALIDATION_LEVEL ();
   p_seg_ptr = seg_ptr;

   call RETURN ();

/* end dm_per_system_$create; */
%page;
dm_per_system_$alloc:
   entry (p_n_words, p_block_ptr);

   entrypoint_name = "alloc";

/*  allocate a block in the area in the system data segment */

   p_block_ptr = null ();
   n_words = p_n_words;

   if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
        | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
        then
      call ERROR_RETURN (dm_error_$per_system_not_init,
	 "Current Data Management state = ^a.",
	 (dm_system_data_$current_dm_state));

   areap = ptr (addr (dm_system_data_$), dm_system_data_$area_rel);

   on area
      call ERROR_RETURN (dm_error_$area_overflow,
	 "Cannot do more allocation in system data area, # of words asked for = ^d.",
	 p_n_words);

   allocate block in (based_area) set (block_ptr);

   p_block_ptr = block_ptr;

   call RETURN ();

/* end dm_per_system_$alloc; */
%page;
dm_per_system_$cleanup:
   entry ();

   entrypoint_name = "cleanup";

/*  undo what we've done so far, only for dm_initializer_ to call */

   if ^dms_initializer_process then			/* we haven't anything to undo */
      call RETURN ();

   if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN then
      call ERROR_RETURN (dm_error_$per_system_not_init,
	 "(Current) Data Management state = ^a.",
	 (dm_system_data_$current_dm_state));

   on sub_error_					/* ignore errors in next two calls */
      go to CLEANUP_PROC_DONE;
   call dm_misc_util_$get_aim_dir (aim_dir);

   dm_system_config_ptr = dm_find_configuration_ ();	/* so we can unlock it if locked */

   on sub_error_					/* don't miss the terminate of config file */
      go to CLEANUP_PROC_TERM_CONFIG_FILE;
   call dm_lock_configuration_$unlock (dm_system_config_ptr);

CLEANUP_PROC_TERM_CONFIG_FILE:
   on sub_error_					/* now back to original handling */
      go to CLEANUP_PROC_DONE;
   call dm_find_configuration_$terminate (dm_system_config_ptr);

   bootload_dir_name = GET_BOOTLOAD_DIR_NAME (dms_initializer_process);
   call delete_$path (aim_dir, bootload_dir_name, "001000"b /* dir */, "",
        code);

   revert sub_error_;

CLEANUP_PROC_DONE:
   call RETURN ();

/* end dm_per_system_$cleanup; */
%page;
dm_per_system_$initiate:
   entry (p_segment_name, p_reference_name, p_seg_ptr);

   entrypoint_name = "initiate";

/*  makes a segment in the per-bootload directory known and returns a */
/*  pointer to it. */

   if dm_system_data_$current_dm_state = DM_SYSTEM_STATE_UNDEFINED
        | dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
        then
      call ERROR_RETURN (dm_error_$per_system_not_init,
	 "Current Data Management state = ^a.",
	 (dm_system_data_$current_dm_state));

   p_seg_ptr = null ();

   call dm_misc_util_$get_bootload_dir (current_bootload_directory);

   call cu_$level_get (level);
   on cleanup call RESET_VALIDATION_LEVEL ();
   call cu_$level_set (get_ring_ ());

   call hcs_$initiate (current_bootload_directory, p_segment_name,
        p_reference_name, 0, 0, p_seg_ptr, code);
   if p_seg_ptr = null () then
      call ERROR_RETURN (code,
	 "Cannot initiate system segment ^a with ref name of ^a.",
	 pathname_ (current_bootload_directory, p_segment_name),
	 p_reference_name);

   call RESET_VALIDATION_LEVEL ();

   call RETURN ();

/* end dm_per_system_$initiate; */
%page;
dm_per_system_$get_system_dir:
   entry (p_system_directory);

   entrypoint_name = "get_system_dir";

/*  get_system_dir - entry to get the system dir for the current process' */
/*  data management system.  We must verify the system dir exists before  */
/*  returning, however.					    */

   call expand_pathname_ (system_dir_in_static, temp_dir, temp_dir_name, code);
   if code ^= 0 then
      call ERROR_RETURN (code, "Unable to expand system directory path ^a.",
	 system_dir_in_static);

   call hcs_$status_minf (temp_dir, temp_dir_name, 0, 0, 0, code);
   if code ^= 0 then
      call ERROR_RETURN (code, "Unable to find system directory ^a.",
	 system_dir_in_static);

   p_system_directory = system_dir_in_static;

   call RETURN ();

/* end dm_per_system_$get_system_dir; */
%skip (4);
dm_per_system_$set_system_dir:
   entry (p_system_directory);

   entrypoint_name = "set_system_dir";

/* set the internal static variable which holds the process' current system */
/* directory.  This is only recommended for developers and testers of DM.   */

   if dm_misc_util_$is_process_using_dm () then
      call ERROR_RETURN (0,
	 "Cannot set DM system directory to ^a, you must do DM user shutdown first.",
	 p_system_directory);

   system_dir = p_system_directory;
   call expand_pathname_ (system_dir, temp_dir, temp_dir_name, code);
   if code ^= 0 then
      call ERROR_RETURN (code,
	 "Unable to set DM system directory to ^a, expand_pathname_ failed on it.",
	 system_dir);

   call hcs_$status_minf (temp_dir, temp_dir_name, 0, 0, 0, code);
   if code = 0 then					/* OK, set it */
      system_dir_in_static = pathname_ (temp_dir, temp_dir_name);
   else call ERROR_RETURN (code,
	   "Cannot set DM system directory to the non-existent directory ^a.",
	   system_dir);

   call RETURN ();

/* end dm_per_system_$set_system_dir; */
%page;
dm_per_system_$get_aim_dir:
   entry (p_aim_directory);

   entrypoint_name = "get_aim_dir";

/*  Entry to return the pathname of the per-AIM directory for this process */
/*  in the current DM system directory.   IF THERE IS NO AIM DIRECTORY FOR */
/*  THIS PROCESS' AUTHORIZATION, WE USE ERROR_RETURN.  We could instead    */
/*  let no error occur and let the firstref trap signal dm_not_available_, */
/*  but there are modules calling this without setting off the trap; and   */
/*  even if they did, it would imply there did exist an AIM dir giving     */
/*  hope a DMS would be booted when it cannot be.  The only exception is   */
/*  system_low since its AIM dir IS the system dir.		     */

   call convert_access_class_$encode (get_authorization_ (), aim_dir_name);
   call dm_misc_util_$get_system_dir (system_dir);
   if aim_dir_name = "" then
SYSTEM_LOW_PROCESS:
      p_aim_directory = pathname_ (system_dir, "system_low");
						/* it better exist */
   else
NON_SYSTEM_LOW_PROCESS:
      do;						/* verify AIM dir exists */
      call hcs_$status_minf (system_dir, aim_dir_name, 0, 0, 0, code);
      if code ^= 0 then
         call ERROR_RETURN (code,
	    "DM is not usable from the current AIM authorization, trying to find the directory ^a.",
	    pathname_ (system_dir, aim_dir_name));
      p_aim_directory = pathname_ (system_dir, aim_dir_name);
   end NON_SYSTEM_LOW_PROCESS;

   call RETURN ();

/* end dm_per_system_$get_aim_dir; */
%skip (4);
dm_per_system_$get_bootload_dir:
   entry (p_bootload_dir);

   entrypoint_name = "get_bootload_dir";

/*  Entry to return the name of the per-bootload directory for this      */
/*  bootload and AIM authorization.  It takes into account that the      */
/*  caller may be the Daemon process booting a new DMS.  We do not	   */
/*  report errors from this entry.				   */

   call dm_misc_util_$get_aim_dir (aim_dir);

   p_bootload_dir =
        pathname_ (aim_dir, GET_BOOTLOAD_DIR_NAME (dms_initializer_process));

   call RETURN ();

/* end dm_per_system_$get_bootload_dir; */
%skip (4);
dm_per_system_$get_enabled_bootload_dirname:
   entry () returns (char (32));

   entrypoint_name = "get_enabled_bootload_dirname";

/* entry to return entryname of enabled bootload directory regardless of */
/* the current DMS state (i.e., the .init suffix will never be returned. */
/* We do not report any errors from this entry.			   */

   return (GET_BOOTLOAD_DIR_NAME (ENABLED_BOOTLOAD_DIR_NAME));

/* end dm_per_system_$get_enabled_bootload_dirname; */
%skip (4);
dm_per_system_$set_system_state:
   entry (p_new_system_state);

/* We currently trust the new state passed to us.  If desired, error	*/
/* detection may be added at a later date (e.g., incorrect sequence	*/
/* of change, invalid state); however, more definition of the states	*/
/* will probably be necessary before doing so.			*/

/* set the state and return */
   dm_system_data_$current_dm_state = p_new_system_state;

   call RETURN ();

/* end dm_per_system_$set_system_state */
%page;
TRY_DM_SYSTEM_TAKEOVER:
   proc (tdst_p_new_event_channel, tdst_p_old_bootload_directory)
        returns (char (4) aligned);

/* This internal procedure tries to adopt a running DMS.  If it	*/
/* fails, the sub_err_ routine will be called to report the failure.	*/
/* If the DMS for the current Multics bootload has shutdown, no	*/
/* takeover is done and the shutdown status is returned so the Daemon	*/
/* may bring up another DMS.  Also, if the DMS should have shutdown,	*/
/* but has not and the time to bump users and logout the Daemon has	*/
/* past, we: reset the shutdown information, allow new transactions,	*/
/* and set the DMS state to running.  This code used to be in the	*/
/* Daemon overseer, but has been moved here to ease maintenance.	*/

dcl  (
     tdst_p_new_event_channel		fixed bin (71) aligned,
     tdst_p_old_bootload_directory	char (*)
     )				parameter;

dcl  tdst_old_dm_system_data_ptr	ptr init (null) automatic;

   on cleanup call TDST_CLEANUP ();

   call hcs_$initiate (tdst_p_old_bootload_directory, SYS_SEG, OLD_SYS_SEG, 0,
        0, tdst_old_dm_system_data_ptr, code);
   if code ^= 0 | tdst_old_dm_system_data_ptr = null () then
      call ERROR_RETURN (code,
	 "Unable to initiate the system data segment ^a with the reference name ^a, in the old DM system directory ^a.",
	 SYS_SEG, OLD_SYS_SEG, tdst_p_old_bootload_directory);

   call hcs_$validate_processid (old_dm_system_data_$initializer_processid,
        code);
   if code = 0 then					/* we have a current caretaker */
      call ERROR_RETURN (0,
	 "Current DM system ^a already has caretaker Daemon ^a (pid ^w).",
	 tdst_p_old_bootload_directory, old_dm_system_data_$initializer_name,
	 old_dm_system_data_$initializer_processid);


   if old_dm_system_data_$current_dm_state ^= DM_SYSTEM_STATE_RUNNING
        & old_dm_system_data_$current_dm_state
        ^= DM_SYSTEM_STATE_SHUTDOWN_BEGUN
        & old_dm_system_data_$current_dm_state
        ^= DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS then
NO_DMS_TO_TAKEOVER:
      do;
      if old_dm_system_data_$current_dm_state = DM_SYSTEM_STATE_NORMAL_SHUTDOWN
	 then
MAY_BOOT_AFTER_NORMAL_SHUT:				/* recovery will take care of boot dir */
         return (DM_SYSTEM_STATE_NORMAL_SHUTDOWN);

      else					/* should not happen, arbitrary damage */
	 call ERROR_RETURN (dm_error_$per_system_not_init,/* need human intervention */
	      "Unable to takeover non-running DMS, state: ^a, bootload dir: ^a.",
	      (old_dm_system_data_$current_dm_state),
	      tdst_p_old_bootload_directory);
   end NO_DMS_TO_TAKEOVER;

   if dm_system_config.adopt = DM_DO_NOT_ADOPT_OLD_BOOTLOAD then
      call ERROR_RETURN (0,
	 "Configuration file disallows takeover of running DM system ^a.",
	 tdst_p_old_bootload_directory);

/* If we get to this point, we must try to take over the current running DM */
/* system's per-bootload directory */

   call hcs_$initiate (tdst_p_old_bootload_directory, SYS_SEG, SYS_SEG, 0, 0,
        null (), code);
   if code ^= 0 & code ^= error_table_$segknown then
      call ERROR_RETURN (code,
	 "Unable to initiate the system data segment ^a with the reference name ^a, in the old DM system directory ^a.  Attempted takeover of running system failed.",
	 SYS_SEG, SYS_SEG, tdst_p_old_bootload_directory);

   call dm_misc_util_$log (LOG_SV, "");			/* dummy to get a blank line */
   call dm_misc_util_$log (LOG_SV,
        "STARTING TAKEOVER of DM system ^a by process ^a (pid = ^w), from ^a (pid = ^w).",
        tdst_p_old_bootload_directory, get_group_id_$tag_star (),
        get_process_id_ (), dm_system_data_$initializer_name,
        dm_system_data_$initializer_processid);

RESET_SHUTDOWN_INFO:
   do;

/* Any takeover resets the admin and active shutdown data, makes sure	*/
/* transactions may be started, and sets the system state to running.	*/
/* The login ring module is responsible for always scheduling a DMS	*/
/* shutdown based on the Multics shutdown time.			*/

      dm_system_data_$current_dm_state = DM_SYSTEM_STATE_RUNNING;
      if dm_system_data_$saved_begin_shutdown_time ^= 0 then do;
         dm_system_data_$saved_user_warning_time,
	    dm_system_data_$saved_begin_shutdown_time,
	    dm_system_data_$saved_user_shutdown_time,
	    dm_system_data_$saved_user_bump_time,
	    dm_system_data_$saved_daemon_logout_time = 0; /* calc from Mutlics shut time */
         dm_system_data_$saved_shutdown_reason =
	    "NO REASON FOR SHUTDOWN GIVEN";		/* same as in dm_system_data_template_ */
         call dm_misc_util_$log (LOG_SV,
	    "Previous admin shutdown infomration reset during takeover of DM."
	    );
      end;

      call transaction_manager_$begins_on ();		/* make sure users can get in */
   end RESET_SHUTDOWN_INFO;

   dm_system_data_$initializer_event_chn = tdst_p_new_event_channel;
   dm_system_data_$initializer_name = get_group_id_$tag_star ();
   dm_system_data_$initializer_processid = get_process_id_ ();
						/* we now "own" it */

   call dm_misc_util_$log (LOG_SV, "Finished takeover of DM system.");

   call term_$single_refname ((OLD_SYS_SEG), (0));

   return (DM_SYSTEM_STATE_RUNNING);			/* This indicates successful takeover. Actual state may be one of the shutdown states. */

TDST_CLEANUP:
   proc ();

   if tdst_old_dm_system_data_ptr ^= null () then
      call term_$seg_ptr (tdst_old_dm_system_data_ptr, (0));

   end TDST_CLEANUP;

   end TRY_DM_SYSTEM_TAKEOVER;
%page;
GET_BOOTLOAD_DIR_NAME:
   proc (gbdn_p_is_process_initializing_dms) returns (char (32));

/*  Internal Procedure to generate the name of the per-bootload directory  */
/*  It accepts one input argument to decide if it should return the name of */
/*  the directory before or after the DMS system has been enabled */
/*  The name is based on the Multics bootload time after running it through */
/*  the request_id_ subr. and truncating the time to the minute.  This */
/*  allows the use of the construct "cwd {aim_dir}>[substr [request_id */
/*  [system date_time_last_up]] 1 10]" from command level and helps prevent */
/*  multiple DMS's running at the same AIM level. */

dcl  gbdn_p_is_process_initializing_dms bit (1) aligned parameter;

dcl  gbdn_time_of_multics_bootload	fixed bin (71) automatic;

/* fill in the internal static that will give the base of all naming of */
/* any per-bootload directory. */
   if multics_bootload_request_id_str = "" then do;
      call system_info_$timeup (gbdn_time_of_multics_bootload);
      multics_bootload_request_id_str =
	 "dm_dir."
	 || substr (request_id_ (gbdn_time_of_multics_bootload), 1, 10);
   end;

   if gbdn_p_is_process_initializing_dms then
      return (multics_bootload_request_id_str || ".init");
   else return (multics_bootload_request_id_str);

   end GET_BOOTLOAD_DIR_NAME;
%page;
RESET_VALIDATION_LEVEL:
   proc ();

   call cu_$level_set (level);

   return;

   end RESET_VALIDATION_LEVEL;
%skip (4);
CLEAN_UP_INIT:
   proc ();

/*  Internal Procedure to clean up for $init entry only.

 - delete dm_system_data_ if created
 - delete the per-bootload directory if created
*/

dcl  cui_initialization_bootload_dir	char (168) automatic;

   if dm_system_copyp ^= null () then do;
      call delete_$ptr (dm_system_copyp, "000100"b, "", 0);
      dm_system_copyp = null ();
   end;

   if dms_initializer_process then do;			/* must delete the init dir if created */
      cui_initialization_bootload_dir =
	 GET_BOOTLOAD_DIR_NAME (INITIALIZATION_BOOTLOAD_DIR_NAME);
      call delete_$path (aim_dir, cui_initialization_bootload_dir, "001000"b,
	 "", 0);
      dms_initializer_process = "0"b;
   end;

   call FINISH_INIT (UNLOCK_CONFIG);

   return;

   end CLEAN_UP_INIT;
%page;
FINISH_INIT:
   proc (fi_p_config_lock_action);
dcl  fi_p_config_lock_action		bit (1) aligned parameter;

   if fi_p_config_lock_action = UNLOCK_CONFIG then
      if dm_system_config_ptr ^= null () then do;
         on sub_error_ go to FI_TERM_CONFIG;
         call dm_lock_configuration_$unlock (dm_system_config_ptr);
FI_TERM_CONFIG:
         on sub_error_ go to FI_CANT_TERM_CONFIG;
         call dm_find_configuration_$terminate (dm_system_config_ptr);
FI_CANT_TERM_CONFIG:
         revert sub_error_;
      end;

   call RESET_VALIDATION_LEVEL ();

   return;

   end FINISH_INIT;
%skip (4);
RETURN:
   proc ();					/* common return procedure for ease of debugging by needing only one break */

   go to MAIN_RETURN;

   end RETURN;
%skip (4);
MAIN_RETURN:
   return;
%page;
ERROR_RETURN:
   proc options (variable);

dcl  (
     er_arg_list_ptr		ptr,
     er_code			fixed bin (35),
     er_message			char (1024),
     er_message_length		fixed bin (21)
     )				automatic;

dcl  (
     er_fixed_bin_35_value		fixed bin (35),
     er_message_overlay		char (er_message_length)
     )				based;

   call cu_$arg_list_ptr (er_arg_list_ptr);
   er_code = er_arg_list_ptr -> arg_list.arg_ptrs (1) -> er_fixed_bin_35_value;

   call ioa_$general_rs (er_arg_list_ptr, 2, 3, er_message, er_message_length,
        IOA_GENERAL_RS_DONT_PAD, IOA_GENERAL_RS_NO_NEW_LINE);
   call sub_err_ (er_code, MYNAME, ACTION_CANT_RESTART, null (), 0,
        "By entry ^a:  ^a", entrypoint_name,
        addr (er_message) -> er_message_overlay);

   end ERROR_RETURN;
%skip (4);
CHECK_VERSION:
   proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);

dcl  cv_p_received_version		char (8) aligned;
dcl  cv_p_expected_version		char (8) aligned;
dcl  cv_p_structure_name		char (*);

   if cv_p_received_version ^= cv_p_expected_version then
      call ERROR_RETURN (error_table_$unimplemented_version,
	 "^/Expected version ^d of the ^a structure.^/Received version ^d, instead.",
	 cv_p_expected_version, cv_p_structure_name, cv_p_received_version);

   end CHECK_VERSION;
%page;
%include access_mode_values;
%page;
%include area_info;
%page;
%include dm_log_sv_codes;
%page;
%include dm_system_states;
%page;
%include dm_system_config;
%page;
%include arg_list;
%page;
%include sub_err_flags;


   end dm_per_system_$init;
