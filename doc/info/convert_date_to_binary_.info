02/19/85  convert_date_to_binary_

The convert_date_to_binary_ subroutine converts a character
representation of a date and time into a 72-bit clock reading.  It
accepts a wide variety of date and time forms, including the output of
the date_time_ subroutine.


Entry points in convert_date_to_binary_:
   (List is generated by the help command)


:Entry: convert_date_to_binary_: 02/19/85  convert_date_to_binary_


Function:
converts a character representation of a date and time into a 72-bit
clock reading.


Syntax:
declare convert_date_to_binary_ entry (char(*), fixed bin(71), fixed
     bin(35));
call convert_date_to_binary_ (time_string, clock, code);


Arguments:
time_string
   the string to be converted.  (Input) See Time String below for a
   description of valid string values.

clock
   the resulting clock value.  (Output) Unchanged if an error occurs.
code
   is a standard status code.  (Output) It can have one of the
   following values:
   error_table_$bad_conversion
      a conversion condition occurred while trying to convert a value.
   error_table_$dt_ambiguous_time
      there is no language common to all words in the time string.


   error_table_$dt_bad_fw
      fiscal_week < 1 or fiscal_week > year_max (which is 52 or 53).
   error_table_$dt_hour_gt_twelve
      the hour given exceeds 12.
   error_table_$dt_multiple_date_spec
      more than one instance of a date has been given.
   error_table_$dt_multiple_diw_spec
      day of the week specified more than once.
   error_table_$dt_multiple_meaning
      the time string does not have the same meaning in all potential
      languages, these being the intersection of all the languages
      possible for all words present.
   error_table_$dt_multiple_time_spec
      more than one instance of a time has been given.
   error_table_$dt_multiple_zone_spec
      the zone may only be specified once.


   error_table_$dt_time_conversion_error
      For any of the following reasons:
      a.  General syntax error
      b.  Month without a day number.
      c.  Midnight or noon preceded by an hour other than 12.
      d.  Improper use of comma or period.
      e.  Improper use of offset.
   error_table_$dt_size_error
      the size condition occurred while converting the time string.
   error_table_$too_many_tokens
      the time string contains more tokens than the routine is prepared
      to handle.
   error_table_$dt_unknown_word
      a word in a time string is not found in the time_info_ token
      list.


Time string:
The time string can have up to six parts -- adverbial offset, date,
time, day of week, signed offset, and time zone.  Adverbial offsets, if
present, must appear leftmost in the string.  Beyond that, all of the
parts are optional and may be in any order.  The parts may be made up
of alphabetic fields, numeric fields, and special characters.

An alphabetic field is made up of letters and must contain a whole word
or an abbreviation (usually made up of the first three letters of the
word).  No distinction is made between uppercase and lowercase
characters.  Although this description gives examples in English, each
of the words is available in several languages.  Any of these languages
may be used in time strings, but all words within a given string must
be in the same language.


To see the languages defined on your site, type
          display_time_info -lang
A numeric field consists of an optionally signed integer (or fraction)
of one or more decimal digits.  The special characters that may be used
in either alphabetic or numeric fields are:  the slash (/), the period
(.), the colon (:), the plus (+), the minus (-), and the comma (,).
Blanks are not required between alphabetic and numeric fields in the
time strings; however, they are required between two numeric fields
unless the second field begins with a plus (+) or minus (-) sign.  For
example:
        2days4hours10minutes
        1245.17+7hours
        10/17/79Wednesday


Underscores may be used in place of blanks in the time string.  For
example:
          09/25/79__1442.6_+5_hours

Usually when a user enters a time string, the time zone is omitted.
Although the zone is seldom seen, it is very important.  The time zone
determines the interpretation of items given in the time string.  Also,
the zone is involved in supplying defaults for missing items.  All
defaults are taken from the current absolute time, adjusted by a
working time zone.  If a zone is given in the string, that becomes the
working zone.  Otherwise, the process default time zone is used.


This means that whether you convert a string with an explicit zone,
such as "XXXX_ast" or set the process default to "ast" and then convert
the string "XXXX", you get the same absolute time.  (Note that setting
the process default will also influence output conversion, while giving
an explicit zone does not.)  To display your default zone, type:

          print_time_defaults zone


Multics accepts dates from the year 0001 through 9999.  The Julian
calendar is used for dates from 0001-01-01 through 1582-10-04.  The
Gregorian calendar is used for dates from 1582-10-15 through
9999-12-31.  (The dates from October 5, 1582 through October 14, 1582
do not exist.  They were dropped when the Gregorian calendar was
adopted.  The leap day is always February 29.  The lower limit on dates
of January 1, 0001 AD was picked since it begins the era.  The upper
limit on dates of December 31, 9999 was chosen to limit year numbers to
four digits.  The time zones as now defined are used regardless of the
year.  The Multics date/time system does not account for "leap seconds"
and, therefore, the difference between any two binary clock values that
are precisely an integral number of days (hours, minutes, seconds,
etc.)  apart is guaranteed to be evenly divisible by the number of
microseconds in a day (hour, minute, second, etc.).


Notes:
See the Subroutines manual for a description of the six parts contained
in time string.


:Entry:  relative:  02/19/85 convert_date_to_binary_$relative


Function:
This entry point is similar to the convert_date_to_binary_
entry point, except that the clock reading returned is computed
relative to an input clock time rather than the current clock time.
Thus the clock reading returned for the string "March 26" is the clock
reading for the first March 26 following the input clock time, rather
than the clock reading for the first March 26 following the current
clock time.  Given a 72-bit clock time to use, this entry point
converts a character representation of a date and time to the
equivalent 72-bit clock reading.


Syntax:
declare convert_date_to_binary_$relative entry (char(*), fixed bin(71),
     fixed bin(71), fixed bin(35));
call convert_date_to_binary_$relative (string, clock, clock_in, code)


Arguments:
string
   is the character representation of the clock reading desired.
   (Input)
clock
   is the computed clock value relative to the clock_in argument.
   (Output)
clock_in
   is the clock time used to compute the clock value.  (Input)
code
   is a standard status code.  (Output)
