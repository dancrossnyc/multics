06/05/87  format_pl1, fp

Syntax as a command:  fp in_path {-control_args}


Function:  formats a PL/I, create_data_segment, reductions, or
pl1_macro source segment to make it more readable.


Arguments:
in_path
   is the pathname of the source segment.  Suffixes for PL/I,
   create_data_segment, reductions, and pl1_macro are recognized.  If
   in_path does not have a recognized suffix, format_pl1 attempts to
   use in_path.pl1 or in_path.cds, in that order.


Control arguments:
-brief, -bf
   does not print a warning if the prevailing style differs from the
   command line modes.
-check_comments, -ckcom
   prints a warning if a comment contains "/*".  It is useful if you
   have omitted a "*/" from a comment.
-check_strings, -ckstr
   prints a warning if a character string constant contains "/*", "*/",
   or vertical white space.  It is useful after receiving an error
   message indicating that you have omitted a quote from a character
   string constant.


-force, -fc
   forms the prevailing style by concatenating the default style, the
   prevailing style control comment modes, and the command line modes.
   If the program already has a prevailing style control comment and
   the prevailing style differs from the prevailing style control
   comment modes, the prevailing style control comment is deleted.  If
   you provide -record_style, a new prevailing style control comment is
   inserted.
-long, -lg
   prints a warning indicating the modes that differ if the prevailing
   style differs from the command line modes.  (Default)
-modes STR, -mode STR, -md STR
   specifies a modes string STR used in forming the prevailing style
   (see "Notes on prevailing style" below).


-no_check_comments, -nckcom
   does not print a warning if a comment contains "/*".  (Default)
-no_check_strings, -nckstr
   does not print a warning if a character string constant contains
   "/*", "*/", or vertical white space.  (Default)
-no_force, -nfc
   forms the prevailing style by concatenating the default style, the
   command line modes, and the prevailing style control comment modes.
   (Default)
-no_record_style, -nrcst
   does not put a control comment in the source specifying the
   prevailing style.  (Default)
-no_require_style_comment, -nrqst
   formats the source even if it does not already contain a prevailing
   style control comment.  (Default)


-no_version, -nver
   does not print the version of format_pl1.  (Default)
-output_file path, -of path
   specifies the pathname of the formatted source segment.  The equal
   convention is allowed.  The suffix of in_path is assumed if not
   specified.  If omitted and there were no errors, in_path is
   overwritten; if omitted and there were errors, a formatted copy is
   left in the process directory.
-record_style, -rcst
   puts a control comment in the source specifying the prevailing style
   if the source does not already have a prevailing style control
   comment.  The comment is placed immediately before the first token
   of the program so it does not interfere with copyright notices.


-require_style_comment, -rqst
   prints an error message if the source does not already contain a
   prevailing style control comment.  This is useful if you are
   concerned with accidentally destroying the style of a hand-formatted
   program.
-version, -ver
   prints the version of format_pl1.


Notes:  Alternate methods of formatting particular language constructs
are selected by means of modes.  Several popular styles, consisting of
groups of modes, are defined.  Modes and styles are specified on the
command line and in comments in the source segment.


An exec_com tool called compare_pl1 compares PL/I source segments of
dissimilar formats via format_pl1.


If you give two opposing control arguments, the rightmost one is
chosen.  The term "token" excludes comments.  See the Multics PL/I
Language Specification, Order No.  AG94, for definitions of words
describing syntactic constructs in a PL/I program, e.g., independent
statement, declaration list, etc.  Condition and label prefixes are not
considered part of a statement.


Notes on modes string:  A modes string changes the style format_pl1
uses to format a program.  It consists of mode names separated by
commas.  Many modes can be preceded by ^ to turn the specified mode
off.  The modes string is processed from left to right; thus, if two or
more contradictory modes appear within the same modes string, the
rightmost mode prevails.  Modes not specified by the modes string are
left unchanged.


Notes on control comments: A control comment has the form
   /* format: STR */
where STR is a modes string.  The control comment can start with one of
the other comment indicators listed in "List of comment indicators"
below.  Control comments can occur only before the first token of the
program, between a semicolon and the first token of the next statement,
or after the last semicolon in the program.  Control comments cannot
occur in the middle of a statement.  Optional horizontal white space
can precede "format" or surround STR.  Some modes changed by a control
comment may not take effect immediately; for example, end statements
are formatted according to the modes in effect when the matching do,
begin, or procedure statement was formatted.


There are two special control comments that are used in if statements.
If a comment containing "/* case */" or "/* tree */" immediately
follows the word "if" in an if statement, then the current style is
changed for the duration of that if statement; exactly one space must
precede and follow "case" and "tree".  (See case and tree modes in the
"List of if statement modes" below.)


Notes on prevailing style:  The style in which format_pl1 formats a
PL/I program is formed from a combination of three sources:
format_pl1's default style, modes specified on the command line, and
control comments in the program.  The first control comment of the
program preceding the first token of the program is called the
prevailing style control comment.  A program might not have a
prevailing style control comment.  The style specified by the
concatenation of the default style, the command line modes, and the
prevailing style control comment modes is called the prevailing style.
This is the style in which most of the program is formatted.


Since a styleN mode specifies the setting of every mode, if the
prevailing style control comment contains a styleN mode, the default
format_pl1 style and the command line modes are ignored.  If the
program doesn't already have a prevailing style control comment, the
command line
   format_pl1 in_path -modes MY_STYLE -record_style
formats a program in MY_STYLE and records the style in a prevailing
style control comment.  If the program has a prevailing style control
comment, the program is formatted in the style specified by its
prevailing style control comment and -record_style has no effect.  The
prevailing style control comment created as a result of -record_style
always begins with a styleN mode.


Notes on examples:  The examples show how various program fragments are
formatted.  If you give no control comment, then style1, is assumed; if
you give a control comment, the default is used for all unspecified
modes.  Unless you use delnl,insnl mode, each line of the input source
segment contains the same tokens as the corresponding line of the
example.  If you use delnl,insnl mode, then newline characters are
inserted and deleted as required by the style.  (See "Notes on styles"
below.)


List of modes: Modes for various language constructs are listed
   separately.
styleN
   specifies formatting style N.
revert
   changes the formatting style to the prevailing style.  You can't
   supply this mode in -modes or in the prevailing style control
   comment.  Note that the on mode is changed to the phase specified in
   the prevailing style.
off, ^on
   leaves the source exactly as it is until a control comment changes
   the style to on.  In this mode, block and group entries and exits
   are noticed so the program following the on mode control comment is
   formatted correctly.


on, ^off
   starts formatting the source again.  (Default)
indN
   N is the number of columns to indent for each block or group
   indentation level.  An independent statement in a then or else
   clause that does not have a condition or label prefix is indented a
   minimum of five columns when not in ifthen mode even if indN is less
   than five.  This avoids placing the then or else clause on the line
   after the "then" or "else".  The five columns are measured from the
   column the "else" would start in if the else clause was an
   independent statement.  (Default:  5)



      Example   /* format: ind3 */
                if v = 2
                then
                   do;
                      x = 12;
                      y = 128;
                   end;
                else z = 12;

llN
   N is the output line length.  (Default:  122)
lineconindN
   N is the number of columns to indent the continuation of lines that
   exceed the output line length.  (Default:  5)
equalindN
   if N is greater than zero, places the equal sign of assignment
   statements in a column indented N columns from the left margin.  If
   in insnl mode, a new line is inserted if necessary to insure that
   the equal sign is indented the specified column positions.  If N is
   zero, then assignment statements are formatted just as ordinary
   statements.  (Default:  0)

      Example:  /* format: style2,equalind8 */
                a       = 12;
                index   = 1;
                second_index
                        = 43;
initcolN
   N is the initial column that statements occurring before the first
   procedure statement should start at.  This is useful for include
   files.  (Default:  6)


Notes on declare statements:  Depending upon delnl and insnl modes,
each level one identifier that is declared is placed on a line by
itself.  In indattr mode, all attributes are indented to the same
column.  If a declaration list (parenthesized list) has all the
attributes factored (i.e., each declaration component in the
declaration list consists only of an identifier) and doesn't contain
any comments and none of the identifiers contain a $, then the
declaration list is placed on as few lines as possible instead of
placing each identifier on a separate line.
   Example:  dcl (hbound, index, null) builtin;


List of declare statement modes:
indattr
   always indents the attributes so they start in the same column.
   (Default)
^indattr
   doesn't indent the attributes from the identifier being declared.
inddcls
   indents declare statements so they start in the same column any
   other statement would start in.  (Default)
^inddcls
   always starts declare statements in column 1.
declareindN
   indents N columns after the start of dcl.  (Default:  8)
dclindN
   indents N columns after the start of dcl.  (Default:  8)


idindN
   indents N columns after the start of an identifier before starting
   the attributes.  Ignored if in ^indattr mode.  (Default:  23)
struclvlindN
   indents N columns for each level in a structure.  (Default:  2)


List of if statement modes:
ifthenstmt
   puts the then clause on the same line as the "if", if it fits.
   These criteria must be met:  (1) the then clause must be an
   independent statement and cannot be another if statement; (2) the
   then clause must not have a condition or label prefix; (3) if in
   tree mode, the if statement must not have an else clause; (4) if in
   case mode, the if statement must fall into one of the following
   categories:  (a) there is no else clause, (b) the else clause
   consists of an if statement, or (c) the if statement under
   consideration is an else clause of another if statement.
      Example:  /* format:  ifthenstmt */
                if x > 3 then return;


^ifthenstmt
   doesn't put the then clause on the same line as the "if".  (Default)
         Example:  if x > 3
                   then return;
ifthendo
   puts the "then do" on the same line as the "if", if it fits even if
   indN is less than five, if the then clause of an if statement is a
   noniterative do group without a condition or label prefix; puts the
   "then do" on the same line if it fits and in ^thendo mode; lines the
   "then" up with the "if" if in thendo mode; puts the "else do" on the
   same line, if it fits even if indN is less than five, if the else
   clause of an if statement is a noniterative do group without a
   condition or label prefix.  In ^delnl mode, the "then" or the "else"
   must already be on the same line as the "do".


      Example   /* format: ifthendo,^indnoniterdo */
                if v = 2 then do;
                     x = 8;
                     y = 9;
                end;
                else do;
                     x = 9;
                     y = 92;
                end;



                /* format: ind3,ifthendo,^indnoniterdo */
                if v = 2 then do;
                   x = 8;
                   y = 9;
                end;
                else do;
                   x = 9;
                   y = 92;
                end;



^ifthendo
   doesn't put the "then do" on the same line as the "if".  (Default)
      Example:  /* format: ^indnoniterdo */
                if v = 2
                then do;
                     x = 8;
                     y = 9;
                end;
                else do;
                     x = 9;
                     y = 92;
                end;



thendo
   if in ifthendo mode, lines the "then" up with the "if".
      Example:  /* format: ind3,ifthendo,thendo,^indnoniterdo */
                if v = 2
                then do;
                   x = 8;
                   y = 9;
                end;
                else do;
                   x = 9;
                   y = 92;
                end;



^thendo
   if in ifthendo mode, puts the "then do" on the same line as the "if"
   if it fits.  (Default)
      Example: /* format: ind3,ifthendo,^indnoniterdo */
                if v = 2 then do;
                   x = 8;
                   y = 9;
                end;
                else do;
                   x = 9;
                   y = 92;
                end;



ifthen
   puts the "then" on the same line as the "if".
      Example:  /* format: ind3,ifthen */
                if v = 2 then
                   do;
                      x = 12;
                      y = 128;
                   end;
                else
                   do;
                      x = 128;
                      y = 12;
                   end;



^ifthen
   lines the "then" up with the "if".  (Default)
      Example:  if v = 2
                then x = 8;
                else x = 9;
elsestmt
   places independent statements on the same line as the else clause;
   places nonindependent statements on the same line as the else clause
   if indN is set to five or more.  (Default)


^elsestmt
   does not place any statements on the same line the else clause
   appears on unless the else clause is part of an if statement in
   "case" mode and the statement following the else clause is another
   if statement.
      Example:  /* format: style2,ifthen,^elsestmt */
                if a = b then
                     x = y;
                else
                     x = z;



indnoniterdo
   indents the statements of the do group two indentation levels from
   the column in which the "if" starts if a then or else clause
   contains a noniterative do group without a condition or label
   prefix; indents three levels if in indthenelse mode.  (Default)
      Example:  if v = 2
                then do;
                          x = 3;
                          y = 4;
                     end;
                else do;
                          x = 35;
                          y = 27;
                     end;



^indnoniterdo
   indents the statements of the do group one indentation level from
   the column in which the "if" starts if a then or else clause
   contains a noniterative do group without a condition or label
   prefix; indents two levels if in indthenelse mode.
      Example:  /* format: ^indnoniterdo */
                if v = 2
                then do;
                     x = 3;
                     y = 4;
                end;
                else do;
                     x = 35;
                     y = 27;
                end;



inditerdo
   indents the statements of the do group two indentation levels from
   the column in which the "if" starts if a then or else clause
   contains an iterative do group and it does not have a condition or
   label prefix; indents three levels if in indthenelse mode.
   (Default)
      Example:  if v = 2
                then do i = 1 to 4;
                          a (i) = i;
                     end;



^inditerdo
   indents the statements of the do group one indentation level from
   the column in which the "if" starts if a then or else clause
   contains an iterative do group and it does not have a condition or
   label prefix; indents two levels if in indthenelse mode.
      Example:  /* format: ^insnl,^inditerdo */
                if v = 2 then do i = 1 to 4;
                     a (i) = i;
                end;



indnoniterend
   starts the end statement of the noniterative do group in the same
   column as the statements of the noniterative do group if a then or
   else clause contains a noniterative do group without a condition or
   label prefix.
      Example:  /* format: ^indnoniterdo,indnoniterend */
                if v = 2
                then do;
                     x = 8;
                     y = 9;
                     end;
                else do;
                     x = 9;
                     y = 92;
                     end;



^indnoniterend
   starts the end statement of the noniterative do group in the column
   that is one indentation level before the column the statements of
   the noniterative do group start in if a then or else clause contains
   a noniterative do group without a condition or label prefix.
   (Default)



      Example   /* format: ^indnoniterdo */
                if v = 2
                then do;
                     x = 8;
                     y = 9;
                end;
                else do;
                     x = 9;
                     y = 92;
                end;



indthenelse
   indents the then and else clauses two indentation levels from the
   column in which the "if" is placed.  Places the "else" one
   indentation level from the column in which the "if" is started.  If
   in ^ifthen mode and the ifthenstmt and ifthendo modes do not apply
   to the if statement, places the "then" in the same column as the
   "else".  If in case mode and the if statement under consideration is
   the else clause of another if statement, then indents from the
   column in which the preceding "else" is placed instead of the column
   in which the "if" is placed.  In case mode this mode is ignored for
   the else clause if the else clause consists of an if statement or
   the if statement under consideration is an else clause of another if
   statement.



      Example   /* format: indthenelse */
                if v = 2
                     then x = 8;
                     else do;
                               x = 9;
                               call default;
                          end;
                /* format: indthenelse */
                if v = 2
                     then x = 8;
                else if v = 3
                     then x = 25;
                else call error;



^indthenelse
   indents the then and else clauses one indentation level from the
   column in which the "if" is placed.  Places the "else" in the same
   column as the "if" is placed.  If in ^ifthen mode and the ifthenstmt
   and ifthendo modes do not apply to the if statement, places the
   "then" in the same column as the "else".  If in case mode and the if
   statement under consideration is the else clause of another if
   statement, then indent from the column in which the preceding "else"
   is placed instead of the column in which the "if" is placed.
      (Default)



      Example   if v = 2
                then x = 8;
                else do;
                          x = 9;
                          call default;
                     end;
                if v = 2
                then x = 8;
                else if v = 3
                then x = 25;
                else call error;



case, ^tree
   indents "else if" clauses like a case statement.  (Default)
      Example:  if char = "a"
                then call char_a;
                else if char = "b"
                then call char_b;
                else if char = "c"
                then call char_c;
                else call error;



                /* format: ifthenstmt */
                if char = "a" then call char_a;
                else if char = "b" then call char_b;
                else if char = "c" then call char_c;
                else call error;
                /* Decision tree formatted like a case statement. */
                if condition_1
                then if condition_2
                     then call condition (0);
                     else call condition (1);
                else if condition_2
                then call condition (2);
                else call condition (3);



tree, ^case
   indents "else if" clauses like a decision tree.
      Example:  if /* tree */ condition_1
                then if condition_2
                     then call condition (0);
                     else call condition (1);
                else if condition_2
                     then call condition (2);
                     else call condition (3);



                /* Case statement formatted like a decision tree. */
                /* format: tree */
                if char = "a"
                then call char_a;
                else if char = "b"
                     then call char_b;
                     else if char = "c"
                          then call char_c;
                          else call error;



indbegin
   indents the body of those begin blocks that do not follow then
   clauses, else clauses, or on statements.  (Default)
      Example:  a = 15;
                begin;
                     x = 21;
                end;
                y = 2;



^indbegin
   does not indent the body of those begin blocks that do not follow
   then clauses, else clauses, or on statements.
      Example:  /* format: ^indbegin */
                a = 15;
                begin;
                x = 21;
                end;
                y = 2;



indbeginend
   indents the end statement of those begin blocks that do not follow
   then clauses, else clauses, or on statements to the level of the
   begin block body.  If in ^indbegin mode, this option does not effect
   the placement of the end statement.  The end statement always lines
   up under the begin block body and in the same column as the begin
   statement since they are the same column.
      Example:  /* format: indbeginend */
                a = 15;
                begin;
                     x = 21;
                     end;
                y = 2;



      Example   /* format: ^indbegin,indbeginend */
                a = 15;
                begin;
                x = 21;
                end;
                y = 2;
^indbeginend
   places the end statement of those begin blocks that do not follow
   then clauses, else clauses, or on statements in the same column as
   the begin statement.  (Default)


indthenbegin
   indents the body of begin blocks that follow then clauses, else
   clauses, or on statements.  (Default)
      Example:  if a = 2
                then begin;
                          x = 12;
                     end;
                y = 15;



^indthenbegin
   does not indent the body of begin blocks that follow then clauses,
   else clauses, or on statements.  By default the corresponding end
   statement is indented one less level than the begin block body (see
   indthenbeginend).
      Example:  /* format: ^indthenbegin */
                if a = 2
                then begin;
                     x = 12;
                end;
                y = 15;



indthenbeginend
   indents the end statement of those begin blocks that follow then
   clauses, else clauses, or on statements to the same level as the
   begin block body.
      Example:  /* format: indthenbeginend */
                if a = 2
                then begin;
                          x = 47;
                          end;
                y = 100;



     Example   /* format: ^indthenbegin,indthenbeginend */
                if a = 89
                then begin;
                     x = y;
                     end;
                y = 100;
^indthenbeginend
   indents the end statement of those begin blocks that follow then
   clauses, else clauses, or on statements one less level than the
   indentation of the begin block body.  (Default)
      Example:  if a = b
                then begin;
                          x = 15;
                     end;
                y = 9;



      Example   /* format: ^indthenbegin */
                if a = b
                then begin;
                     x = 15;
                end;
                y = 9;
indproc
   starts the procedure statement in the same column as other
   statements of the containing procedure if a procedure is contained
   within at least two other procedures, i.e., the procedure is an
   internal procedure of an internal procedure; starts the procedure
   statement in column indN+1, otherwise.



      Example   /* format: indproc */
                extp:
                     procedure;
                          a = 1;
                intp1:
                     procedure;
                          b = 2;
                intp2:
                          procedure;
                               c = 3;
                          end intp2;
                     end intp1;
                     end extp;



^indproc
   start procedure statements in column indN+1.  (Default)
      Example:  extp:
                     procedure;
                          a = 1;
                intp1:
                     procedure;
                          b = 2;
                intp2:
                     procedure;
                          c = 3;
                     end intp2;
                     end intp1;
                     end extp;



indprocbody
   indents the body of the procedure, the statements following the
   procedure statement, one level farther than the indentation of the
   procedure statement.  (Default)
^indprocbody
   begins the statements following a procedure statement in the same
   column as the procedure statement.
      Example:  /* format: ^indprocbody */
                test:
                     procedure;
                     a = 12;
                     end test;



indend
   starts the end statement of a do group, except those affected by
   indnoniterend mode, in the same column as the statements of the
   group.
      Example:  /* format: indend */
                do i = 1 to 5;
                     a (i) = i;
                     end;
^indend
   starts the end statement of a do group, except those affected by
   indnoniterend mode, in the column that is one indentation level
   before the column the statements of the group start in.  (Default)
      Example:  do i = 1 to 5;
                     a (i) = i;
                end;


Notes on horizontal white space:  All horizontal white space, except
within character string constants and comments, is removed from the
program.  Spaces are inserted before left parentheses, after commas,
around operators, and in other places to improve readability.  Where
possible, horizontal tabs are used to conserve space in the output
segment.


Statements continued onto another line are indented lineconindN from
the current left margin.  The left margin at which a statement is
indented is increased by indN for every nested begin block, group, and
then or else clause except as required by the indnoniterdo, inditerdo,
indthenelse, case, indproc, and indprocbody modes.  Entry statements
are placed in the same column as the corresponding procedure statement.
The left margin before a procedure statement is saved; it is restored
after the procedure's end statement.  After a procedure statement the
left margin is increased by indN if the indprocbody option is set.  End
statements are started in the same column as the statement that began
the block or group except as required by the indnoniterend, indend,
indbeginend, and indthenbeginend modes.  Condition and label prefixes
are placed on lines by themselves except possibly in ^insnl mode.


Notes on vertical white space:  Vertical white space within character
string constants and comments is never changed.  Other vertical white
space can be intrastatement and interstatement.  In on mode, vertical
tabs and newlines before newpages are removed, newlines before vertical
tabs are removed, and multiple newpages are reduced to one.  Then a
newline is inserted before and after a sequence of vertical tabs and
newpages if there is not already one there.  Interstatement vertical
white space is never changed except for the above canonicalizations;
intrastatement vertical white space is also canonicalized as above and
processed depending upon delnl and insnl modes.


List of vertical white space modes:
delnl
   deletes all existing intrastatement vertical white space.
^delnl
   leaves existing intrastatement vertical white space in the program.
   (Default)


insnl
   inserts newlines in the program if necessary.  Newlines are inserted
   when statements are too long to fit on a line.  To determine where
   newlines are inserted, various heuristics exist that use the
   statement type and the precedence of the tokens in the statement to
   determine where to insert newlines.  The driving force of format_pl1
   is what column statements or other language constructs should start
   in.  Newlines are inserted to start a statement, subset of a
   statement, or a comment in a particular column.
^insnl
   doesn't insert newlines into the program.  (Default)


Notes on comments:  Comments are classified by where they occur within
a PL/I program and where they are placed in the output segment.  They
are divided into three categories:  intrastatement comments, indented
comments, and block comments.  Intrastatement comments occur between
the first token of a statement and the semicolon ending the statement.
They are normally separated from surrounding tokens by a space except
as required for linecom mode.  Comments that follow a semicolon and are
separated by at most one newline character are considered indented
comments.  They are placed in column comcolN.  All other comments are
block comments.  Block comments are placed in column one or indented to
the current left margin according to the indcom and indblkcom modes.
All comments following a blank line, following a block comment, and
before the first token of the program are block comments.  Placing a
comment in column N means that the "/*" starts in column N.


In these special cases intrastatement comments are treated as indented
comments and placed in column comcolN:  comments following a comma;
preceding the right parenthesis of a declaration component; following
the colon in a condition or label prefix; and, in if statements that
the ifthenstmt or ifthendo modes do not apply to, following the "then"
in ifthen mode and preceding the "then" in ^ifthen mode.


A comment indicator is placed at the beginning of a comment to specify
where the comment is placed or to inhibit indcomtxt mode on the
comment.  If necessary, even in ^insnl mode, a newline is inserted to
place the comment in the specified column.  Comment indicators consist
of the "/*", which starts the comment followed by other characters as
listed below.  A comment indicator does not affect the classification
of succeeding comments.


List of comment indicators:
/*
   places the comment according to its default classification.
/**
   places the comment in column comcolN.
/***
   indents the comment relative to the current left margin according to
   indblkcom mode.



/****
   places the comment in column one.
      Example:  /* format: ind3,comcol21 */
                /**** column one comment */
                      /*** comment indented to left margin */
                                    /** indented comment */
                      a = 3;        /* indented comment */

                /* column one comment by default */
                      b = 4;
/*^
   places the comment according to its default classification; formats
   the comment according to ^indcomtxt mode.



/**^
   places the comment in column comcolN; formats the comment according
   to ^indcomtxt mode.
/***^
   indents the comment relative to the current left margin according to
   indblkcom mode; formats the comment according to ^indcomtxt mode.
/****^
   places the comment in column one; formats the comment according to
   ^indcomtxt mode.


List of comment modes:
comcolN
   N is the column indented comments are placed at.  (Default: 61)
indcom
   indents block comments relative to the current left margin according
   to indblkcom mode.  This mode doesn't apply before the first token
   of the program so it doesn't interfere with copyright notices.
      Example:  /**** format: ind3 */
                      /* comment indented to left margin */
                      a = 3;
^indcom
   places block comment in column one.  (Default)
      Example:  /* format: ind3 */
                /* column one comment */
                      a = 3;



indblkcom
   starts comments that begin with the "/***" or "/***^" comment
   indicators and in indcom mode, block comments, at the current left
   margin.  (Default)
      Example:  /* format: ind3,indcom */
                /**** column one comment */
                      /*** block comment */
                      a = 5;



^indblkcom
   starts comments that begin with the "/***" or "/***^" comment
   indicators and in indcom mode, block comments, one indentation level
   before the current left margin.
      Example:  /* format: ind3,indcom,^indblkcom */
                /**** column one comment */
                   /*** block comment */
                      a = 5;



linecom
   intrastatement comments at the end of a line in the original source
   segment apply to an entire line.  These comments are treated as
   indented comments and are placed in column comcolN.
      Example:  /* format: linecom */
                if line_status < 3            /* Is line active? */
                     | char_count > 0
                then return;
^linecom
   intrastatement comments apply to the preceding token.  (Default)
      Example:  /* format: ^delnl */
                if char = "040"b3 /* space */
                     | char_count > 0
                then return;



indcomtxt
   inserts a space if there is no horizontal or vertical white space
   between the comment indicator and the comment text or between the
   end of the comment text and the "*/" or the reverse of any comment
   indicator.  Indents the text of continuation lines of a multiline
   comment so they line up; indenting the text of continuation lines
   does not apply to intrastatement comments.  The horizontal white
   space between the comment indicator and the comment text on the
   first line of a comment is not reduced; however, leading horizontal
   white space on subsequent lines is replaced by sufficient horizontal
   white space to indent the line.  If the comment is placed in column
   N, the length of the comment indicator is L, then the text of each
   line of the comment begins in column N+L+1.  This mode does not
   apply to comments whose comment indicator ends with "^".  Example:



      Input     /* format: indcomtxt */
                a = 3; /* Here we have a very
      complicated assignment
      statement. */
      Output:   /* format: indcomtxt */
                a = 3;              /* Here we have a very
                                       complicated assignment
                                       statement. */
^indcomtxt
   leaves the white space at the beginning of each line of a comment
   alone.  The character string between the "/*" and the "*/" of a
   comment is never changed in this mode.  (Default)


Notes on irreversible changes: Several modes can cause irreversible
changes to be made to the source program.  Suppose that program p.pl1
was formatted with style S and does not contain a prevailing style
control comment, then style T causes an irreversible change if the
following command lines produce a program q.pl1 that differs
substantially from p.pl1:
   format_pl1 p -modes T -output_file q.pl1
   format_pl1 q -modes S

The following modes can cause irreversible changes--delnl, insnl,
^linecom, and indcomtxt.  If a program is not formatted with
format_pl1, the on mode may also cause irreversible changes.


Notes on styles:
style1:   on,ind5,ll122,initcol6,indattr,inddcls,declareind8,
          dclind8,idind23,struclvlind2,^ifthenstmt,^ifthendo,
          ^thendo,^ifthen,indnoniterdo,inditerdo,
          ^indnoniterend,^indthenelse,case,^indproc,^indend,
          ^delnl,^insnl,comcol61,^indcom,indblkcom,^linecom,
          ^indcomtxt  (Default)
style2:   style1,delnl,insnl
style3:   style2,^inddcls,declareind10,dclind10,idind20
style4:   style1,^indattr,^inddcls,declareind9,dclind5,
          ifthendo,^indnoniterdo,^inditerdo,indproc,linecom,
          indcomtxt
style5:   style2,linecom,ifthen,^indnoniterdo,indnoniterend,
          indcomtxt,^indthenbegin,indthenbeginend,^indprocbody,
          ^elsestmt,ind8,ll80,initcol0,idind24,comcol57,lineconind4,



Style1 indents declare statements, the attributes of declare
statements, and the statements of the do group and lines up the end
statement of a noniterative do group in a then or else clause under the
"do".  No irreversible changes, such as with the delnl, insnl, or
indcomtxt modes, are made.  Example:
   /* format: style1 */
             declare entryname              char (32);
             if x = 2
             then do;
                       a = 43;
                       b = 21;
                  end;



Style2 is the same as style1 except it uses the delnl,insnl modes.  It
may cause irreversible changes.

Style3 is the same as style2 except that declare statements start in
column one and the identifiers and attributes start in columns aligned
on tab stops.  It may can cause irreversible changes.  Example:
   /* format: style3 */
   declare   entryname           char (32);
             if x = 2
             then do;
                       a = 43;
                       b = 21;
                  end;



Style4 starts declare statements in column one, doesn't indent the
attributes in declare statements, formats noniterative do groups in
then or else clauses by indenting the statements of the noniterative do
group one indentation level from the "if" or the "else", and starts the
end statement in the same column as the "if" or the "else".  This style
uses the ^delnl,^insnl modes, but still may cause irreversible changes
from indcomtxt mode; it resembles that of the indent command.  Example:
   /* format: style4 */
   declare  entryname char (32);
             if x = 2 then do;
                  a = 43;
                  b = 21;
             end;



Style5 starts declare statements in column one, sets the line length to
80 columns, sets the indentation amount to eight columns, sets the line
continuation indentation to four columns, places the then clause of the
"if/then" statement on the same line with the if, doesn't place any
statement on a line with an if statement or else clause except for
placing an if statement on the line after an else when in case mode,
doesn't indent the procedure body, and doesn't indent the body of
"begin/end" blocks or noniterative do groups under if statements.



   Example   /* format: style5 */
             test:
                     procedure;
                     a = 12;
                     if a = b then
                             a = 15;
                     else
                             a = -15;
                     b = 78;



                     if b = c then
                             do;
                             x = 1;
                             y = 99;
                             end;
                     a = 0;
                     end test;


Notes on error checking: Parenthesis balance checking is done for
statements that are not partially contained in include files.  A
warning is printed if an end statement with a closure label terminates
more than one block or group.  If you provide no -output_file and there
were errors, the source segment is not overwritten and a formatted copy
is left in the process directory.  An error message is printed if a
control comment is incorrect.


Notes on error severities: The following severity values are returned
by the severity active function when the "format_pl1" keyword is used:
     VALUE     MEANING
       0       No error
       1       Warning
       2       Correctable error
       3       Fatal error
       4       Unrecoverable error
       5       Bad control arguments, could not find source,
               or other severe errors.



Notes on macros: This command makes certain assumptions about macros.
Include files must contain complete statements and balanced blocks or
groups.  Macro constructs can only occur between statements; they must
not occur within a statement.  All macro constructs are placed in
column one.  All %then and %else clauses of a %if macro must have the
same effect on the current left margin and on block and group nesting;
in addition, the effect on block and group nesting can only be to leave
it unchanged or to start new blocks or groups.  Blocks or groups that
were started before the %if macro cannot be closed in the %then or
%else clauses.  A %then or %else clause cannot start with an else
clause.
