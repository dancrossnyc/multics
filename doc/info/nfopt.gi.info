05/28/80  new_fortran optimizer

With the new_fortran (fortran, ft) command, the -optimize (-ot)
control argument invokes a loop optimizer and a machine dependant
global optimizer (register optimizer).


Loop optimizer:
A loop optimizer is an optimizer that is cognizant of the flow of
control in a program and uses that information to improve the code
generated by the compiler.


Examples of loop optimization:
Calculations can be moved out of do-loops if the calculation is not
dependent on the do-loop index.  Identical sub-expressions can be
combined, and therefore only be calculated once, if the value of the
sub-expression does not change in between its uses.  Whole assignment
statements can be removed if the variable is assigned a new value
before it is used.  Assignment statements can also be removed if they
set automatic variables and are immediately followed by a return
statement.


This optimizer is considerably more powerful than the previous
new_fortran optimizer (New Fortran Release 3 or earlier) and provides
several new types of optimization, including strength reduction, test
replacement, dead assignment removal, expansion of statement functions
in-line, partial evaluation of logical expressions in logical if
statements, removal of unused assignments, removal of invariant code
from do-loops, and combining of identical sub-expressions.


Strength reduction:
A variable that is a simple arithmetic function of the do-loop index
can be calculated as repeated additions instead of a multiplication.


Test replacement:
If a do-loop index is not used at all, either within the do-loop or
within the extended range of that do-loop, and there is a variable
within the loop that is a simple arithmetic function of the do-loop
index, then the do-loop end condition test is changed to use that
variable, rather than the do-loop index.


Dead assignment removal:
Assignments to do-loop index are not performed if the do-loop index is
not used at all, either within the do-loop or within the extended
range of that do-loop.


Removal of invariants:
Expressions that are invariant within a do-loop are moved to the next
higher loop.


Partial evaluation of expressions:
Expressions in logical if statements are only evaluated until the
truth value of the expression is completely known.


Array subscripting has been vastly improved.


Statement function references:
References to statement functions are expanded in-line and are
therefore subject to combined sub-expression optimization.


Combining identical sub-expressions:
Whenever the flow of the program allows, identical sub-expressions are
pooled, that is, the expression is calculated once and stored in a
temporary where it can be referenced as needed.


Assignment removal:
Useless assignment statements are removed from the code entirely!!!
The two major causes of useless assignments are assignments to a
variable that are immediately followed by another assignment to the
same variable and assignment statements referencing automatic
variables immediately preceding a return statement.  The optimizer
warns the user whenever a block of code is removed.


Machine dependant optimizations:
In addition to the machine independant optimizations performed by the
loop optimizer, the -optimize (-ot) control argument also invokes a
machine dependant global optimizer (register optimizer) to perform
such optimizations as global register allocation and pulling register
loads out of loops.


Pointers to common blocks:
Pointers to frequently used common blocks are loaded into pointer
registers before the loops in which they are frequently used and are
kept loaded throughout these loops.


Invariant index values:
Loop invariant values used in indexing (subscripting) are loaded into
index registers before the loops in which they are invariant and are
kept loaded throughout these loops.


Induction variables:
Induction variables that are only used for addressing within a loop
are loaded into index registers before the loop and are incremented in
the index registers directly.  An induction variable that is globally
assigned to an index register in this way is not stored within the
loop unless the loop contains contexts which might erase the register,
such as a subroutine call, or unless the induction variable's value is
needed after loop termination or exit.
