10/21/86  object_lib_

The object_lib_ subroutine provides utilities for dealing with
object segments and multisegment files in a consistent manner.


Entry points in object_lib_:
   (List is generated by the help command)


:Entry:  initiate:  10/21/86 object_lib_$initiate


Function:  Initiates the executable binary specified, with the
given refname, terminating the refname as required and returning
a pointer and bit count.  The target is optionally checked to
insure that it is actually an object segment or MSF, and that
its status as an object MSF is consistent.


Syntax:
dcl object_lib_$initiate entry (char(*), char(*), char(*),
     bit (1), ptr, fixed bin (24), bit (1), fixed bin (35));
call object_lib_$initiate (dirname, entryname, refname,
     validate_sw, seg_ptr, bit_count, msf_sw, code);


Arguments:
dirname
   is the directory name of the object to be initiated.  (Input)
entryname
   is the entry name of the object to be initiated.  (Input)
refname
   is the reference name to be placed on the object when it is
   initiated.  If the object is an object MSF, the reference name will
   be placed on component 0.  (Input)
validate_sw
   is a switch to select whether of not the target segment or MSF is
   checked to see if it is a valid executable binary.  (Input)


seg_ptr
   is a pointer to the object.  If the object is an object MSF, a
   pointer to component 0 will be returned.  (Output)
bit_count
   is the bit_count of the segment pointed to by seg_ptr.  If the
   target is an MSF, it is the bit count of component 0.  (Output)
msf_sw
   is a flag indicating whether the object specified is an object MSF.
   (Output)
code
   is a standard status code. (Output)


:Entry:  init_no_clear:  10/21/86 object_lib_$init_no_clear


Function:  Initiates the executable binary specified, with the
given refname, terminating the refname as required and returning
a pointer.  If the refname is already in use, term_$no_clear is
called rather than term_$single_refname.  This entrypoint is
intended for use only by find_command_ since it will not clear
find_command_'s associative memory of entrypoints which is
assumed to be managed manually by find_command_.  The target is
optionally checked to insure that it is actually an object
segment or MSF, and that its status as an object MSF is
consistent.


Syntax:
dcl object_lib_$init_no_clear entry (char(*), char(*), char(*),
          bit (1), ptr, fixed bin (24), bit (1), fixed bin (35));
call object_lib_$init_no_clear (dirname, entryname, refname,
          validate_sw, seg_ptr, bit_count, msf_sw, code);


Arguments:
dirname
   is the directory name of the object to be initiated.  (Input)
entryname
   is the entry name of the object to be initiated.  (Input)
refname
   is the reference name to be placed on the object when it is
   initiated.  If the object is an object MSF, the reference name will
   be placed on component 0.  (Input)
validate_sw
   is a switch to select whether of not the target segment or MSF is
   checked to see if it is a valid executable binary.  (Input)


seg_ptr
   is a pointer to the object.  If the object is an object MSF, a
   pointer to component 0 will be returned.  (Output)
bit_count
   is the bit count of the segment pointed to by seg_ptr.  If the
   target is an MSF, it is the bit count of component 0.  (Output)
msf_sw
   is a flag indicating whether the object specified is a MSF.
   (Output)
code
   is a standard status code.  (Output)


:Entry:  get_component_info:  10/21/86 object_lib_$get_component_info


Function:  Returns structural and identifying information about
an object segment or MSF.  Varying amounts of information may be
returned depending on the value of the oi_type parameter.


Syntax:
dcl object_lib_$get_component_info entry (ptr, ptr, char(8),
          char(*), ptr, fixed bin(35));
call object_lib_$get_component_info (segp, areap, version_reqd,
          oi_type, infop, code);


Arguments:
segp
   is a pointer to the segment to be examined.  This may be a single
   segment or a component of an object MSF.  If it is a component of an
   object MSF info is returned for all of the components.  (Input)
areap
   is a pointer to an area in which the output structure is to be
   allocated.  If this pointer is null, the system_free_area is used.
   (Input)
version_reqd
   is the version of the output structure desired.  Currently only one
   version is supported.  This value should be component_info_version_1
   (declared in object_lib_defs.incl.pl1) (Input)


oi_type
   is  the type  of object  info desired  by the  caller.  Four
   values are supported, described under "List of oi_types" below.
   (Input) 
infop
   is a pointer to a component_info structure allocated by
   object_lib_$get_component_info.  (Output)
code
   is a standard status code.  (Output)


List of oi_types:
none
   No object info is filled into the structure.  Only the segment
   pointers, bit_count, and terminate flag is set.
brief
   Object info is filled in for each component by calling
   object_info_$brief for each component.
display
   Object info is filled in for each component by calling
   object_info_$display for each component.
long
   Object info is filled in for each component by calling
   object_info_$long for each component.


List of component_info elements:
   The component info structure returned has the following definition
   (declared in object_lib_defs.incl.pl1):

   dcl 01 component_info       aligned based (comp_infop),
        02 version             char (8),
        02 flags               aligned,
         03 msf                bit (1) unaligned,
         03 mbz                bit (35) unaligned,
        02 max                 fixed bin,
        02 comp                (0:max_component
			 refer (component_info.max)),
         03 segp               ptr,
         03 bc                 fixed bin (24),
         03 mbz                bit (36) aligned,
         03 info               like object_info;


version
   is the version number of the structure.  It is currently "cinfo1.0".
   The named constant for this value component_info_version_1 is
   declared in object_lib_defs.incl.pl1.
msf
   is a flag indicating that the object in question is an object MSF.
max
   is the number of the largest component in the file.
comp
   contains the per-component information.


segp
   is a pointer to the N'th component of the file.
bc
   is the bit_count of the N'th component of the file.
info
   is identical to the structure object_info (declared in
   object_info.incl.pl1) for a description of the fields in this
   section see object_info_.


:Entry:  get_def_target:  10/21/86 object_lib_$get_def_target


Function:  Searches the segment specified by segp for a
definition matching segname and offsetname and returns a pointer
to the target of the definition.  If the segment specified is
component 0 of an object MSF, the target pointer return points
to the eventual target of the definition (in some component
other than component 0).  If live_sw is "1"b, and the definition
found refers to the static or linkage section, the targetp value
returned will be in the live copy of the linkage or static
section, respectively.  If it is "0"b, the value returned will
point to the template in the object segment.


Syntax:
dcl object_lib_$get_def_target entry (ptr, fixed bin(24), char(*),
          char(*), bit(1), ptr, fixed bin(35));
call object_lib_$get_def_target (segp, bc, segname, offsetname,
          live_sw, targetp, code);


Arguments:
segp
   is a pointer to the segment to search.  (Input)
bc
   is the bit_count of the segment to search.  (Input)
segname
   is the segname to search for.  (Input)
offsetname
   is the name of the definition to search for.  (Input)


live_sw
   specified whether definitions which reference the static or linkage
   section of the object should return a pointer relative to the live
   copy pointed to by the LOT/ISOT or to the static template stored in
   the object segment itself.  (Input)
targetp
   is a pointer to the eventual target of the definition.  (Output)
code
   is a standard status code.  (Output)
