04/15/86  set_ext_variable_


To obtain information on a particular entry point use the "ep" request


Entry points in set_ext_variable_:
   (List is generated by the help command)


:Entry:  set_ext_variable_:  04/15/86  set_ext_variable_


Function: allows the caller to look up an external variable by name.
If the name is not found, the variable is created.


Syntax:
declare set_ext_variable_ entry (char(*), ptr, ptr, bit(1) aligned,
     ptr, fixed bin(35));
call set_ext_variable_ (ext_name, init_info_ptr, sb_ptr, found_sw,
     node_ptr, code);


Arguments:
ext_name
   is the name of the external variable.  (Input)
init_info_ptr
   is a pointer to the initialization info (see "Notes on
   init_info structure").
   (Input)
sb_ptr
   is a pointer to the base of the stack of the caller.  (Input)
found_sw
   is set to indicate whether the variable was found or not.
   (Output)


node_ptr
   is a pointer to the external variable node.  (see "Notes on
   variable_node structure")
   (Output)
code
   is an error code.  (Output)



:Entry:  locate:  04/15/86 set_ext_variable_$locate


Function: This entry point locates the specified external variable
and returns a pointer to the structure describing the variable.


Syntax:
dcl set_ext_variable_$locate entry (char(*), ptr, ptr,
    fixed bin(35));
call set_ext_variable_$locate (ext_name, sb_ptr, node_ptr, code);


Arguments:
ext_name
   is the name of the external variable.  (Input)
sb_ptr
   is a pointer to the base of the stack of the caller.  (Input)
node_pointer
   is a pointer to the variable_node describing the specified
   variable.  This structure is defined in the
   system_link_names.incl.pl1 include file.  (see "Notes on
   variable_node structure")
   (Output)
code
   is an error code.  (Output)


:Entry:  star_heap:  04/15/86  set_ext_variable_$star_heap


Function: allows the caller to look up heap variables by name.  If
the name is not found, the variable is created and added to the
list of heap variables.


Syntax:
declare set_ext_variable_$star_heap entry (char(*), ptr, ptr, ptr
   bit(1) aligned, ptr, fixed bin(35));
call set_ext_variable_$star_heap (ext_name, init_info_ptr, sb_ptr,
  seg_ptr, found_sw, node_ptr, code);


Arguments:
ext_name
   is the name of the external variable.  (Input)
init_info_ptr
   is a pointer to the initialization info (see "Notes on
   init_info structure").
   (Input)
sb_ptr
   is a pointer to the base of the stack of the caller.  (Input)
seg_ptr
   is a pointer to the segment containing the object to be
   initialized. (Input).
found_sw
   is set to indicate whether the variable was found or not.
   (Output)


node_ptr
   is a pointer to the external variable node.
   (see "Notes on variable_node structure") (Output)
code
   is an error code.  (Output)


:Entry:  pointer:  04/15/86  set_ext_variable_$pointer


Function: allows the caller to create a system external variable
using list_init_ pointer intialization.


Syntax:
declare set_ext_variable_$pointer entry (char(*), ptr, ptr, ptr
   bit(1) aligned, ptr, fixed bin(35));
call set_ext_variable_$pointer (ext_name, init_info_ptr, sb_ptr,
  seg_ptr, found_sw, node_ptr, code);


Arguments:
ext_name
   is the name of the external variable.  (Input)
init_info_ptr
   is a pointer to the initialization info (see "Notes on
   init_info structure").
   (Input)
sb_ptr
   is a pointer to the base of the stack of the caller.  (Input)
seg_ptr
   is a pointer to the segment containing the object to be
   initialized. (Input).
found_sw
   is set to indicate whether the variable was found or not.
   (Output)


node_ptr
   is a pointer to the external variable node.
   (see "Notes on variable_node structure") (Output)
code
   is an error code.  (Output)


Notes on init_info structure:
When a new external variable is allocated (not found), it must be
initialized.  The following structure, described in
system_link_init_info.incl.pl1, is pointed to by init_info_ptr:

   dcl 1 init_info           aligned based,
         2 size              fixed bin(19),
         2 type              fixed bin,
         2 init_template
      (init_size refer
      (init_info.size))      fixed bin(35);


   Structure elements:
   size
      is the initialization template size, in words.
   type
      is the type of initialization to be performed.
      0 no init
      1 invalid
      2 invalid
      3 init from template
      4 init area to empty ()
      5 list_template intialization (see "Notes on
        list_template initialization structure").
   init_template
      is the initialization template to be used when type = 3.


Notes on list_template initialization structure:
When the initialization type is 5 or a list_template
initialization is being performed the init_info structure is not
used.  The structure used is the list_init_info structure which
has the following definition in system_link_init_info.incl.pl1 :

dcl	1 list_init_info	     aligned based,
	  2 size		     fixed bin (35),
	  2 type		     fixed bin,
	  2 pad		     bit (18) unaligned,
	  2 list_size	     fixed bin (18)
			     unsigned unaligned,
	  2 template	     (0 refer
			     (list_init_info.list_size))
			     bit (36);


   Structure Elements:
   size
      is the size of the variable in words.
   type
      is the type of initialization to be performed.
      5 list_template
   list_size
     is the number of list_template_entries that make up the
     template.


   template
     takes the form of a list_template_entry structure as defined
     in system_link_init_info.incl.pl1.  This structure is passed
     on to list_init_ and decoded into data which is copied to the
     variable.  See the description of list_init_ in the
     Privileged Subroutines Manual for a more complete
     description.


Notes on variable_node structure:
Great care should be taken when using the node_ptr.  The
variable_node structure should never be modified.  Modifications
to the variable_node will have unpredictable results.

A pointer to the following structure is returned by the entry
points in this subroutine.  It is declared in
system_link_names.incl.pl1.

   dcl 1 variable_node       aligned based,
         2 forward_thread    ptr unaligned,
         2 vbl_size          fixed bin(23) unaligned,
         2 init_type         fixed bin(11) unaligned,
         2 time_allocated    fixed bin(71),
         2 vbl_ptr           ptr,
         2 init_ptr          ptr,
         2 name_size         fixed bin(21) aligned,
         2 name              char (nchars refer
                             (variable_node.name_size)),
         2 seg_ptr	         ptr;


   Structure elements:
   forward_thread
      is used by the linker to thread this variable to the
      next.
   vbl_size
      is the size, in words, of this variable.
   init_type
      is the type of initialization that is performed:
      0 none
      1 invalid
      2 invalid
      3 initialize from template
      4 initialize to an empty area
      5 initialize using a list template (see "Notes on
        list_template initialization structure").


   time_allocated
      is the clock reading at the time this variable was
      allocated.
   vbl_ptr
      is a pointer to the variable's storage.
   init_ptr
      is a pointer to the initialization template.
   name_size
      is the number of characters in the variable name.
   name
      is the name of the variable.
   seg_ptr
      is a pointer to the segment containing the variables
      initialization information.

