:Info: probe: pb:
1990-07-24  probe, pb


Syntax as a command:  pb {procedure_name} {-control_args}


Function:
 provides symbolic, interactive debugging facilities for
 programs compiled with PL/I, Fortran, Pascal, COBOL, ALGOL-68 or C.


Arguments:
procedure_name
 is the reference name of an initiated program, or a pathname.
 If procedure_name is not specified, the procedure owning the frame
 in which the last condition was raised is assumed.


Control arguments:

-handle_conditions
   sets up a handler for any conditions signalled while in probe,
   that prints an appropriate message and prevents faulting.
   (Default)
-no_handle_conditions
   does not set up a handler for conditions signalled while in probe.


Notes:
 Probe is self-documenting.  For further information, invoke probe and
 type:  help

 For a list of all requests, type:  list_requests

 For a list of all topics described by probe, type:  list_help


 Programs examined by probe should not have been compiled with code
 optimizers, such as the -optimize control argument to the pl1 and
 fortran commands.  Optimization can causes program variables to
 appear to have the wrong value when stopped at a break or fault.


:[Info]: summary.topic: summary:
1988-09-30  General information about probe

Summary:

 Probe is a symbolic debugger for programs written in PL/1, Fortran,
 Pascal, COBOL, ALGOL-68 and C.  It permits you to interrupt a program
 at a specified location, to examine or modify program variables, to
 examine the stack history of block invocations, and to display source
 lines and object instructions associated with an object location.
 Probe can evaluate expressions involving program variables and call
 external functions.


Self-documentation:

 Use the probe "help" request to display information about probe
 requests and other probe-related topics.

 To see a list of probe requests, type:
   list_requests
 or
   lr

 To see details about a particular request, type:
   help REQUEST_NAME
 where REQUEST_NAME is the name of one of the probe requests.

 To see a list of topics, type:
   list_help
 or
   lh

 To display information about a particular topic, type:
   help TOPIC
 where TOPIC gives one of the topic names shown by the list_help
 request.


Probe interaction:

 When probe has been invoked, it accepts requests from you.  A probe
 request consists of a keyword (the name of the request to be
 performed) and its arguments, if any.  More than one request can
 appear on a line if they are separated by semicolons (";").  For a
 list of all requests, type:  list_requests


Breakpoints:

 A breakpoint is a set of probe requests associated with a program
 statement.  This set of requests is executed automatically by probe
 whenever the location in the object segment corresponding to the
 statement is executed.  The most common request is "halt", which
 suspends execution of the program and listens for further requests.
 You can then examine and modify the state of the suspended program,
 and resume (or abort) further execution.  Other uses of breakpoints
 are to display the state of the program without halting, or to effect
 source-level patching by executing assignments.

 For more information, type:  help breaks


:[Info]: toc.topic: toc:
1988-09-30  Summary of help files for probe.


Info files are divided into three categories;
   Info about requests.
   Info about probe features.
   Info about probe syntax.


Notes on probe request information:

 To see information about a request, type:
   help REQUEST_NAME
 where REQUEST_NAME is the name of the request.

 For example:  help value

 The help request accepts either long or short name for a request.


Notes on available probe features:

   breaks
   builtins
   c
   cobol
   fortran
   optimization
   pascal
   pointers (source_pointer, control_pointer)
   variables (variables created by the probe declare request)


Notes on syntax info available:

   CONSTANTS
   EXPRESSIONS
   LINE
   NUMBER
   PATH
   PREDICATE
   REQUEST
   STRING
   CROSS-SECTION
   POINTER

Names of syntax topics can be typed in lower case.


:[Info]: C: c:
1988-09-28  Probe and C

Notes on probe and the c language:

When the current language type is C, probe's set of data types
expands to include void types, enumeration types, unions, variant
records (typedef), and type pointers.  The set of builtin functions
for use with the C language data types is the function "sizeof".
Also the modulus operator (%) (similar to the PL1 builtin "mod"
function) and the right (>>) and left (<<) shift operators are
available.


 Differences occur in the syntax that represents array indices, and
 operators.  Array indices are enclosed (as in Pascal) in square
 brackets.  The cross-section ranges are written with ":" e.g.
 a[first:last].  Although C does not have true character strings (C
 uses arrays of characters), the array syntax will be used to display
 a character array.  (see "string" for more details) String constants
 are contained in double quotes (") and single characters are
 contained in single quotes (').  e.g.  a character string - "this is
 a string" , a single character - 'a'.


 Pointer values(indirection operators) are represented by the star (*)
 symbol, and the address operator (if "v" is a variable, then "&v" is
 the address of that variable) is represented by the ampersand (&)
 symbol.

 The relational operators available are: != == < > <= >=

 To maintain consistency with the other languages that probe supports
 the following will not be supported : bitwise operators (&& ||), type
 casting, conditional expressions (?:), logical "and" and "or"
 operators, and compound assignments (+= -= etc.).


:[Info]: PL1: pl1:
1990-06-28  Probe and PL1

Notes on probe and the pl1 language:

Probe uses a PL/1_like syntax when the current language is PL/1.  Probe
communicates with you based on information in the symbol table and the
statement map which are produced by the PL/1 compiler.  The limitations
of the symbol table sometimes limit the communication with probe.


Examples:

 (1) Probe cannot determine the correct dimension size of an array if
     the upperbound of the dimension is an element other than the first
     element of an "external" structure.
     For example: "dcl x dim (1:struct.e4) fixed bin based (pt);
     where "e4" is the fourth element in, "struct", the external
     structure.  Probe (symbol) incorrectly interprets the upperbound
     of the dimension as the first element instead of the proper
     element in the external structure.

 (2) Probe cannot determine the correct value of a variable if the
     variable has an implicit subscripted base reference.
     For example:  "dcl x fixed bin based (b (3));".
     Probe (value) interprets "x based (b (3))" as b(1) -> x.


 (3) Probe cannot determine the correct value of a variable if the
     address of the variable has an implicit base reference containing
     the address expression or is a defined reference.
     For example: "dcl x fixed bin based (addr (p1))"; or
                  "dcl x fixed bin defined (p2)"


:[Info]: COBOL: cobol:
1979-09-28  Probe and COBOL

Notes on probe and the cobol language:

 Probe uses a COBOL-like syntax when the current language is COBOL.
 The current language will be COBOL whenever the current source line
 is in a COBOL program.  When in COBOL mode, probe is insensitive to
 the case of variable names.  The hyphen character can be used to form
 names, as it is in COBOL.  Aggregate names can be qualified in the
 COBOL manner (c of b of a) as well as in the PL/I manner (a.b.c) An
 aggregate is displayed by displaying the values of each of its
 members.

To find out what the current language is, use the "language" request,
with no arguments.  See "where" and "language".


:[Info]: Fortran: fortran:
1979-09-28  Probe and Fortran

Notes on probe and the fortran language:

 When the current source line is a Fortran statement, probe is in
 fortran mode, and acts a little differently.

 Logical variables are displayed as ".true." or ".false." instead of as
 "1"b or "0"b.

 Case is ignored if the program was compiled with "-card" or "-fold".

 The relational operators .le., .lt., .eq., .ne., .gt., .ge. can be
 used.


:[Info]: Pascal: pascal:
1983-09-08  Probe and Pascal

Notes on probe and the pascal language:

 Invoked on a Pascal program, probe understands all the Pascal data
 types, including enumerated types, typed pointers, sets, records,
 files, and user-defined types.  Probe understands the Pascal builtin
 functions chr, eof, eoln, false, nil, ord, and true.

 Array indices are enclosed in brackets, for example "a[i,j]".
 Cross_section ranges are written with "..", as in "a[first..last]".
 References to record fields must specify all levels; implicit level
 names are not allowed.  For example, "a.b.c.d" cannot be abbreviated
 as "a.d" as can sometimes be done with PL/1 structure elements.


 Pointer values are written with circumflex (^) as the up-arrow, for
 example "p^" to indicate the value that p points to.  String
 constants are enclosed in apostrophes: 'This is a string'.  The two
 boolean values are "true" and "false".


:[Info]: LINE: line:
1979-09-28  Syntax of a LINE

Notes on the syntax of 'line':

 A LINE is used to identify a location in an object segment, and
 possibly the source line associated with that location.  A LINE can
 be a label known in the current procedure, the name of an external
 entry, a line number in the source file for the current procedure, $b
 (which denotes the current break), or $c (which denotes the current
 line).


 Source line numbers consist of a source file number and a line number.
 The file number is optional.  If it is not specified, the main file
 (file 0) is used.  File numbers can be found by examining the
 compilation listing.  The first include file is file number 1, and so
 on.  The second part of a source line number is the actual line in
 the file.  This number is found printed on the left edge of a
 compiler listing.  It is also the number one would use with an
 editor.


Examples:

   $c	  the current line.
   $b	  the line where the latest break happened.
   259	  line 259 in the main file.
   2-43     line number 43 in include file 2.
   grotz(3) the line labeled by label array constant grotz(3).
   $101	  the line labeled by 101 (Fortran or COBOL - see below).


 To reference the Nth statement after a given statement, follow the
 line location by a comma and N.  For example, consider the COBOL
 fragment:

 para.
   add 3 to b giving c. display "Cobol is ", c. move spaces to neptune.

 the request "ps para,1" positions to the "display" statement, because
 that is the first statement after the one labeled by "para".  If the
 "display" statement is on the next line, instead of the same line,
 "ps para,1" still works.


 Fortran: Since Fortran labels are numbers, which probe also uses to
 specify line numbers, Fortran labels must be preceded by a dollar
 sign.  For example, "100" is a reference to line number 100, but
 "$100" is a reference to the line whose label is 100.


 COBOL: COBOL allows the use of labels that look like numbers.  When a
 number is used for a LINE, it refers to a source statement line
 number, not a label.  But if the number is preceded by a dollar sign,
 it is treated as the name of a paragraph label.


:[Info]: STRING.topic: STRING: string: STRINGS: strings:
1988-09-30  Syntax of character string constants.

 Probe recognizes character strings and bit strings.  A string is
 delimited by the quote character ("), and for Fortran and Pascal, the
 apostrophe (') can also be used.  In the C language a single
 character constant can be represented with an apostrophe and a string
 (which can be any number of characters from 0 to 256) is delimited by
 the quote.  The maximum length of a string is 256 characters.
 Strings can contain any character.  To enclose the quote character in
 a string, double it.  For example, "a""b" represents the string a"b
 containing a single embedded quote character.  See constants for more
 info.


Examples:
  "preceded by itself, yields falsehood"
  		         char string of length 36.

  "1010"b		         bit string of length 4.
  "033"b3		         octal bit string, 9 bits.
  "A79A"b4	         four hex digits, 16 bits.

  """"		         a string of length 1, containing a quote.
  'a Fortran string"         apostrophe and quote are equivalent.
  "newline is \012"	         a string of length 12.

  '1'		         a single character string for C
  ""		         an empty string in C


 In the C language mode you can specify parts of the character array
 in the following format:

   *p	    specifies the single character pointed to by the
              pointer "p".
   p[0:4]	    specifies the 5 characters starting with the character
              pointed to by "p".
   p[]	    specifies all the characters in the array, starting
              the character pointed to by "p", ending with either
              the null character, the 256th character, or the maximum
              size of the array which ever comes first.
   p[0:N-1]   (where N is the index to the null character) this
 	    format will over come the 256 character default and
              all the characters from "p" to "N-1" to be specified.


:[Info]: TOPIC:
1979-09-30  Misunderstanding of the help command

Notes on the help command:
 You may have misunderstood the documentation.  A word in uppercase
 like TOPIC represents any possible topic that might be supplied as an
 argument to the help request.  By typing "TOPIC" you got information
 on the subject of "TOPIC".  If you had typed a lowercase string like
 "help value", you would see information about the probe value request.
 The word TOPIC in the command description is to be replaced with the
 name of the topic you are interested in, when you type the help
 request.  Please try again.

 To see a list of all topics, type:
   list_help
 or just:
   lh


:[Info]: after: af: a:
2020-12-19  after, af, a

Syntax:  a {LINE} {:REQUEST}
         a /REGEXP/ {:REQUEST}


Function:
 This request sets a breakpoint after a location in the object
 segment.  The "after" request cannot be used on COBOL statements.
 For more information on breakpoints, type:  help breaks


Arguments:
LINE
   gives a source line number on which a statement begins.  The
   breakpoint is set after the end of that statement.  The default for
   LINE is the current line ($c).
:REQUEST
   gives the probe request (or list of requests) to be executed if the
   breakpoint is reached.  A colon (:) separates the after request
   name and optional location from the REQUEST.  The default for
   :REQUEST is ":halt".
/REGEXP/
   If /REGEXP/ is used instead of LINE, a break is set after every
   line matching the qedx regular expression REGEXP.


Notes:
 A break set after a line happens after all effects of the statement
 are completed.  If the statement sets a variable, the variable will
 have its new value by the time the break is executed.  Depending on
 the nature of the code generated by the translator for the statement,
 a break set after a line sometimes cannot be executed.  This is often
 the case for do loops and if-then-else constructions, and always the
 case for return statements and for gotos.


 For information about setting a breakpoint in a line containing
 several statements, type:  help LINE

 For information about associating several probe requests with a given
 breakpoint, type:  help REQUEST


:[Info]: arguments: args:
1985-05-04  arguments, args

Syntax: args
        args N
        args OBJECT


Function:
 The args request displays the names and values of the arguments to
 the current procedure or a specified procedure invocation.


Arguments:
N
  stack level N is used.  The default is to use the stack level
  associated with the current procedure.
OBJECT
  is the reference name of an entry point into some object segment.
  The most recent stack frame for the procedure OBJECT is used.


:[Info]: before: be: b:
2020-12-19 before, be, b

Syntax: b {LINE} {:REQUEST}
        b /REGEXP/ {:REQUEST}


Function:
 This request sets a breakpoint before the location in the object
 segment given by LINE.  For more information on breakpoints,
 type:  help breaks


Arguments:
LINE
   gives a source line number on which a statement begins.  The
   breakpoint is set before the start of that statement.  The default
   for LINE is the current line ($c).
:REQUEST
   gives the probe request (or list of requests) to be executed if the
   breakpoint is reached.  A colon (:) separates the before request
   name and optional location from the REQUEST.  The default for
   :REQUEST is ":halt".
/REGEXP/
   If /REGEXP/ is used instead of LINE, a break is set before every
   line matching the qedx regular expression REGEXP.


Notes:
 For information about setting a breakpoint in a line containing
 several statements, type:  help LINE

 For information about associating several probe requests with a given
 breakpoint, type:  help REQUEST


:[Info]: breaks.topic: breaks:
1979-09-29  Probe breakpoints

 A breakpoint is a list of one or more probe requests that is
 associated with some statement in a program.  The probe requests of a
 breakpoint are known as the break request list for the break.  A
 breakpoint can be set "before" or "after" a given line.  A break
 before a line is executed immediately before the line itself is
 executed, and a break after a line is executed after the line has
 been executed.  Therefore if a transfer is made at line X of a
 program, a break before line X is executed, but a break after line X
 is not.  If a transfer is made TO the state- ment on line X, a break
 set before line X is executed, but one set after line X-1 is not.  If
 statement X assigns a new value to a variable, a break set before X
 is executed before the variable changes, but one after X takes effect
 after the variable has been changed.


Breakpoint requests:
 To set breaks, use the "before" and "after" requests.
 To list breaks (where they are set, what is in their request lists),
    use the "status" request.
 To remove breaks, use the "reset" request.
 To resume execution after a break, use the "continue" request.


Implementation of breakpoints:
 A breakpoint is set at a particular instruction by replacing it with
 an instruction that transfers control to a special sequence of code
 that probe places at the end of the object segment.  This sequence of
 code is called the "map sequence".  It extends the current stack
 frame, stores information about the break in the extension created
 and uses a special pl1 operator to call probe.


:[Info]: builtins:
1988-09-30  Probe builtins

Notes on builtins:

 For a summary of builtins, use the "list_builtins" request.

 All probe builtins, except "ptr", are exactly equivalent to the
 Multics PL/I builtins by the same name.  The "ptr" builtin is an
 extension to the Multics "ptr" builtin.  The third argument, if
 given, is the bit offset of the resultant pointer value

 "sizeof" is the only probe builtin function available for C.

 Builtins can be prefaced with a "$" to distinguish them from program
 variables of the same name.


:[Info]: call: cl:
2020-12-19  call, cl

Syntax: cl PROC_NAME
        cl PROC_NAME (ARG1, ARG2, ... ARGn)


Function:
 Invokes an external entry point, optionally passing as arguments one
 or more variables from the current program, or other EXPRESSIONs.


Arguments:
PROC_NAME
   names the external entry point to be called.
ARG1, ARG2, ARGn
   each is an EXPRESSION whose value is passed as an argument to the
   external entry point.  The simplest EXPRESSION is the name of a
   variable declared by the current program.  EXPRESSIONs are
   documented with the value request.  For information about
   EXPRESSIONs, type:  help value


Notes:
 Only external program entry points may be called.  The call is
 performed by searching for the PROC_NAME external entry point and
 examining the entry point descriptors for its expected arguments.  If
 the given ARGi is of the data type requested in the descriptor, then
 ARGi is passed by reference.  If the called routine changes an
 argument passed by reference, that variable's value is changed after
 the call.

 If probe can't determine what type of argument the external entry
 point expects, or if the argument isn't of the expected type, the
 argument is passed by value.  EXPRESSIONs more complicated than a
 single variable name are always passed by value.  For information
 about EXPRESSIONs, type:  help value


 For information about creating temporary variables for use in call
 requests, type:  help declare


Examples:
 To invoke an external entry point that requires no arguments:

   call date_time
   12/19/20  1752.9 pst Sat

 To invoke an entry point with an EXPRESSION:

   call clock ("iso_date_time")
   2020-12-19 17:52:19 pst


 To invoke a subroutine, passing variables declared by the current
 program or declared by probe's "declare" request:

   call date_time_ (my_clock, my_time_string)

 If my_clock is declared as fixed bin(71) aligned, then it is passed
 by reference; otherwise its value is converted to that data type
 following PL1 conversion rules.  If my_time_string is declared as a
 non-varying character string, then it is passed by reference;
 otherwise its value is converted to a temporary character string, and
 that temporary string is passed as the argument.  If passed by
 reference, then the value of my_time_string is the my_clock number
 converted by the date_time_ subroutine to an equivalent character
 representation of that clock reading.


:[Info]: CONSTANTS: constants:
1979-09-29  Syntax of constants


Notes on the syntax of constants:

 Probe recognizes arithmetic constants, string constants, and pointer
 constants.  Arithmetic constants can be fixed or floating point,
 binary or decimal.  String constants can be character or bit.  Bit
 constants can be entered in any radix from binary to hex.  Numbers
 can be entered in octal.

See "NUMBER", "STRING, and "POINTER".


:[Info]: continue: c:
1989-09-29  continue, c

Syntax: c


Function:
 If used after a breakpoint, this request resumes execution of the
 program.


:[Info]: continue_to: ct:
1989-09-29  continue_to, ct

Syntax: ct LINE


Function:
 This request sets a temporary break before LINE, then continues
 execution of your program.  It is exactly equivalent to the two
 requests "before LINE:pause;continue".  When you resume after a
 temporary break, it is automatically reset.


Arguments:
LINE
   is the line number at which the new temporary break point is set.


:[Info]: CROSS-SECTION: cross-section: CROSS_SECTION: cross_section: cross_section.topic:
1988-09-30  Syntax of a cross-section


 Probe provides cross-sections to allow reference to more than one
 element of an array at a time.  To reference the i'th through j'th
 elements of an array, the cross-section reference is i:j (for Pascal,
 i..j).  Asterisk (*) is used to reference all elements of an array.


Examples:

 Suppose any of the following declarations appear:
     (PL/I) declare gosh (6) fixed bin;
     (Fortran) integer gosh (6)
     (Pascal) var gosh: array [1..6] of integer
     (COBOL) 77 gosh usage is comp-6 occurs 6 times.
     (C) int gosh [6];

 In the case of Pascal, the request "value gosh [*]" prints out all
 elements of gosh, and "value gosh [2..4]" prints out the values of
 gosh(2), gosh(3), and gosh(4).  For the other languages, the request
 "value gosh (*)" prints out all elements of gosh, and "value gosh
 (2:4)" prints out the values of gosh(2), gosh(3), and gosh(4).
 (note: for C you would use square brackets instead of parentheses.)


Limits on cross-section usage:

 Only the value and let requests use cross-sections.  cross-sections
 cannot be used as pointers to values.  cross-sections cannot be
 assigned to cross-sectionS (or scalars).


:[Info]: declare: dcl:
1988-09-30  declare, dcl

Syntax: dcl NAME TYPE {-force} {external} {defined EXPRESSION}


Function:
 This request creates new probe variables, and declares external
 variables.


Arguments:
NAME
   gives the name of a new variable.  By default, storage for a new
   variable is created in the process directory.
TYPE
   gives a keyword specifying the data type of the variable.  If
   external is not specified (i.e., creating a probe variable) and a
   another instance of variable NAME is already declared, the user is
   queried about whether to delete the old instance.
external, ext
   specifies that NAME is an existing external variable that probe may
   reference in expressions.


defined EXPRESSION
   EXPRESSION is a variable expression that designates an existing
   region of storage having one of the data types associated with a
   TYPE keyword.  See "List of type keywords" below.  NAME becomes a
   synonym for that storage region.  This feature is a typing
   convenience, allowing a short name to be used in place of a
   complicated expression.


Control arguments:
-force, -fc
   causes any prior instance of the variable to be deleted without a
   query.


List of type keywords:
   The following possible values may be given for TYPE.
fixed, integer, int, comp-6
   This type is equivalent to PL/I fixed bin (35); or Fortran, Pascal
   or C integer; or COBOL comp-6.
float, real
   This type is equivalent to PL/I float bin (27); Fortran real;
   or C float.
pointer, ptr
   This type is equivalent to PL/I aligned pointer (Multics ITS ptr).
pointer unal, ptr unal
   This type is equivalent to PL/I unaligned pointer (a packed
   pointer).


Notes:
 A warning about a name conflict is displayed if a program variable of
 the given NAME is known in the current block when the variable is
 declared.  If this warning is given, refer to the probe declared
 variable with a percent sign before its name to distinguish it from
 the program variable.


Examples:

   dcl gravel comp-6
   dcl clover ptr -force
   dcl sys_info$max_seg_size fixed external
   dcl axi fixed defined info_ptr -> aregs (i).x.index


:[Info]: display: ds:
1985-05-04  display, ds

Syntax:  ds {*} ADDRESS {FORMAT} {COUNT}


Function:
 displays an arbitrary storage location in a selected format.


Arguments:
ADDRESS
  The location displayed depends on the kind of ADDRESS supplied.  If
  ADDRESS is a reference to a program or probe variable, the storage
  location associated with that variable is displayed.  Otherwise,
  ADDRESS must be an EXPRESSION that evaluates to a pointer which
  points to the storage location that is displayed.
* ADDRESS
  If an asterisk appears before a reference to pointer variable, data
  at the storage location pointed to by that variable is displayed.


FORMAT
  is one of the supported display formats.  See "List of display
  formats" below.
COUNT
  gives the number of storage format items to display from storage at
  the given location.  The count defaults to 1.


List of display formats:
octal, o
  displays the storage location as octal words.
ascii, character, ch
  displays the storage location as characters.
bit, b
  displays the storage location as a bit string value.
binary, bin, binary35, bin35
  displays the storage location as 1-word integers.
binary71, bin71
  displays the storage location as 2-word integer.


float, f, float27, f27
  displays the storage location as 1-word floating point values.
float63, f63
  displays the storage location as 2-word floating point values.
pointer, ptr, its
  displays the storage location as 2-word pointer values.
instruction, i
  displays the storage location as interpreted instruction words.
code
  displays the storage location as a Multics status code, with the
  error message associated with that status code.


Notes:

 COUNT is the number of elements displayed.  The size of an element
 depends on the format displayed.  Note that one pointer is 72 bits
 (two words), and one instruction may be as many as four words (for
 an EIS instruction).


Examples:

   ds 253|100 octal 20	     dumps 20 words in octal.
   ds foo ascii 64		     dumps first 64 chars of foo.
   ds ip|0 i		     dumps current instruction.


:[Info]: execute: e:
1989-09-27  execute, e

Syntax: e "STRING"
        .. STRING


Function:
 Pass a STRING to the Multics command processor.  This request is
 chiefly useful in break request lists, because the more convenient
 ".." escape to the Multics command processor is not available there.

 You can pass an arbitrary line to the Multics command processor by
 preceding it with ".." on a new line.  No other requests can follow
 it on the same line.


Arguments:
STRING
  is the command line to be passed to the Multics command processor.
  As an argument to the execute (e) request, this command line must be
  enclosed in double quote (") characters.  All double quote
  characters inside the string must be doubled.  As an argument to the
  .. escape, the STRING should not be enclosed in double quotes.


Examples:

   ..ls >udd>Gtr>Weir>*.pl1
   e "ls >udd>Gtr>Weir>*.pl1"
   ..cwd >udd>Robot>Gort; dl Klaatu; ls -tt
   e "cwd >udd>Robot>Gort; dl Klaatu; ls -tt"


:[Info]: EXPRESSIONS:  expressions: EXPRESSION: expression:
1979-09-29  Syntax of expressions

Notes on expression syntax:

 Probe expressions are made up using the arithmetic operators "+", "-",
 "*", "/".  Multiply and divide operators have higher precedence than
 add and subtract operators.  Parentheses can be used to override the
 default order of evaluation.

 Many requests include an EXPRESSION in their syntax.  The probe "if"
 and "while" requests include a PREDICATE, which is a comparison of two
 EXPRESSION values.  For more information about expression comparision,
 type:  help PREDICATE


:[Info]: goto: g:
1989-09-29  goto, g

Syntax: g LINE


Function:
 This request leaves probe and resumes execution of your program at
 LINE.  It is an error to use this request if the LINE is in a program
 that is not active.

 Because of unpredictable compiler optimizations, this request can be
 dangerous to use if the program was compiled with -optimize.  For
 more information, type:  help optimization


Arguments:
LINE
   gives a source line number on which a statement begins.


Notes:
 For information about selecting a statement in a line containing
 several statements, type:  help LINE


:[Info]: halt: h:
1989-09-29  halt, h

Syntax: h


Function:
 This is the default break request.  It invokes a new probe command
 level.  It has no effect when typed at probe command level, only when
 in break requests.  If a break is set with no break request list
 supplied by you, halt is assumed.


:[Info]: handlers:
1985-05-04  handlers

Syntax: handlers
        handlers N
        handlers OBJECT


Function:

 The handlers request displays the condition names and actions of the
 condition handlers established by the current procedure or a
 specified procedure invocation.


Arguments:
N
  gives the stack level N for the program block whose handlers are
  displayed.
OBJECT
  selects the most recent stack frame for the procedure OBJECT.


Notes on handlers:

 Information about a handler is printed in the following format:

	on CONDITION_NAME {(FILENAME)} {snap} ACTION

 where ACTION is one of the following:

	call PROCEDURE_NAME
	begin block at line N
	system


:[Info]: help:
1989-09-29  help

Syntax:  help
         help *
         help TOPIC {-control_args}


Function:
 The help request prints information about probe.


Arguments:
TOPIC
  prints information about TOPIC.  Topic may be the name of a probe
  request, or the name of some other probe topic.  If TOPIC is
  omitted, help prints general information about probe.
*
  If the argument is an asterisk, help prints a list of all
  probe-related topics for which info exists.


Control arguments:
   One of the following control arguments may be given in each
   request. 
-brief, -bf
   displays a summary of request syntax, arguments, and control
   arguments.
-control_arg ARG_NAME, -ca ARG_NAME
   displays full information about the given argument or control
   argument or item in a "List of ..." section.


Examples:

   help help          prints this info.
   help status        prints information about the "status" request.
   help errors        prints information about known errors in probe.


:[Info]: if:
1989-09-29  if

Syntax: if PREDICATE :REQUEST


Function:
 The "if" request evaluates its PREDICATE argument.  If the result is
 true, REQUEST is executed, otherwise it is skipped.  The if request is
 especially useful in breakpoint request lists, where it can be used to
 cause a conditional breakpoint.


Arguments:
PREDICATE
   is a comparison of two EXPRESSIONS that evaluates to true ("1"b) or
   false ("0"b).  For more information, type:  help PREDICATE
:REQUEST
   gives the probe request (or list of requests) to be executed if
   PREDICATE evaluates to true.  A colon (:) separates the PREDICATE
   from the request list.  For more information, type:  help REQUEST


Examples:

 To stop whenever the variable "odin" equals 1, the breakpoint request
 list can include the request:  if odin = 1 : halt


:[Info]: input_description: ids:
1985-05-04  input_description, ids

Syntax: ids ATTACH_DESCRIPTION


Function:
 This request takes creates a new I/O switch, attaches that switch
 through a given I/O module to a device or file, and opens that switch
 for stream_input.  probe then reads all its input from this switch
 until a subsequent input_description or input_switch request is given.


Arguments:
ATTACH_DESCRIPTION
   gives a full I/O attach description.  It includes the name of an
   I/O module followed by arguments specifying a device, media, or
   file to which that I/O module should be attached.  The I/O module
   must support the stream_input opening mode.


Notes:
 The effects of input_switch, output_switch, input_description and
 output_description, unlike other requests, are static to the process
 and remain from one probe invocation to the next until reverted.

 For information about reverting, type:  help input_switch


Examples:

   ids tty_ stereo_console

 causes further probe input to be read from the device stereo_console.


:[Info]: input_switch: isw:
1985-05-04  input_switch, isw

Syntax: isw {SWITCH_NAME}


Function:
 Reverts probe input source to the default I/O switch: user_input; or
 switches probe input to another I/O switch.


Arguments:
SWITCH_NAME
   is the name of an I/O switch which is already attached and open for
   stream_input or stream_input_output.  If SWITCH_NAME is omitted,
   probe reads from the user_input switch.


Notes:

 The effects of input_switch, output_switch, input_description and
 output_description, unlike other requests, are static to the process
 and remain from one probe invocation to the next until reverted.


:[Info]: language: lng:
1989-09-29  language, lng

Syntax: lng {LANGUAGE_NAME}


Function:
 Given the name of one of the languages supported by probe, this
 request sets the current language mode.  Otherwise, it displays the
 name of the current language mode.


Arguments:
LANGUAGE_NAME
   may be one of the names in "List of language types" below.


List of language types:
   The LANGUAGE_NAME argument may be one of the following:
PL/I, pl1, PL1
FORTRAN, fortran, fortran2, FT, ft
COBOL, cobol
ALM, alm
ALGOL68, Algol68, algol68, a68
PASCAL, pascal
C, c


:[Info]: let: l:
1989-09-29  let, l

Syntax: let VARIABLE = EXPRESSION
        l CROSS-SECTION = EXPRESSION


Function:
 This request sets the VARIABLE or CROSS-SECTION to the value of
 EXPRESSION.


Arguments:
VARIABLE
   gives the name of a program variable or probe variable (storage
   created by the probe declare request) whose value is set.
CROSS-SECTION
   is a VARIABLE followed by a range of array index values.  For
   syntax details of a cross-section, type:  help cross-section
EXPRESSION
   gives a value to be assigned to the VARIABLE or CROSS-SECTION
   array elements.  If type conversion is needed, it is performed
   according to the conversion rules of PL/I.  Certain data types
   cannot be assigned to any type other than their own (e.g.  area,
   file).


Notes on assigning values:

 Because of unpredictable compiler optimization, the change sometimes
 may not take effect, even though the "value" request seems to show
 that it has.  For more information, type:  help optimization


:[Info]: list_builtins: lb:
1985-01-11  list_builtins, lb

Syntax: lb


Function:
 This request prints a summary of all builtins and their meanings.


:[Info]: list_help: lh:
1989-09-29  list_help, lh

Syntax: lh


Function:
 The list_help request prints a summary of all TOPICS for which there
 is info.  The topics are divided into three categories.  Most files
 are infos in the segment probe.info, so to see a copy of all probe
 information, print the entire segment.

To print information on a topic, type:  help TOPIC


:[Info]: list_variables: lsv:
1985-01-11  list_variables, lsv

Syntax: lsv {NAMEs}


Function:
 This request lists all variables that have been declared by the
 "declare" request in the current invocation of probe, along with
 their types and values.


Arguments:
NAME
   If one or more NAMEs are supplied, then only those variables are
   listed.  By default, all defined variables are listed.


:[Info]: modes: mode:
1985-11-07  modes, mode

Syntax: mode               (for display only)
        mode MODE VALUE    (to set mode values)


Function:
 A mode is a probe variable that specifies how a particular function
 behaves.  This request displays current mode settings, and changes
 the value of a given mode.

 For a description of available modes, see "List of modes" below.


Arguments:
MODE
   gives the name of a mode to set.
VALUE
   gives the new value for MODE.   Most modes can be set to a value
   that is either a LENGTH or a BOOLEAN.

   A LENGTH is either "long" ("lg"), "short" ("sh") or "brief" ("bf"),
   and is used to specify the kind or amount of printing to be done by
   the part of probe.  The amount of output is greatest for "long",
   least for "brief", and "short" is intermediate.  In some cases
   "short" is synonymous with "brief".

   BOOLEAN is used to turn a feature on or off.  It can be "yes",
   "on", or "true"; or "no", "off", or "false".


List of modes:
error_messages, em
  (LENGTH) controls the length of the text used for an error message.
  Possible values for this mode are:
     long: full message text is printed (default).
    brief: short error message keywords are printed.

qualification, qf
  (LENGTH) controls the format of variables names as printed by the
  value request.  Possible values for this mode are:
     long: prints names with full qualification.
    brief: prints only the last name of a structure (default).
  Note that COBOL and Fortran names are always printed briefly,
  regardless of the value of this mode.


value_print, vp
  (LENGTH) controls whether or not the value request prints the name
  of a variable.  Possible values for this mode are:
     long: names are always printed.
    short: names of array and structure elements are shown (default).
    brief: values are printed without names.

value_separator, vs
  (STRING) controls the string printed by the value request between
  the name of a variable and its value.  Only the first 32 characters
  of STRING are used.  The default value_separator is " = ".


truncate_strings
  (BOOLEAN) truncates character and bit string values to 200
  characters or bits, printing "<MORE>" at the end if the string is
  longer than 200.  This mode is on by default.

meter
  (BOOLEAN) controls the printing of meter values when breaks are
  hit.  The meter values are the number of minutes and seconds of
  real time ("TIME"), the number of seconds of virtual cpu time
  ("VCPU"), and the number of page faults ("PAGE FAULTS") since
  the last break was restarted or since "mode meter on".  These
  values do not include any overhead from probe itself.


prompt
  (BOOLEAN) controls whether or not probe prints a prompting
  string on the terminal when it is listening for a request.  It
  is off by default.  See the "prompt_string" mode.

prompt_string
  (STRING) specifies the string to be used for prompting.  The
  initial value is "probe^[(^d)^]  ".  STRING is used in a call to
  ioa_$nnl, where the first argument is a bit (1) that is on if
  the current invocation of probe is recursive, and the second
  argument is the current probe depth.


:[Info]: NUMBER: number:
1979-09-30  number

Notes on the syntax of numeric constants:

 Probe recognizes numeric constants using the rules of PL/I.  A
 numeric constant can be binary or decimal, fixed or float.  A binary
 numeric constant uses only "1" and "0" as digits, and always has a
 trailing "b".  A decimal constant uses the digits "01234565789", or
 lacks the trailing "b".  The type of a constant is determined by its
 literal appearance.


Examples:

   259		fixed decimal (3)
   -1101b		fixed binary (4)
   12.3		fixed dec (3,1)
   4.21f10	fixed dec (3,-8)
   4.301e10	float dec (4)

 Integers can be entered in octal by following them with a lower case
 "o".  (This is not found in PL/I.) Example --

   123o		fixed bin (35), value is 83 decimal

Fortran double precision constants are not implemented.


:[Info]: object: obj:
1985-05-04  object, obj

Syntax: obj {N}


Function:
 Displays the assembly instructions for source lines.


Arguments:
N
  specifies the number of source lines for which instructions are
  displayed.  By default, N is 1.


:[Info]: optimization:
1989-09-30  optimization

Notes on the ill effects of optimization:

 Optimization is an action performed by Multics translators to
 generate efficient code.  This can cause problems for probe, and
 therefore one should not try to use probe on a segment compiled with
 "-optimize".


Notes on optimization and the 'value' and 'let' requests:

 One class of problems arises when a compiler stores the value of a
 variable in a register, instead of in memory.  Probe looks in memory
 for the variable, and obtains an obsolete copy of its value.  You can
 try to set the variable.  Probe has no way of knowing which register
 holds the current copy of the value, and so it changes the value in
 storage.  When the register is later stored, this wipes out the value
 stored by probe.  This problem is particularly insidious, because
 until the value is wiped out, a look at it with the "value" request
 will seem to show the proper value.


Notes on optimization and 'gotos':

 Most compilers perform some optimizations on an inter-statement
 basis.  This means that the compiler takes advantage of the fact that
 if there are no labels on statement N, and if statement N is
 executed, then statement N-1 must also have been executed, and that
 any values calculated then are still valid.  This assumption is made
 false by using the probe goto, which can transfer to any line.  To
 use the probe goto safely, one should only goto lines with labels.
 This request will become safer when compilers are able to suppress
 this optimization, which will happen in some future release of
 Multics.


:[Info]: output_description: ods:
1985-05-04  output_description, ods

Syntax: ods ATTACH_DESCRIPTION


Function:
 This request takes creates a new I/O switch, attaches that switch
 through a given I/O module to a device or file, and opens that switch
 for stream_output.  probe then writes all its output to this switch
 until a subsequent output_description or output_switch request is
 given.


Arguments:
ATTACH_DESCRIPTION
   gives a full I/O attach description.  It includes the name of an
   I/O module followed by arguments specifying a device, media, or
   file to which that I/O module should be attached.  The I/O module
   must support the stream_output opening mode.


Notes on output description:

 The effects of input_switch, output_switch, input_description and
 output_description, unlike other requests, are static to the process
 and remain from one probe invocation to the next until reverted.

 For information about reverting, type:  help output_switch


Examples:

   ods vfile_ probe_trace.output

 causes further output to be written to the segment
 'probe_trace.output'.


:[Info]: output_switch: osw:
1985-09-17  output_switch, osw

Syntax: osw {SWITCH_NAME}


Function:
 Reverts probe output (except for error messages) to the default I/O
 switch: user_output; or switches probe output (except for error
 messages) to another I/O switch.


Arguments:
SWITCH_NAME
   is the name of an I/O switch which is already attached and open for
   stream_output or stream_input_output.  If SWITCH_NAME is omitted,
   probe writes non-error output to the user_output switch.


Notes on restoring the output switch:

 The effects of input_switch, output_switch, input_description and
 output description, unlike other requests, are static to the process
 and remain from one probe invocation to the next until reverted.


:[Info]: PATH: path:
1979-09-30  path

Notes on the syntax of a path:

 Some probe requests accept a Multics pathname as an argument.  If a
 PATH contains characters other than the letters of the alphabet, the
 digits 0-9, or the characters ">", "<", ".", ",", "-", "_", "$", or
 "/", it must be enclosed in quotes.


Examples:

   >udd>SoftWork>Brie>dog_lb	absolute pathname
   hunter>aoxo$moxoa	relative pathname
   "PSC+OCCUPATION.10|06|79"	strange characters


:[Info]: pause: pa:
1989-09-30  pause, pa

Syntax: pa


Function:
 The pause request is useful in breakpoint request lists.  It is like
 halt, in that it causes execution of the breakpoint request list to
 be suspended and probe to read from the terminal.  Unlike "halt",
 when the breakpoint is continued (by the "continue" request), the
 break is immediately reset.  The effect is a one-time-only temporary
 break.  The "pause" request is used to implement the "step" and
 "continue_to" requests.


:[Info]: POINTER: pointer:
1979-09-30  pointer

Notes on the syntax of probe pointer constants:

 Probe pointer constants are of the form SSS|WWW or SSS|WWW(bbb) where
 SSS is the segment number in octal, WWW is the word offset in octal,
 and bbb is the bit offset (optional) in decimal.  SSS can be replaced
 with a two letter code to specify a pointer relative to the current
 stack frame (sp), linkage section (lp), text segment (tp), or
 instruction (ip).


Examples:

   254|100(13)	bit 13 of word 100 in segment 254
   sp|2500	word at offset 2500 in current stack frame
   ip|0		instruction last executed
   lp|10		word 10 in linkage section


:[Info]: pointers.topic: pointers: source_pointer: control_pointer:
1985-03-14  pointers for source and control location

 Two pointers keep track of the program's state.

   source   indicates current source-program statement.
   control  indicates current control point.

 The values of the pointers can be obtained using the "where" request.
 The source pointer is set using the "position" or "use" request.  The
 control pointer is set when probe is entered.


Notes on the probe 'source' pointer:

 The source pointer always indicates some location in a program.  If
 the program is active, then it indicates a stack frame associated
 with the program.  If the object segment was compiled with the
 "table" options then a source line number will be available,
 otherwise the location will be indicated by an octal offset from the
 base of the segment to an instruction.


 If the program was compiled with a "table" option, probe obtains the
 text of source lines from the program's source segment (NAME.pl1,
 NAME.fortran, etc.).  This is either the segment that the program was
 originally compiled from, if it exists, or the first segment with the
 appropriate name found using the "probe" search paths.  If no source
 segment can be found, the position and source requests are unable to
 print source lines.


Notes on the probe 'control' pointer:

 If probe was invoked by a breakpoint, the control pointer indicates
 the statement where the break occurred.  If probe was invoked from
 the command line, it indicates either: the last location executed in
 the procedure first examined, whether it took a fault, or called out;
 of if the procedure was inactive, the control pointer is the location
 of the entry statement for the procedure.


:[Info]: position: ps:
2020-12-21  position, ps

Syntax:
  ps {OPERANDs}


Function:
 Sets the source pointer to the statement specified and prints the
 statement.  For information on repositioning without printing the
 source statement, type:  help use


Arguments:
OPERAND
  The position request accepts many different operand types.  See a
  complete list in the following section.


List of position operands:
  Items below show the position request being used with each form
  of operand.
ps
  with no operands, position resets the source pointer to its initial
  value (same as the control pointer).
ps LINE
  positions to a LINE in the current procedure.  This could be a line
  number, or one of the line reference symbols.  For details, type:
    help LINE
ps +N
  position to the statement N statements after the current one.
ps -N
  position to the statement N statements before the current one.


ps line +N
  position to the statement N lines after the current one.
ps line -N
  position to the statement N lines before the current one.
ps level N
  position to the last line executed in the block at stack level N.
ps level +N
  position to the last line executed for the block N levels more
  recent than the current stack level.
ps level -N
  position to the last line executed for the block N levels less
  recent than the current stack level.


ps OBJECT
  position to the last line executed in the most recent invocation of
  OBJECT, where OBJECT is a program reference.  For more information,
  type:  help OBJECT
ps "STRING"
  search in the source for the next statement containing the literal
  string.  STRING may be any program label, or statement element.
ps /REGEXP/
  search in the source for the next statement that matches the qedx
  regular expression REGEXP.


Notes on positioning:

 In PL/I, names (including labels) are not available to probe when the
 source pointer is outside the block in which they are declared.  This
 means that probe cannot find a label in an internal procedure or
 begin block unless that block is now the "current block".  The label
 can still be found by a search for a character string that appears in
 the labeled line (e.g., "program_label:").

 The source segment used is either the one that the program was
 originally compiled from, if it exists, or the first segment with the
 appropriate name (NAME.pl1, NAME.fortran, etc.) found using the
 "probe" search paths.  If no source segment can be found, probe is
 unable to search in source, or print source lines.


 It is only possible to set the source pointer to an executable
 statement.  Every language has certain statements that are not
 executable.  Blank lines, comments, and declarations are not
 executable in any language.  For more information, type:
    help where
    help LINE


:[Info]: PREDICATE: predicate:
1988-09-30  predicate

Notes on the syntax of a predicate:

 EXPRESSION COMPARISON EXPRESSION

 where COMPARISON is one of the following operators:
     "<", ">", "<=", ">=", "=", "^=".

 A PREDICATE is a comparison of two values, and yields a Boolean
 value.  (A Boolean variable is one that can have only two possible
 values, corresponding to "true" or "false".  PL/I uses bit (1) for
 Boolean variables, Fortran use logical.  The concept is absent from
 COBOL.)  The "if" and "while" requests accept a predicate, then
 perform some action if the predicate is true.


 In Fortran mode, the Fortran equivalents (".lt.", ".gt.", etc.) are
 allowed and in C mode, "=" and "^=" have the equivalents "==" and
 "!=" respectively.


Notes on the predicate restrictions:

 PREDICATES cannot be nested or combined.  In a future release, the
 operators "&", "|", and "^" will be available, but not now.


:[Info]: quit: q:
1989-09-30  quit, q

Syntax: q


Function:
 It exits the current invocation of probe.  If the current invocation
 was a recursive invocation, you may still be in probe, although at a
 lower level.


:[Info]: REQUEST: request:
1979-09-30  request

Notes on the syntax of a probe request:

 Probe requests begin with the name of the probe function to be used
 (such as "value", or "help") followed by the arguments to the
 request.  A request ends with a newline or with a semicolon.

 Certain requests accept a request or list of requests as one of their
 arguments (e.g.  "before", "after", "if" and "while").  When a
 request accepts a request (or list of requests) as an argument, the
 argument (which is called a REQUEST) is preceded by a colon
 (":").  A :REQUEST can be either a single request, or a list of
 requests enclosed in parenthesis and separated from each other by a
 semicolon (";").


Examples:

 before 259 : (value a; value b)
   sets a break before line 259.  When this break is hit, the values
   of variables a and b are printed.
 before 680: if a = 3: halt
   nests 3 levels of requests.  When the break at line 680 is hit,
   the "if" request is executed.  If a=3, then, the "halt" request
   is executed.


:[Info]: reset: r:
1985-05-04  reset, r

Syntax:
  r {OPERAND} {-control_arg}


Function:
 Resets probe breaks at selected lines in selected procedures.  Line
 number of each reset breakpoint is printed as the break is removed.


Arguments:
OPERAND
  may be any of the items shown below in "List of reset operands".


Control arguments:
-brief, -bf
  suppresses printing of line numbers as breakpoints are removed.


List of reset operands:
  Items below show the reset request being used with each form
  of operand.
reset
  reset the break at the current statement, if any.
reset {before|after} LINE,
 r {be|af} LINE,
 r {b|a} LINE
  reset the break at LINE in the current procedure.  This could be a
  line number, or one of the line reference symbols.  If STRING is
  preceded by the keyword "before" (or "be" or "b"), only breaks
  before statements are removed.  If preceded by "after" (or "af" or
  "a"), only breakpoints after statements are removed.  For details,
  type:  help LINE


reset OBJECT
  reset all breaks in the object segment OBJECT.
reset -all,
 r *
  reset all breaks set by you in all segments.
reset {before|after} "STRING",
 r {be|af} "STRING",
 r {b|a} "STRING"
  reset all lines containing STRING in the current procedure.
  STRING may be any program label, or statement element.  If STRING is
  preceded by the keyword "before" (or "be" or "b"), only breaks
  before statements are removed.  If preceded by "after" (or "af" or
  "a"), only breakpoints after statements are removed.


reset {before|after} /REGEXP/,
 r {be|af} /REGEXP/,
 r {b|a} /REGEXP/
  reset breaks at all lines matching the regular expression REGEXP.
  If REGEXP is preceded by the keyword "before" (or "be" or "b"), only
  breaks before statements are removed.  If preceded by "after" (or
  "af" or "a"), only breakpoints after statements are removed.


:[Info]: source: sc:
1985-03-14  source, sc

Syntax: sc {COUNT}
        sc path PATHNAME


Function:

 The first form prints the next N source statements, beginning with
 the current one.  If COUNT is omitted, then one statement is printed.
 Any lines in the source segment between the first and last statement
 lines are printed.

 The second form is used to specify the location of the source
 segment.  It is useful when the source has been moved since the
 object segment was compiled.  In this second form, the literal
 keyword "path" is followed by the pathname, for example:
   sc path >udd>Wire>u>Doon>new_program.pl1


Arguments:
COUNT
  is in integer giving the number of source statements to display.
path PATHNAME
  gives the PATHNAME for the source segment compiled to create the
  object being probed.


Notes on the source request:

 If the "sc path PATHNAME" form has not be used, the source segment is
 either: the source program originally compiled to create the object,
 if it exists; or the first segment with the appropriate name
 (NAME.pl1, NAME.fortran, etc.) found using the "probe" search paths.
 If no source segment can be found, probe is unable to print source
 lines.


:[Info]: stack: sk:
1985-05-04  stack, sk

Syntax:
  sk {{N,} COUNT} {all} {long}


Function:
 Displays your stack, showing block names and line numbers (if known)
 last executed in each frame, and conditions raised.  Each frame is
 displayed with a number, which is the "level number", and used in
 various requests to indicate a stack frame.  Most recent stack frames
 have higher levels and appear earliest in the display.


Arguments:
COUNT
  gives the number of stack frames to display.  The default is to
  display all frames.
N
  gives a starting "level number".  COUNT frames are displayed
  beginning with that level and including earlier frames.
all
  includes "support" frames in the trace.  By default, these frames
  are skipped.  See "Notes on support frames" below.
long
  prints the pathname for the object segment that owns each stack
  frame.


Notes on support frames:

 Support frames are frames that belong to a support procedure.  A
 support procedure is a system utility that performs action directly
 related to the compiled user code (for example, allocation) and in
 which there is a high probability that any errors that arise are due
 to improper use by the calling program (such as allocating in a full
 area).  When conditions arise in support frames, the standard Multics
 error handler attributes the error to the code that called the
 support procedure, rather than the support procedure.

 The probe "stack" request does not display support frames unless
 invoked as "stack all".  Support frames are given incremental numbers
 between those of the surrounding frames (6.1, 6.2, ...).


Examples:

   sk 4, 3 all    displays frames 4, 3, and 2.
   sk 3           displays three frames, starting with the most recent


:[Info]: status: st:
1989-09-30  status, st

Syntax:
  st {OPERANDs} {-control_arg}


Function:
 Displays line numbers of breaks, and optionally the break request
 list.


Arguments:
OPERAND
  may be any of the items shown below in "List of status operands".


Control arguments:
  One of the following control argument may be given with a status
  request.  If neither is given, the break request list is
  displayed for the "status LINE" request, and omitted for other
  status requests.
-long, -lg
  displays the break request list for each displayed breakpoint.
-brief, -bf
  suppresses display of the break request list.


List of status operands:
  Items below show the status request being used with each form
  of operand.
status
  displays all breaks in the current procedure.
status {before|after} LINE,
 st {be|af} LINE,
 st {b|a} LINE
  displays the break at LINE in current procedure.  This could be a
  line number, or one of the line reference symbols.  For details,
  type:  help LINE

  If LINE is preceded by the keyword "before" (or "be" or "b"), only
  breaks before the statement is displayed.  If preceded by "after"
  (or "af" or "a"), only breaks after the statement is removed.


status OBJECT
  displays all breaks in object segment named OBJECT.
status *
  displays the pathnames of all object segments in which breaks were
  set by the user.
status -all,  st -a
  displays breaks set by the user in all object segments.  If status
  is used without any OPERAND, the default displays breaks only in the
  current procedure.


Examples:

   status >udd>Dog20>foo>zloty   lists all breaks in zloty.
   status 35 -lg                 lists breaks and text at line 35.
   st b 7	                       lists only the break before line 7.
   st -all                       lists all breaks set by you.


:[Info]: step: s:
1989-09-30  step, s

Syntax: s


Function:
 The step request places a temporary break (see "pause") at the
 statement that it feels is "next", and then resumes executing your
 program.  It is somewhat unreliable (see below) but, when it works,
 it allows you to step through the program a statement at


Notes on the pitfalls of the step request:

 The reason that "step" is so unreliable is that often the statement
 that comes next in the object segment is not the next one executed by
 the program.  This happens when the current statement is a call, a
 goto, the "end" statement of a loop (or continue statement for
 Fortran), or the "then" statement of an "if-then-else".  (There are
 other statements that fail, but these are the most common).  In some
 cases (do loop, call), the "next" statement is eventually executed,
 and the break occurs.


:[Info]: symbol: sb:
1988-09-30  symbol, sb

Syntax: sb VARIABLE {long}


Function:
 This request displays the attributes of a program variable (symbol)
 or probe-declared variable.


Arguments:
VARIABLE
   gives the name of a program variable or probe variable (storage
   created by the probe declare request) whose attributes should be
   displayed.
long
   display attributes of all members of a PL/1 or C structure, or a
   COBOL or Pascal record referenced by the VARIABLE name.


:[Info]: use:
2020-12-21  use

Syntax:
  use {OPERANDs}


Function:
 Sets the source pointer to the statement specified and but does
 not print the statement.  For information on printing the
 source statement when repositioning, type:  help position


Arguments:
OPERAND
  The use request accepts many different operand types.  See a
  complete list in the following section.


List of use operands:
  Items below show the use request being used with each form
  of operand.
use
  with no operands, use resets the source pointer to its initial
  value (same as the control pointer).
use LINE
  positions to a LINE in the current procedure.  This could be a line
  number, or one of the line reference symbols.  For details, type:
    help LINE
use +N
  position to the statement N statements after the current one.
use -N
  position to the statement N statements before the current one.


use line +N
  position to the statement N lines after the current one.  This
  differs from the "use +N" operand when the current line contains
  more than one statement.
use line -N
  position to the statement N lines before the current one.
use level N
  position to the last line executed in the block at stack level N.
use level +N
  position to the last line executed for the block N levels more
  recent than the current stack level.
use level -N
  position to the last line executed for the block N levels less
  recent than the current stack level.


use OBJECT
  position to the last line executed in the most recent invocation of
  OBJECT, where OBJECT is a program reference.  For more information,
  type:  help OBJECT
use "STRING"
  search in the source for the next statement containing the literal
  string.  STRING may be any program label, or statement element.
use /REGEXP/
  search in the source for the next statement that matches the qedx
  regular expression REGEXP.


Notes on positioning:

 In PL/I, names (including labels) are not available to probe when the
 source pointer is outside the block in which they are declared.  This
 means that probe cannot find a label in an internal procedure or
 begin block unless that block is now the "current block".  The label
 can still be found by a search for a character string that appears in
 the labeled line (e.g., "program_label:").

 The source segment used is either the one that the program was
 originally compiled from, if it exists, or the first segment with the
 appropriate name (NAME.pl1, NAME.fortran, etc.) found using the
 "probe" search paths.  If no source segment can be found, probe is
 unable to search in source, or print source lines.


 It is only possible to set the source pointer to an executable
 statement.  Every language has certain statements that are not
 executable.  Blank lines, comments, and declarations are not
 executable in any language.  For more information, type:
    help where
    help LINE


:[Info]: value: v:
1988-09-30  value, v

Syntax:  v EXPRESSION {data}
         v CROSS-SECTION {data}


Function:

 The value request displays the value of a given EXPRESSION or
 CROSS-SECTION.


Arguments:
EXPRESSION
  gives a variable name or expression.  Character string values are
  surrounded by double-quote (") and double-quotes inside them are
  doubled.  For the syntax of an EXPRESSION, type:  help expressions
CROSS-SECTION
  gives a cross-section reference.  For the syntax of a cross-section,
  type:  help cross-section
data
  The data pointed to by C pointers may be displayed by following the
  EXPRESSION or CROSS-SECTION with the keyword "data".


Notes:
 You can control the circumstances under which the name of the
 variable being displayed is printed, the way a name is printed if it
 is printed, and the string that separates the name from the value.
 For details, type:  help modes

 If the EXPRESSION is an external function, it is called and its
 return value is displayed.  For details, type:  help call


Examples:
 The simplest example of an EXPRESSION is the name of a variable, for
 example:
    v subr_args.ptr_len
 which prints the value of the variable or substructure ptr_len in the
 structure subr_args.


:[Info]: variables:
1985-01-15  variables

Notes on probe variables:

 Probe variables are variables created by the probe declare request.
 They are used like variables from programs.  Unlike program
 variables, probe variables are not associated with a given block.
 Once defined, they can be referenced no matter what value the source
 pointer has.  All probe variables are discarded when the process
 ends.


Examples:

 Suppose there is a PL/1 structure 'struc' that is threaded onto a
 linked list by the pointer 'next', and you want to count the number
 of structures.  This can be done by creating two probe variables, a
 pointer 'p', and a counter 'i', and using them in a while loop as
 follows:

   declare p ptr
   declare i integer
   let p = first
   let i = 0
   while p ^= null : (let i = i + 1; let p = p -> struc.next)


 If the current program declares a variable with the same name as a
 probe variable, the program variable is used.  To reference the probe
 variable, preface it with a percent sign, e.g.  %p or %i in the above
 example.  It is recommended for clarity that probe variables always
 be prefixed by %.


:[Info]: where: wh:
1985-09-24  where, wh

Syntax:
  wh {OPERANDs}


Function:
 This request displays the values of the probe pointers.  For
 definitions of these pointers, type:  help pointers


Arguments:
OPERAND
  The where request accepts several different operands.  See a
  complete list in the following section.


List of where operands:
  Items below show the where request being used with each form
  of operand.  If where is invoked with no arguments, it displays the
  values of the source and control pointers.
wh source
  prints the value of the source pointer.
wh source path
  prints the pathname of the segment referenced by the source pointer.
  (ie., the source segment currently in use).
wh {control|object}
  prints the value of the control pointer.
wh {control|object} path
  prints the value of the control pointer and the pathname of the
  segment referenced by the control pointer (ie., the current object
  segment).


:[Info]: while: wl:
1989-09-30  while, wl

Syntax: wl PREDICATE :REQUEST


Function:
 This request executes REQUEST repeatedly verifying that PREDICATE is
 true before each execution.  Execution stops when PREDICATE is false.
 For information about testing a PREDICATE, type:
   help PREDICATE
   help if
   help REQUEST

 For an example of the while request, type:  help variables


Arguments:
PREDICATE
  compares two expressions using a Boolean operator, returning a
  true-or-false value.  For details, type:  help PREDICATE
:REQUEST
   gives the probe request (or list of requests) to be executed if the
   PREDICATE evaluates to true.  A colon (:) separates the PREDICATE
   from the REQUEST.  For details, type:  help REQUEST


:hcom:

/****^  HISTORY COMMENTS:
  1) change(2020-12-19,GDixon), approve(2021-02-22,MCR10084),
     audit(2021-05-27,Swenson), install(2021-05-27,MR12.6g-0055):
      A) Convert all heading line dates to iso_date format.
      B) All info blocks but the first document probe requests or
         other subsystem topics.  Therefore, none of the names on
         these info blocks should be added as external names on the
         probe.info segment.  Change the :Info: divider to :[Info]: to
         inform verify_info of this intended naming scheme.  probe's
         help request will display such "internal" info blocks using
         help_'s info_name selection value.
      C) Under verify_info rules, an info block whose first section
         title is "Syntax" with heading line date before 1985 is
         treated as documenting a command.  Since probe wants all
         such blocks treated as a Request, all of the 1979 years were
         changed to 1989; 1980, 1981, 1982, 1983, and 1984  were
         changed to 1985.
      D) Many requests had Syntax lines that referenced arguments
         without providing an Arguments section to describe them.
         Instead, they were mentioned in summary fashion in the
         Function section.  For these requests, an Arguments section
         was added in that request's info block.
      E) Enhance documentation for the "call" request.
      F) Enhance documentation for "position" and "use" requests by
         including text from MPM Commands writeup of probe.
      G) Change probe "help" request to support -brief and -control_arg
         arguments, and TOPIC values containing two hyphenated words
         (e.g., CROSS-SECTION).
                                                   END HISTORY COMMENTS */

