02/13/84  ring_zero_peek_

The ring_zero_peek_ subroutine is used to copy information out of an
inner ring segment.  The user must have access to either the phcs_ gate
or the metering_ring_zero_peek_ gate in order to use any of the entry
points in this subroutine.  The phcs_ gate allows unrestricted access
to all inner ring segments; metering_ring_zero_peek_ allows the user to
examine specifically those data bases that are useful for metering the
system.  The program chooses the appropriate gate depending on the
user's access and the segments being examined.


Entry points in ring_zero_peek_:
   (List is generated by the help command)


:Entry: ring_zero_peek_: 02/13/84 ring_zero_peek_

Function: copies information out of a segment in the Multics
supervisor, given a pointer to it.


Syntax:
declare ring_zero_peek_ entry (ptr, ptr, fixed bin(19), fixed bin(35));
call ring_zero_peek_ (ptr0, ptr_user, nwords, code);


Arguments:
ptr0
   is a pointer to the data in ring 0 that is to be copied out.
   (Input)
ptr_user
   is a pointer to the region in the user's address space where the
   data is to be copied.  (Input)
nwords
   is the number of words to be copied.  (Input)
code
   is the standard status code that is nonzero if the user did not have
   access to the requested data.  (Output)


:Entry:  by_definition:  02/13/84 ring_zero_peek_$by_definition


Function: copies information out of a named segment in the Multics
supervisor, starting at a named symbol.  It is like
ring_zero_peek_$by_name, except that the copying is done from the
specified definition, rather than from the base of the segment.


Syntax:
declare ring_zero_peek_$by_definition entry (char(*), char(*),
     fixed bin(18), pointer, fixed bin(19), fixed bin(35));
call ring_zero_peek_$by_definition (segment_name, symbol_name, offset,
     ptr_user, word_count, code);


Arguments:
segment_name
   is the name of the supervisor segment from which words are to be
   copied.  (Input).  It cannot be a pathname.
symbol_name
   is the name of the external symbol in the specified segment at which
   copying is to start.  (Input)
offset
   is the offset from the specified definition at which copying is to
   start.  (Input).  It can be specified as zero to cause copying to
   start at the specified definition.


ptr_user
   is a pointer to the area in the outer ring where the data is to be
   copied.  (Input)
word_count
   is the number of words to be copied.  (Input)
code
   is a standard status code.  (Output).  It is nonzero if the segment
   cannot be found, if the specified external symbol does not exist or
   is ambiguous, or if the user does not have sufficient access to copy
   the requested data.


Notes:  This entry point can be used to avoid a call to ring0_get_.
For examining segments in the supervisor, this entry point and the
by_name entry point are recommended because they are much simpler
to use than ring0_get_, and they are only minimally less efficient.
Generally, it is nearly as efficient to use this entry point as it is
to save static pointers to inner ring objects.


:Entry:  by_name:  02/13/84 ring_zero_peek_$by_name


Function: copies information out of a named segment in the Multics
supervisor.  It is like ring_zero_peek_, except that the name of the
ring zero segment is provided, rather than a pointer to it.


Syntax:
declare ring_zero_peek_$by_name entry (char(*), fixed bin(18), pointer,
     fixed bin(19), fixed bin(35));
call ring_zero_peek_$by_name (segment_name, offset, copy_ptr,
     word_count, code);


Arguments:
segment_name
   is the name of the supervisor segment from which data is to be
   copied.  It cannot be a pathname.  (Input)
offset
   is the offset from the beginning of the segment at which copying is
   to start.  (Input).  It can be specified as zero to cause copying to
   start from the base of the segment.
copy_ptr
   is a pointer to the area in the outer ring where the data is to be
   copied.  (Input)


word_count
   is the number of words to be copied.  (Input)
code
   is a standard status code.  (Output).  It is nonzero if the segment
   cannot be found, or if the user does not have sufficient access to
   copy the requested data from it.


Notes:  This entry point can be used to avoid a call to ring0_get_.
For examining segments in the supervisor, this entry point and the
by_definition entry point are recommended because they are much simpler
to use than ring0_get_, and they are only minimally less efficient.
Generally, it is nearly as efficient to use this entry point as it is
to save static pointers to inner ring objects.


:Entry:  get_max_length:  02/13/84 ring_zero_peek_$get_max_length


Function: determines the maximum length of a named ring zero segment.


Syntax:
declare ring_zero_peek_$get_max_length entry (char(*), fixed bin(19),
     fixed bin(35));
call ring_zero_peek_$get_max_length (seg_name, max_length, code);


Arguments:
seg_name
   is the name of the ring zero segment.  (Input)
max_length
   is the maximum length (in words) of the segment.  (Output)
code
   is a standard status code.  (Output).  It is nonzero if the user
   does not have sufficient access to copy the requested data, or if
   the segment does not exist.


:Entry:  get_max_length_ptr:
02/13/84 ring_zero_peek_$get_max_length_ptr


Function: determines the maximum length of a specified segment by
examining its SDW.  The user must have sufficient access to examine
the SDW for the segment.


Syntax:
declare ring_zero_peek_$get_max_length_ptr entry (pointer,
     fixed bin(19), fixed bin(35));
call ring_zero_peek_$get_max_length_ptr (seg_ptr, max_length, code);


Arguments:
seg_ptr
   is a pointer to the segment for which the max length is to be
   returned.  (Input).  If the segment is not active at the time of the
   call, the user must have sufficient access to reference the segment,
   and this reference causes a segment fault.
max_length
   is the maximum length (in words) of the segment.  (Output)
code
   is a standard status code.  (Output).  It is nonzero if the user
   does not have sufficient access to copy the requested data, or if
   the segment does not exist.
