01/24/83  get_entry_point_dcl_

The get_entry_point_dcl_ subroutine returns attributes needed to
construct a PL/I declare statement for external procedure entry points
and for error_table_ codes and other system-wide external data.  The
program obtains the attributes from data files declaring all unusual
procedure entry points (e.g., ALM segments), and system-wide data
values (e.g., sys_info$max_seg_size), and from the argument descriptors
describing the entry point's parameters that are included with the
entry point itself.


Entry points in get_entry_point_dcl_:
   (List is generated by the help command)


:Entry: get_entry_point_dcl_: 01/19/83  get_entry_point_dcl_


Function: returns the declaration for an external value, either from
one of the data files, or by using the parameter argument descriptors
associated with the procedure entry point.  It makes a special case of
error_table_ values by always returning 'fixed bin(35) ext static' for
them.


Syntax:
dcl get_entry_point_dcl_ entry (char(*), fixed bin, fixed bin,
     char(*) varying, char(32) varying, fixed bin(35));
call get_entry_point_dcl_ (name, dcl_style, line_length, dcl, type,
     code);


Arguments:
name
   is the name of the external entry point or data item whose
   declaration must be obtained.  (Input)
dcl_style
   is the style of indentation to be performed for the name.  See
   "Notes" below for a list of allowed values.  (Input)
line_length
   is the maximum length to which lines in return value are allowed to
   grow when indentation is performed.  (Input)
dcl
   is the declaration that was obtained.  (Output)


type
   is the type of declaration.  In the current implementation, this is
   always a null string.  (Output)
code
   is a standard status code describing any failure to obtain the
   declaration.  (Output)


Notes on styles: Three styles of declaration indentation are supported 
by the dcl_style argument described above.


Style 0:	 (dcl_style = 0)
   involves no indentation.  The declaration is returned as a single 
   line.


Style 1:	 (dcl_style = 1)
   indents the declaration in the format similar to the indent command.
   Long declarations are broken into several lines.  For example, a
   declare statement for hcs_$initiate_count would appear as:

   dcl  hcs_$initiate_count entry (char(*), char(*), char(*),
        fixed bin(24), fixed bin(2), ptr, fixed bin(35));

   when the string "dcl hcs_$initiate_count" is concatenated with the
   value returned by get_entry_point_dcl_, and a semicolon (;) is
   appended to this value.


Style 2:	 (dcl_style = 2)
   indents the declaration in an alternate format that makes the name
   of the entry point stand out from its declaration.  It assumes that
   the name of the entry point begins in column 11 (indented one
   horizontal tab stop from left margin), and the declaration begins
   in column 41.  In style 2, the declare statement for
   hcs_$initiate_count would appear as:

   dcl       hcs_$initiate_count           entry (char(*), (char(*), (char(*),
                                                fixed bin(24), fixed bin(2),
                                                ptr, fixed bin(35));


Notes: Most command and active function entry points do not declare
arguments in their procedure statements since they accept a variable
number of arguments.  Neither do they use the options(variable)
attribute in their procedure statements.  Therefore, when
get_entry_point_dcl_ encounters a procedure entry point with no
declared arguments and without options(variable), it assumes the
options(variable) attribute required for commands and active functions
and returns:
        entry options(variable)


It distinguishes between such assumed options(variable) entries and
those that explicitly use the options(variable) attribute in their
procedure statement by returning "entry" for the assumed case and
"entry()" for the explicit case.  Thus, for the display_entry_point_dcl
command, which explicitly uses options(variable) in its procedure
statement, get_entry_point_dcl_ returns:
        entry() options(variable)


For procedures which use structures as arguments, certain structure
declarations are inexactly returned as parameter declarations because
the mechanism for encoding argument descriptors does not provide an
adequate description of the alignment of a structure.  The descriptor
only determines whether the overall structure is packed or not, and
does not specify whether or not it was originally declared with the
aligned attribute.


The following structures generate the same argument descriptors, even
though PL/I treats the level 1 structures as having different
attributes:
   dcl 1 s2 structure aligned,
         2 el1 fixed bin aligned,
         2 el2 fixed bin aligned;

   dcl 1 s2 structure,
         2 el1 fixed bin aligned,
         2 el2 fixed bin aligned;

get_entry_point_dcl_ reproduces the declaration for s2 when either s1
or s2 are used as parameters for an entry point.  In order to bypass
this problem, declare the subroutine properly in your personal .dcl
segment (see "User-Provided Data Files" below), and place this segment
in your "declare" search paths.


Notes on Search List:
The get_entry_point_dcl_ subroutine uses the "declare" search list,
which has the synonym "dcl", to find data files describing unusual
procedure entry points.  The default search list identifies the data
file >sss>pl1.dcl.


User-Provided Data Files:
Users may provide data files that redeclare standard system entry
points (e.g., redeclaring a subroutine as a function), or that declare
their own entry points or external data items.  The add_search_paths
command can be used to place user-provided data files in the "declare"
search list.

Declarations have the general form of:
        virtual_entry declaration
For example:
        ioa_ entry options(variable)
Note that the word "dcl" is not included in the data item, nor does the
declaration end with a semicolon (;).  External data values are
declared in a similar fashion.  For example:
        iox_$user_output ptr external static
