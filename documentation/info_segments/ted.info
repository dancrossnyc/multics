:Info: ted: TED:
12/10/86  ted

Function:  The ted command is used to create and edit ASCII segments
and is used to perform many kinds of text processing.  It can be called
as an active function and be invoked recursively to a depth of 14.


Syntax:  ted {ted_com} {-control_args}


Arguments:
ted_com
   reads the contents of the named segment into buffer (exec) and
   executes it.  The ted suffix is supplied if not present.  When the
   contents of buffer (exec) is exhausted, request lines are read from
   user_input unless the -abort argument (below) is present.


Control arguments:
        See "Notes" below as regards the execution sequence of
        arguments, and list of undocumented control segments.
-abort
   exit the program if an error occurs while executing a ted_com
   instead of returning to ted request level.  (For historical
   compatibility, "-com" may be used for this function.)
-arguments args, -ag args
   makes the argument list args available during the processing of
   a ted_com.  The args may be referenced either in buffers
   (arg1), (arg2), etc., or line 1, line 2, etc.  of buffer
   (args).  None of these buffers show up on an x request list
   until they have been referenced.


-debug, -db
   instructs ted to display "Edit ."  before accepting a request
   line from user_input.  This control is useful for detecting
   when a ted_com "falls" back to request level.  The -abort
   argument (above) detects when a ted_com "falls" back to request
   level, but does not leave you in a position to examine the
   environment.
-option STR1{,...STRn}, -opt STR1{,...STRn}
   sets the options specified by STRi before anything else is
   accomplished during ted startup.  STR is any option setting
   which may be given to the "o" request.  Multiple options
   must be separated by either a comma (,) or a space ( )
   character.  If space is utilized as the separator, then
   the whole string must be in quotes.


-pathname path, -pn path
   begin ted execution by reading segment path into buffer(0).
-pause
   interrupts execution of a ted_com (to ted, this simulates
   encountering a breakpoint at the beginning of the next line in
   EDIT mode).  The next time a request line is fetched, the input
   routine enters the break sequence.  This argument is valid
   only after having interrupted a ted execution.  (This argument
   is mutually exclusive with all other control arguments.)


-request STR, -rq STR
   executes STR as a ted request line before entering the request loop.
   For example:

        ted -pn foo -rq "gd/abc/w" -rq "q"

   deletes all instances of "abc" in the foo segment, writes it back,
   and then quits.


-reset {level}
   breaks out of a ted_com loop and returns to ted request level.
   The optional "level" is a two-digit number specifying the ted
   recursion level to be returned to.  If level is not specified,
   then the most recent invocation is assumed.  This argument is
   valid only after having interrupted a ted execution.  (This
   argument is mutually exclusive with all other control
   arguments.)
-restart
   restarts a -safe environment which was left due to a system
   crash, process interruption, or overt user action (see
   qhold request).  If only one environment exists, it is
   restarted.  If more than one exists, all are listed and the
   user is asked which invocation to restart.


-safe
   places the active ted work segments in the user's default
   working directory so that the environment is saved in case of a
   loss such as a system crash.  It also displays a warning if
   there are any existing environments.
-status, -st
   generates a list of existing "-safe" environments.  (This
   argument is mutually exclusive with all other control
   arguments.)


-temp_dir path, -td path
   saved environments are normally kept in the home directory.  In
   some cases there may not be enough quota for the work to be
   done.  This argument allows an environment to be placed
   elsewhere.  When this control argument is given, a link is
   created in the home_dir to the data base for the environment,
   so that -status and -restart know what exists.  The link is
   removed in cleaning up an environment.  The -status listing
   indicates where any remote environments actually are.


Notes:  Several of the arguments cause a portion of a "script" to be
created for ted to follow.  The sequence in which arguments contribute
to the script, regardless of the sequence used in the command line (top
to lowest priority) is:

    -option, -pathname, -request, ted_com, -abort, and -debug


List of requests:
" (comment)
# (if line)
^# (if-not line)
% (call buffer)
* (if expression found)
^* (if expression not-found)
.. (execute)
: (define label)
> (transfer of control)
^> (error exit)
= (print linenumber)
\? (where am I?)
{} (evaluate)
|xxx (external request call)


~ (return)
a (append)
!a (bulk append)
b (change buffer)
!b (change buffer remembering)
^b (delete buffer)
c (change)
!c (bulk buffer)
d (delete)
e (execute)
!e (print and execute)
f (fileout into buffer)
!f (fileout into buffer)
g (global)
g* (global-if)


h (process out pseudo-tabs)
help (online information)
i (insert)
!i (bulk insert)
j (sort)
!j (special sort)
k (kopy, or copy)
!k (kopy-append, or copy-append)
l (linefeed to user_output)
!l (linefeed to error_output)
m (move)
!m (move-append)
n (nothing)
o (option)
p (print)


!p (print with linenumber)
q (quit)
!q (force-quit)
qhold (quit-hold)
r (read)
!r (abbrev-expand-read)
^r (force pathname)
s (substitute)
!s (no-fail substitute)
t (type string to user_output)
!t (type string to error_output)
u (translate to lowercase)
!u (translate to uppercase)
v (exclude)
w (write)


!w (abbrev-expand-write)
x (buffer status)
!x (buffer status)
y (tabin)
z.fi.ad (fill/adjust)
z.fi.na (fill/no-adjust)
zdump (dump octal/ASCII)
zif (conditional test)


:Info: ted_act:
06/03/80  ted_act

Syntax:  e ted_act args


Function:  causes args to be placed into b(act) of the current invoca-
tion of ted.  args may contain abbrevs and/or active functions.  If
multiple arguments are received by ted_act, they will be placed into
b(act) separated by a VT (\013).  The user may then change this to
whatever he wishes.


Examples:  e ted_act [date_time]
This puts the current date /time value into b(act).


:Info: ted_buffer:
06/03/80  ted_buffer

Syntax:  e ...  [ted_buffer x]


Function:  The active function ted_buffer is used to reference data in
ted buffers.  It returns the pathname of the segment containing the
data in b(x).  The bitcount of this segment gets set to properly
reflect the amount of data present.  After returning from the "e"
request, the bitcount of the segment will be used to determine the NEW
length of the buffer data.


Examples:  e ds [ted_buffer 0]
This dumps the segment which contains the data of b(0).


:Info: ted.new_features: new_features:
11/08/82  ted(3.0) new features

Purpose:  This info file lists features which have been added or
upgraded in ted.


List of features:
-safe
   The format of a saved environment is changed.  Old environments are
   not restartable with the new ted.  Saved environments are named
   including a request-id just as dprint requests are.  In this way,
   multiple users in the same directory may be accomodated, either dif-
   ferent people or different instances of the same person.
-temp_dir
   This allows the user to specify where the safe data is to be kept.
   A link to this environment is placed in the home directory so that
   -status and -restart can find it.  The link is removed when the
   environment is cleaned up.  (This implies -safe).
-status
   This now gives a much more meaningful listing of the saved environ-
   ments.


-restart
   When there is only 1 saved environment, it will be restarted.  If
   there are more than 1, they will be listed and the user asked which
   one he wants.  See note in ted info on the details of what may be
   done at that point.
qhold
   When running as -safe or -temp_dir, this request may be used to exit
   from ted without losing the environment.  It may then be restarted
   at a later time.
o comment="..."
   This sets a value to be displayed by -status (also "o").  If an
   environment is going to be saved over several executions, it will be
   helpful to have some identifying information other that the
   date/time when the execution originally began.


Absolute buffer addressing.  @(X),adr
   The @ address prefix specifies that the address and request that
   follows is to be executed in the named buffer, reqardless of which
   one is current.
Limited range expression search [adr]/RE/
   An address enclosed in []'s and preceding "/" or <"/" in an address
   causes the expression to be searched for only within the range spec-
   ified.  The forward search searches from beginning to end, the back-
   ward search searches from end to beginning.


:Info: ted.old_features: old_features:
11/08/82	ted(3.0) old features

Purpose:  This info file lists features of ted which are being phased
out.  In most cases there is no change in functionality, just in how to
ask for the function.


Control arguments:
-com
   This is superceded by -abort.
-blank
   This is superceded by -option blank
-part_blank
   This requires the blank on only the a,c,i,d,r,e,w requests.
-no_blank
   This is superceded by -option ^blank.  (default)
-read
   This is superceded by -option read.  (default)
-no_read
   This is superceded by -option ^read.
-break
   This is superceded by -option break.
-no_break
   This is superceded by -option ^break.  (default)


-label
   This is superceded by -option flow.
-no_label
   This is superceded by -option ^flow.  (default)
-trace_edit
   This is superceded by -option edit.
-trace_input
   This is superceded by -option input.
-trace
   This is superceded by -option trace.
-no_trace
   This is superceded by -option ^trace.  (default)
-Jset {XX...}
   This functionality is now requested within ted via j/s=XX.../.
-Jshow
   This is now requested from within ted via j/?/.


List of out-of-date facilities:
(read/write) A|b
   This references component b of the ted superfile A.
(substitution) "o ct"
   This is superceded by {mct();}
(evaluation) <cat> <aexp>
   This is an old form of <cat>||<aexp>.
(evaluation) sk
   The subfile kind of the file associated with this buffer.   "|"
   "superfile" component


:Info: input: append: a: !a: change: c: !c: insert: i: !i:
12/01/78  Input operations

Basic [a c i]:
[.] a TEXT\f
   append TEXT after addressed line (location)
[.,.] c TEXT\f
   change addressed text, replacing it with TEXT
[.] i TEXT\f
   insert TEXT before addressed line (location)

   INPUT MODE inputs a string of characters, looking for and processing
   escape sequences.  Terminated by the escape "\F".


Bulk [!a !c !i]:
[.]!a <REST>
 LINES
 .
   append LINES after addressed line
[.,.]!c <REST>
 LINES
 .
   change addressed text, replacing it with LINES
[.]!i <REST>
 LINES
 .
   insert LINES before addressed line

   BULK MODE inputs lines of characters.  No escape sequences are
   processed.  Terminated by a line consisting of ".".  Anything which
   follows the request ("<REST>" below) is not input data.  It repre-
   sents additional requests which are then executed when the input is
   terminated.


:Info: buffers: b: ^b: 'b: !b: b(): buffer: buffers: data:
11/30/78  Buffers

Basic [b]:
b(X)
   make buffer X become the "current" one.


Windowing [b(X,a)]:
b(X,a)
   change current buffer to buffer X, but set a window as specified by
   the addresses.  Until the next buffer change, all requests will act
   as though the buffer contained only data within the window.


Pushing/Popping [!b b()]:
!b(X)
   change current buffer to buffer X, but first remember the current
   one in a LIFO stack.
!b(X,a)
   change current buffer to a window of buffer X, remembering the cur-
   rent one.
b()
   change current buffer, using the last one remembered.  (Up to 10 may
   be remembered at once.)  If an error occurs, the buffer stack is
   cleared.


Deleting ['b ^b]:
^b(X)
   delete buffer X (remove from known buffer list).  X must not be cur-
   rent.


Overview:  Input and editing operations are not performed directly on
the target segments but in a temporary workspace known as a buffer.
ted supports a virtually unlimited number of them.  One buffer at a
time is designated as the "current buffer".  Requests operate on the
current buffer unless explicitly told to do otherwise.

When ted is entered, a single buffer named 0 is created and designated
as current.


Names:  Each buffer is given a name of from 1 to 16 ASCII chracters
(except for "(", ")", ",", " ").  A name which consists of 1 character
may be given as just that character.  A name which has more than 1
character must be enclosed in parentheses.  Thus changing to buffer 1
may be done with either "b1" or "b(1)".  All buffer names in this docu-
ment are written as "(X)".

A buffer name may be followed by an address.  In this case the
name,address must always be enclosed in parentheses regardless of name
length.  All buffer names with address in this document will be written
as either "(X,l)" or "(X,a)" depending on whether a line only is
allowed or whether any kind of address is acceptable.


:Info: delete: d:
12/02/78  Delete

[.,.] d
   delete addressed text


:Info: execute: e: E: !e: ..:
01/29/81  Execute Multics command line

e <REST>
   execute Multics command line <REST>
!e <REST>
   print, then execute Multics command line <REST>.  Request may also
   be given as "E".
.. <REST>
   This form requires the ".." to be the first two characters of a
   line.  <REST> is executed without any input function expansion


01/29/81 Change:  The ".." form now does not do input function
processing on the line.


:Info: fileout: f: !f: F:
03/20/80  Fileout to buffer

Basic [f]:
f(X) <REST>
   fileout into buffer X.  Fileout is terminated at end of request
   line.


Continuing [!fX !f<NL>]:
!f(X)
   fileout into buffer X.  Not automatically terminated.  May also be
   entered as "F"
!f<NL>
   terminate fileout begun by the prior form.


:Info: global: v: g: g*:
09/09/85  Global

Overview:  There are three kinds of these requests, global-inclusive
(g), global-exclusive (v), and global-if (g*).  The first two go thru
the buffer a line at a time, searching each line for the presence a
given regular expression, <RE>.  The g requests process the line if a
match is found.  The v requests process the line if a match is not
found.

The global-if goes thru the buffer a line at a time, but it test each
line for a (possibly) complex logical condition made up of <RE>'s and
<eval>'s.  If a TRUE results, then (potentially) several operations are
done on the line.


List of g/v requests [g= gd gp gP]:
[1,$] g=`<RE>`
   print line numbers
[1,$] gd`<RE>`
   delete
[1,$] gp`<RE>`
   print
[1,$] g!p`<RE>`
   print with line numbers.  May also be entered as "gP".


If [g*]:  The global-if request offers a great deal of selection capa-
bility and request power.  It has these forms:
    g*<search><SP><requests>
    g*<SP><requests>
    g*//<SP><requests>
    g*<NL>
<search>
   is a logical expression made up of <operand>'s and the operators
   "|", "&", "^", "(", ")".  If <search> is not present, then every
   line is to be processed.  If <search> is "//" it means to use the
   same <search> as on the last g*.  If nothing follows the g*, it
   means to execute the exact same g* as the last one.
<operand>
   is either a regular expression, /<RE>/, or an evaluation,
   { <eval> }.  No blanks may surround the operators.
<SP>
   is a REQUIRED space.  The first space encountered separates the
   <search> portion from the <request> portion.
<requests>
   is one or more sub-requests, separated by spaces.


   The logical expression is processed in an optimal fashion.
/<RE>/ is TRUE if a match is found, is FALSE otherwise.
{ <eval> } return value is examined.  "0" or "false" is FALSE, anything
   else is TRUE.
     /a/&/b/&/c/ will fail immediately if "a" is not found.
     /a/|/b/|/c/ will match immediately if "a" is found.
   This means that "/abc/&{a[10]:=a[10]+1}" will increment a[10] when-
   ever a line contains an "abc".


Allowable g* sub-requests:  Most of these are identical in function to
the corresponding requests, except where noted below.
[  ($)] a<SP>string\f
[(1,$)] c<SP>string\f
[  (1)] i<SP>string\f
[(1,$)] d
        l
        !l
[(1,$)] m(X)
[(1,$)] !m(X)
[(1,$)] k(X)
[(1,$)] !k(X)
[(1,$)] p
[(1,$)] P


        t`...`
        !t`...`
[(1,$)] u`<RE>`
[(1,$)] !u`<RE>`
        { <eval> }
        >X
   X may be any of these forms "C", "(xxx)", "+n", "-n"
        =
   prints a 6-digit linenumber, with no NL.
[(1,$)] s`<RE>`<REPL>`
   This is like the "S" request, in that a substitute-failed does not
   cause any message and does not abort processing the g*.  There is an
   additional facility
    in <REPL>.  "\g{ <eval> }" calls for an evaluation whose returned
   value is substituted in.  The string matched is available as "Ks"
   during evaluation.  It differs from \{} in that \{} is expanded
   while the request line is being built, whereas this form is expanded
   each time the <REPL> is used.  "."  is set to the line being
   examined, the g* terminates by executing the goto


The total global-if expanded request line is limited to 512 characters.

The addressing is numeric only.  "(1,3)" and "($-10,$)" are examples.
If either address specified does not exist on any particular line, then
the request is skipped on that line.  (1,10)p will be skipped if there
are not 10 characters on the line.


Examples g*:
g*/^--/ s/those/these/ s|which|that|
   Change "those" to "these" and "which" to "that" on every line which
   begins with a "--".
1,200g*/if/|/then/ p
   Print every line in the first 200 which contain either an "if" or a
   "then".
{a[1]:=0} g*/:$/&{a[1]:=3;1}|{a[1]} P {a[1]:=a[1]-1}
   Print, with line number, every line which ends with a ":" and the 2
   lines which follow.  The logical expression procedes like this.
     if :$ is found, then set a[1]:= 3 and return a 1 for success.
     otherwise return a[1], which will be success if ^=0.
     On success, print/linenumber and then decrement a[1] by 1
g*/SEE/&^/SEE:/ P
   All occurances of "SEE" in a file are to be followed by a ":".  This
   request shows all which do not.


07/16/81 Change:  A g* request may now be followed by a comment.


01/29/81 Change:  Documentation of two additional formats:
g*//<SP><reqests> and g*<NL>


:Info: h: tabout: tab: tabs:
03/20/80  Process out pseudo-tabs

[.,.] h`C,n,n...`
   convert pseudo-tab C to spaces using tabstops defined by n,n,...
   Tabstop specifications are of this form:
       n - set text left
       nL - set text left
       nC - set text centered
       nR - set text right
   "n" represents the column where the character following the tab
   character is to be placed.  It must be in the range 1 thru 200.

   When the left or center options are selected, they apply to the text
   leading up to the tabstop.  The location of each tabstop in turn is
   remembered.  Then when a left/center is called for, the data since
   the last tabstop is involved.  The number of spaces needed is calcu-
   lated; then if centering, half of this number is placed before the
   data and the rest after.  Otherwise all the spaces are placed before
   the data.


:Info: sort: sorting: collate: j: J: !j:
10/28/82  Sorting

Basic [j]:
[1,$] j`key,key ...`
   sort addressed text on specified keys
[1,$]!j`s,key,key ...`
   sort addressed text on specified keys with user specified collating
   sequence.


Sort keys:  A sorting specification is an optional series of key
specifiers which may include a duplicate suppression specifier.  If no
key is specified, e.i.  j//, the default is as if you had typed j/1:$/.

A key specifier has these four parts:
  {order} from X to
The "order" may be "a" or "A" for ascending, "d" or "D" for descending
and is optional (assuming "a").  The "from" represents the character
number where the sort key begins.  It may be specified as "n", "$", or
"$-n".  "n" is a number and "$" means end-of-line.  The "X" is the sep-
arator and may be "," or ":".  The "to" represents the length of the
key in one of to ways.  If the separator is "," then it is a number
which is the length of the key (or "-" for rest of record).  If the
separator is ":" then it represents the character number where the key
ends.  It may be in any of the forms shown under "from".


Duplicate suppression:  The last two call for elimination of dupli-
cates.  When duplicates exist, if duplicates are being dropped, the
last one in the file will remain.  Otherwise, they will remain in the
order they had to start with.  A duplicate is determined by the speci-
fied keys being equal; the rest of the record is not examined.  The
last form calls for the count to be placed in the record beginning at
character "n" and with length "l".
      WARNING:  this count field MUST exist in each record.
No check is made to see if it is within the limits of the record.

If no keys are given, "a1,-" is assumed.
    'xxx can precede the first key.  This specifies the record
delimiter to use.  "xxx" is 3 octal digits.  The default is '012.


Using a special collating sequence:
j`s=`
   Set the special collating sequence to its default value
   (uppercase=lowercase).  This is as if you had typed:
     j/s='000->'177'000->'177'200->'777'777a->zA->Z/


j`s=XX...`
   First set the special collating sequence to its default value and
   then adjust it as specified by XX....  Each X represents a mapping
   pair in one of these forms:
    CC map first character to second
    X->YC map range of characters to second
    X->YX->Y map range of characters to range of characters.  Ranges
   must be
             of equal size.
   X->Y means the contigious characters X through Y.  X must be less
   than Y in the 9-bit collating sequence.  X and Y are any of the C
   forms.  (When a character is mapped to '777 it means to ignore it.)
   C is any of 3 forms
      'ooo ooo is 3 octal characters
      'Z Z is any non-octal digit
      Z Z is any character except ' (which must be entered as '')
j`?`
   Display the special collating sequence.  Characters will be shown in
   "bunches" of perhaps 1 character.  Each character in a bunch has the
   same collating value.  The earlier bunches sort lower than the lat-
   ter ones.


Examples:
j/7,2,1,5/
   Sort all the lines of the buffer which begin with dates in the form
   mm/dd/yy, sorting into calender sequence.
j/=,7,2,1,5/
   This is the same sort, except any duplicates are to be removed.
1,$s/^/00000     / j/17,2,11,5,=1,5/
   The same sort again, except this time you want to know how many
   there were of each.  The first request makes room for the count.
   Then, since 10 characters were added to the front of each line, the
   offsets into the record had to be adjusted.


11/09/82 Change:
 1) Keys may also be located with respect to the end of the line.
 2) The end of the key may be specified by character number.
 3) Setting/using/displaying the special collating sequence is now done
    via the sort request.


:Info: copy: kopy: k: !k: K:
12/02/78  Copy

Basic [k]:
[.,.] k(X)
   kopy addressed text to buffer X.  Previous contents of b(X) is lost.
   If the target buffer contains a modified file, ted asks if you wish
   to overwrite it unless you are running in -abort mode or are running
   as ted$qedx.


Append [K(X) K(X,l)]:
[.,.]!k(X)
   kopy-append addressed text to buffer X.  New data is placed at the
   end of b(X).  Request may also be entered as "K".
[.,.]!k(X,l)
   open up a hole in buffer X after location l and into it copy the
   addressed text

   The current buffer may be the target of the copy-append.  There are
   no restrictions on where you can put the data.


:Info: move: move-append: m: M: !m:
03/20/80  Move

Basic [m]:
[.,.] m(X)
   move addressed text to buffer X.  X cannot be the current buffer.
   Any prior data in X is lost.  If the target buffer contains a
   modified file, ted asks if you wish to overwrite it unless you are
   running in -abort mode or are running as ted$qedx.


Append [M(X) M(X,l)]:
[.,.]!m(X)
   move-append addressed text to buffer X.  New data is placed at the
   end of b(X).  Request may also be entered as "M".
[.,.]!m(X,l)
   open up a hole in buffer X after location l and into it move the
   addressed text Any prior data in X is retained.

   The current buffer may be the target of a move-append, but the place
   specified must not be in the range being moved.


Overview:  When data is moved, it is deleted from where it was.  The
only copy of the data exists in the target buffer.  So when data is
moved to another buffer, it is marked as unused until it is utilized
via the "r" request or "\bx" function, or is deleted.  Quit will com-
plain as long as there is unused data left in some buffer.


:Info: nop: n: !n:
12/05/78  Nop

[.] n
   set "."  to address
[.,.] !n
   set "."  to the RANGE addressed.


:Info: options: o:
07/16/81  o -  Options request

Displaying:
o
   display current option settings.  The result will be a line like
   this:
      NAME(VR)[NN] global-options local-options
    * TED is the name under which ted is being run, i.e "ted"
    * VR is the current version/revision of ted, i.e "2.5"
    * NN is the recursion number for ted, i.e.  "01"
    * global-options are options which are shared between all
   recursions of ted; they are good for the current process.
    * local-options are those which are effective only within this
   invocation of ted.


Setting:
o xxx ...
   xxx is a space or comma separated list of options to be turned
   on/off.

   This request uses up the rest of the line.


Global options:
blank, ^blank
   This controls the requirement that there be at least one blank
   between multiple requests on one line.
caps, ^caps
   This controls the utilization of capital letters for requests.
resetread, ^resetread
   Do/dont't do a resetread on user_input if an error occurs.


Local options:
break, ^break
   Process the \037 character as a BREAK in EDIT mode, otherwise, skip
   it.
edit, ^edit
   This controls the display of lines in EDIT mode before processing.
input, ^input
   This controls the display of lines in INPUT mode before processing.
trace, ^trace
   This turns both input and edit on or off together.
label, ^label
   This controls the display of labels as encountered.
read, ^read
   When a read is done in an empty buffer, reference the file in place
   instead of copying it.  (Default on)
old-style, ^old-style
   This controls whether the old (645 days) form of \B \C \F \R are
   recognized within ted_coms.  (DEFAULT on)
tablit, ^tablit
   In the "h" request, HT chars are literal.  i.e.  whenever enclosed
   in a quoted string, do not remove, just account for the "room" used
   up.  (DEFAULT off)
(string, ^string)
   Operating in STRING mode.  This is set only by \s and \l.  Displayed
   for information purposes only.
null=p, null=P, null=!p
   This sets the action to be taken when a null request is given.  A
   null request is an address which is followed by a NEWLINE.  (DEFAULT
   null=p)


07/16/81 Change:  The options old-style and null= have been added.


02/24/81 Change:  Options- edit,input,break,label have been made local.
This means that they now apply only to the invocation of ted in which
they are used.  The option "label" used to be named "flow".  The option
"on" has been changed to "trace".  The option "off" has been changed to
"^trace".


:Info: print: p: !p: P: type: t: !t: T: linefeed: l: !l: L:
03/21/80  Printing

Basic [p !p <null>]:
[.,.] p
   print addressed text
[.,.]!p
   print addressed text with linenumbers.  Request may also be entered
   as "P".


Null request:  When an address is given without any request following
it, the addressed area is printed


Literal data [t !t l !l]:
t`STR`
   type; send STR to user_output (new-line not added)
!t`STR`
   type; send STR to error_output (new-line not added).  May also be
   entered as "T".
l
   send a NL to user_output
!l
   send a NL to error_output.  May also be entered as "L".


:Info: quit: q: !q: Q: exit:
12/02/78  Quit

Basic [q Q]:
q
   quit from ted after checking for modified buffers.
!q
   quit from ted without buffer check.  Request may also be entered as
   "Q".


Abort execution:  There are two ways available to stop execution.
 1) if a print or global request is executing, it may be aborted by
hitting the BREAK key and then typing "pi".  NO OTHER requests are
terminated via this procedure.
 2) To terminate anything, hit the BREAK key and then type "ted
-reset".  This makes believe an error has just occurred and unwinds
execution back to ted request level.  All buffers are as they were at
the time of interruption.


Suspend execution:  If a ted_com is running and it appears to be in a
loop execution can be suspended to allow examination of conditions.
Hit the BREAK key and then type "ted -pause".  The next time a line of
input is requested in EDIT mode, it will act as though a breakpoint had
been encountered.  SEE:  break.


Overview:  Any buffer which has an associated pathname is assumed to
contain meaningful data.  b(0) is considered meaningful even if there
is no pathname.  Whenever such a buffer is modified, it is flagged.
When the buffer is written or if all the data is deleted, the flag is
turned off.  This is a flag which the q request checks.

Whenever data is moved to a buffer, it no longer exists in its old
location.  The new buffer is the only place where it exists.  It is
therefore flagged an not-pasted (from cut/paste terminology).  This
flag is turned off by either doing a read, "r (X)", by invoking the
whole buffer, "\bX", or by deleting it all.

When a "q" is given, both of these flags are checked on all buffers.
If any are so marked, they are listed and you will be asked if you
still wish to quit.


:Info: read: r: R: !r:
07/16/81  Read

Basic [r]:
[$] r PATH
   append contents of segment PATH after addressed line
[$] r
   append contents of a segment after addressed line.  The segment is
   that which is associated with this buffer.  It is an error if there
   is no associated segment.


With abbrevs:
[$]!r PATH
   read as above, PATH is abbrev-expanded before use.  Request may also
   be entered as "R".


Buffer [r (X) r (X,a)]:
[$] r (X)
   read contents of buffer X after addressed line
[$] r (X,a)
   read addressed part of buffer X after addressed line


Force pathname ['r ^r]:
^r PATH
   Do not read specified file, merely force pathname of buffer to be
   PATH.  Can then never be removed.  Thereafter, "r PATH" and "w PATH"
   are not allowed on the buffer.


Pathnames:  The PATH used in read and write requests can specify vari-
ous kinds of files.  These are the forms available:
  A::b this references component b of A.archive
  A this references segment A.

Also, any PATH which begins with the string "[pd]" will get these 4
characters replaces by the name of the process directory.


Overview:  When "r PATH" is used and the buffer is empty, then PATH
becomes associated with the buffer.  If the the buffer is not empty,
then PATH is not remembered and if a name already is associated, it is
flagged as not trustable (^trust).

When any read is being done, a check is made to see if the sum of the
present data and the new data will exceed the maximum segment size.  If
this is true, then the resulting number of pages is displayed and the
read is aborted.


07/16/81 Change:  The old form of archive reading, via the "!"  charac-
ter, has been completely removed.  All referenced must now use the "::"
form.


:Info: substitute: s: S: !s: change:
03/21/80  Substitute

Basic [s'<RE>'<REPL>']:
[.,.] s`<RE>`<REPL>`
   substitute the string <REPL> for all strings in the addressed lines
   which match the expression <RE>.  SEE:  <RE> SEE:  <REPL>


No-fail [!s S]:
[.,.]!s`<RE>`<REPL>`
   no-fail substitute.  Acts just like the previous one except that the
   fail condition is never considered to happen.  This is for when you
   dont care whether the string is there or not, you just want some-
   thing done to any which might exist.  Request may also be entered as
   "S".


WARNING:  If the expression has no match and execution is currently
from a buffer, then execution will revert to the previous level with no
error message being printed.  This condition can be caught, however.
SEE:  ^>


Overview:  Each time a match is found, it is replaced by whatever
<REPL> implies.  If <REPL> ends in "$", this means that the NL is used
in the search but is not included in the match.  The NL is skipped over
before the next search is begun since some expressions could again
match the NL.
   Also, "$" at the end cannot succeed on the last line of a buffer if
there is no NL.


:Info: u:
03/21/80  Translate to lower case

[.,.] u/<RE>/
   Each string which matches <RE> in the addressed range is translated
   to lower case.


:Info: U:
03/21/80  Translate to upper case

[.,.] U/<RE>/
   Each string which matches <RE> in the addressed range is translated
   to upper case.


:Info: write: w: W: !w:
03/21/80  Write

Basic [w]:
[1,$] w PATH
   write the addressed text into the segment PATH.  SEE:  read
   pathname.
[1,$] w
   write the addresset text into the segment associated with this buff-
   er.  It is an error if no name is associated.


With abbrevs [!w W]:
[1,$]!w PATH
   write, PATH is abbrev-expanded before use.  Request may also be
   entered as "W".


Buffer [w (X)]:
[1,$] w (X)
   write the addressed text into buffer X.  This is actually the k
   request with different defaults.


Modified [wm]:
wm
   write all modified buffers to their respecitive pathnames.  (This is
   available only when in BLANK mode.)


:Info: status: x: X: !x: xm:
03/21/80  Status of buffers

Basic [x X xm]:
x
   list all known buffers.
!x<NL>
   list status for current buffer.  May be entered as "X".
!x(X)
   list status for b(X).
xm
   list all modified or unpasted buffers.  (This request only available
   in BLANK mode.)


Format:  The output of the status request looks like this:
     3 -> mod (0)
   555 mod (a) [^trust] >udd>Multics>Falksenj>install>ted_info.ec
    15 (farble) m from b(a)
  1816 (info) >udd>Multics>Falksenj>install>ted_info.compin *
The first column tells how many lines are in the buffer.  The second
column has "->" to mark which buffer is current.  The third column says
"mod" when the buffer has its modify status on.  Note that b(0) has a
"mod" status even though there is no associated pathname.  The fourth
column contains the name of the buffer.  The last column contains the
associated pathname, if any.  It has a prefix of "[^trust]" when the
name is not trusted.  After the pathname will be a "*" if the file is
not-read, that is, it is being referenced directly instead of there
being a copy in a buffer segment.


:Info: y: tabin: tabs: tab:
03/21/80  Tabin

[.,.] y
   This goes thru the addressed string and replaces all blanks possible
   with HT characters.  It also removes any trailing whitespace.


:Info: zif:
03/19/80  zif - Conditional test

zif { <eval> } <REST>
   Execute <REST> unless result of evaluating <eval> is "0" or "false".
   NOTE:  addresses may be present, but there is NO default.  If no
   address is present, then <eval> may not reference any of the buffer
   content builtins, e.g.  sb.


:Info: linenumber: =:
12/02/78  Linenumber

[.] =
   print line number of addressed line


:Info: call: |:
03/01/80  External function call

[.,.] |xxx <REST>
   Call external support routine ted_xxx_.  The blank after |xxx is
   required if <REST> exists.  This routine will be found via system
   search rules.  The way the addressed portion of the buffer and
   <REST> is determined by each particular routine.  "Standard" rou-
   tines will be available.  For info on writing a support routine,
   see:  ted_support.incl.pl1


:Info: call: %:
12/05/78  Call buffer

%(X)`p1`p2...
   call buffer (X) passing parameters ` is the first character after
   the buffer name and may be a blank.  Each delimiter BEGINS a parame-
   ter.
      %x|a|b| gives 3 parameters, the third being a null string.


:Info: *: ^*: '*:
03/25/80  If expression found

[.,.] "<RE>` <REST>
   search the addressed text for <RE>.  If found, execute <REST>
[.,.]^"<RE>` <REST>
   search the addressed text for <RE>.  If not found, execute <REST>
   NOTE:  "'" may be used in place of "^".


:Info: #: ^#: ^#:
03/25/80  If-line

# <REST>
   if current buffer contains data, execute <REST>
A # <REST>
   if current line is A, execute <REST>
A1,A2 # <REST>
   if current line is in range A1,A2, execute <REST>

^# <REST>
   if current buffer does not contain data, execute <REST>
A^# <REST>
   if current line is not A, execute <REST>
A1,A2^# <REST>
   if current line is not in range A1,A2, execute <REST>
   NOTE:  "'" may be used in place of "^".


:Info: label: goto: ":": >:
12/05/78  Transfer of control

Label [:]:
:C
   define label C.  C must be 1 character.
:(C)
   define label C.  C can be 1-14 characters.  all labels must begin
   lines.


Goto [>]:
>C
   goto label C.  C must be 1 character.  Label to be found must have
   form :C
>(C)
   goto label C.  C can be 1-14 characters.  Label to be found must
   have form :(C)
>+n, >-n
   goto relative line.  n must be a single digit.  >-0 or >+0
   re-executes current line


Error catch [^>]:
^>(C)
   don't goto label (C), remember it for the rest of the request line.
   If any error occurs, don't print the message; goto (C) instead.  The
   error message can then be printed by saying "{emt();}".  May also be
   entered as "'>".


:Info: break: breakpoint:
12/02/78  Breakpoints

For ted_com debugging, ted has a breakpoint facility.  It is
   implemented via the \037 character.  The break mode can be set/reset
   with the control arguments -break/-no_break.  It can also set/reset
   with the option requests o break/o ^break.
      The break character is recognized only when in EDIT mode.  In
   order to enter the character, it may be concealed with the \c
   sequence.  The breakpoint character is treated in one of two fash-
   ions:
    ** NOBREAK mode - all occurances of of \037 are discarded.
    ** BREAK mode - any occurance of \037 is treated like a NL.  The
   request line being built is terminated and returned.  The next time
   a request line is asked for then the break message will be printed.
   After the break is continued, the character after the \037 becomes
   the first character of an request line.


:Info: modes: input-mode: edit-mode: bulk-mode: read-mode: line-mode: string-mode:
12/02/78  Modes


 INPUT mode is entered by "a", "c", and "i".
    BULK mode is entered by "!a", "!c", and "!i".
    READ mode is filling a "\r" function.
    EDIT mode is everything left over.
    BREAK mode is like EDIT mode except are stopped at a breakpoint.

   Line mode treats a file as a series of lines (delimited by the NL
   character).  The current location is a line in the file.  Entered
   during address processing by \l.

   String mode treats a file as a character string.  The current loca-
   tion is a character in the file.  Entered during address processing
   by \s.

   String mode interacts slightly with line and byte addressing and
   with string search.  For a comparison of line and string SEE:
   line/string


:Info: line/string:
03/12/80  Line mode/string mode comparison

[\s \l .]:
|+          +|+        line mode        +|+       string mode       +|
+------------+---------------------------+---------------------------+
| \s         |enters string mode         |stays in string mode       |
+------------+---------------------------+---------------------------+
| \l         |stays in line mode         |enters line mode           |
|            |NOTE: \l and \s are considered address parts. The      |
|            |mode can change any number of times during an address  |
+------------+---------------------------+---------------------------+
| /a.*b/     |"b" must follow "a" on same|"b" must follow "a" in     |
|            |line                       |buffer i.e. the "." will   |
|            |                           |match a NL                 |


[line/byte addresses]:
| address    |"a" is looked for, starting the line following the     |
| /a.*b/     |current location, proceeding to end of buffer, then    |
|            |from beginning of buffer to current location.          |
+------------+---------------------------+---------------------------+
| address    |"a" is looked for in the   |"a" is looked for in the   |
| (/a.*b/)   |rest of the current line,  |rest of the buffer,        |
|            |starting at the current    |starting at the current    |
|            |byte.                      |byte.                      |
+------------+---------------------------+---------------------------+
| address    |will give message          |will address the first     |
| 12($+1)    |  Addr- after line end     |character of line 13       |
+------------+---------------------------+---------------------------+
| 12(-1)     |will give message          |will address the NL of line|
|            |  Addr- before line begin  |11                         |


[= request]:
| 2(3)=      |The line-byte address is   |Both the file address and  |
|            |displayed.                 |line-byte address is       |
|            |                           |displayed.                 |
|            | 2(3)                      |                           |
|            |                           | 0(9)     2(3)             |
+------------+---------------------------+---------------------------+
| 2(3)==     |The byte portion of the    |The byte portion of the    |
|            |current location is not    |current location is        |
|            |maintained from the first  |maintained from the first  |
|            |request to the second.     |request to the second.     |
|            |                           |                           |
|            | 2(3)                      | 0(9)     2(3)             |
|            | 2                         | 0(9)     2(3)             |


[$ used in s request]:
| 1,$s/c$/X/ |Buffer before:             |Buffer before:             |
|            | 1   abc                   | 1   abc                   |
|            | 2   crb                   | 2   crb                   |
|            |                           |                           |
|            |Buffer after:              |Buffer after:              |
|            | 1   abX                   | 1   abXcrb                |
|            | 2   crb                   |                           |
|            |                           |The NL is used in          |
|            |The NL is used in          |finding the string and is  |
|            |finding the string but is  |included in it.            |
|            |not included in it.        | Note: This function may   |
|            |                           |be accomplished by a       |
|            |                           |conceal of the NL:         |
|            |                           | 1,$s/c\c\012/X/           |


:Info: (X): (X,a): (X,l):
03/12/80  Conventions- buffer names

(X)
   This represents a general buffer name.  When the name consists of a
   single character, the ()'s are optional.
(X,a)
   A buffer name may also be represented by "(X,a)".  The "a" repre-
   sents an address range.  Use of this form indicates that some part
   of a buffer is to be referenced.

   During the processing of the address, "."  will be the current loca-
   tion in that buffer.  Must not be referenced if it is not defined.
(X,l)
   A buffer name in a M or K request may also be represented by
   "(X,l)".  In this case the parens are required.  The "l" represents
   a location (an address).  If a range should be given, the end of the
   range will be the location used.

   During the processing of the address, "."  will be the current loca-
   tion in that buffer.  Must not be referenced if it is not defined.


:Info: cut: paste:
12/02/78  Cut/paste

One to one
   To cut out one piece of text and paste it in one place.  Assume you
   are in b(0) and want to move lines 3-5 to after line 9.  To accom-
   plish this you do..
      3,5M(0,9)
Many to many
   To bring together several sets of lines and/or paste into several
   places you do something like this..
      3,5m1 13,30M1 102,112M1
      13r (1)
      89r (1)

   Note that each move and read done changes the line numbers.  Howev-
   er, if the moves were done this way it would not upset the
   linenumbers for the next move.
      102,112m1 13,30M(1,0) 3,5m(1,0)
   Likewise, the reads done in this way would not upset the linenumbers
   for the next one.
      89r (1)
      13r (1)


:Info: <REPL>:
03/19/80  <REPL> Substitute replace string

"&" is replaced by the matched string.  "X\=" is replaced by a string
   of "X"s which is as long as the matched string.


:Info: quote: """":
12/05/78  Comment

[.] "
   comment.  Set "."  to address and ignore rest of line


:Info: if:
03/17/80  Conditional execution


Test for a given expression within a specified range.  SEE:  *

   Test for buffer empty, within specified line range.  SEE:  #

   Test for a complex logical condition.  SEE:  zif

   Execute if line does/doesn't match a given expression.  SEE:  g

   Execute requests on lines which fulfill complex condition.  SEE:  g*


:Info: [: ]:
10/12/82  [ ]


Within ted "[ ]" are used to bracket subscripts within <eval>.

   Within ted_help "[ ]" are used in request descriptions to enclose
   the default address, if any.  For example,
     [.,.] d
   means that the d request takes 2 addresses and has the current line
   as a default address.

   The range of an address search may be limited by preceeding the
   search by an address withing []'s.  [1,4]/s/ looks for an s on lines
   1 thru 4.  [.,$]/some looks for "some" from here to the eind of the
   buffer (no wrap-around occurs).  [5,8]</abc/ begins on line 8 and
   searches backward thru line 5 looking for "abc".


:Info: (: ):
03/17/80  ( )

Used to bracket byte addresses, multi-character buffer names,
   multi-character labels, arithmetic grouping within <eval>, and logi-
   cal grouping in g*.


:Info: {: }:
03/21/80  { } Evaluation

{ <eval> }
   An evaluation may be requested, it is not expected to return any
   value.  There is no default address.  However, 1 or 2 addresses may
   be given.  Values refering to buffer data are not defined if no
   address is given.  There is no default address in order that this
   request may be used in an empty buffer.

   "{" and "}" always bracket an <eval>.  Any use other than as
   mentioned above is a context where a value is expected:
         \{ <eval> } zif { <eval> } \g{ <eval> }


:Info: * :
03/25/80  * Operator

"*" is the closure operator in a regular expression.  It matches
   0-or-more occurances of the character which preceeds it.  It is also
   the multiply operator within <eval>.


:Info: expression: <RE>: regexp:
12/11/78  Regular expression

A regular expression is referrred to in ted-help as "<RE>".  It is a
   description of a string you wish to find.  Most characters in <RE>
   are taken literally.  These have a special meaning:
^
   as the first character of a regular expression will match the (fic-
   titious) character preceding the first one on a line.
$
   as the last character of a regular expression matches the (ficti-
   tious) character after the last character of the line.  The new-line
   is not considered part of the line.  However, SEE:  string-mode
*
   matches ZERO or more occurances of the character which immediately
   precedes the "*" in the regular expression.
.
   matches any character
\[n]x
   matches exactly n occurances of character x
\[n].
   matches exactly n occurances of any character.
\[n]\c.
   matches exactly n occurances of a period.


:Info: address:
12/11/78  Addresses

Overview:  Many requests have addresses which specify what is to be
acted upon.  Addresses occur before requests.  Some requests use a sin-
gle address; some can have an address pair to specify a range to work
on.

There are two major parts to an address, the line part and the byte
part.  This is the general format (both parts are optional):
   <line-address> ( <byte-address> )
The line address references a line within a buffer.  The byte address
references a byte within a line (however, for an exception to this,
SEE:  string-mode).  A byte address is generally of the same form as a
line address except that it is enclosed in parentheses.


Absolute [<number> 0 $ .]:
<number>
   When the first thing in an address is a number, it is an absolute
   reference.
    a) Absolute line number within buffer (e.g.  3,5p)
    b) Absolute character number within line (e.g.  (1),(3)d OR (1,3)d)
0
   When the first thing in an address in a zero, it is a buffer refer-
   ence.
    a) Beginning of buffer (e.g.  0r path)
    b) Absolute character number within buffer (e.g.  0(256),0(511)p)
$
   "$" in an address refers to the "end-of" the buffer or line.
    a) Last line of buffer (e.g.  $d)
    b) Last byte of line (e.g.  ($)d)
.
   "."  refers to the current position, either line-in-buffer or
   byte-in-line.
    a) Current line of buffer (e.g.  .p)
    b) Current byte of line (e.g.  (.)d)


Relative [+ -]:  Addressing may be done relative to the current posi-
tion or relative to a preceeding address part.  The "+" is optional
when not the first thing in an address.  Thus ".+4" is the same as ".4"
(which is the same as "+4").
 a) Relative to the last line in the buffer (e.g.  $-5P)
 b) Relative to the new-line ($) in the line (e.g.  ($-5),($)d)
    [NOTE:  15($)d will merge lines 15 and 16 by deleting the new-line]
    [NOTE:  If last line has no NL, ($) refers to where it WOULD be.]
 c) Relative to the current line in the buffer (e.g.  .,.+5p OR .,.5p)
 d) Relative to the current character in the line (e.g.  (20);(.+6)p)


Contextual [/.../ </.../]:
/<RE>/
   Addressing may be accomplished by regular expression (<RE>) search.
    a) Regular expression search within the buffer.  The search is done
   by
       starting on the line following "."  and searching from there to
   the end
       of buffer.  If it is not found, then the search continues at the
       beginning of the buffer and goes up to and including the current
   line.
       "/" is the required delimiter in this use of regular expression.
       (e.g.  /abc/-4)
    b) Regular expression within a line.  The search is done starting
   with (.+1)
       except for the first thing after a line address (conceptually
   the line
       address locates the 0'th byte of the line).  "/" is also the
   required
       delimiter here.  (e.g.  (13/somestring/))
</<RE>/
   Backup search looks for an expression by moving backward one line at
   a time.  "/" need not be used as a delimiter in this case.  (e.g.
   $<`end;`)


Mode change [\s \l]:
\s
   Enter string mode.  SEE string-mode
\l
   Enter line mode


Separators [, ;]:  When two addresses occur to form a range, they can
be separated in one of two ways.
,
   "," as an address separator means that the following address is to
   be searched for from the same starting point as the past address
   was.
;
   ";" as an address separator means that the following address is to
   be searched for from the location found by the past address.
Special form
   There is a shorthand address form available in certain circum-
   stances.  The two forms below are identical in meaning, with the
   second being the shorthand.
      /abc/(2); .(10)
      /abc/(2,10)
   In other words, when the line part is the same on both addresses,
   then the byte portions may be combined within the same parentheses.


Prefix [?]:  "?"  preceeding an address makes it an address prefix.  An
address prefix has the same form as an address.  It causes the same
processing as an address.  But, it does not act as an address to a
request.  Its purpose is to test for the validity of an address.

If any part of an address is not findable, all processing stops and
control is returned to ted request level.  However, if an address pre-
fix fails, it does not give a message; it merely ignores the rest of
the request line and continues.  Since all the work has been done of
processing the address, you may want to be at that location.  This is
accomplished by separating the prefix from the following address with a
";".
  ?/Charly/; .; .+1d >-0
will find all lines in the buffer containing "Charly" and delete it and
the following line.  Actually this is not fail-safe.  To cover the pos-
sibility of the match begin on the last line (important when writing a
ted_com where control must be retained) you could use:
  ?/Charly/+1; .-1; .+1d >-0


Examples:
    /abc/-5 references the line 5 ahead of one containing the string
"abc"
   (/abc/+2) references the "c" of the first occurance of "abc" on the
                 current line
  0/J/(/k/) references the first "k" on the first line containing a "J"
   (/a.*z/)d deletes the string beginning with "a" and ending with "z"
on
                 the current line
 (/abc/);(+5)d deletes a string beginning with "abc" and 6 characters
long


:Info: not: ': ^:
12/07/78  "Not" request modifier

The sense of certain requests may be reversed by placing a NOT ("^" or
"'") before them.  SEE any of the following:  ^# ^* ^> ^r ^b


:Info: alternate: !:
12/11/78  Alternative request forms

There are alternate forms of certain requests available.  This is
indicated by preceding the request letter by "!".  Some of these are
available via capital letters.
 SEE any of the following:
      !a !b !c !e !f !i !j !k !l !m !n !p !q !r !s !t !u !w !x
                E F J K L M P Q R S T U W X


:Info: assign: =: ":=":
12/11/78  Assignment operator

":=" is the assignment operator within <eval>.  Not to be confused with
the "=" operator which is equality.


:Info: active_function: argn: arg:
12/07/78  ted as active function


When ted is called as an active function, the contents of b(argn) when
q is executed is the result.


:Info: arg: args:
03/21/80  Calling ted with arguments

ted can be called and given arguments which are made available during
the processing.

"ag" is an arithmetic variable which contains the number of arguments
passed to the current ted invocation.

The arguments are available in two ways, as successive lines of b(args)
and as b(arg1), b(arg2), etc.  None of these buffers will show up on an
x list until they have been referenced.


:Info: trace:
03/17/80  Trace option

This may be controlled when calling ted with these control arguments:
   -trace -trace_edit -trace_input -no_trace
Also, these can be set with the option request:
   edit input ^edit ^input trace ^trace
"trace" is the same as "edit input".  "^trace" is the same as "^edit
^input".  flow controls the displaying of labels.


:Info: break:
12/05/78  break blurb

          BREAK:  b(x), line n, level m[dd]
 At this time each line typed is used directly as a request line.  All
requests may be used except INPUT requests.  To continue after a break,
type ">" (goto request).
   If \?  is typed while at a break , ted will retype the break message
followed by the line on which the break occurred with the point of
break being indicated.  This means that it is best to place a break on
a line with requests instead of on a line by itself.

If a ted_com appears to be in a loop, you can hit QUIT, and type
          ted -pause ted will then break the next time a request line
is asked for in EDIT mode.


:Info: prefix: ?:
03/17/80  Address prefix

"?"  preceeding an address makes it an address prefix.

For further information type "help address ?".


:Info: ^?: '?:
03/17/80  FYI

It is impossible to use ^?  because when an address fails during its
processing there is no way to recover except to drop the rest of the
line.


:Info: @:
10/12/82  Absolute buffer reference

An address may be reference any buffer, regardless of which is current,
by prefixing all other address parts with @b, or \(b), where b is the
name of the buffer to reference.
  @2,1,$d deletes all of b2.
  @(exec),1p prints the first line of b(exec).


:Info: <:
03/17/80  Backup search

For information on this, type "help address </"


:Info: <: >: metasymbols: metasymbol:
03/19/80  Metasymbols

Within this info, there are occurances of metasymbols.  These are names
enclosed in <>'s.  For example, <RE>.  A metasymbol represents the name
of something and not a literal occurance of the characters.
Explaination of metasymbols is available in this info.  If you wonder
what "<RE>" stands for you can ask "help <RE>" to find out.


:Info: $:
02/24/81   $ - "End"

"$" has three distinct, but similar, meanings depending on context.  In
a line address it means "last line of the buffer".  In a byte address
it means "the NL or where the NL would be if there is none".  In a reg-
ular expression it means "match end-of-line".  As an address it is
absolute.  It thus may only occur first within an address part.


:Info: &:
03/17/80  "&" Operator

"&" is a special symbol in the replace string of a substitute meaning
"give me the string which was matched".  It also the logical AND in the
g* request.


:Info: +:
03/17/80  "+" Operator

"+" is use in line or byte address to represent forward relative
addressing.  It is also the add operator within <eval>.


:Info: -:
03/17/80  "-" Operator

"-" is used in a line or byte address to represent backward relative
addressing.  It is also the subtract operator within <eval>.


:Info: ;: ,:
03/17/80  Address separators

"," as an address separator means that the following address is to be
searched for from the same starting point as the past address was.

";" as an address separator means that the following address is to be
searched for from the location found by the past address.


:Info: .:
02/24/81  "." Operator

"."  means "the current line" in a line address, "the current byte" in
a byte address.  This is an absolute and may only occur first within an
address part.

"."  means "match any character" in a regular expression.

"."  on a line by itself is the end-of-inout symbol in BULK mode.  SEE:
modes


:Info: /:
03/17/80  "/" Operator

"/" is used in a line or byte address to delimit a search expression.
It is also the divide operator within <eval>.


:Info: 0: 1: 2: 3: 4: 5: 6: 7: 8: 9:
01/01/78  Decimal digits

The digits are used to build line and byte numbers in addresses, and
integers within <eval>.


:Info: quote: """":
09/09/85  Quote mark

It delimits quoted strings within <eval>.


:Info: A:  01/01/78  "A" is not a request.


:Info: B:  01/01/78  "B" is not a request.


:Info: C:  01/01/78  "C" is not a request.


:Info: D:  01/01/78  "D" is not a request.


:Info: G:  01/01/78  "G" is not a request.


:Info: H:  01/01/78  "H" is identical to "h".


:Info: I:  01/01/78  "I" is not a request.


:Info: N:  01/01/78  "N" is not a request.


:Info: O:  01/01/78  "O" is not a request.


:Info: V:  01/01/78  "V" is not a request.


:Info: Y:  01/01/78  "Y" is not a request.


:Info: Z:  01/01/78  "Z" is not a request.


:Info: _:  01/01/78  "_" is not a request.


:Info: `:  01/01/78  "`" is not a request.

However, this is used in ted-help to represent a delimiter.  For exam-
ple, S`<RE>`STR` means the letter "S" followed by any non- blank char-
acter which represents a delimiter.  There are then 2 more occurances
of the same character to finish out the request.


:Info: escape: \: "\":
03/18/80  "\" - Escape

"\" is part of several special sequences.  Some are recognized by ted;
others are recognized by Multics terminal I/O.
 SEE any of the following:  \c\b, \c\c, \f, \g{, \l, \r, \s, \[n]x, \?
Multics I/O recognizes \\ \# \@ \ooo and \NL
 "ooo" is 3 octal digits.  NL is the NL character.


:Info: \?:
03/18/80  "\?" - Where am I?

"\?"  is the where-am-I request when given on a line by itself.  The
response to this will be of this form:
  ted(v.r)xxx MODE[rc]safe
"v.r" is the current version/revision of ted.  "rc" is the current
recursion level of ted.  "safe" means you are operating in SAFE mode;
not present if not safe.
"xxx" can be any of these
    INPUT EDIT READ BULK BREAK
 SEE:  modes


:Info: \c\c: \C\c: \C\C \c\C:
03/18/80  "\c" - Conceal function

"\c" or "\C" is the conceal function.  It is used whenever a character
with a special meaning is to be taken literally.  It is used as a pre-
fix to the the thing to be concealed.

For example, in order to input the "\f" sequence, which would terminate
input mode, you must enter it as "\c\f".


:Info: \b: \B: \r: \R: \{:
03/21/80  Input functions

Overview:
  "\b", "\r", and "\{" are the three input functions.  In general, ted
input is obtained a line at a time.  Input comes from user_input and
from invoked buffers.  Each time ted needs another line it calls its
input routine.  This routine takes from the input until a NL is
encountered.  Along the way it looks for input functions and processes
them.

ted knows nothing about any input functions which may have existed.
The input routine knows nothing about what will be done with the line
gotten.  The result of this is that ALL input functions on a line are
processed before any requests in the line.  You might consider the
input functions as having higher priority than requests.  This means
that a line typed this way will not work as you probably want:
   2,4k(x) $a \bx\f
You might think that you are moving some data to buffer x and then
appending it to the end of the current buffer.  However, since the \b
has higher prioroty, it is done first and the data is not in buffer x
yet.


Invoke [\b]:  "\b" or "\B" is the invoke buffer input function.  It can
be used in these forms:
     \b(X) \b(X,a) It basically means "replace the invoke sequence with
the contents of the specified buffer or with the selected portion of
the contents of the buffer".

The contents is used one line at a time.  In INPUT mode the lines are
used in sequence (assuming no \f therein).  In EDIT mode this also hap-
pens, except that a goto request may change the sequence in which the
lines are used.

The contents is scanned looking for input functions and thus nesting
may occur.  The invoke sequence will look like one of these:
     \bx \b(xxx) \b(xxx,5;/abc/)
This sequence cannot contain any input functions.


Read-a-line [\r]:  "\r" or "\R" is the "terminal" input function.  When
this function is encountered, a line is read from user_input and is
used to replace the function.  The NL from the line read is not inclu-
ded (unless you are running in ted$qedx mode).  The line is not scanned
for any input functions.  However SEE:  \f


Evaluation [\{}]:  "\{}" is the evaluation input function.  An evalua-
tion is done and the value returned replaces the evaluation function.
If the evaluation does nothing to return a value, a NULL value is
assumed.  The form is:
   \{ <eval> }
This sequence cannot contain any input functions.


Example \b:
\bx  OR \b(x)
   This invokes buffer x.
\b(x,1)
   This invokes just the first line of buffer x.
\b(x,0(1),0(20))
   This invokes the first 20 characters of buffer x.


Example \r:
s/abc/\r/ s/def/\r/
   This will require 2 responses before the line can be executed.  Then
   it will replace all occurances of "abc" with whatever you typed in
   first.  Then it will replace all occurances of "def" with whatever
   you typed second.


Example \{}:
{ln:=0}
a \{ln:=ln+10;LN:=fak(ln,"00000");LN:LN} \r
\f >-1
   This will accept lines of input, automatically prefixing each one by
   a 5-digit line number which is incremented by 10.  The loop is
   terminated by the person responding with just "\f".

"{ln:=0}" initializes the counter.  The second line has 2 input func-
  tions in it.  The first one does this:  "ln:=ln+10" increments the
  counter.
"LN:=fak(ln,*"00000*")" converts the number to a character string with
  leading 0's.
"LN:" prints the number without a NL.
"LN" returns the value for use in the request line.
"\r" then accepts the user input line.  The last line comes out of
  input mode and loops back to get the next user line.


:Info: \f: \F:
03/21/80  End-of-input [\f]

"\f" or "\F" is the end-of-input sequence.  It is used in two places.
  When in INPUT mode, this terminates it and causes ted to enter EDIT
  mode.  When in READ mode, this causes the line being built to be
  aborted.  If the line is being built from an invoked buffer, this
  will act as a RETURN.  If the line is being built from "terminal"
  level, this will cause an error message to be printed.


:Info: \g: \g{: \g{}:
03/21/80  Substitute evaluation (under g*) [\g{}]

"\g{}" or "\G{}" is the evaluation function of substitute done under
  global-if.  This is similar to the "\{}" except that the evaluation
  is done once for each match found.  The form is:
     \g{ <eval> } Since this is NOT an input function, there may be
  input functions within the sequence.


:Info: \l: \s:
03/21/80  Line/string modes [\l \s]

\l
   as part of an address means "enter line mode".
\s
   as part of an address means "enter string mode".  SEE:  modes string


:Info: |: or: concatenate:
03/21/80  or/concatenate operators

|
   the logical OR operator in g*.
||
   the concatenate operator within <eval>.


:Info: ~:
12/07/78  Return from buffer call

~
   stop executing in this buffer, revert to next lower level.


:Info: <eval>: eval: evaluation:
03/13/80  <eval> - Evaluation

Overview:  Evaluation is a process of doing arithmetic and/or string
operation within ted.  A user may place numbers or strings into vari-
ables of his own chosing.  He may then use them at a later time (in the
same invocation of ted).  With this facility one may implement count-
ers, parse strings, build up strings, etc.

Evaluation coding always occurs within "{}".


Description:
{ <part...> <lpart> }
   An evaluation may be a list of <part>s followed by a <lpart>.
{ <part...> }
   Or it may be just a list of <part>s.
{ <lpart> }
   Or it may be just a <lpart>.
{ }
   It may even be null.


Examples:  These examples are one of each type mentioned above.  The
contexts vary as is appropriate for the type.
zif {i:=i+3;  j<i} >a
{i:=i+2}
\{fs("Now is the time for",i,7)}
\{}


Note:  In the description above, you will notice that <part...> and
<lpart> are used.  The complete BNF-like presentation of the evaluation
syntax will contain metasymbols in this fashion.  To determine the form
of any of these, type "help <lpart>", for example.


:Info: <part>: <part...>: ":": ;:
03/13/80  <part> - evaluation part

<cat> ;
   The value of <cat> is printed followed by a NL.
<lexp> ;
   The value of <lexp> is printed followed by a NL.
<cat> :
   The value of <cat> is printed without a NL.
<lexp> :
   The value of <lexp> is printed without a NL.
<assign> ;
   The value is "used up" by being assigned, so there is no further
   action.
d ( <cat> ) ;
   This requests a dump of variables.  <cat> must result in a string
   consisting of only the characters "akKv".  If "a" is present, all
   non-zero a[*] are shown.  If "k" is present, all non-null k[*] are
   shown.  If "K" is present, all non-null K[*] are shown.  If "v" is
   present, all user-defined variables are shown regardless of content.


:Info: <lpart>:
03/13/80  <lpart> - evaluation last part

<cat>
   The value of <cat> is returned as a character string.
<lexp>
   The value of <lexp> is returned as either "true" or "false".
<assign>
   A null value is returned.


:Info: <lexp>: <rel>: =: ^=: >=: <=: <: >:
03/13/80  <lexp> -  logical expression

<cat> <rel> <cat>
   This compares two values.  If the values are not of the same type,
   conversion is done to the "higher" of the two types.  The order, low
   to high, is this:
      arithmetic logical string
   <rel> is any of these operators:  = ^= >= <= < >


:Info: <cat>: ||:
03/13/80  <cat> - concatenate operation

<cat> || <aexp>
   This means a series of expressions may be concatenated.  If any are
   not strings, they will be converted.
<aexp>
   Or there may be no concatenation.  In this case, no conversion is
   done.


:Info: <assign>: ":=": a[: k[: K[: a[]: k[]: K[]: []:
03/12/80  <assign> - assignment

a[ <cat-1> ] := <cat-2>
   The value of <cat-2> is assigned to an element of the a[] array.
   <cat-2> and <cat-1> must both be convertable to a number.
k[ <cat-1> ] := <cat-2>
   The value of <cat-2> is assigned to an element of the k[] array.
   <cat-1> must be convertable to a number.  <cat-1> will be converted
   to a string.
K[ <cat-1> ] := <cat-2>
   The value of <cat-2> is assigned to an element of the k[] array.
   <cat-1> must be convertable to a number.  <cat-1> will be converted
   to a string.
<var> := <cat>
   The value of <cat> is assigned to the variable <var>.  The type of
   <var> is determined by the type of <cat> and may change from assign-
   ment to assignment.


:Info: <aexp>: +: -:
03/14/80  <aexp> - Arithmetic expression

<aexp> + <term>
   Terms may be added.  They must be convertible to numbers.
<aexp> - <term>
   Terms may be subtracted.  They must be convertible to numbers.
<term>
   Or a term may be left unchanged.


:Info: <term>: *: /: |:
03/14/80  <term> - Arithmetic term

<term> * <factor>
   Factors may be multiplied.  They must be convertible to numbers.
<term> / <factor>
   Factors may be (integer) divided.  They must be convertible to num-
   bers.
<term> | <factor>
   Factors may be mod'ed.  (Remainder when dividing.)  They must be
   convertible to numbers.
<factor>
   Or a factor may be left unchanged.


:Info: <factor>: +: -:
06/06/80  <factor> - unary-operator expression

+ <fact>
   A unary plus may preceed a <fact> which must be convertable to a
   number.
- <fact>
   A unary minus may preceed a <fact> which must be convertable to a
   number.
<fact>
   Or there may be no unary operator at all.  The type may then be any-
   thing.


:Info: <fact>: (: ): ():
01/29/81  <fact> - Arithmetic factor

<data>
   A factor may be one of several types of data, either literal,
   builtin, or variable.
<func>
   A factor may also be the value produced by a function.
( <cat> )
   It may also be an expression in parentheses.  There is no implied
   conversion by the fact that it is used in this fashion.
( <lexp> )
   A factor can be the arithmetic conversion of a <lexp>.  If <lexp> is
   FALSE, the result is 0.  Otherwise the result is 1.
( <assign> )
   A factor may be the value of an assignment.  This results in the
   assignment being done, then the value assigned being used as a fac-
   tor in whatever context it appears.


:Info: <data>:
06/04/80  <data> - Data elements

There are several kinds of data available.  To get info about all of
   them type
      help data-all
   Or you can ask for parts of this by means of any of these
      help data-literal
      help data-variable
      help data-buffer
      help data-addressed
      help data-string
      help data-error
      help data-parameter
      help func-addressed
      help func-substr
      help func-rearrange
      help func-if
      help func-convert
      help func-arithmetic


:Info: data-all: data-literal:
06/04/80  Literal data

<integer>
   Numeric data may be in decimal.
...
   Numeric data may be given as an octal string.  The string must con-
   tain only the characters "01234567".
...
   Numeric data may be given as a hexadecimal string.  The string must
   be comprised of only these characters, "0123456789abcdefABCDEF"
...
   String data may be entered as a quoted string.  Any internal quotes
   must be doubled.


:Info: data-all: data-variable: a[: a[]: k[: k[]: K[: K[]: []:
06/04/80  Variable data

<var>
   This references a user defined variable.  The variable must have
   been previously assigned some value.  Its type is dependant upon the
   assignment which was last done.  A variable name must begin with a
   letter, may contain up to 16 characters, and must consist of let-
   ters, digits, and "_".
a[ <cat> ]
   This is a reference to an element of the arithmetic array.  <cat>
   must be convertible to a number in the range -200:200.
k[ <cat> ]
   This is a reference to an element of the short-character array.
   Each element is restricted to 32 characters.  <cat> must be convert-
   ible to a number in the range -200:200.
K[ <cat> ]
   This is a reference to an element of the long-character array.  Each
   element is restricted to 512 characters.  <cat> must be convertible
   to a number in the range -10:10.


:Info: data-all: data-buffer: bn: dn: en: sk: sn:
06/04/80  Buffer builtins

bn
   The name of the current buffer.  Does not give expected results when
   used in \{} context.  In fact, none is this section do.
dn
   The directory name of the file associated with the current buffer.
   Null if no pathname on the buffer.
en
   The entry name of the file associated with this buffer.
sk
   The subfile kind of the file associated with this buffer.
    ":" archive component
    " " No subfile
sn
   The archive component name of the file associated with this buffer.


:Info: data-all: data-addressed: Ks: Kl: Kb: lb: sb: se: le: be:
06/04/80  Addressed data

These data are available in {} and zif {}, but only if an address is
   present.
Ks
   This is the string addressed.  If no byte-address is given, then
   this is identical to Kl.
Kl
   This is the line addressed.  Or more precisely, it begins at the
   beginning of the line where Ks begins and ends at the end of the
   line where Ks ends.  It is possible for this to span lines; it is
   all dependant on the address given.
Kb
   This is the contents of the whole buffer.
lb
   This is the offset in the buffer of the place where Kl starts.
sb
   This is the offset in the buffer of the place where Ks starts.
se
   This is the offset in the buffer of the place where Ks ends.
le
   This is the offset in the buffer of the place where Kl ends.
be
   This is the offset in the buffer of the place where the buffer ends.
   That is, the number of characters in the buffer.


:Info: data-all: func-addressed: fln:
06/04/80  Addressed functions

fln ( lb )
   This yields the line number of where lb is.
fln ( le )
   This yields the line number of where le is.
fln ( be )
   This yields the line number of where be is, i.e.  the number of
   lines in the buffer.


:Info: data-all: data-string: cs:
02/24/81  String builtin

cs
   This is a string containing the ascii collating sequence.  PL/I
   collate9().


02/24/81 Change:  cs is now collate9() instead of collate()


:Info: data-all: data-parameter: pn: p[: p[]: ag:
06/04/80  Parameter data

pn
   This specifies how many parameters are present.  Parameters are
   presented only when a buffer is called via the % request.  When a
   buffer is invoked, this value is 0.
p[ <cat> ]
   This is a reference to an element in the parameter array.  <cat>
   must be convertible to a number in the range 0:pn.  p[0] is a spe-
   cial case.  It represents the whole string following the buffer name
   in the % request.  The first character of this string is the
   delimiter of the parameters.
ag
   This tells the number of arguments which were given when ted was
   called.


:Info: mct: mct(): match:
11/10/82  Substitute match count

mct()
   This is the number of matches found during the last substitute.


:Info: data-all: data-error: em: emc(): emc: emt(): emt:
06/04/80  Error data

em
   This is the full text of last error message, whether printed or not.
   Messages have this form:    Xxx)  text
   Xxx is the message identifier.  text is the part which is normally
   printed.
emc()
   This function returns the code, the message identifier Xxx.
emt()
   This function returns the text.


:Info: data-all: func-substr: fs: substr:
06/04/80  Substr

fs( <cat-1> , <cat-2> )
   This yields a substring of <cat-1> which is converted to string if
   necessary.  <cat-2> is converted to a number which specifies where
   to begin taking the string.  If it is negative, it means to count
   from the end of the string.  The string returned is everything after
   the beginning point.
fs( <cat-1> , <cat-2> , <cat-3> )
   This yields a string of a specified length.  <cat-1> and <cat-2> are
   just as described above.  <cat-3> is converted to a number which
   specifies the length of the string to return.  If there are not suf-
   ficient characters in <cat-1>, then the result is padded to the
   required size with spaces.  If this number is negative, it means
   that if any padding is needed, do it on the left.
fs( <cat-1> , <cat-2> : <cat-3> )
   This is similar to the form just above, except that <cat-3>
   specifies the ending POSITION of the string to take.  If <cat-3> is
   negative, it means to count from the end of the string.


:Info: data-all: func-rearrange: frs:
06/04/80  Rearrange a string

frs( <cat-1> , <cat-2> , <cat-3> )
   This function "re-arranges" a string.  First an index of <cat-2> in
   <cat-1> is done.  This breaks the <cat-1> into parts which may then
   be selected by the contents of <cat-3> which must consist of only
   these characters:
     "b" give the before part.  If no match, this is <cat-1>.
     "m" give the matched part.
     "a" give the after part.
     "s" give the value of <cat-2>
   This means that:  frs(name,".pl1","bs")
   will yield a string with the suffix ".pl1", taking into account the
   presence of one to start with.


:Info: data-all: func-if: if:
09/09/85  String function- if

if( <lexp> , <cat-1> , <cat-2> )
   This yields <cat-1> if <lexp> is TRUE.  Otherwise it yields <cat-2>.
if( <lexp> , <cat> )
   This yields <cat> if <lexp> is TRUE.  Otherwise it yields nothing.


:Info: data-all: func-arithmetic: fl: fi: fir: ff: ffr: fv: fvr:
09/09/85  Arithmetic functions

fl( <cat> )
   This yields the length of <cat>.  If <cat> is not a string, it is
   converted.
fi( <cat-1> , <cat-2> )
   This is the index function.  Both arguments are converted to
   strings.  The value returned is the position in <cat-1> where string
   <cat-2) is found.  The result is 0 if it is not there.  PL/I index.
fir( <cat-1> , <cat-2> )
   This does an index function on the reverse of <cat-1>.  <cat-2> must
   be in reverse order in order to be found.
ff( <cat-1> , <cat-2> )
   This "finds" a character of <cat-2> in <cat-1>.  If none exist, 0 is
   returned.  PL/I search().
ffr( <cat-1> , <cat-2> )
   This "finds", except it looks from the end of the string.  PL/I
   search(reverse()).
fv( <cat-1> , <cat-2> )
   This "verifies" the presence of some character in <cat-2> in
   <cat-1>.  If all match, 0 is returned.  PL/I verify.
fvr( <cat-1> , <cat-2> )
   This "verifies", except it looks from the end of the string.  PL/I
   verify(reverse()).
ff( <cat> , S(xxx) )
   This "finds" a member of a specified set of characters which is
   specified by the value of xxx, which is made up of one or more of
   these selectors:
     "n" numeric
     "u" uppercase letter
     "l" lowercase letter
     "a" letters plus "_"
     "o" octal
     "x" hexadecimal
     "g" graphic, \041->\176
     "m" motion, BSP HT NL VT FF SP
ffr( <cat> , S(xxx) )
   This "finds", but from the end of <cat>.
fv( <cat> , S(xxx) )
   This verifies, with a set.
fvr( <cat> , S(xxx) )
   This verifies, but from the end of the string.
fmn( <cat...> )
   This returns the minimum of all the arguments given to it.  The
   arguments are separated by commas.
fmx( <cat...> )
   This returns the maximum of all the arguments given to it.


:Info: data-all: data-convert: fak: fka:
06/04/80  Data conversion

fka( <cat> )
   This converts a string to arithmetic.  It is for compatability only,
   it is no longer needed.
fak( <cat-1> , <cat-2> )
   This does a conversion of a number, <cat-1>, to a string under the
   control of a mask, <cat-2>.


Mask description:  MASK may be of length zero ("") in which case the
converted result is exactly the significant digits preceeded by a minus
sign if appropriate.

If MASK is not of length zero, then the result of the conversion is
exactly as long as the mask.  The significant digits of the number and
the mask are processed from right to left.  All numeric, alphabetic,
and special characters may appear in MASK.  However, some of the char-
acters have special meanings:

"~" causes a space in the result.

"0" is replaced by a digit if one is left; otherwise it remains
    in the result.

"b" is replaced by a digit if one is left; otherwise it is
    replaced by a fill character.  After a fill character is used
    it becomes a "b" if it is not "*".  All zeroes should occur to
    the right of the spaces in the mask.  The rightmost space or
    zero is the units position.

"-" in the units position signals floating minus sign.  The fill
    character will be set to "-" or "b" as is appropriate.

"-" in the leftmost position of the mask signals a fixed minus
    sign.  It will be set to either "-" or "b" as is appropriate.

"$" in the units position signals floating dollar sign.  The fill
    character is set to "$".

"**" in the units position signals asterisk protection.  The fill
    character is set to "**".

"O" in the units position signals octal conversion is to be done
    on the value.  The result is a string, not a signed value.

"X" in the units position signals hexadecimal conversion is to be
    done on the value.  The result is a string, not a signed
    value.

"," is replaced by a fill character if no digits are left.
    Otherwise it remains in the result.

"."  is replaced by a fill character if no digits are left.
    Otherwise it remains in the result.

Any character not having a special meaning remains in the result.


:Info: request: requests:
01/29/81  Ted requests

To get a list of ted requests, type "help ted requests"


:Info: help:
12/04/78  Help facility within ted

Overview:  ted has help available.  This is implemented via the same
suboutine as is used by the help command.  Thus, all question/answer
sequences are as you are used to with help.

Most of the info available via ted_help is not available to the help
command.


help:  This form gives additional information about the last error
which occured.  If there is no last error, it will give information
about help.


help info:  This form gives information about "info".  It will begin by
listing all the titles in the info and then ask if you want to see the
first one.  (If there is only 1 section, then it is just printed.)  If
more than one info matches "info", they are listed in turn.  If there
is only 1 section in each, there will be no pause between any of them.


help info sec:  This form tries to find section "sec" in info "info".
This begins by printing the named section and then asks if you want to
see more if there is other data to be seen.  Titles are not automati-
cally given.

If "info" is given as "**", then all infos are given which have a sec-
tion "sec".  For example if you say "help ** overview" it shows all
Overview sections of all infos.


help -about topic:  This form selects all infos which contain the
string "topic".  Each in turn will be presented for your examination.
The string is not matched on a word basis; be careful about doing some-
thing like "help -about b".  This would probably match every paragraph
of every section of every info in the file.


help info -about topic:  This form starts you in the first paragraph of
info "info" which contains the string "topic".


help -from date:  This form will select all infos which have been
updated since "date".  It will list the info name, the header line
(which shows the data) and the size of the info.


help ** change -from date:  This form will select the section "mm/dd/yy
Change" from all infos which have been updated since "date".  It will
begin printing with the selected section.  If a section by that name
does not exist (i.e.  info is new), then no printing will occur.


help |func:  This form tries to find info about the external function
ted_func_.  If this exists, it will be in a segment named
ted_func_.info.  The search rules used when trying to find the info
will contain the directory where ted_func_ is found.  If ted_func_ does
not exist, then no info will be looked for.


help |func info:  This form attempts to find info "info" in an external
function info file.


Conventions:  Many sections will describe one or more constructs.  In
general, the title of a section will give a summary of the constructs
it contains.  This summary will be enclosed by "[]".  Thus a section
title like this
   Basic [a c i]
indicates that the "a", "c", and "i" requests are described therein.

When a request form is shown, the default address will be shown
enclosed in "[ ]"'s
   [.,.] p
means that the p request defaults to the current line if no address is
given.

When a new info is added to ted.info it will get the current date.  If
any changes are made to the technical content of the info, a section
will be added which is named "mm/dd/yy Change".  This will be inserted
ahead of any prior change indicators.

Many request descriptions begin with a section named "Basic".  This
gives the ordinary form of the request.  Some infos have a section
named "Overview".  This contains auxilliary information which is not
absolutely necessary to know, but which may be of benefit to have read
once.


List of ted_help infos:
<REPL>              <lexp>              assign              execute
<aexp>              <lpart>             break               expression
<assign>            <part>              buffers             fileout
<cat>               <term>              call                global
<data>              active_function     copy                if
<eval>              address             cut                 input
<fact>              alternate           delete              label
<factor>            arg                 escape              line/string

linenumber          quit
modes               quote
move                read
nop                 sort
not                 status
options             substitute
prefix              trace
print               write
