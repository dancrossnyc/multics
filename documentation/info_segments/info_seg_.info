:Info: info_seg_:  2020-11-04  info_seg_


The info_seg_ subroutine...
 - parses info segments into their components (lines, paragraphs,
   sections, blocks); and
 - verifies formatting and section titles of each info seg component.
   Any errors are diagnosed by error switches in the parse output
   structures.


Notes on usage sequences:
A) The verify_info command uses info_seg_ to parse info segments to be
   validated, making the following sequence of calls:
     - call info_seg_$initialize(...);
	Called one per verify_info command.
     - call info_seg_$append_iFiles(...);
	Called once for each INFO_PATH starname argument.
     - call info_seg_$parse_iFile(...);
	Called for each info seg (iFile structure) found by
	$append_iFiles.
     - call info_seg_$terminate(...);
	Called once after all files have been verified.


Entry points in info_seg_:
   (List is generated by the help command)


:Entry: initialize:  2020-11-04  info_seg_$initialize

Function: creates an ssu_ standalone invocation to simplify argument
processing and storage management for any command using info_seg_.

Completes initialization of the info_seg_data structure provided by the
caller.


Syntax:
   declare info_seg_$initialize entry (ptr, char(*), char(*), ptr,
     entry variable, fixed bin(35);
   call info_seg_$initialize (info_seg_dataP, caller_name,
     caller_version, arg_list_ptr, ssu_abort_routine, code);


Arguments:
info_seg_dataP
   points to the info_seg_data structure (see info_seg_dcls_.incl.pl1)
   which caller provides as input.
     A) Caller sets info_seg_data.version to indicate which structure
        version is being passed.
     B) Caller sets info_seg_data.ptrs, info_seg_data.files = null()
        to prepare for a later call to info_seg_$terminate.
     C) Caller optionally sets info_seg_data.sciP to point to an
        existing ssu_ invocation.  If this pointer is null(), then
        initialization also creates its own ssu_ standalone
        invocation, using the other parameters.
   See the "Notes on cleanup" section for more information.


   If info_seg_data.sciP is null, the following arguments are passed
   directly to ssu_$standalone_invocation.  See the MPM Subroutines
   description of that entry point for more details.


caller_name
   gives name of calling command.  Can be accessed by
   ssu_$get_subsystem_name.
caller_version
   gives caller's version number.  Can be accessed by
   ssu_$get_subsystem_version.
arg_list_ptr
   points to calling command's input argument list.  Use ssu_$arg_ptr
   to access arguments.  The caller may used ssu_ calls to process its
   input arguments.  The info_seg_ subroutine does not access this
   arg_list_ptr.    To simply argument handling, see:
      ssu_standalone_command_.incl.pl1


ssu_abort_routine
   subroutine to be called if an info_seg_$XXX routine encounters a
   fatal error and needs to abort execution of the calling command.
   This subroutine should go to a label that exits the command (call's
   its cleanup routine, then returns).
code
   is an ssu_ status code.  It is non-zero when a fatal error occurs.
   Cases include:
    - info_seg_data.version has a value not supported by info_seg_; or
    - ssu_$standalone_invocation creation failed.
   ssu_$print_message (and other ssu_ routines) may not be called to
   report such errors.


Notes on cleanup:

When initialization completes, info_seg_data.ptrs and
info_seg_data.relatives.files point to data items used in subsequent
calls to info_seg_ subroutines.  The caller must create a cleanup
on-unit that calls info_seg_$terminate to terminate info segments, and
release storage for structures describing those info segments.


:Entry: append_iFiles:  2020-03-01  info_seg_$append_iFiles

Function: creates an iFile structure for each info segment matching an
input pathname.  Each new iFile structure is attached to the
info_seg_data.files threaded list, in alphabetic order by first
entryname of the info segment.  For details, see the "Notes on iFile
structures" section of this info segment.


Syntax:
   declare info_seg_$append_iFiles entry (ptr, char(*));
   call info_seg_$append_iFiles (info_seg_dataP, path);


Arguments:
info_seg_dataP
   points to the info_seg_data structure.  Refer to
   info_seg_dcls_.incl.pl1.
path
   a relative or absolute pathname identifying one or more info
   segments.  A suffix of .info is assumed if not present.  The star
   convention is supported.


Notes on the structure:
Each iFile structure created by info_seg_ is added to the
info_seg_data.files threaded list.  Use the following code to set
iFileP to point to structures on this list:

     do iFileP = info_seg_data.relatives.files.firstP
          repeat iFile.sib.nextP   while (iFileP ^= null());
  	   ... <code to operate on each iFile> ...
	end;

The code for each iFile would include a call to parse the info
segment, followed by code to process the structure hierarchy returned
by parsing.  The iFile and info_seg_data structures are declared in
info_seg_dcls_.incl.pl1.


:Entry: parse_iFile:  2020-03-01  info_seg_$parse_iFile

Function: initiates the info segment described by iFile, and parses
that segment into one or more components:

   - info block   Portion of an info segment completely describing:
	        a command or active function; a subroutine or one of
	        its entry points; a subsystem request or active
	        request; or some other topic of general information.
   - section      A titled group of paragraphs in an info block.
   - paragraph    A group of lines from an info block which are
	        displayed as a unit.
   - line         A set of characters short enough to display on a
	        single row of most display terminals.


Syntax:
   declare info_seg_$parse_iFile entry (ptr, ptr);
   call info_seg_$parse_iFile (info_seg_dataP, iFileP);


Arguments:
info_seg_dataP
   points to the info_seg_data structure (see info_seg_dcls_.incl.pl1).
iFileP
   points to an iFile input structure for the file to be parsed.


Notes:
Before calling info_seg_$parse_iFile, the iFile structure contains
only the location of an info segment, and threads to other iFile
structures.


After parsing, the following information has been added to the iFile
structure...
 - A pointer to, and length of, the characters in the info segment.
 - An array of all names on the info segment.
 - A list of iLine structures, each describing a line of the info
   segment.
 - A list of iBlok structures, each describing a block of the info
   segment.
 - Integers classifying the block organization within the info segment.


In addition, each iBlok structure describes...
 - A pointer to, and length of, the characters in the block.
 - An array of names in the block divider (if the block began with a
   divider).
 - Block heading line information (date and header string).
 - A list of iSect structures, each item describing sections within
   the block.
 - A list of iPgh structures, each item describing paragraphs within
   the block.
 - A list of iLine structures, each item describing lines within the
   block.


:Entry: reinitialize:  2020-03-09  info_seg_$reinitialize

Function: terminates info segment files that were parsed, and empties
temporary storage used for info segment data structures.


Syntax:
   declare info_seg_$reinitialize entry (ptr);
   call info_seg_$reinitialize (info_seg_dataP);


Arguments:
info_seg_dataP
   points to the info_seg_data structure (see info_seg_dcls_.incl.pl1).


Notes on cleanup:
When initialization completes, info_seg_data.ptrs point to data items
used in subsequent calls to info_seg_ subroutines.  The caller must
create a cleanup on-unit that calls a routine to release storage for
these data items:
   - Calls info_seg_$reinitialize to reinitialize info segments, and
     release storage for structures describing those info segments.
   - Calls ssu_$destroy_invocation to release the ssu_ standalone
     invocation identified by the info_seg_data.sciP pointer.

In addition, the caller must call the cleanup routine described
above before returning to its caller.


:Entry: terminate:  2020-03-09  info_seg_$terminate

Function: terminates info segment files that were parsed, and releases
temporary storage used for info segment data structures.  If
info_seg_$initiate created its own ssu_ standalone invocation, that
invocation is destroyed.


Syntax:
   declare info_seg_$terminate entry (ptr);
   call info_seg_$terminate (info_seg_dataP);


Arguments:
info_seg_dataP
   points to the info_seg_data structure (see info_seg_dcls_.incl.pl1).


Notes on cleanup:
When initialization completes, info_seg_data.ptrs point to data items
used in subsequent calls to info_seg_ subroutines.  The caller must
create a cleanup on-unit that calls a routine to release storage for
these data items:
   - Calls info_seg_$terminate to terminate info segments, and
     release storage for structures describing those info segments.
   - Calls ssu_$destroy_invocation to release the ssu_ standalone
     invocation identified by the info_seg_data.sciP pointer if the
     caller created that ssu_ standalone invocation.

In addition, the caller must call the cleanup routine described
above before returning to its caller.


:hcom:

/****^  HISTORY COMMENTS:
  1) change(2020-03-01,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     Information segment created as subroutine was developed.
  2) change(2020-11-04,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     In info_seg_$initialize, change description of info_seg_dataP
     argument to correctly describing setup of this structure by callers.
  3) change(2020-11-25,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     Change spelling of "entrypoint" to "entry point".
                                                   END HISTORY COMMENTS */
